# Comparing `tmp/junit2html-30.1.6-py3-none-any.whl.zip` & `tmp/junit2html-31.0.1-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,22 +1,23 @@
-Zip file size: 15845 bytes, number of entries: 20
--rw-rw-rw-  2.0 fat        0 b- defN 20-Jun-13 10:51 junit2htmlreport/__init__.py
--rw-rw-rw-  2.0 fat      112 b- defN 20-Jun-13 10:51 junit2htmlreport/__main__.py
--rw-rw-rw-  2.0 fat      899 b- defN 21-Jan-04 09:01 junit2htmlreport/common.py
--rw-rw-rw-  2.0 fat     8230 b- defN 24-Feb-21 00:37 junit2htmlreport/matrix.py
--rw-rw-rw-  2.0 fat     2641 b- defN 21-Jan-04 09:01 junit2htmlreport/merge.py
--rw-rw-rw-  2.0 fat    14596 b- defN 24-Feb-21 00:37 junit2htmlreport/parser.py
--rw-rw-rw-  2.0 fat      316 b- defN 21-Jan-04 09:01 junit2htmlreport/parserimpl.py
--rw-rw-rw-  2.0 fat     1345 b- defN 24-Feb-21 00:37 junit2htmlreport/render.py
--rw-rw-rw-  2.0 fat     3680 b- defN 24-Feb-21 00:37 junit2htmlreport/runner.py
--rw-rw-rw-  2.0 fat      345 b- defN 20-Jun-13 10:51 junit2htmlreport/textutils.py
--rw-rw-rw-  2.0 fat      313 b- defN 21-Jan-04 09:01 junit2htmlreport/templates/base.html
--rw-rw-rw-  2.0 fat     2874 b- defN 24-Feb-21 00:37 junit2htmlreport/templates/matrix.html
--rw-rw-rw-  2.0 fat     4915 b- defN 24-Feb-21 00:37 junit2htmlreport/templates/report.html
--rw-rw-rw-  2.0 fat     3009 b- defN 24-Feb-21 00:37 junit2htmlreport/templates/styles.css
--rw-rw-rw-  2.0 fat     1088 b- defN 24-Feb-21 00:41 junit2html-30.1.6.dist-info/LICENSE
--rw-rw-rw-  2.0 fat      406 b- defN 24-Feb-21 00:41 junit2html-30.1.6.dist-info/METADATA
--rw-rw-rw-  2.0 fat       92 b- defN 24-Feb-21 00:41 junit2html-30.1.6.dist-info/WHEEL
--rw-rw-rw-  2.0 fat       61 b- defN 24-Feb-21 00:41 junit2html-30.1.6.dist-info/entry_points.txt
--rw-rw-rw-  2.0 fat       17 b- defN 24-Feb-21 00:41 junit2html-30.1.6.dist-info/top_level.txt
--rw-rw-r--  2.0 fat     1714 b- defN 24-Feb-21 00:41 junit2html-30.1.6.dist-info/RECORD
-20 files, 46653 bytes uncompressed, 13019 bytes compressed:  72.1%
+Zip file size: 17441 bytes, number of entries: 21
+-rw-r--r--  2.0 unx        0 b- defN 24-May-10 20:15 junit2htmlreport/__init__.py
+-rw-r--r--  2.0 unx      106 b- defN 24-May-10 20:15 junit2htmlreport/__main__.py
+-rw-r--r--  2.0 unx      474 b- defN 24-May-10 20:15 junit2htmlreport/case_result.py
+-rw-r--r--  2.0 unx     1080 b- defN 24-May-10 20:15 junit2htmlreport/common.py
+-rw-r--r--  2.0 unx     9496 b- defN 24-May-10 20:15 junit2htmlreport/matrix.py
+-rw-r--r--  2.0 unx     2647 b- defN 24-May-10 20:15 junit2htmlreport/merge.py
+-rw-r--r--  2.0 unx    15374 b- defN 24-May-10 20:15 junit2htmlreport/parser.py
+-rw-r--r--  2.0 unx      298 b- defN 24-May-10 20:15 junit2htmlreport/parserimpl.py
+-rw-r--r--  2.0 unx     1953 b- defN 24-May-10 20:15 junit2htmlreport/render.py
+-rw-r--r--  2.0 unx     3929 b- defN 24-May-10 20:15 junit2htmlreport/runner.py
+-rw-r--r--  2.0 unx      302 b- defN 24-May-10 20:15 junit2htmlreport/textutils.py
+-rw-r--r--  2.0 unx      297 b- defN 24-May-10 20:15 junit2htmlreport/templates/base.html
+-rw-r--r--  2.0 unx     2795 b- defN 24-May-10 20:15 junit2htmlreport/templates/matrix.html
+-rw-r--r--  2.0 unx     4859 b- defN 24-May-10 20:15 junit2htmlreport/templates/report.html
+-rw-r--r--  2.0 unx     3491 b- defN 24-May-10 20:15 junit2htmlreport/templates/styles.css
+-rw-r--r--  2.0 unx     1067 b- defN 24-May-10 20:16 junit2html-31.0.1.dist-info/LICENSE
+-rw-r--r--  2.0 unx      393 b- defN 24-May-10 20:16 junit2html-31.0.1.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 24-May-10 20:16 junit2html-31.0.1.dist-info/WHEEL
+-rw-r--r--  2.0 unx       61 b- defN 24-May-10 20:16 junit2html-31.0.1.dist-info/entry_points.txt
+-rw-r--r--  2.0 unx       17 b- defN 24-May-10 20:16 junit2html-31.0.1.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     1802 b- defN 24-May-10 20:16 junit2html-31.0.1.dist-info/RECORD
+21 files, 50533 bytes uncompressed, 14477 bytes compressed:  71.4%
```

## zipnote {}

```diff
@@ -1,13 +1,16 @@
 Filename: junit2htmlreport/__init__.py
 Comment: 
 
 Filename: junit2htmlreport/__main__.py
 Comment: 
 
+Filename: junit2htmlreport/case_result.py
+Comment: 
+
 Filename: junit2htmlreport/common.py
 Comment: 
 
 Filename: junit2htmlreport/matrix.py
 Comment: 
 
 Filename: junit2htmlreport/merge.py
@@ -36,26 +39,26 @@
 
 Filename: junit2htmlreport/templates/report.html
 Comment: 
 
 Filename: junit2htmlreport/templates/styles.css
 Comment: 
 
-Filename: junit2html-30.1.6.dist-info/LICENSE
+Filename: junit2html-31.0.1.dist-info/LICENSE
 Comment: 
 
-Filename: junit2html-30.1.6.dist-info/METADATA
+Filename: junit2html-31.0.1.dist-info/METADATA
 Comment: 
 
-Filename: junit2html-30.1.6.dist-info/WHEEL
+Filename: junit2html-31.0.1.dist-info/WHEEL
 Comment: 
 
-Filename: junit2html-30.1.6.dist-info/entry_points.txt
+Filename: junit2html-31.0.1.dist-info/entry_points.txt
 Comment: 
 
-Filename: junit2html-30.1.6.dist-info/top_level.txt
+Filename: junit2html-31.0.1.dist-info/top_level.txt
 Comment: 
 
-Filename: junit2html-30.1.6.dist-info/RECORD
+Filename: junit2html-31.0.1.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## junit2htmlreport/__main__.py

 * *Ordering differences only*

```diff
@@ -1,6 +1,6 @@
-import sys
-if sys.version_info >= (3, 0):
-    from . import runner
-else:
-    import runner
-runner.start()
+import sys
+if sys.version_info >= (3, 0):
+    from . import runner
+else:
+    import runner
+runner.start()
```

## junit2htmlreport/common.py

```diff
@@ -1,38 +1,47 @@
-"""
-Common code between JUnit2HTML matrix and merge classes
-"""
-from __future__ import print_function
-
-
-class ReportContainer(object):
-    """
-    Hold one or more reports
-    """
-    def __init__(self):
-        self.reports = {}
-
-    def add_report(self, file):
-        raise NotImplementedError()
-
-    def failures(self):
-        """
-        Return all the failed test cases
-        :return:
-        """
-        found = []
-        for report in self.reports:
-            for suite in self.reports[report].suites:
-                found.extend(suite.failed())
-
-        return found
-
-    def skips(self):
-        """
-        Return all the skipped test cases
-        :return:
-        """
-        found = []
-        for report in self.reports:
-            for suite in self.reports[report].suites:
-                found.extend(suite.skipped())
-        return found
+"""
+Common code between JUnit2HTML matrix and merge classes
+"""
+from __future__ import print_function
+
+from typing import TYPE_CHECKING
+
+from .parser import Case, Junit
+
+if TYPE_CHECKING: # pragma: no cover
+    from typing import Dict, List
+
+
+class ReportContainer(object):
+    """
+    Hold one or more reports
+    """
+    reports: "Dict[str, Junit]"
+
+    def __init__(self):
+        self.reports = {}
+
+    def add_report(self, filename: str) -> None:
+        raise NotImplementedError()
+
+    def failures(self):
+        """
+        Return all the failed test cases
+        :return:
+        """
+        found: "List[Case]" = []
+        for report in self.reports:
+            for suite in self.reports[report].suites:
+                found.extend(suite.failed())
+
+        return found
+
+    def skips(self):
+        """
+        Return all the skipped test cases
+        :return:
+        """
+        found: "List[Case]" = []
+        for report in self.reports:
+            for suite in self.reports[report].suites:
+                found.extend(suite.skipped())
+        return found
```

## junit2htmlreport/matrix.py

```diff
@@ -1,253 +1,274 @@
-"""
-Handle multiple parsed junit reports
-"""
-from __future__ import unicode_literals
-import os
-from . import parser
-from .common import ReportContainer
-from .parser import SKIPPED, FAILED, PASSED, ABSENT
-from .render import HTMLMatrix, HTMLReport
-
-UNTESTED = "untested"
-PARTIAL_PASS = "partial pass"
-PARTIAL_FAIL = "partial failure"
-TOTAL_FAIL = "total failure"
-
-
-class ReportMatrix(ReportContainer):
-    """
-    Load and handle several report files
-    """
-
-    def __init__(self):
-        super(ReportMatrix, self).__init__()
-        self.cases = {}
-        self.classes = {}
-        self.casenames = {}
-        self.result_stats = {}
-        self.case_results = {}
-
-    def add_case_result(self, case):
-        testclass = case.testclass.name
-        casename = case.name
-        if testclass not in self.case_results:
-            self.case_results[testclass] = {}
-        if casename not in self.case_results[testclass]:
-            self.case_results[testclass][casename] = []
-        self.case_results[testclass][casename].append(case.outcome())
-
-    def report_order(self):
-        return sorted(self.reports.keys())
-
-    def short_outcome(self, outcome):
-        if outcome == PASSED:
-            return "/"
-        elif outcome == SKIPPED:
-            return "s"
-        elif outcome == FAILED:
-            return "f"
-        elif outcome == TOTAL_FAIL:
-            return "F"
-        elif outcome == PARTIAL_PASS:
-            return "%"
-        elif outcome == PARTIAL_FAIL:
-            return "X"
-        elif outcome == UNTESTED:
-            return "U"
-
-        return "?"
-
-    def add_report(self, filename):
-        """
-        Load a report into the matrix
-        :param filename:
-        :return:
-        """
-        parsed = parser.Junit(filename=filename)
-        filename = os.path.basename(filename)
-        self.reports[filename] = parsed
-
-        for suite in parsed.suites:
-            for testclass in suite.classes:
-                if testclass not in self.classes:
-                    self.classes[testclass] = {}
-                if testclass not in self.casenames:
-                    self.casenames[testclass] = list()
-                self.classes[testclass][filename] = suite.classes[testclass]
-
-                for testcase in self.classes[testclass][filename].cases:
-                    name = testcase.name.strip()
-                    if name not in self.casenames[testclass]:
-                        self.casenames[testclass].append(name)
-
-                    if testclass not in self.cases:
-                        self.cases[testclass] = {}
-                    if name not in self.cases[testclass]:
-                        self.cases[testclass][name] = {}
-                    self.cases[testclass][name][filename] = testcase
-
-                    outcome = testcase.outcome()
-                    self.add_case_result(testcase)
-
-                    self.result_stats[outcome] = 1 + self.result_stats.get(
-                        outcome, 0)
-
-    def summary(self):
-        """
-        Render a summary of the matrix
-        :return:
-        """
-        raise NotImplementedError()
-
-    def combined_result_list(self, classname, casename):
-        """
-        Combone the result of all instances of the given case
-        :param classname:
-        :param casename:
-        :return:
-        """
-        if classname in self.case_results:
-            if casename in self.case_results[classname]:
-                results = self.case_results[classname][casename]
-                return self.combined_result(results)
-
-        return " ", ""
-
-    def combined_result(self, results):
-        """
-        Given a list of results, produce a "combined" overall result
-        :param results:
-        :return:
-        """
-        if results:
-            if PASSED in results:
-                if FAILED in results:
-                    return self.short_outcome(PARTIAL_FAIL), PARTIAL_FAIL.title()
-                return self.short_outcome(PASSED), PASSED.title()
-
-            if FAILED in results:
-                return self.short_outcome(FAILED), FAILED.title()
-            if SKIPPED in results:
-                return self.short_outcome(UNTESTED), UNTESTED.title()
-        return " ", ""
-
-
-class HtmlReportMatrix(ReportMatrix):
-    """
-    Render a matrix report as html
-    """
-
-    def __init__(self, outdir):
-        super(HtmlReportMatrix, self).__init__()
-        self.outdir = outdir
-
-    def add_report(self, filename):
-        """
-        Load a report
-        """
-        super(HtmlReportMatrix, self).add_report(filename)
-        basename = os.path.basename(filename)
-        # make the individual report too
-        report = self.reports[basename].html()
-        if self.outdir != "" and not os.path.exists(self.outdir):
-            os.makedirs(self.outdir)
-        with open(
-                os.path.join(self.outdir, basename) + ".html", "wb") as filehandle:
-            filehandle.write(report.encode("utf-8"))
-
-    def short_outcome(self, outcome):
-        if outcome == PASSED:
-            return "ok"
-        return super(HtmlReportMatrix, self).short_outcome(outcome)
-
-    def short_axis(self, axis):
-        if axis.endswith(".xml"):
-            return axis[:-4]
-        return axis
-
-    def summary(self, template=None):
-        """
-        Render the html
-        :return:
-        """
-        html_matrix = HTMLMatrix(self, template)
-
-        return str(html_matrix)
-
-
-class TextReportMatrix(ReportMatrix):
-    """
-    Render a matrix report as text
-    """
-
-    def summary(self):
-        """
-        Render as a string
-        :return:
-        """
-
-        output = "\nMatrix Test Report\n"
-        output += "===================\n"
-
-        axis = list(self.reports.keys())
-        axis.sort()
-
-        # find the longest classname or test case name
-        left_indent = 0
-        for classname in self.classes:
-            left_indent = max(len(classname), left_indent)
-            for casename in self.casenames[classname]:
-                left_indent = max(len(casename), left_indent)
-
-        # render the axis headings in a stepped tree
-        treelines = ""
-        for filename in self.report_order():
-            output += "{}    {}{}\n".format(" " * left_indent, treelines,
-                                            filename)
-            treelines += "| "
-        output += "{}    {}\n".format(" " * left_indent, treelines)
-        # render in groups of the same class
-
-        for classname in self.classes:
-            # new class
-            output += "{}  \n".format(classname)
-
-            # print the case name
-            for casename in sorted(set(self.casenames[classname])):
-                output += "- {}{}  ".format(casename,
-                                            " " * (left_indent - len(casename)))
-
-                # print each test and its result for each axis
-                case_data = ""
-                for axis in self.report_order():
-                    if axis not in self.cases[classname][casename]:
-                        case_data += "  "
-                    else:
-                        testcase = self.cases[classname][casename][axis]
-                        if testcase.skipped:
-                            case_data += "s "
-                        elif testcase.failure:
-                            case_data += "f "
-                        else:
-                            case_data += "/ "
-
-                combined, combined_name = self.combined_result(
-                    self.case_results[classname][testcase.name])
-
-                output += case_data
-                output += " {} {}\n".format(combined, combined_name)
-
-        # print the result stats
-
-        output += "\n"
-        output += "-" * 79
-        output += "\n"
-
-        output += "Test Results:\n"
-
-        for outcome in sorted(self.result_stats):
-            output += "  {:<12} : {:>6}\n".format(
-                outcome.title(),
-                self.result_stats[outcome])
-
-        return output
+"""
+Handle multiple parsed junit reports
+"""
+from __future__ import unicode_literals
+
+import os
+from typing import TYPE_CHECKING
+
+from . import parser
+from .case_result import CaseResult
+from .common import ReportContainer
+from .render import HTMLMatrix
+
+if TYPE_CHECKING: # pragma: no cover
+    from .parser import Case, Class
+    from typing import Dict, List, Optional, Any, Literal
+
+
+class ReportMatrix(ReportContainer):
+    """
+    Load and handle several report files
+    """
+    cases: "Dict[str, Dict[str, Dict[str, Case]]]"
+    classes: "Dict[str, Dict[str, Class]]"
+    casenames: "Dict[str, List[str]]"
+    result_stats: "Dict[CaseResult, int]"
+    case_results: "Dict[str, Dict[str, List[CaseResult]]]"
+
+    def __init__(self):
+        super(ReportMatrix, self).__init__()
+        self.cases = {}
+        self.classes = {}
+        self.casenames = {}
+        self.result_stats = {}
+        self.case_results = {}
+
+    def add_case_result(self, case: "Case"):
+        if case.testclass is None or case.testclass.name is None:
+            testclass = ""
+        else:
+            testclass = case.testclass.name
+        casename = "" if case.name is None else case.name
+        if testclass not in self.case_results:
+            self.case_results[testclass] = {}
+        if casename not in self.case_results[testclass]:
+            self.case_results[testclass][casename] = []
+        self.case_results[testclass][casename].append(case.outcome())
+
+    def report_order(self):
+        return sorted(self.reports.keys())
+
+    def short_outcome(self, outcome: CaseResult) -> "Literal['ok', '/', 's', 'f', 'F', '%', 'X', 'U', '?']":
+        if outcome == CaseResult.PASSED:
+            return "/"
+        elif outcome == CaseResult.SKIPPED: # pragma: no cover
+            return "s" # currently unused because SKIPPED returns UNTESTED
+        elif outcome == CaseResult.FAILED:
+            return "f"
+        elif outcome == CaseResult.TOTAL_FAIL:
+            return "F"
+        elif outcome == CaseResult.PARTIAL_PASS:
+            return "%"
+        elif outcome == CaseResult.PARTIAL_FAIL:
+            return "X"
+        elif outcome == CaseResult.UNTESTED:
+            return "U"
+
+        return "?"
+
+    def add_report(self, filename: str):
+        """
+        Load a report into the matrix
+        :param filename:
+        :return:
+        """
+        parsed = parser.Junit(filename=filename)
+        filename = os.path.basename(filename)
+        self.reports[filename] = parsed
+
+        for suite in parsed.suites:
+            for testclass in suite.classes:
+                if testclass not in self.classes:
+                    self.classes[testclass] = {}
+                if testclass not in self.casenames:
+                    self.casenames[testclass] = list()
+                self.classes[testclass][filename] = suite.classes[testclass]
+
+                for testcase in self.classes[testclass][filename].cases:
+                    name = "" if testcase.name is None else testcase.name.strip()
+                    if name not in self.casenames[testclass]:
+                        self.casenames[testclass].append(name)
+
+                    if testclass not in self.cases:
+                        self.cases[testclass] = {}
+                    if name not in self.cases[testclass]:
+                        self.cases[testclass][name] = {}
+                    self.cases[testclass][name][filename] = testcase
+
+                    outcome = testcase.outcome()
+                    self.add_case_result(testcase)
+
+                    self.result_stats[outcome] = 1 + self.result_stats.get(
+                        outcome, 0)
+
+    def summary(self) -> str:
+        """
+        Render a summary of the matrix
+        :return:
+        """
+        raise NotImplementedError()
+
+    def combined_result_list(self, classname: str, casename: str):
+        """
+        Combone the result of all instances of the given case
+        :param classname:
+        :param casename:
+        :return:
+        """
+        if classname in self.case_results:
+            if casename in self.case_results[classname]:
+                results = self.case_results[classname][casename]
+                return self.combined_result(results)
+
+        return " ", ""
+
+    def combined_result(self, results: "List[CaseResult]"):
+        """
+        Given a list of results, produce a "combined" overall result
+        :param results:
+        :return:
+        """
+        if results:
+            if CaseResult.PASSED in results:
+                if CaseResult.FAILED in results:
+                    return self.short_outcome(CaseResult.PARTIAL_FAIL), CaseResult.PARTIAL_FAIL.title()
+                return self.short_outcome(CaseResult.PASSED), CaseResult.PASSED.title()
+
+            if CaseResult.FAILED in results:
+                return self.short_outcome(CaseResult.FAILED), CaseResult.FAILED.title()
+            if CaseResult.SKIPPED in results:
+                return self.short_outcome(CaseResult.UNTESTED), CaseResult.UNTESTED.title()
+            if CaseResult.PARTIAL_PASS in results:
+                return self.short_outcome(CaseResult.PARTIAL_PASS), CaseResult.PARTIAL_PASS.title()
+            if CaseResult.TOTAL_FAIL in results:
+                return self.short_outcome(CaseResult.TOTAL_FAIL), CaseResult.TOTAL_FAIL.title()
+        return " ", ""
+
+
+class HtmlReportMatrix(ReportMatrix):
+    """
+    Render a matrix report as html
+    """
+
+    outdir: str
+
+    def __init__(self, outdir: str):
+        super(HtmlReportMatrix, self).__init__()
+        self.outdir = outdir
+
+    def add_report(self, filename: str, show_toc: bool=True):
+        """
+        Load a report
+        """
+        super(HtmlReportMatrix, self).add_report(filename)
+        basename = os.path.basename(filename)
+        # make the individual report too
+        report = self.reports[basename].html(show_toc=show_toc)
+        if self.outdir != "" and not os.path.exists(self.outdir):
+            os.makedirs(self.outdir)
+        with open(
+                os.path.join(self.outdir, basename) + ".html", "wb") as filehandle:
+            filehandle.write(report.encode("utf-8"))
+
+    def short_outcome(self, outcome: CaseResult) -> "Literal['ok', '/', 's', 'f', 'F', '%', 'X', 'U', '?']":
+        if outcome == CaseResult.PASSED:
+            return "ok"
+        return super(HtmlReportMatrix, self).short_outcome(outcome)
+
+    def short_axis(self, axis: str):
+        if axis.endswith(".xml"):
+            return axis[:-4]
+        return axis
+
+    def summary(self, template: "Optional[Any]"=None):
+        """
+        Render the html
+        :return:
+        """
+        html_matrix = HTMLMatrix(self, template)
+
+        return str(html_matrix)
+
+
+class TextReportMatrix(ReportMatrix):
+    """
+    Render a matrix report as text
+    """
+
+    def summary(self):
+        """
+        Render as a string
+        :return:
+        """
+
+        output = "\nMatrix Test Report\n"
+        output += "===================\n"
+
+        axis = list(self.reports.keys())
+        axis.sort()
+
+        # find the longest classname or test case name
+        left_indent = 0
+        for classname in self.classes:
+            left_indent = max(len(classname), left_indent)
+            for casename in self.casenames[classname]:
+                left_indent = max(len(casename), left_indent)
+
+        # render the axis headings in a stepped tree
+        treelines = ""
+        for filename in self.report_order():
+            output += "{}    {}{}\n".format(" " * left_indent, treelines,
+                                            filename)
+            treelines += "| "
+        output += "{}    {}\n".format(" " * left_indent, treelines)
+        # render in groups of the same class
+
+        for classname in self.classes:
+            # new class
+            output += "{}  \n".format(classname)
+
+            # print the case name
+            for casename in sorted(set(self.casenames[classname])):
+                output += "- {}{}  ".format(casename,
+                                            " " * (left_indent - len(casename)))
+
+                # print each test and its result for each axis
+                case_data = ""
+                testcase: "Optional[Case]" = None
+                for axis in self.report_order():
+                    if axis not in self.cases[classname][casename]:
+                        case_data += "  "
+                    else:
+                        testcase = self.cases[classname][casename][axis]
+                        if testcase.skipped:
+                            case_data += "s "
+                        elif testcase.failure:
+                            case_data += "f "
+                        else:
+                            case_data += "/ "
+
+                if testcase is None or testcase.name is None:
+                    testcase_name = ""
+                else:
+                    testcase_name = testcase.name
+                combined, combined_name = self.combined_result(
+                    self.case_results[classname][testcase_name])
+
+                output += case_data
+                output += " {} {}\n".format(combined, combined_name)
+
+        # print the result stats
+
+        output += "\n"
+        output += "-" * 79
+        output += "\n"
+
+        output += "Test Results:\n"
+
+        for outcome in sorted(self.result_stats):
+            output += "  {:<12} : {:>6}\n".format(
+                outcome.title(),
+                self.result_stats[outcome])
+
+        return output
```

## junit2htmlreport/merge.py

```diff
@@ -1,90 +1,99 @@
-"""
-Classes for merging several reports into one
-"""
-from __future__ import unicode_literals
-import os
-from io import BytesIO
-from junit2htmlreport import parser
-from junit2htmlreport.common import ReportContainer
-from junit2htmlreport.textutils import unicode_str
-import xml.etree.ElementTree as ET
-
-
-def has_xml_header(filepath):
-    """
-    Return True if the first line of the file is <?xml
-    :param filepath:
-    :return:
-    """
-    return True
-
-
-class Merger(ReportContainer, parser.ToJunitXmlBase):
-    """
-    Utility class to create a merged junix xml report
-    """
-    def __init__(self):
-        super(Merger, self).__init__()
-        self.suites = []
-
-    def add_report(self, filename):
-        """
-        Load a test report or folder
-        :param filename:
-        :return:
-        """
-        if os.path.isfile(filename):
-            report = parser.Junit(filename)
-            self.reports[filename] = report
-            for suite in report.suites:
-                self.suites.append(suite)
-        elif os.path.isdir(filename):
-            # try importing all files in this folder
-            for root, dirs, files in os.walk(filename):
-                for filename in files:
-                    filepath = os.path.join(root, filename)
-                    if has_xml_header(filepath):
-                        try:
-                            self.add_report(filepath)
-                        except (parser.ParserError, ET.ParseError):
-                            pass
-
-    def add_suite(self, suite):
-        """
-        Add a suite to the merge
-        :param suite:
-        :return:
-        """
-        self.suites.append(suite)
-
-    def calculate_duration(self):
-        """
-        Add up the time values in all testcases
-        :return:
-        """
-        total = 0
-        for suite in self.suites:
-            for testcase in suite.all():
-                total += testcase.duration
-        return total
-
-    def tojunit(self):
-        """
-        Render a merged xml report
-        :return:
-        """
-        root = self.make_element("testsuites")
-        root.set(u"duration", unicode_str(self.calculate_duration()))
-        for suite in self.suites:
-            root.append(suite.tojunit())
-        return root
-
-    def toxmlstring(self):
-        """
-        Render the xml document as a string
-        :return:
-        """
-        tree = ET.ElementTree(self.tojunit())
-        buf = BytesIO()
-        tree.write(buf)
-        return u'<?xml version="1.0" encoding="utf-8"?>' + u"\n" + unicode_str(buf.getvalue())
+"""
+Classes for merging several reports into one
+"""
+from __future__ import unicode_literals
+
+from typing import TYPE_CHECKING
+
+import os
+import xml.etree.ElementTree as ET
+from io import BytesIO
+
+from . import parser
+from .common import ReportContainer
+from .textutils import unicode_str
+
+if TYPE_CHECKING:
+    from typing import List
+
+
+def has_xml_header(filepath: str):
+    """
+    Return True if the first line of the file is <?xml
+    :param filepath:
+    :return:
+    """
+    return True
+
+
+class Merger(ReportContainer, parser.ToJunitXmlBase):
+    """
+    Utility class to create a merged junix xml report
+    """
+    suites: "List[parser.Suite]"
+
+    def __init__(self):
+        super(Merger, self).__init__()
+        self.suites = []
+
+    def add_report(self, filename: str):
+        """
+        Load a test report or folder
+        :param filename:
+        :return:
+        """
+        if os.path.isfile(filename):
+            report = parser.Junit(filename)
+            self.reports[filename] = report
+            for suite in report.suites:
+                self.suites.append(suite)
+        elif os.path.isdir(filename):
+            # try importing all files in this folder
+            for root, dirs, files in os.walk(filename):
+                for filename in files:
+                    filepath = os.path.join(root, filename)
+                    if has_xml_header(filepath):
+                        try:
+                            self.add_report(filepath)
+                        except (parser.ParserError, ET.ParseError):
+                            pass
+
+    def add_suite(self, suite: "parser.Suite"):
+        """
+        Add a suite to the merge
+        :param suite:
+        :return:
+        """
+        self.suites.append(suite)
+
+    def calculate_duration(self):
+        """
+        Add up the time values in all testcases
+        :return:
+        """
+        total = 0
+        for suite in self.suites:
+            for testcase in suite.all():
+                total += testcase.duration
+        return total
+
+    def tojunit(self):
+        """
+        Render a merged xml report
+        :return:
+        """
+        root = self.make_element("testsuites")
+        root.set(u"duration", unicode_str(self.calculate_duration()))
+        for suite in self.suites:
+            root.append(suite.tojunit())
+        return root
+
+    def toxmlstring(self):
+        """
+        Render the xml document as a string
+        :return:
+        """
+        tree = ET.ElementTree(self.tojunit())
+        buf = BytesIO()
+        tree.write(buf)
+        return u'<?xml version="1.0" encoding="utf-8"?>' + u"\n" + unicode_str(buf.getvalue())
```

## junit2htmlreport/parser.py

```diff
@@ -1,476 +1,505 @@
-"""
-Parse a junit report file into a family of objects
-"""
-from __future__ import unicode_literals
-
-import os
-import sys
-import xml.etree.ElementTree as ET
-import collections
-from .textutils import unicode_str
-from .render import HTMLReport
-import uuid
-
-
-NO_CLASSNAME = "no-testclass"
-
-FAILED = "failed"  # the test failed
-SKIPPED = "skipped"  # the test was skipped
-PASSED = "passed"  # the test completed successfully
-ABSENT = "absent"  # the test was known but not run/failed/skipped
-
-
-def clean_xml_attribute(element, attribute, default=None):
-    """
-    Get an XML attribute value and ensure it is legal in XML
-    :param element:
-    :param attribute:
-    :param default:
-    :return:
-    """
-
-    value = element.attrib.get(attribute, default)
-    if value:
-        value = value.encode("utf-8", errors="replace").decode("utf-8", errors="backslashreplace")
-        value = value.replace(u"\ufffd", "?")  # strip out the unicode replacement char
-
-    return value
-
-
-class ParserError(Exception):
-    """
-    We had a problem parsing a file
-    """
-    def __init__(self, message):
-        super(ParserError, self).__init__(message)
-
-
-class ToJunitXmlBase(object):
-    """
-    Base class of all objects that can be serialized to Junit XML
-    """
-    def tojunit(self):
-        """
-        Return an Element matching this object
-        :return:
-        """
-        raise NotImplementedError()
-
-    def make_element(self, xmltag, text=None, attribs=None):
-        """
-        Create an Element and put text and/or attribs into it
-        :param xmltag: tag name
-        :param text:
-        :param attribs: dict of xml attributes
-        :return:
-        """
-        element = ET.Element(unicode_str(xmltag))
-        if text is not None:
-            element.text = unicode_str(text)
-        if attribs is not None:
-            for item in attribs:
-                element.set(unicode_str(item), unicode_str(attribs[item]))
-        return element
-
-
-class AnchorBase(object):
-    """
-    Base class that can generate a unique anchor name.
-    """
-    def __init__(self):
-        self._anchor = None
-
-    def id(self):
-        return self.anchor()
-
-    def anchor(self):
-        """
-        Generate a html anchor name
-        :return:
-        """
-        if not self._anchor:
-            self._anchor = str(uuid.uuid4())
-        return self._anchor
-
-
-class Class(AnchorBase):
-    """
-    A namespace for a test
-    """
-    def __init__(self):
-        super(Class, self).__init__()
-        self.name = None
-        self.cases = list()
-
-
-class Property(AnchorBase, ToJunitXmlBase):
-    """
-    Test Properties
-    """
-    def __init__(self):
-        super(Property, self).__init__()
-        self.name = None
-        self.value = None
-
-    def tojunit(self):
-        """
-        Return the xml element for this property
-        :return:
-        """
-        prop = self.make_element("property")
-        prop.set(u"name", unicode_str(self.name))
-        prop.set(u"value", unicode_str(self.value))
-        return prop
-
-
-class Case(AnchorBase, ToJunitXmlBase):
-    """
-    Test cases
-    """
-
-    def __init__(self):
-        super(Case, self).__init__()
-        self.failure = None
-        self.failure_msg = None
-        self.skipped = False
-        self.skipped_msg = None
-        self.stderr = None
-        self.stdout = None
-        self.duration = 0
-        self.name = None
-        self.testclass = None
-        self.properties = list()
-
-    @property
-    def display_suffix(self):
-        if self.skipped:
-            return "[s]"
-        return ""
-
-    def outcome(self):
-        """
-        Return the result of this test case
-        :return:
-        """
-        if self.skipped:
-            return SKIPPED
-        elif self.failed():
-            return FAILED
-        return PASSED
-
-    def prefix(self):
-        if self.skipped:
-            return "[S]"
-        if self.failed():
-            return "[F]"
-        return ""
-
-    def tojunit(self):
-        """
-        Turn this test case back into junit xml
-        :note: this may not be the exact input we loaded
-        :return:
-        """
-        testcase = self.make_element("testcase")
-        testcase.set(u"name", unicode_str(self.name))
-        testcase.set(u"classname", unicode_str(self.testclass.name))
-        testcase.set(u"time", unicode_str(self.duration))
-
-        if self.stderr is not None:
-            testcase.append(self.make_element("system-err", self.stderr))
-        if self.stdout is not None:
-            testcase.append(self.make_element("system-out", self.stdout))
-
-        if self.failure is not None:
-            testcase.append(self.make_element(
-                "failure", self.failure,
-                {
-                    "message": self.failure_msg
-                }))
-
-        if self.skipped:
-            testcase.append(self.make_element(
-                "skipped", self.skipped,
-                {
-                    "message": self.skipped_msg
-                }))
-
-        if self.properties:
-            props = self.make_element("properties")
-            for prop in self.properties:
-                props.append(prop.tojunit())
-            testcase.append(props)
-
-        return testcase
-
-    def fullname(self):
-        """
-        Get the full name of a test case
-        :return:
-        """
-        return "{} : {}".format(self.testclass.name, self.name)
-
-    def basename(self):
-        """
-        Get a short name for this case
-        :return:
-        """
-        if self.name.startswith(self.testclass.name):
-            return self.name[len(self.testclass.name):]
-        return self.name
-
-    def failed(self):
-        """
-        Return True if this test failed
-        :return:
-        """
-        return self.failure is not None
-
-
-class Suite(AnchorBase, ToJunitXmlBase):
-    """
-    Contains test cases (usually only one suite per report)
-    """
-    def __init__(self):
-        super(Suite, self).__init__()
-        self.name = None
-        self.duration = 0
-        self.classes = collections.OrderedDict()
-        self.package = None
-        self.properties = []
-        self.errors = []
-        self.stdout = None
-        self.stderr = None
-
-    def tojunit(self):
-        """
-        Return an element for this whole suite and all it's cases
-        :return:
-        """
-        suite = self.make_element("testsuite")
-        suite.set(u"name", unicode_str(self.name))
-        suite.set(u"time", unicode_str(self.duration))
-        if self.properties:
-            props = self.make_element("properties")
-            for prop in self.properties:
-                props.append(prop.tojunit())
-            suite.append(props)
-
-        for testcase in self.all():
-            suite.append(testcase.tojunit())
-        return suite
-
-    def __contains__(self, item):
-        """
-        Return True if the given test classname is part of this test suite
-        :param item:
-        :return:
-        """
-        return item in self.classes
-
-    def __getitem__(self, item):
-        """
-        Return the given test class object
-        :param item:
-        :return:
-        """
-        return self.classes[item]
-
-    def __setitem__(self, key, value):
-        """
-        Add a test class
-        :param key:
-        :param value:
-        :return:
-        """
-        self.classes[key] = value
-
-    def all(self):
-        """
-        Return all testcases
-        :return:
-        """
-        tests = list()
-        for testclass in self.classes:
-            tests.extend(self.classes[testclass].cases)
-        return tests
-
-    def failed(self):
-        """
-        Return all the failed testcases
-        :return:
-        """
-        return [test for test in self.all() if test.failed()]
-
-    def skipped(self):
-        """
-        Return all skipped testcases
-        :return:
-        """
-        return [test for test in self.all() if test.skipped]
-
-    def passed(self):
-        """
-        Return all the passing testcases
-        :return:
-        """
-        return [test for test in self.all() if not test.failed() and not test.skipped()]
-
-
-class Junit(object):
-    """
-    Parse a single junit xml report
-    """
-
-    def __init__(self, filename=None, xmlstring=None):
-        """
-        Parse the file
-        :param filename:
-        :return:
-        """
-        self.filename = filename
-        if filename == "-":
-            # read the xml from stdin
-            stdin = sys.stdin.read()
-            xmlstring = stdin
-            self.filename = None
-
-        self.tree = None
-        if self.filename is not None:
-            self.tree = ET.parse(self.filename)
-        elif xmlstring is not None:
-            self._read(xmlstring)
-        else:
-            raise ValueError("Missing any filename or xmlstring")
-        self.suites = []
-        self.process()
-
-    def __iter__(self):
-        return self.suites.__iter__()
-
-    def _read(self, xmlstring):
-        """
-        Populate the junit xml document tree from a string
-        :param xmlstring:
-        :return:
-        """
-        self.tree = ET.fromstring(xmlstring)
-
-    def process(self):
-        """
-        populate the report from the xml
-        :return:
-        """
-        testrun = False
-        suites = None
-        if isinstance(self.tree, ET.ElementTree):
-            root = self.tree.getroot()
-        else:
-            root = self.tree
-
-        if root.tag == "testrun":
-            testrun = True
-            root = root[0]
-
-        if root.tag == "testsuite":
-            suites = [root]
-
-        if root.tag == "testsuites" or testrun:
-            suites = [x for x in root]
-
-        if suites is None:
-            raise ParserError("could not find test suites in results xml")
-        suitecount = 0
-        for suite in suites:
-            suitecount += 1
-            cursuite = Suite()
-            self.suites.append(cursuite)
-            cursuite.name = clean_xml_attribute(suite, "name", default="suite-" + str(suitecount))
-            cursuite.package = clean_xml_attribute(suite, "package")
-
-            cursuite.duration = float(suite.attrib.get("time", '0').replace(',', '') or '0')
-
-            for element in suite:
-                if element.tag == "error":
-                    # top level error?
-                    errtag = {
-                        "message": element.attrib.get("message", ""),
-                        "type": element.attrib.get("type", ""),
-                        "text": element.text
-                    }
-                    cursuite.errors.append(errtag)
-                if element.tag == "system-out":
-                    cursuite.stdout = element.text
-                if element.tag == "system-err":
-                    cursuite.stderr = element.text
-
-                if element.tag == "properties":
-                    for prop in element:
-                        if prop.tag == "property":
-                            newproperty = Property()
-                            newproperty.name = prop.attrib["name"]
-                            newproperty.value = prop.attrib["value"]
-                            cursuite.properties.append(newproperty)
-
-                if element.tag == "testcase":
-                    testcase = element
-
-                    if not testcase.attrib.get("classname", None):
-                        testcase.attrib["classname"] = NO_CLASSNAME
-
-                    if testcase.attrib["classname"] not in cursuite:
-                        testclass = Class()
-                        testclass.name = testcase.attrib["classname"]
-                        cursuite[testclass.name] = testclass
-
-                    testclass = cursuite[testcase.attrib["classname"]]
-                    newcase = Case()
-                    newcase.name = clean_xml_attribute(testcase, "name")
-                    newcase.testclass = testclass
-                    newcase.duration = float(testcase.attrib.get("time", '0').replace(',', '') or '0')
-                    testclass.cases.append(newcase)
-
-                    # does this test case have any children?
-                    for child in testcase:
-                        if child.tag == "skipped":
-                            newcase.skipped = child.text
-                            if "message" in child.attrib:
-                                newcase.skipped_msg = child.attrib["message"]
-                            if not newcase.skipped:
-                               newcase.skipped = "skipped"
-                        elif child.tag == "system-out":
-                            newcase.stdout = child.text
-                        elif child.tag == "system-err":
-                            newcase.stderr = child.text
-                        elif child.tag == "failure":
-                            newcase.failure = child.text
-                            if "message" in child.attrib:
-                                newcase.failure_msg = child.attrib["message"]
-                            if not newcase.failure:
-                                newcase.failure = "failed"
-                        elif child.tag == "error":
-                            newcase.failure = child.text
-                            if "message" in child.attrib:
-                                newcase.failure_msg = child.attrib["message"]
-                            if not newcase.failure:
-                                newcase.failure = "error"
-                        elif child.tag == "properties":
-                            for property in child:
-                                newproperty = Property()
-                                newproperty.name = property.attrib["name"]
-                                newproperty.value = property.attrib["value"]
-                                newcase.properties.append(newproperty)
-
-    def html(self):
-        """
-        Render the test suite as a HTML report with links to errors first.
-        :return:
-        """
-
-        doc = HTMLReport()
-        title = "Test Results"
-        if self.filename:
-            if os.path.exists(self.filename):
-                title = os.path.basename(self.filename)
-        doc.load(self, title=title)
-        return str(doc)
+"""
+Parse a junit report file into a family of objects
+"""
+from __future__ import unicode_literals
+
+from typing import TYPE_CHECKING
+
+import os
+import sys
+import xml.etree.ElementTree as ET
+import collections
+import uuid
+
+from .case_result import CaseResult
+from .render import HTMLReport
+from .textutils import unicode_str
+
+if TYPE_CHECKING:
+    from typing import Dict, List, Optional, Union, Any, OrderedDict
+
+NO_CLASSNAME = "no-testclass"
+
+
+def clean_xml_attribute(element: "ET.Element", attribute: str, default: "Optional[str]"=None):
+    """
+    Get an XML attribute value and ensure it is legal in XML
+    :param element:
+    :param attribute:
+    :param default:
+    :return:
+    """
+
+    value = element.attrib.get(attribute, default)
+    if value:
+        value = value.encode("utf-8", errors="replace").decode("utf-8", errors="backslashreplace")
+        value = value.replace(u"\ufffd", "?")  # strip out the unicode replacement char
+
+    return value
+
+
+class ParserError(Exception):
+    """
+    We had a problem parsing a file
+    """
+    def __init__(self, message: str):
+        super(ParserError, self).__init__(message)
+
+
+class ToJunitXmlBase(object):
+    """
+    Base class of all objects that can be serialized to Junit XML
+    """
+    def tojunit(self) -> "ET.Element":
+        """
+        Return an Element matching this object
+        :return:
+        """
+        raise NotImplementedError()
+
+    def make_element(self, xmltag: str, text: "Optional[str]"=None, attribs: "Optional[Dict[str, Any]]"=None):
+        """
+        Create an Element and put text and/or attribs into it
+        :param xmltag: tag name
+        :param text:
+        :param attribs: dict of xml attributes
+        :return:
+        """
+        element = ET.Element(unicode_str(xmltag))
+        if text is not None:
+            element.text = unicode_str(text)
+        if attribs is not None:
+            for item in attribs:
+                element.set(unicode_str(item), unicode_str(attribs[item]))
+        return element
+
+
+class AnchorBase(object):
+    """
+    Base class that can generate a unique anchor name.
+    """
+    def __init__(self):
+        self._anchor = None
+
+    def id(self):
+        return self.anchor()
+
+    def anchor(self):
+        """
+        Generate a html anchor name
+        :return:
+        """
+        if not self._anchor:
+            self._anchor = str(uuid.uuid4())
+        return self._anchor
+
+
+class Class(AnchorBase):
+    """
+    A namespace for a test
+    """
+    name: "Optional[str]" = None
+    cases: "list[Case]"
+    
+    def __init__(self):
+        super(Class, self).__init__()
+        self.cases = list()
+
+
+class Property(AnchorBase, ToJunitXmlBase):
+    """
+    Test Properties
+    """
+    def __init__(self):
+        super(Property, self).__init__()
+        self.name: "Optional[str]" = None
+        self.value: "Optional[str]" = None
+
+    def tojunit(self):
+        """
+        Return the xml element for this property
+        :return:
+        """
+        prop = self.make_element("property")
+        prop.set(u"name", unicode_str(self.name))
+        prop.set(u"value", unicode_str(self.value))
+        return prop
+
+
+class Case(AnchorBase, ToJunitXmlBase):
+    """
+    Test cases
+    """
+    failure: "Optional[str]" = None
+    failure_msg: "Optional[str]" = None
+    skipped: "Optional[str]" = None
+    skipped_msg: "Optional[str]" = None
+    stderr: "Optional[Union[str,Any]]" = None
+    stdout: "Optional[Union[str,Any]]" = None
+    duration: float = 0
+    name: "Optional[str]" = None
+    testclass: "Optional[Class]" = None
+    properties: "List[Property]"
+
+    def __init__(self):
+        super(Case, self).__init__()
+        self.properties = list()
+
+    @property
+    def display_suffix(self):
+        if self.skipped:
+            return "[s]"
+        return ""
+
+    def outcome(self) -> CaseResult:
+        """
+        Return the result of this test case
+        :return:
+        """
+        if self.skipped:
+            return CaseResult.SKIPPED
+        elif self.failed():
+            return CaseResult.FAILED
+        return CaseResult.PASSED
+
+    def prefix(self):
+        if self.skipped:
+            return "[S]"
+        if self.failed():
+            return "[F]"
+        return ""
+
+    def tojunit(self):
+        """
+        Turn this test case back into junit xml
+        :note: this may not be the exact input we loaded
+        :return:
+        """
+        if self.testclass is None or self.testclass.name is None:
+            testclass_name = ""
+        else:
+            testclass_name = self.testclass.name
+
+        testcase = self.make_element("testcase")
+        testcase.set(u"name", unicode_str(self.name))
+        testcase.set(u"classname", unicode_str(testclass_name))
+        testcase.set(u"time", unicode_str(self.duration))
+
+        if self.stderr is not None:
+            testcase.append(self.make_element("system-err", self.stderr))
+        if self.stdout is not None:
+            testcase.append(self.make_element("system-out", self.stdout))
+
+        if self.failure is not None:
+            testcase.append(self.make_element(
+                "failure", self.failure,
+                {
+                    "message": self.failure_msg
+                }))
+
+        if self.skipped:
+            testcase.append(self.make_element(
+                "skipped", self.skipped,
+                {
+                    "message": self.skipped_msg
+                }))
+
+        if self.properties:
+            props = self.make_element("properties")
+            for prop in self.properties:
+                props.append(prop.tojunit())
+            testcase.append(props)
+
+        return testcase
+
+    def fullname(self):
+        """
+        Get the full name of a test case
+        :return:
+        """
+        if self.testclass is None or self.testclass.name is None:
+            testclass_name = ""
+        else:
+            testclass_name = self.testclass.name
+        return "{} : {}".format(testclass_name, self.name)
+
+    def basename(self):
+        """
+        Get a short name for this case
+        :return:
+        """
+        if (   self.name is None
+            or self.testclass is None
+            or self.testclass.name is None
+        ):
+            return None
+
+        if self.name.startswith(self.testclass.name):
+            return self.name[len(self.testclass.name):]
+        return self.name
+
+    def failed(self):
+        """
+        Return True if this test failed
+        :return:
+        """
+        return self.failure is not None
+
+
+class Suite(AnchorBase, ToJunitXmlBase):
+    """
+    Contains test cases (usually only one suite per report)
+    """
+    name: "Optional[str]" = None
+    properties: "List[Property]"
+    classes: "OrderedDict[str, Class]"
+    duration: float = 0
+    package: "Optional[str]" = None
+    errors: "List[Dict[str, Optional[Union[str,Any]]]]"
+    stdout: "Optional[Union[str,Any]]" = None
+    stderr: "Optional[Union[str,Any]]" = None
+
+    def __init__(self):
+        super(Suite, self).__init__()
+        self.classes = collections.OrderedDict()
+        self.properties = []
+        self.errors = []
+
+    def tojunit(self):
+        """
+        Return an element for this whole suite and all it's cases
+        :return:
+        """
+        suite = self.make_element("testsuite")
+        suite.set(u"name", unicode_str(self.name))
+        suite.set(u"time", unicode_str(self.duration))
+        if self.properties:
+            props = self.make_element("properties")
+            for prop in self.properties:
+                props.append(prop.tojunit())
+            suite.append(props)
+
+        for testcase in self.all():
+            suite.append(testcase.tojunit())
+        return suite
+
+    def __contains__(self, item: str):
+        """
+        Return True if the given test classname is part of this test suite
+        :param item:
+        :return:
+        """
+        return item in self.classes
+
+    def __getitem__(self, item: str):
+        """
+        Return the given test class object
+        :param item:
+        :return:
+        """
+        return self.classes[item]
+
+    def __setitem__(self, key: str, value: "Class"):
+        """
+        Add a test class
+        :param key:
+        :param value:
+        :return:
+        """
+        self.classes[key] = value
+
+    def all(self):
+        """
+        Return all testcases
+        :return:
+        """
+        tests: "List[Case]" = list()
+        for testclass in self.classes:
+            tests.extend(self.classes[testclass].cases)
+        return tests
+
+    def failed(self):
+        """
+        Return all the failed testcases
+        :return:
+        """
+        return [test for test in self.all() if test.failed()]
+
+    def skipped(self):
+        """
+        Return all skipped testcases
+        :return:
+        """
+        return [test for test in self.all() if test.skipped]
+
+    def passed(self):
+        """
+        Return all the passing testcases
+        :return:
+        """
+        return [test for test in self.all() if not test.failed() and not test.skipped]
+
+
+class Junit(object):
+    """
+    Parse a single junit xml report
+    """
+    filename: "Optional[str]"
+    suites: "List[Suite]"
+    tree: "Union[ET.ElementTree,ET.Element]"
+
+    def __init__(self, filename: "Optional[str]"=None, xmlstring: "Optional[str]"=None):
+        """
+        Parse the file
+        :param filename:
+        :return:
+        """
+        self.filename = filename
+        if filename == "-":
+            # read the xml from stdin
+            stdin = sys.stdin.read()
+            xmlstring = stdin
+            self.filename = None
+
+        self.tree = None # type: ignore
+        if self.filename is not None:
+            self.tree = ET.parse(self.filename)
+        elif xmlstring is not None:
+            self._read(xmlstring)
+        else:
+            raise ValueError("Missing any filename or xmlstring")
+        self.suites = []
+        self.process()
+
+
+    def __iter__(self):
+        return self.suites.__iter__()
+
+    def _read(self, xmlstring: str):
+        """
+        Populate the junit xml document tree from a string
+        :param xmlstring:
+        :return:
+        """
+        self.tree = ET.fromstring(xmlstring)
+
+
+    def process(self):
+        """
+        populate the report from the xml
+        :return:
+        """
+        testrun = False
+        suites: "Optional[list[ET.Element]]" = None
+        root: "ET.Element"
+        if isinstance(self.tree, ET.ElementTree):
+            root = self.tree.getroot()
+        else:
+            root = self.tree
+
+        if root.tag == "testrun":
+            testrun = True
+            root: "ET.Element" = root[0]
+
+        if root.tag == "testsuite":
+            suites = [root]
+
+        if root.tag == "testsuites" or testrun:
+            suites = [x for x in root]
+
+        if suites is None:
+            raise ParserError("could not find test suites in results xml")
+        suitecount = 0
+        for suite in suites:
+            suitecount += 1
+            cursuite = Suite()
+            self.suites.append(cursuite)
+            cursuite.name = clean_xml_attribute(suite, "name", default="suite-" + str(suitecount))
+            cursuite.package = clean_xml_attribute(suite, "package")
+
+            cursuite.duration = float(suite.attrib.get("time", '0').replace(',', '') or '0')
+
+            for element in suite:
+                if element.tag == "error":
+                    # top level error?
+                    errtag = {
+                        "message": element.attrib.get("message", ""),
+                        "type": element.attrib.get("type", ""),
+                        "text": element.text
+                    }
+                    cursuite.errors.append(errtag)
+                if element.tag == "system-out":
+                    cursuite.stdout = element.text
+                if element.tag == "system-err":
+                    cursuite.stderr = element.text
+
+                if element.tag == "properties":
+                    for prop in element:
+                        if prop.tag == "property":
+                            newproperty = Property()
+                            newproperty.name = prop.attrib["name"]
+                            newproperty.value = prop.attrib["value"]
+                            cursuite.properties.append(newproperty)
+
+                if element.tag == "testcase":
+                    testcase = element
+
+                    if not testcase.attrib.get("classname", None):
+                        testcase.attrib["classname"] = NO_CLASSNAME
+
+                    if testcase.attrib["classname"] not in cursuite:
+                        testclass = Class()
+                        testclass.name = testcase.attrib["classname"]
+                        cursuite[testclass.name] = testclass
+
+                    testclass: "Class" = cursuite[testcase.attrib["classname"]]
+                    newcase = Case()
+                    newcase.name = clean_xml_attribute(testcase, "name")
+                    newcase.testclass = testclass
+                    newcase.duration = float(testcase.attrib.get("time", '0').replace(',', '') or '0')
+                    testclass.cases.append(newcase)
+
+                    # does this test case have any children?
+                    for child in testcase:
+                        if child.tag == "skipped":
+                            newcase.skipped = child.text
+                            if "message" in child.attrib:
+                                newcase.skipped_msg = child.attrib["message"]
+                            if not newcase.skipped:
+                               newcase.skipped = "skipped"
+                        elif child.tag == "system-out":
+                            newcase.stdout = child.text
+                        elif child.tag == "system-err":
+                            newcase.stderr = child.text
+                        elif child.tag == "failure":
+                            newcase.failure = child.text
+                            if "message" in child.attrib:
+                                newcase.failure_msg = child.attrib["message"]
+                            if not newcase.failure:
+                                newcase.failure = "failed"
+                        elif child.tag == "error":
+                            newcase.failure = child.text
+                            if "message" in child.attrib:
+                                newcase.failure_msg = child.attrib["message"]
+                            if not newcase.failure:
+                                newcase.failure = "error"
+                        elif child.tag == "properties":
+                            for property in child:
+                                newproperty = Property()
+                                newproperty.name = property.attrib["name"]
+                                newproperty.value = property.attrib["value"]
+                                newcase.properties.append(newproperty)
+
+    def html(self, show_toc: bool=True):
+        """
+        Render the test suite as a HTML report with links to errors first.
+        :return:
+        """
+
+        doc = HTMLReport(show_toc=show_toc)
+        title = "Test Results"
+        if self.filename:
+            if os.path.exists(self.filename):
+                title = os.path.basename(self.filename)
+        doc.load(self, title=title)
+        return str(doc)
```

## junit2htmlreport/parserimpl.py

 * *Ordering differences only*

```diff
@@ -1,18 +1,18 @@
-"""
-Parse results files
-"""
-from .parser import Junit
-
-
-def load_report(filename: str) -> Junit:
-    """
-    Load a report from disjk
-    """
-    return Junit(filename=filename)
-
-
-def load_string(text: str) -> Junit:
-    """
-    Load a report from a string
-    """
-    return Junit(xmlstring=text)
+"""
+Parse results files
+"""
+from .parser import Junit
+
+
+def load_report(filename: str) -> Junit:
+    """
+    Load a report from disjk
+    """
+    return Junit(filename=filename)
+
+
+def load_string(text: str) -> Junit:
+    """
+    Load a report from a string
+    """
+    return Junit(xmlstring=text)
```

## junit2htmlreport/render.py

```diff
@@ -1,46 +1,63 @@
-"""
-Render junit reports as HTML
-"""
-from jinja2 import Environment, PackageLoader, select_autoescape, FileSystemLoader
-
-
-class HTMLReport(object):
-    def __init__(self):
-        self.title = ""
-        self.report = None
-
-    def load(self, report, title="JUnit2HTML Report"):
-        self.report = report
-        self.title = title
-
-    def __iter__(self):
-        return self.report.__iter__()
-
-    def __str__(self) -> str:
-        env = Environment(
-            loader=PackageLoader("junit2htmlreport", "templates"),
-            autoescape=select_autoescape(["html"])
-        )
-
-        template = env.get_template("report.html")
-        return template.render(report=self, title=self.title)
-
-
-class HTMLMatrix(object):
-    def __init__(self, matrix, template=None):
-        self.title = "JUnit Matrix"
-        self.matrix = matrix
-        self.template = template
-
-    def __str__(self) -> str:
-        if self.template:
-            loader = FileSystemLoader(self.template)
-        else:
-            loader = PackageLoader("junit2htmlreport", "templates")
-        env = Environment(
-            loader=loader,
-            autoescape=select_autoescape(["html"])
-        )
-
-        template = env.get_template("matrix.html")
-        return template.render(matrix=self.matrix, title=self.title)
+"""
+Render junit reports as HTML
+"""
+from typing import TYPE_CHECKING
+
+if TYPE_CHECKING: # pragma: no cover
+    from .matrix import ReportMatrix
+    from .parser import Junit
+    from os import PathLike
+    from typing import Union, Sequence, Optional
+
+from jinja2 import Environment, PackageLoader, select_autoescape, FileSystemLoader
+
+
+class HTMLReport(object):
+    title: str = ""
+    report: "Optional[Junit]" = None
+    show_toc: bool = True
+
+    def __init__(self, show_toc: bool=True):
+        self.show_toc = show_toc
+
+    def load(self, report: "Junit", title: str="JUnit2HTML Report"):
+        self.report = report
+        self.title = title
+
+    def __iter__(self):
+        if self.report is None:
+            raise Exception("A report must be loaded through `load(...)` first.")
+
+        return self.report.__iter__()
+
+    def __str__(self) -> str:
+        env = Environment(
+            loader=PackageLoader("junit2htmlreport", "templates"),
+            autoescape=select_autoescape(["html"])
+        )
+
+        template = env.get_template("report.html")
+        return template.render(report=self, title=self.title, show_toc=self.show_toc)
+
+
+class HTMLMatrix(object):
+    title: str = "JUnit Matrix"
+    matrix: "ReportMatrix"
+    template: "Optional[Union[str,PathLike[str],Sequence[Union[str,PathLike[str]]]]]"
+
+    def __init__(self, matrix: "ReportMatrix", template:"Optional[Union[str,PathLike[str],Sequence[Union[str,PathLike[str]]]]]"=None):
+        self.matrix = matrix
+        self.template = template
+
+    def __str__(self) -> str:
+        if self.template:
+            loader = FileSystemLoader(self.template)
+        else:
+            loader = PackageLoader("junit2htmlreport", "templates")
+        env = Environment(
+            loader=loader,
+            autoescape=select_autoescape(["html"])
+        )
+
+        template = env.get_template("matrix.html")
+        return template.render(matrix=self.matrix, title=self.title)
```

## junit2htmlreport/runner.py

```diff
@@ -1,110 +1,122 @@
-"""
-Small command line tool to generate a html version of a junit report file
-"""
-import os
-from argparse import ArgumentParser
-import sys
-from junit2htmlreport import parser, matrix, merge
-
-PARSER = ArgumentParser(prog="junit2html")
-
-PARSER.add_argument("--summary-matrix", dest="text_matrix", action="store_true",
-                    default=False,
-                    help="Render multiple result files to the console")
-
-PARSER.add_argument("--report-matrix", dest="html_matrix", type=str,
-                    metavar="REPORT",
-                    help="Generate an HTML report matrix")
-
-PARSER.add_argument("--max-failures", dest="fail", type=int, default=0,
-                    metavar="FAILURES",
-                    help="Exit non-zero if FAILURES or more test cases are failures (has no effect with --merge)")
-
-PARSER.add_argument("--max-skipped", dest="skip", type=int, default=0,
-                    metavar="SKIPPED",
-                    help="Exit non-zero if SKIPPED or more test cases are skipped (has no effect with --merged)")
-
-PARSER.add_argument("--merge", dest="merge_output", type=str,
-                    metavar="NEWREPORT",
-                    help="Merge multiple test results into one file")
-
-PARSER.add_argument("--reports-template-folder", dest="template_folder", type=str,
-                    help="Render reports with these templates")
-
-PARSER.add_argument("REPORTS", metavar="REPORT", type=str, nargs="+",
-                    help="Test file to read")
-
-PARSER.add_argument("OUTPUT", type=str, nargs="?",
-                    help="Filename to save the html as")
-
-
-def run(args):
-    """
-    Run this tool
-    :param args:
-    :return:
-    """
-    opts = PARSER.parse_args(args) if args else PARSER.parse_args()
-    inputs = opts.REPORTS
-    util = None
-    if opts.merge_output:
-        util = merge.Merger()
-        for inputfile in inputs:
-            util.add_report(inputfile)
-
-        xmltext = util.toxmlstring()
-        with open(opts.merge_output, "w") as outfile:
-            outfile.write(xmltext)
-    elif opts.text_matrix:
-        util = matrix.TextReportMatrix()
-        for filename in inputs:
-            util.add_report(filename)
-        print(util.summary())
-    elif opts.html_matrix:
-        util = matrix.HtmlReportMatrix(os.path.dirname(opts.html_matrix))
-        for filename in inputs:
-            util.add_report(filename)
-        with open(opts.html_matrix, "w") as outfile:
-            outfile.write(util.summary(opts.template_folder))
-
-    if util:
-        if opts.fail:
-            failed = util.failures()
-            if len(failed) >= opts.fail:
-                sys.exit(len(failed))
-        if opts.skip:
-            skipped = util.skips()
-            if len(skipped) >= opts.fail:
-                sys.exit(len(skipped))
-
-    if not util:
-        # legacy interface that we need to preserve
-        # no options, one or two args, first is input file, optional second is output
-
-        if len(opts.REPORTS) > 2:
-            PARSER.print_usage()
-            sys.exit(1)
-
-        if len(opts.REPORTS) == 2:
-            outfilename = opts.REPORTS[1]
-        else:
-            outfilename = opts.REPORTS[0] + ".html"
-
-        report = parser.Junit(args[0])
-        html = report.html()
-        if report.filename is not None:
-            with open(outfilename, "wb") as outfile:
-                outfile.write(html.encode('utf-8'))
-        else:
-            print(html.encode('utf-8'))
-
-
-def start():
-    """
-    Run using the current sys.argv
-    """
-    run(sys.argv[1:])
-
-
-if __name__ == "__main__":
-    start()
+"""
+Small command line tool to generate a html version of a junit report file
+"""
+from typing import TYPE_CHECKING
+
+import os
+import sys
+from argparse import ArgumentParser
+
+from . import matrix, merge, parser
+
+if TYPE_CHECKING:
+    from typing import List
+
+PARSER = ArgumentParser(prog="junit2html")
+
+PARSER.add_argument("--summary-matrix", dest="text_matrix", action="store_true",
+                    default=False,
+                    help="Render multiple result files to the console")
+
+PARSER.add_argument("--report-matrix", dest="html_matrix", type=str,
+                    metavar="REPORT",
+                    help="Generate an HTML report matrix")
+
+PARSER.add_argument("--max-failures", dest="fail", type=int, default=0,
+                    metavar="FAILURES",
+                    help="Exit non-zero if FAILURES or more test cases are failures (has no effect with --merge)")
+
+PARSER.add_argument("--max-skipped", dest="skip", type=int, default=0,
+                    metavar="SKIPPED",
+                    help="Exit non-zero if SKIPPED or more test cases are skipped (has no effect with --merged)")
+
+PARSER.add_argument("--merge", dest="merge_output", type=str,
+                    metavar="NEWREPORT",
+                    help="Merge multiple test results into one file")
+
+PARSER.add_argument("--reports-template-folder", dest="template_folder", type=str,
+                    help="Render reports with these templates")
+
+PARSER.add_argument("--hide-toc", dest="hide_toc", action="store_true",
+                    default=False,
+                    help="Don't include a table-of-contents in the HTML report")
+
+PARSER.add_argument("REPORTS", metavar="REPORT", type=str, nargs="+",
+                    help="Test file to read")
+
+PARSER.add_argument("OUTPUT", type=str, nargs="?",
+                    help="Filename to save the html as")
+
+
+def run(args: "List[str]"):
+    """
+    Run this tool
+    :param args:
+    :return:
+    """
+    opts = PARSER.parse_args(args) if args else PARSER.parse_args()
+    inputs = opts.REPORTS
+    util = None
+    if opts.merge_output:
+        util = merge.Merger()
+        for inputfile in inputs:
+            util.add_report(inputfile)
+
+        xmltext = util.toxmlstring()
+        with open(opts.merge_output, "w") as outfile:
+            outfile.write(xmltext)
+    elif opts.text_matrix:
+        util = matrix.TextReportMatrix()
+        for filename in inputs:
+            util.add_report(filename)
+        print(util.summary())
+    elif opts.html_matrix:
+        util = matrix.HtmlReportMatrix(os.path.dirname(opts.html_matrix))
+        for filename in inputs:
+            util.add_report(filename, show_toc=not opts.hide_toc)
+        with open(opts.html_matrix, "w") as outfile:
+            outfile.write(util.summary(opts.template_folder))
+
+    if util:
+        if opts.fail:
+            failed = util.failures()
+            if len(failed) >= opts.fail:
+                sys.exit(len(failed))
+        if opts.skip:
+            skipped = util.skips()
+            if len(skipped) >= opts.fail:
+                sys.exit(len(skipped))
+
+    if not util:
+        # legacy interface that we need to preserve
+        # no options, one or two args, first is input file, optional second is output
+
+        if len(opts.REPORTS) > 2:
+            PARSER.print_usage()
+            sys.exit(1)
+
+        infilename = opts.REPORTS[0]
+
+        if len(opts.REPORTS) == 2:
+            outfilename = opts.REPORTS[1]
+        else:
+            outfilename = infilename + ".html"
+
+        report = parser.Junit(infilename)
+        html = report.html(show_toc=not opts.hide_toc)
+        if report.filename is not None:
+            with open(outfilename, "wb") as outfile:
+                outfile.write(html.encode('utf-8'))
+        else:
+            print(html.encode('utf-8'))
+
+
+def start():
+    """
+    Run using the current sys.argv
+    """
+    run(sys.argv[1:])
+
+
+if __name__ == "__main__":
+    start()
```

## junit2htmlreport/textutils.py

```diff
@@ -1,18 +1,16 @@
-"""
-Stringify to unicode
-"""
-import sys
-__py3__ = sys.version_info > (3, 0)
-
-
-def unicode_str(text):
-    """
-    Convert text to unicode
-    :param text:
-    :return:
-    """
-    if __py3__:
-        if isinstance(text, bytes):
-            return text.decode("utf-8", "strict")
-        return str(text)
-    return unicode(text)
+"""
+Stringify to unicode
+"""
+
+from typing import Any, Optional
+
+
+def unicode_str(text: "Optional[Any]"):
+    """
+    Convert text to unicode
+    :param text:
+    :return:
+    """
+    if isinstance(text, bytes):
+        return text.decode("utf-8", "strict")
+    return "" if text is None else str(text)
```

## junit2htmlreport/templates/base.html

 * *Ordering differences only*

```diff
@@ -1,17 +1,17 @@
-<!DOCTYPE html>
-<html lang="en">
-<head>
-    <meta charset="UTF-8">
-    <title>{{title}}</title>
-    <style type="text/css">
-        {% include "styles.css" %}
-    </style>
-</head>
-<body>
-    {% block content %}
-    {% endblock %}
-<p class="footer">
-    Generated by junit2html
-</p>
-</body>
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <title>{{title}}</title>
+    <style type="text/css">
+        {% include "styles.css" %}
+    </style>
+</head>
+<body>
+    {% block content %}
+    {% endblock %}
+<p class="footer">
+    Generated by junit2html
+</p>
+</body>
 </html>
```

## junit2htmlreport/templates/matrix.html

 * *Ordering differences only*

```diff
@@ -1,79 +1,79 @@
-{% extends "base.html" %}
-{% block content %}
-<h1>
-    Reports Matrix
-</h1>
-
-<table class="matrix-table">
-    {% set report_names = matrix.report_order() %}
-    {% set n_reports = report_names.__len__() %}
-    {% if n_reports > 0 %}
-    <tr><!-- top row, stats and each matrix axis -->
-        <td colspan="1" rowspan="{{n_reports + 2}}"> <!-- stats -->
-            <table class="stats-table">
-                {% for outcome in matrix.result_stats %}
-                <tr>
-                    <th class="{{outcome}}">{{outcome.title()}}</th>
-                    <td>{{matrix.result_stats[outcome]}}</td>
-                </tr>
-                {% endfor %}
-            </table>
-        </td>
-        <td colspan="{{n_reports + 1}}"></td>
-
-    </tr>
-    {% endif %}
-    <!-- matrix column index - {{report_names}} -->
-    {% for i in range(n_reports) %}
-    <tr>
-        <td colspan="{{n_reports + 1 - i}}" class="matrix-axis-name {% if (n_reports - i) % 2 == 0 %}matrix-even{% endif %}">
-            <a href="{{report_names[n_reports - 1 - i]}}.html">{{matrix.short_axis(report_names[n_reports - 1 - i])}}</a>
-        </td>
-        {% for n in range(i) %}
-        <td class="matrix-axis-line {% if (n_reports - n) % 2 != i % 2 %}matrix-even{% endif %}"></td>
-        {% endfor %}
-    </tr>
-    {% endfor %}
-    <tr>
-        {% for n in range(n_reports + 1) %}
-        <td class="matrix-axis-line {% if n % 2 == 0 %}matrix-even{% endif %}"></td>
-        {% endfor %}
-    </tr>
-
-    <!-- test results by class/test -->
-    {% for classname in matrix.classes %}
-    <tr>
-        <th class="matrix-classname" colspan="2">{{classname}}</th>
-        {% for n in range(n_reports) %}
-        <td class="matrix-axis-line {% if n % 2 == 1 %}matrix-even{% endif %}"></td>
-        {% endfor %}
-    </tr>
-    {% for casename in matrix.casenames[classname] %}
-    {% set xcase = matrix.cases[classname][casename] %}
-    <tr>
-        <th class="matrix-casename">{{casename}}</th>
-        <td class="matrix-casename matrix-result-combined">
-            {{ matrix.combined_result_list(classname, casename)[1] }}
-        </td>
-        {% for n in range(n_reports) %}
-        {% set axis = report_names[n] %}
-
-        <td class="matrix-axis-line {% if n % 2 == 1 %}matrix-even{% endif %}">
-            {% if axis in xcase %}
-            <a href="{{axis}}.html#{{xcase[axis].anchor()}}">
-                        <span class="matrix-result matrix-result-{{xcase[axis].outcome()}}">
-                            {{ matrix.short_outcome(xcase[axis].outcome()) }}
-                        </span>
-            </a>
-            {% else %}
-            <span class="matrix-result">&nbsp;</span>
-            {% endif %}
-
-        </td>
-        {% endfor %}
-        {% endfor %}
-    </tr>
-    {% endfor %}
-
-</table>
-{% endblock %}
+{% extends "base.html" %}
+{% block content %}
+<h1>
+    Reports Matrix
+</h1>
+
+<table class="matrix-table">
+    {% set report_names = matrix.report_order() %}
+    {% set n_reports = report_names.__len__() %}
+    {% if n_reports > 0 %}
+    <tr><!-- top row, stats and each matrix axis -->
+        <td colspan="1" rowspan="{{n_reports + 2}}"> <!-- stats -->
+            <table class="stats-table">
+                {% for outcome in matrix.result_stats %}
+                <tr>
+                    <th class="{{outcome}}">{{outcome.title()}}</th>
+                    <td>{{matrix.result_stats[outcome]}}</td>
+                </tr>
+                {% endfor %}
+            </table>
+        </td>
+        <td colspan="{{n_reports + 1}}"></td>
+
+    </tr>
+    {% endif %}
+    <!-- matrix column index - {{report_names}} -->
+    {% for i in range(n_reports) %}
+    <tr>
+        <td colspan="{{n_reports + 1 - i}}" class="matrix-axis-name {% if (n_reports - i) % 2 == 0 %}matrix-even{% endif %}">
+            <a href="{{report_names[n_reports - 1 - i]}}.html">{{matrix.short_axis(report_names[n_reports - 1 - i])}}</a>
+        </td>
+        {% for n in range(i) %}
+        <td class="matrix-axis-line {% if (n_reports - n) % 2 != i % 2 %}matrix-even{% endif %}"></td>
+        {% endfor %}
+    </tr>
+    {% endfor %}
+    <tr>
+        {% for n in range(n_reports + 1) %}
+        <td class="matrix-axis-line {% if n % 2 == 0 %}matrix-even{% endif %}"></td>
+        {% endfor %}
+    </tr>
+
+    <!-- test results by class/test -->
+    {% for classname in matrix.classes %}
+    <tr>
+        <th class="matrix-classname" colspan="2">{{classname}}</th>
+        {% for n in range(n_reports) %}
+        <td class="matrix-axis-line {% if n % 2 == 1 %}matrix-even{% endif %}"></td>
+        {% endfor %}
+    </tr>
+    {% for casename in matrix.casenames[classname] %}
+    {% set xcase = matrix.cases[classname][casename] %}
+    <tr>
+        <th class="matrix-casename">{{casename}}</th>
+        <td class="matrix-casename matrix-result-combined">
+            {{ matrix.combined_result_list(classname, casename)[1] }}
+        </td>
+        {% for n in range(n_reports) %}
+        {% set axis = report_names[n] %}
+
+        <td class="matrix-axis-line {% if n % 2 == 1 %}matrix-even{% endif %}">
+            {% if axis in xcase %}
+            <a href="{{axis}}.html#{{xcase[axis].anchor()}}">
+                        <span class="matrix-result matrix-result-{{xcase[axis].outcome()}}">
+                            {{ matrix.short_outcome(xcase[axis].outcome()) }}
+                        </span>
+            </a>
+            {% else %}
+            <span class="matrix-result">&nbsp;</span>
+            {% endif %}
+
+        </td>
+        {% endfor %}
+        {% endfor %}
+    </tr>
+    {% endfor %}
+
+</table>
+{% endblock %}
```

## junit2htmlreport/templates/report.html

```diff
@@ -1,132 +1,135 @@
-{% extends "base.html" %}
-{% block content %}
-<h1>
-    Test Report : {{ report.title }}
-</h1>
-<a id="toc"></a>
-<table class="index-table">
-    <tr>
-        <td>
-            <ul class="toc">
-            {% for suite in report %}
-                {% for classname in suite.classes %}
-                <li>{{classname}}
-                <ul>
-                    {% for test in suite.classes[classname].cases %}
-                    <li><a href="#{{test.anchor()}}">{{test.name}}</a>{{test.display_suffix}}</li>
-                    {% endfor %}
-                </ul>
-                </li>
-                {% endfor %}
-            {% endfor %}
-            </ul>
-        </td>
-        <td class="failure-index">
-            <ul class="toc">
-            {% for suite in report %}
-                {% for classname in suite.classes %}
-                    {% for test in suite.classes[classname].cases %}
-                    {% if test.failed() %}
-                    <li><a href="#{{test.anchor()}}">{{test.prefix()}} {{test.fullname()}}</a></li>
-                    {% endif %}
-                    {% endfor %}
-                {% endfor %}
-            {% endfor %}
-            </ul>
-        </td>
-    </tr>
-</table>
-
-{% for suite in report %}
-    <div class="testsuite">
-        <h2>Test Suite: {{ suite.name }}</h2>
-        <a id="{{ suite.anchor() }}"></a>
-        {% if suite.package %}
-        <span>Package: {{suite.package}}</span>
-        {% endif %}
-        {% if suite.properties %}
-        <h3>Suite Properties</h3>
-        <table class="proplist">
-            {% for prop in suite.properties %}
-            <tr>
-                <th>{{prop.name}}</th><td>{{prop.value}}</td>
-            </tr>
-            {% endfor %}
-        </table>
-        {% endif %}
-        <h3>Results</h3>
-        <table class="proplist">
-            <tr>
-                <th>Duration</th><td>{{suite.duration |round(3)}} sec</td>
-            </tr>
-            <tr>
-                <th>Tests</th><td>{{suite.all() |length}}</td>
-            </tr>
-            <tr>
-                <th>Failures</th><td>{{suite.failed()| length}}</td>
-            </tr>
-        </table>
-
-        <div class="testclasses">
-            <h3>Tests</h3>
-            {% for classname in suite.classes %}
-            <div class="testclass">
-                <h4>{{classname}}</h4>
-                <div class="testcases">
-                {% for test in suite.classes[classname].cases %}
-                    <div class="test outcome outcome-{{test.outcome()}}">
-                        <a id="{{test.anchor()}}"></a>
-                        <table class="proplist">
-                            <tr><th>Test case:</th><td><b>{{test.name}}</b></td></tr>
-                            <tr><th>Outcome:</th><td>{{test.outcome().title()}}</td></tr>
-                            <tr><th>Duration:</th><td>{{test.duration|round(3)}} sec</td></tr>
-                        {% if test.failed() %}
-                            <tr><th>Failed</th><td>{{test.failure_msg}}</td></tr>
-                        {% endif %}
-                        {% if test.skipped %}
-                            <tr><th>Skipped</th><td>{{test.skipped_msg}}</td></tr>
-                        {% endif %}
-                        </table>
-
-                        {% if test.failed() %}
-                        <pre>{{test.failure}}</pre>
-                        {% endif %}
-                        {% if test.skipped %}
-                        <pre>{{test.skipped}}</pre>
-                        {% endif %}
-
-                        {% if test.properties %}
-                        <table class="proplist">
-                            {% for prop in test.properties %}
-                            <tr>
-                                <th>{{prop.name}}</th><td>{{prop.value}}</td>
-                            </tr>
-                            {% endfor %}
-                        </table>
-                        {% endif %}
-                        {% if test.stdout %}
-                        <div class="stdout"><i>Stdout</i><br>
-                            <pre>{{test.stdout}}</pre>
-                        </div>
-                        {% endif %}
-                        {% if test.stderr %}
-                        <div class="stderr"><i>Stderr</i><br>
-                            <pre>{{test.stderr}}</pre>
-                        </div>
-                        {% endif %}
-                    </div>
-                {% endfor %}
-                </div>
-            </div>
-            {% endfor %}
-        </div>
-    </div>
-    {% if suite.stdout or suite.stderr %}
-        <h3>Suite stdout:</h3>
-        <pre class="stdio">{{suite.stdout}}</pre>
-        <h3>Suite stderr:</h3>
-        <pre class="stdio">{{suite.stderr}}</pre>
-    {% endif %}
-{% endfor %}
-
-{% endblock %}
+{% extends "base.html" %}
+{% block content %}
+<h1>
+    Test Report : {{ report.title }}
+</h1>
+
+{% if show_toc %}
+<a id="toc"></a>
+<table class="index-table">
+    <tr>
+        <td>
+            <ul class="toc">
+            {% for suite in report %}
+                {% for classname in suite.classes %}
+                <li>{{classname}}
+                <ul>
+                    {% for test in suite.classes[classname].cases %}
+                    <li class="outcome outcome-{{test.outcome()}}"><a href="#{{test.anchor()}}">{{test.name}}</a>{{test.display_suffix}}</li>
+                    {% endfor %}
+                </ul>
+                </li>
+                {% endfor %}
+            {% endfor %}
+            </ul>
+        </td>
+        <td class="failure-index">
+            <ul class="toc">
+            {% for suite in report %}
+                {% for classname in suite.classes %}
+                    {% for test in suite.classes[classname].cases %}
+                    {% if test.failed() %}
+                    <li><a href="#{{test.anchor()}}">{{test.prefix()}} {{test.fullname()}}</a></li>
+                    {% endif %}
+                    {% endfor %}
+                {% endfor %}
+            {% endfor %}
+            </ul>
+        </td>
+    </tr>
+</table>
+{% endif %}
+
+{% for suite in report %}
+    <div class="testsuite">
+        <h2>Test Suite: {{ suite.name }}</h2>
+        <a id="{{ suite.anchor() }}"></a>
+        {% if suite.package %}
+        <span>Package: {{suite.package}}</span>
+        {% endif %}
+        {% if suite.properties %}
+        <h3>Suite Properties</h3>
+        <table class="proplist">
+            {% for prop in suite.properties %}
+            <tr>
+                <th>{{prop.name}}</th><td>{{prop.value}}</td>
+            </tr>
+            {% endfor %}
+        </table>
+        {% endif %}
+        <h3>Results</h3>
+        <table class="proplist">
+            <tr>
+                <th>Duration</th><td>{{suite.duration |round(3)}} sec</td>
+            </tr>
+            <tr>
+                <th>Tests</th><td>{{suite.all() |length}}</td>
+            </tr>
+            <tr>
+                <th>Failures</th><td>{{suite.failed()| length}}</td>
+            </tr>
+        </table>
+
+        <div class="testclasses">
+            <h3>Tests</h3>
+            {% for classname in suite.classes %}
+            <div class="testclass">
+                <h4>{{classname}}</h4>
+                <div class="testcases">
+                {% for test in suite.classes[classname].cases %}
+                    <div class="test outcome outcome-{{test.outcome()}}">
+                        <a id="{{test.anchor()}}"></a>
+                        <table class="proplist">
+                            <tr><th>Test case:</th><td><b>{{test.name}}</b></td></tr>
+                            <tr><th>Outcome:</th><td>{{test.outcome().title()}}</td></tr>
+                            <tr><th>Duration:</th><td>{{test.duration|round(3)}} sec</td></tr>
+                        {% if test.failed() %}
+                            <tr><th>Failed</th><td>{{test.failure_msg}}</td></tr>
+                        {% endif %}
+                        {% if test.skipped %}
+                            <tr><th>Skipped</th><td>{{test.skipped_msg}}</td></tr>
+                        {% endif %}
+                        </table>
+
+                        {% if test.failed() %}
+                        <pre>{{test.failure}}</pre>
+                        {% endif %}
+                        {% if test.skipped %}
+                        <pre>{{test.skipped}}</pre>
+                        {% endif %}
+
+                        {% if test.properties %}
+                        <table class="proplist">
+                            {% for prop in test.properties %}
+                            <tr>
+                                <th>{{prop.name}}</th><td>{{prop.value}}</td>
+                            </tr>
+                            {% endfor %}
+                        </table>
+                        {% endif %}
+                        {% if test.stdout %}
+                        <div class="stdout"><i>Stdout</i><br>
+                            <pre>{{test.stdout}}</pre>
+                        </div>
+                        {% endif %}
+                        {% if test.stderr %}
+                        <div class="stderr"><i>Stderr</i><br>
+                            <pre>{{test.stderr}}</pre>
+                        </div>
+                        {% endif %}
+                    </div>
+                {% endfor %}
+                </div>
+            </div>
+            {% endfor %}
+        </div>
+    </div>
+    {% if suite.stdout or suite.stderr %}
+        <h3>Suite stdout:</h3>
+        <pre class="stdio">{{suite.stdout}}</pre>
+        <h3>Suite stderr:</h3>
+        <pre class="stdio">{{suite.stderr}}</pre>
+    {% endif %}
+{% endfor %}
+
+{% endblock %}
```

### html2text {}

```diff
@@ -1,20 +1,21 @@
 {% extends "base.html" %} {% block content %}
 ************ TTeesstt RReeppoorrtt :: {{{{ rreeppoorrtt..ttiittllee }}}} ************
+{% if show_toc %}
     * {% for suite in report %} {% for     * {% for suite in report %} {% for
       classname in suite.classes %}          classname in suite.classes %} {%
     * {{classname}}                          for test in suite.classes
           o {% for test in                   [classname].cases %} {% if
             suite.classes                    test.failed() %}
             [classname].cases %}           * _{_{_t_e_s_t_._p_r_e_f_i_x_(_)_}_}_ _{_{_t_e_s_t_._f_u_l_l_n_a_m_e
           o _{_{_t_e_s_t_._n_a_m_e_}_}{                   _(_)_}_}
             {test.display_suffix}}         * {% endif %} {% endfor %} {% endfor
           o {% endfor %}                     %} {% endfor %}
     * {% endfor %} {% endfor %}
-{% for suite in report %}
+{% endif %} {% for suite in report %}
 ********** TTeesstt SSuuiittee:: {{{{ ssuuiittee..nnaammee }}}} **********
 {% if suite.package %} Package: {{suite.package}} {% endif %} {% if
 suite.properties %}
 ******** SSuuiittee PPrrooppeerrttiieess ********
 {{{{pprroopp..nnaammee}}}} {{prop.value}}
 {% endif %}
 ******** RReessuullttss ********
```

## junit2htmlreport/templates/styles.css

```diff
@@ -1,193 +1,237 @@
-body {
-    background-color: white;
-    padding-bottom: 20em;
-    margin: 0;
-    min-height: 15cm;
-}
-
-h1, h2, h3, h4, h5, h6, h7 {
-    font-family: sans-serif;
-}
-
-h1 {
-    background-color: #007acc;
-    color: white;
-    padding: 3mm;
-    margin-top: 0;
-    margin-bottom: 1mm;
-}
-
-.footer {
-    font-style: italic;
-    font-size: small;
-    text-align: right;
-    padding: 1em;
-}
-
-.testsuite {
-    padding-bottom: 2em;
-    margin-left: 1em;
-}
-
-.proplist {
-    width: 100%;
-    margin-bottom: 2em;
-    border-collapse: collapse;
-    border: 1px solid grey;
-}
-
-.proplist th {
-    background-color: silver;
-    width: 5em;
-    padding: 2px;
-    padding-right: 1em;
-    text-align: left;
-}
-
-.proplist td {
-    padding: 2px;
-}
-
-.index-table {
-    width: 90%;
-    margin-left: 1em;
-}
-
-.index-table td {
-    vertical-align: top;
-    max-width: 200px;
-    word-wrap: break-word;
-}
-
-.failure-index {
-
-}
-
-.toc {
-    margin-bottom: 2em;
-    font-family: monospace;
-}
-
-.stdio, pre {
-    min-height: 1em;
-    background-color: #1e1e1e;
-    color: silver;
-    padding: 0.5em;
-}
-.tdpre {
-    background-color: #1e1e1e;
-}
-
-.test {
-    margin-left: 0.5cm;
-}
-
-.outcome {
-    border-left: 1em;
-    padding: 2px;
-}
-
-.outcome-failed {
-    border-left: 1em solid lightcoral;
-}
-
-.outcome-passed {
-    border-left: 1em solid lightgreen;
-}
-
-.outcome-skipped {
-    border-left: 1em dotted silver;
-}
-
-.stats-table {
-}
-
-.stats-table td {
-    min-width: 4em;
-    text-align: right;
-}
-
-.stats-table .failed {
-    background-color: lightcoral;
-}
-
-.stats-table .passed {
-    background-color: lightgreen;
-}
-
-.matrix-table {
-    table-layout: fixed;
-    border-spacing: 0;
-    width: available;
-    margin-left: 1em;
-}
-
-.matrix-table td {
-    vertical-align: center;
-}
-
-.matrix-table td:last-child {
-    width: 0;
-}
-
-.matrix-table tr:hover {
-    background-color: yellow;
-}
-
-.matrix-axis-name {
-    white-space: nowrap;
-    padding-right: 0.5em;
-    border-left: 1px solid black;
-    border-top: 1px solid black;
-    text-align: right;
-}
-
-.matrix-axis-line {
-    border-left: 1px solid black;
-    width: 0.5em;
-}
-
-.matrix-classname {
-    text-align: left;
-    width: 100%;
-    border-top: 2px solid grey;
-    border-bottom: 1px solid silver;
-}
-
-.matrix-casename {
-    text-align: left;
-    font-weight: normal;
-    font-style: italic;
-    padding-left: 1em;
-    border-bottom: 1px solid silver;
-}
-
-.matrix-result {
-    display: block;
-    width: 1em;
-    text-align: center;
-    padding: 1mm;
-    margin: 0;
-}
-
-.matrix-result-combined {
-    white-space: nowrap;
-    padding-right: 0.2em;
-    text-align: right;
-}
-
-.matrix-result-failed {
-    background-color: lightcoral;
-}
-
-.matrix-result-passed {
-    background-color: lightgreen;
-}
-
-.matrix-result-skipped {
-    background-color: lightyellow;
-}
-
-.matrix-even {
-    background-color: lightgray;
-}
+body {
+    background-color: white;
+    padding-bottom: 20em;
+    margin: 0;
+    min-height: 15cm;
+}
+
+h1, h2, h3, h4, h5, h6, h7 {
+    font-family: sans-serif;
+}
+
+h1 {
+    background-color: #007acc;
+    color: white;
+    padding: 3mm;
+    margin-top: 0;
+    margin-bottom: 1mm;
+}
+
+.footer {
+    font-style: italic;
+    font-size: small;
+    text-align: right;
+    padding: 1em;
+}
+
+.testsuite {
+    padding-bottom: 2em;
+    margin-left: 1em;
+}
+
+.proplist {
+    width: 100%;
+    margin-bottom: 2em;
+    border-collapse: collapse;
+    border: 1px solid grey;
+}
+
+.proplist th {
+    background-color: silver;
+    width: 5em;
+    padding: 2px;
+    padding-right: 1em;
+    text-align: left;
+}
+
+.proplist td {
+    padding: 2px;
+    word-break: break-all;
+}
+
+.index-table {
+    width: 90%;
+    margin-left: 1em;
+}
+
+.index-table td {
+    vertical-align: top;
+    max-width: 200px;
+    word-wrap: break-word;
+}
+
+.failure-index {
+
+}
+
+.toc {
+    margin-bottom: 2em;
+    font-family: monospace;
+}
+
+.stdio, pre {
+    min-height: 1em;
+    background-color: #1e1e1e;
+    color: silver;
+    padding: 0.5em;
+}
+.tdpre {
+    background-color: #1e1e1e;
+}
+
+.test {
+    margin-left: 0.5cm;
+}
+
+.toc {
+    list-style: none;
+}
+
+.toc li.outcome {
+    list-style: none;
+}
+
+.toc li.outcome::before {
+    content: "\2022";
+    color: black;
+    font-weight: bold;
+    display: inline-block;
+    width: 1.27em;
+    margin-left: -1.27em;
+    font-size: 1.2em;
+}
+
+.toc li.outcome-failed {
+    background-color: lightcoral;
+}
+
+.toc li.outcome-failed::before {
+    color: red;
+}
+
+.toc li.outcome-passed::before {
+    color: green;
+}
+
+.toc li.outcome-skipped::before {
+    color: orange;
+}
+
+.testcases .outcome {
+    border-left: 1em;
+    padding: 2px;
+}
+
+.testcases .outcome-failed {
+    border-left: 1em solid lightcoral;
+}
+
+
+.outcome-passed {
+    border-left: 1em solid lightgreen;
+}
+
+.outcome-skipped {
+    border-left: 1em dotted silver;
+}
+
+.testcases .outcome-passed {
+    border-left: 1em solid lightgreen;
+}
+
+.testcases .outcome-skipped {
+    border-left: 1em solid #FED8B1;
+}
+
+.stats-table {
+}
+
+.stats-table td {
+    min-width: 4em;
+    text-align: right;
+}
+
+.stats-table .failed {
+    background-color: lightcoral;
+}
+
+.stats-table .passed {
+    background-color: lightgreen;
+}
+
+.matrix-table {
+    table-layout: fixed;
+    border-spacing: 0;
+    width: available;
+    margin-left: 1em;
+}
+
+.matrix-table td {
+    vertical-align: center;
+}
+
+.matrix-table td:last-child {
+    width: 0;
+}
+
+.matrix-table tr:hover {
+    background-color: yellow;
+}
+
+.matrix-axis-name {
+    white-space: nowrap;
+    padding-right: 0.5em;
+    border-left: 1px solid black;
+    border-top: 1px solid black;
+    text-align: right;
+}
+
+.matrix-axis-line {
+    border-left: 1px solid black;
+    width: 0.5em;
+}
+
+.matrix-classname {
+    text-align: left;
+    width: 100%;
+    border-top: 2px solid grey;
+    border-bottom: 1px solid silver;
+}
+
+.matrix-casename {
+    text-align: left;
+    font-weight: normal;
+    font-style: italic;
+    padding-left: 1em;
+    border-bottom: 1px solid silver;
+}
+
+.matrix-result {
+    display: block;
+    width: 1em;
+    text-align: center;
+    padding: 1mm;
+    margin: 0;
+}
+
+.matrix-result-combined {
+    white-space: nowrap;
+    padding-right: 0.2em;
+    text-align: right;
+}
+
+.matrix-result-failed {
+    background-color: lightcoral;
+}
+
+.matrix-result-passed {
+    background-color: lightgreen;
+}
+
+.matrix-result-skipped {
+    background-color: lightyellow;
+}
+
+.matrix-even {
+    background-color: lightgray;
+}
```

## Comparing `junit2html-30.1.6.dist-info/LICENSE` & `junit2html-31.0.1.dist-info/LICENSE`

 * *Ordering differences only*

 * *Files 22% similar despite different names*

```diff
@@ -1,21 +1,21 @@
-MIT License
-
-Copyright (c) 2016 Ian Norton
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in all
-copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-SOFTWARE.
+MIT License
+
+Copyright (c) 2016 Ian Norton
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
```

## Comparing `junit2html-30.1.6.dist-info/RECORD` & `junit2html-31.0.1.dist-info/RECORD`

 * *Files 19% similar despite different names*

```diff
@@ -1,20 +1,21 @@
 junit2htmlreport/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-junit2htmlreport/__main__.py,sha256=naIiRAQN_cNtVfjm3mfbaJBCCx2zpYjUEzDJcU5xYfs,112
-junit2htmlreport/common.py,sha256=KTjZINc_pyCEMJiTBOsQn1SeM5BWdAF4r3DFjdgyKBc,899
-junit2htmlreport/matrix.py,sha256=QjX-dSOTb2aMRt4TARE0fp2t9xCn5AXNvk3-j2g8-RI,8230
-junit2htmlreport/merge.py,sha256=Qt3iwslA5Jke4RuCVdOlpZz2DdYDFHzMLPZajLW_Uts,2641
-junit2htmlreport/parser.py,sha256=UvKeQ1yv0TkQczNuSiX0qWgB7rquLWL4TCYfVDqN1ug,14596
-junit2htmlreport/parserimpl.py,sha256=5rmjQl7Wtc1Rqv0VkUJBnex4Xc87FAdVHiGTYf0I0Dw,316
-junit2htmlreport/render.py,sha256=jK3NVCMRIE_TQKl9ULHMNuXfsp-8Cb18o0RfCspg24c,1345
-junit2htmlreport/runner.py,sha256=F6jTx2mEyPup7oz6DY7WhsB8AU9eDGCOVzVKIa1-iP0,3680
-junit2htmlreport/textutils.py,sha256=6XYaM1E_T1QB0qBLP43KbCvmCr4RWGbizra1PrPGYpI,345
-junit2htmlreport/templates/base.html,sha256=77JQ-0c0iYjjnM-Cm-r9xJZgZPFbgw-1b2DIIgwFnNU,313
-junit2htmlreport/templates/matrix.html,sha256=crAij5d8ZsXUZuYabwle6YEST4FaDN5_0bUiBMq6j-A,2874
-junit2htmlreport/templates/report.html,sha256=SaN4X2MOe2v4b2YC5qR16r9fiig9MJrYSnnYGwbn_Vc,4915
-junit2htmlreport/templates/styles.css,sha256=w9pz1hosrRMPx2n2rSEgGtHeVbmNF_xxaaRNJPpwKbs,3009
-junit2html-30.1.6.dist-info/LICENSE,sha256=eOLwFzh1K2nA5_hJiOSpR8tsKHeTRROV9b5BWZzuTL0,1088
-junit2html-30.1.6.dist-info/METADATA,sha256=9uRyVlsBLoqeL-sWuFPOCa17t2Bno4sammvwAriYG3w,406
-junit2html-30.1.6.dist-info/WHEEL,sha256=oiQVh_5PnQM0E3gPdiz09WCNmwiHDMaGer_elqB3coM,92
-junit2html-30.1.6.dist-info/entry_points.txt,sha256=SGCtRQG6bPYBflaA4n9fSC1A07omx-SoOgyti2niMg4,61
-junit2html-30.1.6.dist-info/top_level.txt,sha256=owI63bvIj-v171IWbY9x6W-5vPr0uMP9Hlm9fgjwc4k,17
-junit2html-30.1.6.dist-info/RECORD,,
+junit2htmlreport/__main__.py,sha256=Pc2x_9ZITfVd9f8zmykZ_JxzC7v0W9OgYYPIRSQNv2s,106
+junit2htmlreport/case_result.py,sha256=Bdh5dNQnDOpgnIKpgw89i--Owo6OibdypuQay4YmuRM,474
+junit2htmlreport/common.py,sha256=uO5m_02Ln6DkbmN1_7IYaRgBnaqQw3z9e41qiOeWaI8,1080
+junit2htmlreport/matrix.py,sha256=zg57QqRoUhbHIiIhmrclfgiWwWphiFSZd-64qwwED7o,9496
+junit2htmlreport/merge.py,sha256=F4Ml6VXqMs0S52fxdB6bBU_e5pXaBgFteC-XiHh6BZk,2647
+junit2htmlreport/parser.py,sha256=TSUOWY6OBRFMfSxi0KQIZu7w4FCnjMyaRVhqV15DLYw,15374
+junit2htmlreport/parserimpl.py,sha256=PPt2_zzeHwx1HV0MDt228LNE1JjBWH_crspPQsQdpAc,298
+junit2htmlreport/render.py,sha256=cAn4f2hGQInqa7uPG-Poeug-Y81-VmySL-3dz3H7Tlw,1953
+junit2htmlreport/runner.py,sha256=u5D0wtpRr1HU7pAlOE6KrLUQIUMqwR4ZL91bCxNanBY,3929
+junit2htmlreport/textutils.py,sha256=pzYrwfQX2b8V0u6Gaibkh0QGY6yLt8kRYuyVVxvmBMs,302
+junit2htmlreport/templates/base.html,sha256=psEV5nS2H3gyF0fMVuwb4xdzrBt4lpEVeRSdmu7_6Kw,297
+junit2htmlreport/templates/matrix.html,sha256=wm8vJpNckn3RR7gmmeDGTbcdA4qPBHCKy1D2iNPLkFo,2795
+junit2htmlreport/templates/report.html,sha256=nryF11xwS1O_e6Ka5Lzf2FQtMCkkB1PQKGCDwVDT_58,4859
+junit2htmlreport/templates/styles.css,sha256=tH2LNuTQOVH5zCKrnfGwC5lWBKcB-BcijQAB2BkVsaQ,3491
+junit2html-31.0.1.dist-info/LICENSE,sha256=ivuVVcN0m-Z13p4AlvzR1igQOmsKRunaTW0YFrtzKv8,1067
+junit2html-31.0.1.dist-info/METADATA,sha256=AlKsx2CfOBkVY2sPuIrUZDr_JvIs9GRQ-xe7k6iVEFo,393
+junit2html-31.0.1.dist-info/WHEEL,sha256=GJ7t_kWBFywbagK5eo9IoUwLW6oyOeTKmQ-9iHFVNxQ,92
+junit2html-31.0.1.dist-info/entry_points.txt,sha256=SGCtRQG6bPYBflaA4n9fSC1A07omx-SoOgyti2niMg4,61
+junit2html-31.0.1.dist-info/top_level.txt,sha256=owI63bvIj-v171IWbY9x6W-5vPr0uMP9Hlm9fgjwc4k,17
+junit2html-31.0.1.dist-info/RECORD,,
```

