# Comparing `tmp/sparc_curation_tools-0.7.0-py3-none-any.whl.zip` & `tmp/sparc_curation_tools-0.7.1-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,26 +1,26 @@
-Zip file size: 26080 bytes, number of entries: 24
--rw-r--r--  2.0 unx       75 b- defN 24-Mar-25 06:32 sparc/__init__.py
--rw-r--r--  2.0 unx        0 b- defN 24-Mar-25 06:32 sparc/curation/__init__.py
--rw-r--r--  2.0 unx      513 b- defN 24-Mar-25 06:32 sparc/curation/tools/__init__.py
--rw-r--r--  2.0 unx     3650 b- defN 24-Mar-25 06:32 sparc/curation/tools/context_annotations.py
--rw-r--r--  2.0 unx     1492 b- defN 24-Mar-25 06:32 sparc/curation/tools/definitions.py
--rw-r--r--  2.0 unx     6996 b- defN 24-Mar-25 06:32 sparc/curation/tools/errors.py
--rw-r--r--  2.0 unx     7346 b- defN 24-Mar-25 06:32 sparc/curation/tools/plot_annotations.py
--rw-r--r--  2.0 unx     4420 b- defN 24-Mar-25 06:32 sparc/curation/tools/plot_utilities.py
--rw-r--r--  2.0 unx     8739 b- defN 24-Mar-25 06:32 sparc/curation/tools/scaffold_annotations.py
--rw-r--r--  2.0 unx     1596 b- defN 24-Mar-25 06:32 sparc/curation/tools/utilities.py
--rw-r--r--  2.0 unx        0 b- defN 24-Mar-25 06:32 sparc/curation/tools/helpers/__init__.py
--rw-r--r--  2.0 unx      241 b- defN 24-Mar-25 06:32 sparc/curation/tools/helpers/base.py
--rw-r--r--  2.0 unx    19215 b- defN 24-Mar-25 06:32 sparc/curation/tools/helpers/error_helper.py
--rw-r--r--  2.0 unx    14509 b- defN 24-Mar-25 06:32 sparc/curation/tools/helpers/file_helper.py
--rw-r--r--  2.0 unx    14586 b- defN 24-Mar-25 06:32 sparc/curation/tools/helpers/manifest_helper.py
--rw-r--r--  2.0 unx        0 b- defN 24-Mar-25 06:32 sparc/curation/tools/models/__init__.py
--rw-r--r--  2.0 unx     2645 b- defN 24-Mar-25 06:32 sparc/curation/tools/models/contextinfo.py
--rw-r--r--  2.0 unx     1531 b- defN 24-Mar-25 06:32 sparc/curation/tools/models/plot.py
--rw-r--r--  2.0 unx      564 b- defN 24-Mar-25 06:32 sparc_curation_tools-0.7.0.dist-info/LICENSE
--rw-r--r--  2.0 unx     1326 b- defN 24-Mar-25 06:32 sparc_curation_tools-0.7.0.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 24-Mar-25 06:32 sparc_curation_tools-0.7.0.dist-info/WHEEL
--rw-r--r--  2.0 unx      149 b- defN 24-Mar-25 06:32 sparc_curation_tools-0.7.0.dist-info/entry_points.txt
--rw-r--r--  2.0 unx        6 b- defN 24-Mar-25 06:32 sparc_curation_tools-0.7.0.dist-info/top_level.txt
--rw-rw-r--  2.0 unx     2238 b- defN 24-Mar-25 06:32 sparc_curation_tools-0.7.0.dist-info/RECORD
-24 files, 91929 bytes uncompressed, 22352 bytes compressed:  75.7%
+Zip file size: 27048 bytes, number of entries: 24
+-rw-r--r--  2.0 unx       75 b- defN 24-May-10 05:20 sparc/__init__.py
+-rw-r--r--  2.0 unx        0 b- defN 24-May-10 05:20 sparc/curation/__init__.py
+-rw-r--r--  2.0 unx      513 b- defN 24-May-10 05:20 sparc/curation/tools/__init__.py
+-rw-r--r--  2.0 unx     3650 b- defN 24-May-10 05:20 sparc/curation/tools/context_annotations.py
+-rw-r--r--  2.0 unx     1699 b- defN 24-May-10 05:20 sparc/curation/tools/definitions.py
+-rw-r--r--  2.0 unx     7314 b- defN 24-May-10 05:20 sparc/curation/tools/errors.py
+-rw-r--r--  2.0 unx     7346 b- defN 24-May-10 05:20 sparc/curation/tools/plot_annotations.py
+-rw-r--r--  2.0 unx     4438 b- defN 24-May-10 05:20 sparc/curation/tools/plot_utilities.py
+-rw-r--r--  2.0 unx     8690 b- defN 24-May-10 05:20 sparc/curation/tools/scaffold_annotations.py
+-rw-r--r--  2.0 unx     2162 b- defN 24-May-10 05:20 sparc/curation/tools/utilities.py
+-rw-r--r--  2.0 unx        0 b- defN 24-May-10 05:20 sparc/curation/tools/helpers/__init__.py
+-rw-r--r--  2.0 unx      241 b- defN 24-May-10 05:20 sparc/curation/tools/helpers/base.py
+-rw-r--r--  2.0 unx    20929 b- defN 24-May-10 05:20 sparc/curation/tools/helpers/error_helper.py
+-rw-r--r--  2.0 unx    15594 b- defN 24-May-10 05:20 sparc/curation/tools/helpers/file_helper.py
+-rw-r--r--  2.0 unx    14717 b- defN 24-May-10 05:20 sparc/curation/tools/helpers/manifest_helper.py
+-rw-r--r--  2.0 unx        0 b- defN 24-May-10 05:20 sparc/curation/tools/models/__init__.py
+-rw-r--r--  2.0 unx     2645 b- defN 24-May-10 05:20 sparc/curation/tools/models/contextinfo.py
+-rw-r--r--  2.0 unx     1531 b- defN 24-May-10 05:20 sparc/curation/tools/models/plot.py
+-rw-r--r--  2.0 unx      564 b- defN 24-May-10 05:20 sparc_curation_tools-0.7.1.dist-info/LICENSE
+-rw-r--r--  2.0 unx     1326 b- defN 24-May-10 05:20 sparc_curation_tools-0.7.1.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 24-May-10 05:20 sparc_curation_tools-0.7.1.dist-info/WHEEL
+-rw-r--r--  2.0 unx      149 b- defN 24-May-10 05:20 sparc_curation_tools-0.7.1.dist-info/entry_points.txt
+-rw-r--r--  2.0 unx        6 b- defN 24-May-10 05:20 sparc_curation_tools-0.7.1.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     2238 b- defN 24-May-10 05:20 sparc_curation_tools-0.7.1.dist-info/RECORD
+24 files, 95919 bytes uncompressed, 23320 bytes compressed:  75.7%
```

## zipnote {}

```diff
@@ -48,26 +48,26 @@
 
 Filename: sparc/curation/tools/models/contextinfo.py
 Comment: 
 
 Filename: sparc/curation/tools/models/plot.py
 Comment: 
 
-Filename: sparc_curation_tools-0.7.0.dist-info/LICENSE
+Filename: sparc_curation_tools-0.7.1.dist-info/LICENSE
 Comment: 
 
-Filename: sparc_curation_tools-0.7.0.dist-info/METADATA
+Filename: sparc_curation_tools-0.7.1.dist-info/METADATA
 Comment: 
 
-Filename: sparc_curation_tools-0.7.0.dist-info/WHEEL
+Filename: sparc_curation_tools-0.7.1.dist-info/WHEEL
 Comment: 
 
-Filename: sparc_curation_tools-0.7.0.dist-info/entry_points.txt
+Filename: sparc_curation_tools-0.7.1.dist-info/entry_points.txt
 Comment: 
 
-Filename: sparc_curation_tools-0.7.0.dist-info/top_level.txt
+Filename: sparc_curation_tools-0.7.1.dist-info/top_level.txt
 Comment: 
 
-Filename: sparc_curation_tools-0.7.0.dist-info/RECORD
+Filename: sparc_curation_tools-0.7.1.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## sparc/curation/tools/__init__.py

```diff
@@ -1,11 +1,11 @@
 import os
 import kaleido
 
-__version__ = "0.7.0"
+__version__ = "0.7.1"
 
 if kaleido.__version__ == "0.2.1":
     kaleido_dir = os.path.dirname(os.path.abspath(kaleido.__file__))
     base_file = os.path.join(kaleido_dir, 'scopes', 'base.py')
     with open(base_file) as f:
         contents = f.readlines()
```

## sparc/curation/tools/definitions.py

```diff
@@ -1,13 +1,15 @@
 # VERSION = sparc.curation.tools.__version__
 
 SCAFFOLD_DIR_MIME = 'inode/vnd.abi.scaffold+directory'
 SCAFFOLD_META_MIME = 'application/x.vnd.abi.scaffold.meta+json'
 SCAFFOLD_VIEW_MIME = 'application/x.vnd.abi.scaffold.view+json'
 SCAFFOLD_THUMBNAIL_MIME = 'image/x.vnd.abi.thumbnail+jpeg'
+STL_MODEL_MIME = 'model/stl'
+VTK_MODEL_MIME = 'model/vtk'
 CONTEXT_INFO_MIME = 'application/x.vnd.abi.context-information+json'
 PLOT_CSV_MIME = 'text/x.vnd.abi.plot+csv'
 PLOT_TSV_MIME = 'text/x.vnd.abi.plot+Tab-separated-values'
 
 OLD_SCAFFOLD_MIMES = [SCAFFOLD_DIR_MIME, 'inode/vnd.abi.scaffold+file', 'inode/vnd.abi.scaffold+thumbnail']
 
 SIZE_NAME = ("B", "KiB", "MiB", "GiB", "TiB", "PiB", "EiB", "ZiB", "YiB")
@@ -23,20 +25,24 @@
 SUPPLEMENTAL_JSON_COLUMN = 'Supplemental JSON Metadata'
 ANATOMICAL_ENTITY_COLUMN = 'isAboutAnatomicalEntity'
 
 MIMETYPE_TO_FILETYPE_MAP = {
     SCAFFOLD_META_MIME: 'Metadata',
     SCAFFOLD_VIEW_MIME: 'View',
     SCAFFOLD_THUMBNAIL_MIME: 'Thumbnail',
+    STL_MODEL_MIME: 'STL Model',
+    VTK_MODEL_MIME: 'VTK Model',
     SCAFFOLD_DIR_MIME: 'Directory'
 }
 
 MIMETYPE_TO_PARENT_FILETYPE_MAP = {
     SCAFFOLD_VIEW_MIME: 'Metadata',
     CONTEXT_INFO_MIME: 'Metadata',
-    SCAFFOLD_THUMBNAIL_MIME: 'View'
+    SCAFFOLD_THUMBNAIL_MIME: 'View',
+    STL_MODEL_MIME: 'View',
+    VTK_MODEL_MIME: 'View',
 }
 
 MIMETYPE_TO_CHILDREN_FILETYPE_MAP = {
-    SCAFFOLD_VIEW_MIME: ['Thumbnail'],
+    SCAFFOLD_VIEW_MIME: ['Thumbnail', 'STL Model', 'VTK Model'],
     SCAFFOLD_META_MIME: ['View', 'ContextInfo'],
 }
```

## sparc/curation/tools/errors.py

```diff
@@ -107,36 +107,46 @@
 
 class IncorrectBaseError(ScaffoldAnnotationError):
     """
     Base class for errors related to incorrect base files.
     Inherits from ScaffoldAnnotationError.
     """
 
-    def __init__(self, message, location, mime, target):
+    def __init__(self, message, location, mime, target, replace=False):
         """
         Initialize the IncorrectBaseError object.
 
         Args:
             message (str): Error message.
             location (str): Location of the file.
             mime (str): MIME type of the file.
             target (str): Target file.
         """
         super(IncorrectBaseError, self).__init__(message, location, mime)
         self._target = target
+        self._replace = replace
 
     def get_target(self):
         """
         Get the target file.
 
         Returns:
             str: Target file.
         """
         return self._target
 
+    def get_replace(self):
+        """
+        Get the replace state.
+
+        Returns:
+            bool: state
+        """
+        return self._replace
+
     def __eq__(self, other):
         """
         Check if two IncorrectBaseError objects are equal.
 
         Args:
             other (IncorrectBaseError): Another object to compare.
 
@@ -151,28 +161,29 @@
 
 class IncorrectSourceOfError(IncorrectBaseError):
     """
     Class for errors related to incorrect source files.
     Inherits from IncorrectBaseError.
     """
 
-    def __init__(self, location, mime, target):
+    def __init__(self, location, mime, target, replace=False):
         """
         Initialize the IncorrectSourceOfError object.
 
         Args:
             location (str): Location of the file.
             mime (str): MIME type of the file.
             target (str): Target file.
+            replace (bool): If removing an incorrect source of replace with current content.
         """
         fileType = MIMETYPE_TO_FILETYPE_MAP.get(mime, 'unknown')
         childrenFileType = ', '.join(MIMETYPE_TO_CHILDREN_FILETYPE_MAP.get(mime, 'unknown'))
         message = f"Found '{fileType}' file '{location}' either has no {childrenFileType} file or it's annotated to " \
                   f"an incorrect file. "
-        super(IncorrectSourceOfError, self).__init__(message, location, mime, target)
+        super(IncorrectSourceOfError, self).__init__(message, location, mime, target, replace)
 
 
 class IncorrectDerivedFromError(IncorrectBaseError):
     """
     Class for errors related to incorrect derived from files.
     Inherits from IncorrectBaseError.
     """
```

## sparc/curation/tools/plot_utilities.py

```diff
@@ -51,15 +51,15 @@
             else:
                 if "EIT STARTING" in line:
                     start = True
 
     if csv_rows:
         df = pd.DataFrame(csv_rows)
     else:
-        df = pd.read_csv(file_path, header=None, delimiter='\t')
+        df = pd.read_csv(file_path, header=None, delimiter='\t', low_memory=False)
 
     if is_valid_plot(df):
         return df
 
 
 def get_plot(plot, plot_df):
     # if plot_df only has one cell or has null, not valid
```

## sparc/curation/tools/scaffold_annotations.py

```diff
@@ -1,12 +1,12 @@
 import argparse
 import os
 
 from sparc.curation.tools.definitions import FILE_LOCATION_COLUMN
-from sparc.curation.tools.helpers.error_helper import ErrorManager
+from sparc.curation.tools.helpers.error_helper import ErrorManager, fix_error
 from sparc.curation.tools.helpers.file_helper import OnDiskFiles
 from sparc.curation.tools.helpers.manifest_helper import ManifestDataFrame
 from sparc.curation.tools.utilities import convert_to_bytes
 
 
 def setup_data(dataset_dir, max_size):
     """
@@ -186,18 +186,14 @@
     """
     if error is None:
         return "Let this magic tool fix all errors for you?"
 
     return "Let this magic tool fix this error for you?"
 
 
-def fix_error(error):
-    ErrorManager().fix_error(error)
-
-
 def fix_errors(errors):
     failed = False
     index = 0
     while not failed and len(errors) > 0:
         current_error = errors[index]
 
         fix_error(current_error)
```

## sparc/curation/tools/utilities.py

```diff
@@ -1,12 +1,15 @@
 import argparse
 import math
 import os
 import re
 
+import pandas as pd
+import tabulate
+
 from sparc.curation.tools.definitions import SIZE_NAME
 
 
 def convert_size(size_bytes):
     if size_bytes == 0:
         return "0B"
     i = int(math.floor(math.log(size_bytes, 1024)))
@@ -44,7 +47,30 @@
     if os.path.exists(os.path.join(dataset_dir, "files")):
         dataset_dir = os.path.join(dataset_dir, "files")
     if filename.startswith("derivative"):
         return os.path.join(dataset_dir, filename)
     if os.path.exists(os.path.join(dataset_dir, "derivative")):
         dataset_dir = os.path.join(dataset_dir, "derivative")
     return os.path.join(dataset_dir, filename)
+
+
+def print_as_table(xlsx_file):
+    df = pd.read_excel(xlsx_file)
+
+    headers = [table_header(header) for header in df.keys()]
+    print(tabulate.tabulate(df, headers=headers, tablefmt='simple'))
+
+
+def print_errors(errors):
+    for i, e in enumerate(errors):
+        print(i + 1, e.get_error_message())
+
+
+def table_header(in_header):
+    if in_header == 'timestamp':
+        return 'ts'
+    elif in_header == 'file type':
+        return 'type'
+    elif in_header.startswith('Unnamed'):
+        return '*'
+
+    return in_header
```

## sparc/curation/tools/helpers/error_helper.py

```diff
@@ -4,55 +4,78 @@
 
 from sparc.curation.tools.helpers.base import Singleton
 from sparc.curation.tools.errors import IncorrectAnnotationError, NotAnnotatedError, IncorrectDerivedFromError, \
     IncorrectSourceOfError, OldAnnotationError
 from sparc.curation.tools.definitions import FILE_LOCATION_COLUMN, FILENAME_COLUMN, ADDITIONAL_TYPES_COLUMN, \
     SCAFFOLD_META_MIME, SCAFFOLD_VIEW_MIME, \
     SCAFFOLD_THUMBNAIL_MIME, DERIVED_FROM_COLUMN, SOURCE_OF_COLUMN, MANIFEST_DIR_COLUMN, \
-    OLD_SCAFFOLD_MIMES, MIMETYPE_TO_PARENT_FILETYPE_MAP, MIMETYPE_TO_FILETYPE_MAP
+    OLD_SCAFFOLD_MIMES, MIMETYPE_TO_PARENT_FILETYPE_MAP, MIMETYPE_TO_FILETYPE_MAP, STL_MODEL_MIME, VTK_MODEL_MIME
 from sparc.curation.tools.helpers.file_helper import OnDiskFiles
 from sparc.curation.tools.helpers.manifest_helper import ManifestDataFrame
 
 
+def fix_error(error):
+    # Check files write permission
+    ManifestDataFrame().check_directory_write_permission(error.get_location())
+
+    # Correct old annotation first, then incorrect annotation, and lastly no annotation.
+    if isinstance(error, OldAnnotationError) or isinstance(error, IncorrectAnnotationError):
+        ManifestDataFrame().update_additional_type(error.get_location(), None)
+    elif isinstance(error, NotAnnotatedError):
+        ManifestDataFrame().update_additional_type(error.get_location(), error.get_mime())
+    elif isinstance(error, IncorrectDerivedFromError):
+        ErrorManager().update_derived_from(error.get_location(), error.get_mime(), error.get_target())
+    elif isinstance(error, IncorrectSourceOfError):
+        ErrorManager().update_source_of(error.get_location(), error.get_mime(), error.get_target(), error.get_replace())
+
+
 class ErrorManager(metaclass=Singleton):
     """
     Class to check and manage the different or errors between the annotations in the manifest dataframe and
     the actual files on disk.
     """
 
     def __init__(self):
         self.on_disk = OnDiskFiles()
         self.manifest = ManifestDataFrame()
         self.on_disk_metadata_files = None
         self.on_disk_view_files = None
         self.on_disk_thumbnail_files = None
+        self.on_disk_plot_thumbnail_files = None
+        self._on_disk_alt_forms_files = None
         self.manifest_metadata_files = None
         self.manifest_view_files = None
         self.manifest_thumbnail_files = None
+        self._manifest_alt_forms_files = None
         self.on_disk_context_info_files = None
 
         self.update_content()
 
     def update_content(self):
         """
         Update the content of the on-disk and manifest files.
         """
         self.on_disk_metadata_files = self.on_disk.get_metadata_files()
         self.on_disk_view_files = self.on_disk.get_view_files()
         self.on_disk_thumbnail_files = self.on_disk.get_thumbnail_files()
+        self._on_disk_alt_forms_files = self.on_disk.get_alt_forms_files()
         self.on_disk_plot_thumbnail_files = self.on_disk.get_plot_thumbnails()
         self.on_disk_context_info_files = self.on_disk.get_context_info_files()
 
         self.manifest_metadata_files = self.manifest.get_matching_entry(ADDITIONAL_TYPES_COLUMN, SCAFFOLD_META_MIME,
                                                                         FILE_LOCATION_COLUMN)
         self.manifest_view_files = self.manifest.get_matching_entry(ADDITIONAL_TYPES_COLUMN, SCAFFOLD_VIEW_MIME,
                                                                     FILE_LOCATION_COLUMN)
         self.manifest_thumbnail_files = self.manifest.get_matching_entry(ADDITIONAL_TYPES_COLUMN,
                                                                          SCAFFOLD_THUMBNAIL_MIME,
                                                                          FILE_LOCATION_COLUMN)
+        self._manifest_alt_forms_files = {
+            STL_MODEL_MIME: self.manifest.get_matching_entry(ADDITIONAL_TYPES_COLUMN, STL_MODEL_MIME, FILE_LOCATION_COLUMN),
+            VTK_MODEL_MIME: self.manifest.get_matching_entry(ADDITIONAL_TYPES_COLUMN, VTK_MODEL_MIME, FILE_LOCATION_COLUMN),
+        }
 
     # === Find Errors ===
 
     def get_old_annotations(self):
         """
         Get errors for old annotations in the manifest dataframe.
 
@@ -89,14 +112,19 @@
 
         # Derive thumbnail files from view files, now we don't consider all image files to be annotation errors.
         # manifest_thumbnail_files = manifest.get_matching_entry(ADDITIONAL_TYPES_COLUMN, SCAFFOLD_THUMBNAIL_MIME, FILE_LOCATION_COLUMN)
         # for i in on_disk_thumbnail_files:
         #     if i not in manifest_thumbnail_files:
         #         errors.append(NotAnnotatedError(i, SCAFFOLD_THUMBNAIL_MIME))
 
+        for mime_type in [STL_MODEL_MIME, VTK_MODEL_MIME]:
+            for i in self._on_disk_alt_forms_files[mime_type]:
+                if i not in self._manifest_alt_forms_files[mime_type]:
+                    errors.append(NotAnnotatedError(i, mime_type))
+
         return errors
 
     def get_incorrect_annotations(self):
         """
         Get errors for incorrect annotations in the manifest dataframe.
 
         Returns:
@@ -163,14 +191,19 @@
         errors.extend(view_derived_from_errors)
 
         thumbnail_derived_from_errors = self._process_incorrect_derived_from(
             self.on_disk_thumbnail_files, self.on_disk_view_files, self.manifest_thumbnail_files,
             SCAFFOLD_THUMBNAIL_MIME)
         errors.extend(thumbnail_derived_from_errors)
 
+        for mime_type in [STL_MODEL_MIME, VTK_MODEL_MIME]:
+            alt_forms_derived_from_errors = self._process_incorrect_derived_from(
+                self._on_disk_alt_forms_files[mime_type], self.on_disk_view_files, self._manifest_alt_forms_files[mime_type], mime_type)
+            errors.extend(alt_forms_derived_from_errors)
+
         return errors
 
     def _process_incorrect_source_of(self, on_disk_files, mimetype, on_disk_child_files):
         """
         Helper method to process incorrect source of errors.
 
         Args:
@@ -192,29 +225,28 @@
                         if _is_valid_mimetype_for(mimetype, source_of_mimetype[0]):
                             on_disk_source_of = self.manifest.get_matching_entry(FILENAME_COLUMN, source_of, FILE_LOCATION_COLUMN)
                             if not os.path.isfile(on_disk_source_of[0]):
                                 errors.append(IncorrectSourceOfError(on_disk_file, mimetype, on_disk_child_files))
                         else:
                             corrected_source_of_entries = source_of_entries[:] + on_disk_child_files
                             corrected_source_of_entries.remove(source_of)
-                            errors.append(IncorrectSourceOfError(on_disk_file, mimetype, corrected_source_of_entries))
-                else:
+                            errors.append(IncorrectSourceOfError(on_disk_file, mimetype, corrected_source_of_entries, replace=True))
+                elif on_disk_child_files:
                     errors.append(IncorrectSourceOfError(on_disk_file, mimetype, on_disk_child_files))
 
         if len(errors) == 0:
             for on_disk_file in on_disk_child_files:
                 derived_from = self.manifest.get_derived_from(on_disk_file)
                 for derived_from_entry in derived_from:
                     if not pd.isna(derived_from_entry):
-                        on_disk_dervied_from = self.manifest.get_matching_entry(FILENAME_COLUMN, derived_from_entry, FILE_LOCATION_COLUMN)
-                        derived_from_source_of = self.manifest.get_matching_entry(FILE_LOCATION_COLUMN, on_disk_dervied_from[0], SOURCE_OF_COLUMN)
+                        on_disk_derived_from = self.manifest.get_matching_entry(FILENAME_COLUMN, derived_from_entry, FILE_LOCATION_COLUMN)
+                        derived_from_source_of = self.manifest.get_matching_entry(FILE_LOCATION_COLUMN, on_disk_derived_from[0], SOURCE_OF_COLUMN)
                         derived_from_filename = self.manifest.get_filename(on_disk_file)
-                        if not derived_from_source_of or derived_from_filename[0] not in derived_from_source_of[0].split('\n'):
-                            errors.append(IncorrectSourceOfError(on_disk_dervied_from[0], mimetype, on_disk_child_files))
-
+                        if not derived_from_source_of or derived_from_filename[0] not in derived_from_source_of[0].split('\n') and on_disk_child_files:
+                            errors.append(IncorrectSourceOfError(on_disk_derived_from[0], mimetype, on_disk_child_files))
 
         return errors
 
     def get_incorrect_source_of(self):
         """
         Get errors for incorrect source of relationships in the manifest dataframe.
 
@@ -226,14 +258,19 @@
         on_disk_source_of_files = self.on_disk_view_files + self.on_disk_context_info_files
         metadata_source_of_errors = self._process_incorrect_source_of(self.on_disk_metadata_files, SCAFFOLD_META_MIME, on_disk_source_of_files)
         errors.extend(metadata_source_of_errors)
 
         view_source_of_errors = self._process_incorrect_source_of(self.on_disk_view_files, SCAFFOLD_VIEW_MIME, self.on_disk_thumbnail_files)
         errors.extend(view_source_of_errors)
 
+        for mime_type in [STL_MODEL_MIME, VTK_MODEL_MIME]:
+            alt_forms_derived_from_errors = self._process_incorrect_source_of(
+                self.on_disk_view_files, SCAFFOLD_VIEW_MIME, self._on_disk_alt_forms_files[mime_type])
+            errors.extend(alt_forms_derived_from_errors)
+
         return errors
 
     def get_incorrect_complementary(self):
         """
         Get errors for incorrect complementary files in the manifest dataframe.
 
         Returns:
@@ -258,15 +295,17 @@
                     source_of_files_list.extend(source_of_files)
 
                 manifest_filename = self.manifest.get_matching_entry(FILE_LOCATION_COLUMN, i, FILENAME_COLUMN)
                 for source_of in source_of_files_list:
                     values = self.manifest.get_matching_entry(FILE_LOCATION_COLUMN, source_of, DERIVED_FROM_COLUMN)
                     mimetypes = self.manifest.get_matching_entry(FILE_LOCATION_COLUMN, source_of,
                                                                  ADDITIONAL_TYPES_COLUMN)
-                    if mimetypes[0] != SCAFFOLD_THUMBNAIL_MIME:
+                    if mimetypes[0] in [STL_MODEL_MIME, VTK_MODEL_MIME]:
+                        pass
+                    elif mimetypes[0] != SCAFFOLD_THUMBNAIL_MIME:
                         errors.append(NotAnnotatedError(source_of, SCAFFOLD_THUMBNAIL_MIME))
 
                     if not values[0]:
                         incorrect_derived_from_errors.append(
                             IncorrectDerivedFromError(source_of, SCAFFOLD_THUMBNAIL_MIME, manifest_filename))
 
         errors.extend(incorrect_derived_from_errors)
@@ -296,87 +335,76 @@
                 target_manifest = self.manifest.get_matching_entry(FILE_LOCATION_COLUMN, t, MANIFEST_DIR_COLUMN)
                 if source_manifest == target_manifest:
                     target_filenames.extend(
                         self.manifest.get_matching_entry(FILE_LOCATION_COLUMN, t, FILENAME_COLUMN))
 
         elif mime == SCAFFOLD_THUMBNAIL_MIME:
             # If the MIME type is SCAFFOLD_THUMBNAIL_MIME, find the best matching target filename
-            source_filenames = self.manifest.get_matching_entry(FILE_LOCATION_COLUMN, file_location, FILENAME_COLUMN)
-            source_filename = source_filenames[0]
-            best_match = -1
-            for t in target:
-                target_manifest = self.manifest.get_matching_entry(FILE_LOCATION_COLUMN, t, MANIFEST_DIR_COLUMN)
-                if source_manifest == target_manifest:
-                    matching_entries = self.manifest.get_matching_entry(FILE_LOCATION_COLUMN, t, FILENAME_COLUMN)
-                    match_rating = [calculate_match(tt, source_filename) for tt in matching_entries]
-                    max_value = max(match_rating)
-                    max_index = match_rating.index(max_value)
-                    if max_value > best_match:
-                        best_match = max_value
-                        target_filenames = [matching_entries[max_index]]
+            target_filenames = self._find_best_match(file_location, source_manifest, target)
+        elif mime in [STL_MODEL_MIME, VTK_MODEL_MIME]:
+            target_filenames = self._find_best_match(file_location, source_manifest, target)
 
         # Update the 'Derived From' column content with the target filenames
         self.manifest.update_column_content(file_location, DERIVED_FROM_COLUMN, "\n".join(target_filenames))
 
-    def update_source_of(self, file_location, mime, target):
+    def update_source_of(self, file_location, mime, target, replace):
         """
         Update the 'Source Of' column in the manifest data frame for the given file location.
     
         Args:
             file_location (str): The file location to update.
             mime (str): The MIME type of the file.
             target (list): List of target file locations.
     
         """
         # Get the source manifest entry for the given file location
         source_manifest = self.manifest.get_matching_entry(FILE_LOCATION_COLUMN, file_location, MANIFEST_DIR_COLUMN)
 
         # List to store target filenames
-        target_filenames = []
+        target_filenames = self.manifest.get_matching_entry(FILE_LOCATION_COLUMN, file_location, SOURCE_OF_COLUMN)
+        target_filenames = [tt for tt in target_filenames if str(tt) != "nan"]
 
-        if mime == SCAFFOLD_META_MIME:
+        if mime in [SCAFFOLD_META_MIME, SCAFFOLD_VIEW_MIME, STL_MODEL_MIME, VTK_MODEL_MIME]:
             # If the MIME type is SCAFFOLD_META_MIME, find the matching target filenames
+            filtered_targets = []
             for t in target:
                 target_manifest = self.manifest.get_matching_entry(FILE_LOCATION_COLUMN, t, MANIFEST_DIR_COLUMN)
                 if source_manifest == target_manifest:
-                    target_filenames.extend(
-                        self.manifest.get_matching_entry(FILE_LOCATION_COLUMN, t, FILENAME_COLUMN))
+                    t_mime = self.manifest.get_matching_entry(FILE_LOCATION_COLUMN, t, ADDITIONAL_TYPES_COLUMN)
+                    if t_mime and t_mime[0] == SCAFFOLD_THUMBNAIL_MIME:
+                        filtered_targets.append(t)
+                    else:
+                        if replace:
+                            target_filenames = self.manifest.get_matching_entry(FILE_LOCATION_COLUMN, t, FILENAME_COLUMN)
+                        else:
+                            target_filenames.extend(
+                                self.manifest.get_matching_entry(FILE_LOCATION_COLUMN, t, FILENAME_COLUMN))
 
-        elif mime == SCAFFOLD_VIEW_MIME:
-            # If the MIME type is SCAFFOLD_VIEW_MIME, find the best matching target filename
-            source_filenames = self.manifest.get_matching_entry(FILE_LOCATION_COLUMN, file_location, FILENAME_COLUMN)
-            source_filename = source_filenames[0]
-            best_match = -1
-            for t in target:
-                target_manifest = self.manifest.get_matching_entry(FILE_LOCATION_COLUMN, t, MANIFEST_DIR_COLUMN)
-                if source_manifest == target_manifest:
-                    matching_entries = self.manifest.get_matching_entry(FILE_LOCATION_COLUMN, t, FILENAME_COLUMN)
-                    match_rating = [calculate_match(tt, source_filename) for tt in matching_entries]
-                    max_value = max(match_rating)
-                    max_index = match_rating.index(max_value)
-                    if max_value > best_match:
-                        best_match = max_value
-                        target_filenames = [matching_entries[max_index]]
+            target_filenames.extend(self._find_best_match(file_location, source_manifest, filtered_targets))
 
         # Update the 'Source Of' column content with the target filenames
         self.manifest.update_column_content(file_location, SOURCE_OF_COLUMN, "\n".join(target_filenames))
 
-    def fix_error(self, error):
-        # Check files write permission
-        ManifestDataFrame().check_directory_write_permission(error.get_location())
-
-        # Correct old annotation first, then incorrect annotation, and lastly no annotation.
-        if isinstance(error, OldAnnotationError) or isinstance(error, IncorrectAnnotationError):
-            ManifestDataFrame().update_additional_type(error.get_location(), None)
-        elif isinstance(error, NotAnnotatedError):
-            ManifestDataFrame().update_additional_type(error.get_location(), error.get_mime())
-        elif isinstance(error, IncorrectDerivedFromError):
-            ErrorManager().update_derived_from(error.get_location(), error.get_mime(), error.get_target())
-        elif isinstance(error, IncorrectSourceOfError):
-            ErrorManager().update_source_of(error.get_location(), error.get_mime(), error.get_target())
+    def _find_best_match(self, file_location, source_manifest, target):
+        target_filenames = []
+        source_filenames = self.manifest.get_matching_entry(FILE_LOCATION_COLUMN, file_location, FILENAME_COLUMN)
+        source_filename = source_filenames[0]
+        best_match = -1
+        for t in target:
+            target_manifest = self.manifest.get_matching_entry(FILE_LOCATION_COLUMN, t, MANIFEST_DIR_COLUMN)
+            if source_manifest == target_manifest:
+                matching_entries = self.manifest.get_matching_entry(FILE_LOCATION_COLUMN, t, FILENAME_COLUMN)
+                match_rating = [calculate_match(tt, source_filename) for tt in matching_entries]
+                max_value = max(match_rating)
+                max_index = match_rating.index(max_value)
+                if max_value > best_match:
+                    best_match = max_value
+                    target_filenames = [matching_entries[max_index]]
+
+        return target_filenames
 
 
 def calculate_match(item1, item2):
     """
     Calculate the match rating between two items.
 
     Args:
```

## sparc/curation/tools/helpers/file_helper.py

```diff
@@ -1,12 +1,13 @@
 import csv
 import json
 import os
 from pathlib import Path
 
+from sparc.curation.tools.definitions import STL_MODEL_MIME, VTK_MODEL_MIME
 from sparc.curation.tools.helpers.base import Singleton
 from sparc.curation.tools.utilities import convert_to_bytes
 from sparc.curation.tools.plot_utilities import generate_dataframe_from_txt
 
 ZINC_GRAPHICS_TYPES = ["points", "lines", "surfaces", "contours", "streamlines"]
 
 
@@ -275,14 +276,43 @@
     image_file_paths += list(Path(dataset_dir).rglob("*.jpeg"))
     image_file_paths += list(Path(dataset_dir).rglob("*.jpg"))
     image_file_paths = list(set(image_file_paths))
 
     return image_file_paths
 
 
+def _add_file(mime_type_list, potential_file, thumbnail_file):
+    common_path = os.path.commonprefix([potential_file, thumbnail_file])
+    if not os.path.isdir(common_path):
+        common_prefix = os.path.basename(common_path)
+        thumbnail_file_name = os.path.basename(thumbnail_file)
+        potential_file_name = os.path.basename(potential_file)
+        if thumbnail_file_name.startswith(common_prefix) and potential_file_name.startswith(common_prefix):
+            mime_type_list.append(potential_file)
+
+
+def _filter_alt_forms_by_thumbnail(thumbnail_files):
+    alt_forms_files = {
+        STL_MODEL_MIME: [],
+        VTK_MODEL_MIME: [],
+    }
+    for thumbnail_file in thumbnail_files:
+        target_dir = os.path.dirname(thumbnail_file)
+        files = os.listdir(os.path.dirname(thumbnail_file))
+        for f in files:
+            potential_file = os.path.join(target_dir, f)
+            if os.path.isfile(potential_file) and potential_file is not thumbnail_file:
+                if potential_file.endswith(".vtk"):
+                    _add_file(alt_forms_files[VTK_MODEL_MIME], potential_file, thumbnail_file)
+                if potential_file.endswith(".stl"):
+                    _add_file(alt_forms_files[STL_MODEL_MIME], potential_file, thumbnail_file)
+
+    return alt_forms_files
+
+
 def filter_thumbnail_files_by_parent(image_file_paths, parent_files):
     """
     Filter a list of image file paths to include only those whose in the same folder
     of any parent file in the given parent_files.
 
     Args:
         image_file_paths (list): List of image file paths.
@@ -360,44 +390,34 @@
     return context_data_files
 
 
 class OnDiskFiles(metaclass=Singleton):
     """
     Singleton class for managing on-disk files.
 
-    This class provides methods for setting and retrieving metadata, view, thumbnail, and plot files from a dataset directory.
-    It also provides a method for setting up the dataset by searching for the required files.
+    This class provides methods for setting and retrieving metadata, view, thumbnail, alternative forms,
+    and plot files from a dataset directory. It also provides a method for setting up the
+    dataset by searching for the required files.
 
     Attributes:
         _plot_files (dict): Dictionary containing lists of CSV and TSV plot file paths.
         _scaffold_files (dict): Dictionary containing lists of metadata, view, and thumbnail file paths.
-
-    Methods:
-        setup_dataset(dataset_dir, max_size): Set up the dataset by searching for the required files.
-        set_metadata_files(files, metadata_views): Set the metadata files and metadata views.
-        get_metadata_files(): Get the metadata file paths.
-        set_view_files(files): Set the view files.
-        get_view_files(): Get the view file paths.
-        set_thumbnail_files(files): Set the thumbnail files.
-        get_thumbnail_files(): Get the thumbnail file paths.
-        get_plot_files(): Get the plot file paths.
-        get_plot_thumbnails(): Get the plot thumbnail paths.
-        get_all_image_files(): Get all the image file paths in the dataset.
     """
 
     _dataset_dir = None
     _image_paths = []
     _plot_files = {
         'plot': [],
         'thumbnail': [],
     }
     _scaffold_files = {
         'metadata': [],
         'view': [],
         'thumbnail': [],
+        'alt_forms': {},
     }
     _context_info_files = []
 
     def is_defined(self):
         return self._dataset_dir is not None
 
     def setup_dataset(self, dataset_dir, max_size):
@@ -413,21 +433,22 @@
         """
         self._dataset_dir = dataset_dir
         self._image_paths = search_for_image_files(dataset_dir)
 
         metadata_file, metadata_views = search_for_metadata_files(dataset_dir, max_size)
         self.set_metadata_files(metadata_file, metadata_views)
 
-        self._scaffold_files['view'] = search_for_view_files(dataset_dir, max_size)
-        self._scaffold_files['thumbnail'] = filter_thumbnail_files_by_parent(self._image_paths,
-                                                                             self._scaffold_files['view'])
+        self._scaffold_files["view"] = search_for_view_files(dataset_dir, max_size)
+        self._scaffold_files["thumbnail"] = filter_thumbnail_files_by_parent(self._image_paths,
+                                                                             self._scaffold_files["view"])
+        self._scaffold_files["alt_forms"] = _filter_alt_forms_by_thumbnail(self._scaffold_files["thumbnail"])
 
         self._plot_files["plot"] = search_for_plot_files(self._dataset_dir)
         self._plot_files["thumbnail"] = filter_thumbnail_files_by_parent(self._image_paths,
-                                                                         self._plot_files['plot'])
+                                                                         self._plot_files["plot"])
 
         self._context_info_files = search_for_context_data_files(self._dataset_dir, convert_to_bytes("2MiB"))
 
         return self
 
     def get_dataset_dir(self):
         return self._dataset_dir
@@ -456,14 +477,23 @@
         Get the view file paths.
 
         Returns:
             list: List of view file paths.
         """
         return [str(i) for i in self._scaffold_files['view']]
 
+    def get_alt_forms_files(self):
+        """
+        Get the alternative forms file paths.
+
+        Returns:
+            list: List of alternative forms file paths.
+        """
+        return self._scaffold_files['alt_forms']
+
     def get_thumbnail_files(self):
         """
         Get the thumbnail file paths.
 
         Returns:
             list: List of thumbnail file paths.
         """
```

## sparc/curation/tools/helpers/manifest_helper.py

```diff
@@ -48,15 +48,15 @@
         Raises:
             BadManifestError: If a manifest sanitization error is found.
         """
         self._manifestDataFrame = pd.DataFrame()
         for r in Path(self._dataset_dir).rglob(MANIFEST_FILENAME):
             with pd.ExcelFile(r) as xl_file:
                 for sheet_name in xl_file.sheet_names:
-                    currentDataFrame = xl_file.parse(sheet_name)
+                    currentDataFrame = pd.read_excel(xl_file, sheet_name=sheet_name, dtype=str)
                     currentDataFrame[SHEET_NAME_COLUMN] = sheet_name
                     currentDataFrame[MANIFEST_DIR_COLUMN] = os.path.dirname(r)
                     self._manifestDataFrame = pd.concat([currentDataFrame, self._manifestDataFrame])
 
         if not self._manifestDataFrame.empty:
             self._manifestDataFrame[FILE_LOCATION_COLUMN] = self._manifestDataFrame.apply(
                 lambda row: os.path.join(row[MANIFEST_DIR_COLUMN], row[FILENAME_COLUMN]) if pd.notnull(
@@ -128,15 +128,15 @@
 
         if bad_column_name:
             manifests = [row[MANIFEST_DIR_COLUMN] for i, row in
                          self._manifestDataFrame[self._manifestDataFrame[bad_column_name].notnull()].iterrows()]
             unique_manifests = list(set(manifests))
             for manifest_dir in unique_manifests:
                 current_manifest = os.path.join(manifest_dir, MANIFEST_FILENAME)
-                mDF = pd.read_excel(current_manifest)
+                mDF = pd.read_excel(current_manifest, dtype=str)
                 mDF.rename(columns={bad_column_name: DERIVED_FROM_COLUMN}, inplace=True)
                 mDF.to_excel(current_manifest, index=False, header=True)
                 sanitised = True
 
         return sanitised
 
     def _sanitise_dataframe(self):
@@ -199,15 +199,15 @@
         return filenames[0]
 
     def scaffold_get_metadata_files(self):
         return self.get_matching_entry(ADDITIONAL_TYPES_COLUMN, SCAFFOLD_META_MIME, FILE_LOCATION_COLUMN)
 
     def scaffold_get_plot_files(self):
         return self.get_matching_entry(ADDITIONAL_TYPES_COLUMN, PLOT_CSV_MIME, FILE_LOCATION_COLUMN) + \
-               self.get_matching_entry(ADDITIONAL_TYPES_COLUMN, PLOT_TSV_MIME, FILE_LOCATION_COLUMN)
+            self.get_matching_entry(ADDITIONAL_TYPES_COLUMN, PLOT_TSV_MIME, FILE_LOCATION_COLUMN)
 
     def get_manifest_directory(self, file_location):
         return self.get_matching_entry(FILE_LOCATION_COLUMN, file_location, MANIFEST_DIR_COLUMN)
 
     def get_derived_from(self, file_location):
         return self.get_matching_entry(FILE_LOCATION_COLUMN, file_location, DERIVED_FROM_COLUMN)
 
@@ -236,15 +236,15 @@
 
         # If fileDF is empty, means there's no manifest file containing this file's annotation.
         if fileDF.empty:
             newRow = pd.DataFrame({FILENAME_COLUMN: file_name}, index=[1])
             # Check if there's manifest file under same Scaffold File Dir. If yes get data from it.
             # If no manifest file create new manifest file. Add file to the manifest.
             if not manifestDataFrame[manifestDataFrame[MANIFEST_DIR_COLUMN] == manifest_dir].empty:
-                mDF = pd.read_excel(os.path.join(manifest_dir, MANIFEST_FILENAME))
+                mDF = pd.read_excel(os.path.join(manifest_dir, MANIFEST_FILENAME), dtype=str)
                 newRow = pd.concat([mDF, newRow], ignore_index=True)
             newRow.to_excel(os.path.join(manifest_dir, MANIFEST_FILENAME), index=False, header=True)
 
             # Re-read manifests to find dataframe for newly added entry.
             self._read_manifests()
             fileDF = self._get_matching_dataframe(file_location)
             # fileDF = newRow
@@ -295,35 +295,38 @@
         Raises:
             FileNotFoundError: If the file is not found in the manifest.
         """
         # Update the cells with row: file_location, column: column_name to content
         fileDF = self.get_file_dataframe(file_location)
         for index, row in fileDF.iterrows():
             mDF = pd.read_excel(os.path.join(row[MANIFEST_DIR_COLUMN], MANIFEST_FILENAME),
-                                sheet_name=row[SHEET_NAME_COLUMN])
+                                sheet_name=row[SHEET_NAME_COLUMN], dtype=str)
 
             if content and os.path.isabs(content):
                 content = os.path.relpath(content, row[MANIFEST_DIR_COLUMN])
             if column_name not in mDF.columns:
                 mDF[column_name] = ""
 
             if append:
                 mDF.loc[mDF[FILENAME_COLUMN] == row[FILENAME_COLUMN], column_name] \
                     = mDF.loc[mDF[FILENAME_COLUMN] == row[FILENAME_COLUMN], column_name].fillna(content)
+
                 def _append_new_line_separated(x):
                     if x:
                         val = x + "\n" + content if content not in x.split("\n") else x
                     else:
                         val = content
 
                     return val
 
                 result = mDF.loc[mDF[FILENAME_COLUMN] == row[FILENAME_COLUMN], column_name].apply(_append_new_line_separated)
                 mDF.loc[mDF[FILENAME_COLUMN] == row[FILENAME_COLUMN], column_name] = result
             else:
+                if content is None:
+                    content = ""
                 mDF.loc[mDF[FILENAME_COLUMN] == row[FILENAME_COLUMN], column_name] = content
 
             mDF.to_excel(os.path.join(row[MANIFEST_DIR_COLUMN], MANIFEST_FILENAME), sheet_name=row[SHEET_NAME_COLUMN],
                          index=False, header=True)
 
         self._read_manifests()
```

## Comparing `sparc_curation_tools-0.7.0.dist-info/LICENSE` & `sparc_curation_tools-0.7.1.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `sparc_curation_tools-0.7.0.dist-info/METADATA` & `sparc_curation_tools-0.7.1.dist-info/METADATA`

 * *Files 0% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: sparc-curation-tools
-Version: 0.7.0
+Version: 0.7.1
 Summary: A collection of tools to help with curating SPARC datasets.
 Home-page: https://github.com/ABI-Software/sparc-curation-tools.git
 Author: Hugh Sorby
 Author-email: h.sorby@auckland.ac.nz
 License: Apache Software License
 Description-Content-Type: text/x-rst
 License-File: LICENSE
```

## Comparing `sparc_curation_tools-0.7.0.dist-info/RECORD` & `sparc_curation_tools-0.7.1.dist-info/RECORD`

 * *Files 8% similar despite different names*

```diff
@@ -1,24 +1,24 @@
 sparc/__init__.py,sha256=QDJyS5jtJnGFsSuOx43ZvLBCOrHImm8NrZk5f9URWdk,75
 sparc/curation/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-sparc/curation/tools/__init__.py,sha256=RG0AJp-zWJxcCKbBVxMB5VE1Xshp-zMISdnEOELO7MM,513
+sparc/curation/tools/__init__.py,sha256=AK3Pgz9T8Tc5vkIXZHt2-vLkscP5R7qt_YpCeK4Z0-Y,513
 sparc/curation/tools/context_annotations.py,sha256=wrSWBGh56H-E--EGz5H5l-5BcgwsBp6t9y3K14fAmbQ,3650
-sparc/curation/tools/definitions.py,sha256=JG5aCN_txT7mvjtQfinI8bDyu89zEFhKSrFU5EOxdG0,1492
-sparc/curation/tools/errors.py,sha256=kN4JBNZU38pyoK8s2BquaszC2Jn6_SOy4MkA_GsDQFI,6996
+sparc/curation/tools/definitions.py,sha256=7hOlOGFkkJLNDC96z0p3Z0WEhRyvfzjcMTi3VsgBwPo,1699
+sparc/curation/tools/errors.py,sha256=G4fZ6scCk5cGbvp84QGBUGLPLVZ_isAXUo5qDe--Qg8,7314
 sparc/curation/tools/plot_annotations.py,sha256=HSKdL6w5WcCjXY5DOiQY_G-6M3SDlgVGKimlsFqSew0,7346
-sparc/curation/tools/plot_utilities.py,sha256=ZDP_AbuJvcUWb213ZAFkessUupQBqbYq-BDkH7MU-4E,4420
-sparc/curation/tools/scaffold_annotations.py,sha256=rQva_Cc0Fgan8LAIPHbBHxJ8ilLi9vOrFX3mG9Z0y6E,8739
-sparc/curation/tools/utilities.py,sha256=07WblhOk1mrT9CNpm2b2P_1aZ0Ya8ao-9x_7NFUsEEQ,1596
+sparc/curation/tools/plot_utilities.py,sha256=5TMa3EZeVNcZe902lIe3w1DJLiWM1FbOf2nqLcpzwhY,4438
+sparc/curation/tools/scaffold_annotations.py,sha256=yoJGGRyK5q2Qm0BSsUeAn_Od0B457VhHY4tQyWwpP1w,8690
+sparc/curation/tools/utilities.py,sha256=vqqTHKrbkS_PDVwcF2a3ODqRVNf8f029wcUt3M-aw_A,2162
 sparc/curation/tools/helpers/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 sparc/curation/tools/helpers/base.py,sha256=HHb_IUEKnjLUyIpm193WICjkIW9cthjiKbgFFPrhNg0,241
-sparc/curation/tools/helpers/error_helper.py,sha256=x57iSHyzjc-92pSu53jUlivwuy-avQRRFFoT7_i79ok,19215
-sparc/curation/tools/helpers/file_helper.py,sha256=doYihnFi2H_GFcWpVYCrwX9UYBYv3vBcchYemVVC9dI,14509
-sparc/curation/tools/helpers/manifest_helper.py,sha256=FVm-4G5KgcpdpI61KnUwjmPe3Sz86-G0r7I8X67GrBs,14586
+sparc/curation/tools/helpers/error_helper.py,sha256=XvVeEm4GElDS0_yTG6LT5gQ3GSzx8mM2ttQEt5Z8pM8,20929
+sparc/curation/tools/helpers/file_helper.py,sha256=T3r7J9tnkw1XAWz5xW7Is1c-RO6WCHPXZU6oSXeuPZg,15594
+sparc/curation/tools/helpers/manifest_helper.py,sha256=9Fe52ICRU1OMNzGElxwkEGnLpYw8-m0nGC5cj-zfsr4,14717
 sparc/curation/tools/models/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 sparc/curation/tools/models/contextinfo.py,sha256=Sb9aY14fHXEk0U-h3oA1byiQ_28yUBdtp3NfU0wvsS8,2645
 sparc/curation/tools/models/plot.py,sha256=ckxl-ljVxP4IA-mE6MJGl1MbQjdacdptr6FvbTgfkbE,1531
-sparc_curation_tools-0.7.0.dist-info/LICENSE,sha256=y3eEknQp0TEekrP_qzouW-C_gagfgBMacOWHyJgUxcE,564
-sparc_curation_tools-0.7.0.dist-info/METADATA,sha256=CaF06Kp-hCKWFRs_6KoNNsscA6v4lZgmZVYMnbJUEuk,1326
-sparc_curation_tools-0.7.0.dist-info/WHEEL,sha256=GJ7t_kWBFywbagK5eo9IoUwLW6oyOeTKmQ-9iHFVNxQ,92
-sparc_curation_tools-0.7.0.dist-info/entry_points.txt,sha256=Yu3OlH4HENiXkw7kDmAih2xp4Z2HNvmQF6maUHyPumk,149
-sparc_curation_tools-0.7.0.dist-info/top_level.txt,sha256=0Rkt3aTPDJTiu4CYXIrK3J29ztJr3Fd8oBc_SwyDECs,6
-sparc_curation_tools-0.7.0.dist-info/RECORD,,
+sparc_curation_tools-0.7.1.dist-info/LICENSE,sha256=y3eEknQp0TEekrP_qzouW-C_gagfgBMacOWHyJgUxcE,564
+sparc_curation_tools-0.7.1.dist-info/METADATA,sha256=7IHnXYLgYvwDGpWvH0g-ZZmuXLVs-Wftowdwn2xDOR0,1326
+sparc_curation_tools-0.7.1.dist-info/WHEEL,sha256=GJ7t_kWBFywbagK5eo9IoUwLW6oyOeTKmQ-9iHFVNxQ,92
+sparc_curation_tools-0.7.1.dist-info/entry_points.txt,sha256=Yu3OlH4HENiXkw7kDmAih2xp4Z2HNvmQF6maUHyPumk,149
+sparc_curation_tools-0.7.1.dist-info/top_level.txt,sha256=0Rkt3aTPDJTiu4CYXIrK3J29ztJr3Fd8oBc_SwyDECs,6
+sparc_curation_tools-0.7.1.dist-info/RECORD,,
```

