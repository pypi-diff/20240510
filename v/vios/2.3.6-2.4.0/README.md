# Comparing `tmp/vios-2.3.6-py3-none-any.whl.zip` & `tmp/vios-2.4.0-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,26 +1,26 @@
-Zip file size: 45409 bytes, number of entries: 24
--rw-rw-rw-  2.0 fat    18569 b- defN 24-Apr-25 14:44 quark/proxy.py
--rw-rw-rw-  2.0 fat    18867 b- defN 24-Apr-29 13:27 quark/app/__init__.py
--rw-rw-rw-  2.0 fat     2575 b- defN 24-Mar-19 11:19 quark/app/_data.py
--rw-rw-rw-  2.0 fat    10205 b- defN 24-Mar-19 11:19 quark/app/_demo.py
--rw-rw-rw-  2.0 fat     8790 b- defN 24-Apr-28 13:40 quark/app/_task.py
--rw-rw-rw-  2.0 fat     5876 b- defN 24-Mar-19 11:19 quark/app/uapi.py
--rw-rw-rw-  2.0 fat     7914 b- defN 24-Mar-19 11:19 quark/driver/VirtualDevice.py
--rw-rw-rw-  2.0 fat      386 b- defN 24-Mar-19 11:19 quark/driver/__init__.py
--rw-rw-rw-  2.0 fat      217 b- defN 24-Mar-19 11:19 quark/driver/common/__init__.py
--rw-rw-rw-  2.0 fat     4478 b- defN 24-Mar-19 11:19 quark/driver/common/basedriver.py
--rw-rw-rw-  2.0 fat     4663 b- defN 24-Mar-19 11:19 quark/driver/common/quantity.py
--rw-rw-rw-  2.0 fat     5432 b- defN 24-Mar-19 11:19 quark/driver/common/visadriver.py
--rw-rw-rw-  2.0 fat     1188 b- defN 24-Mar-19 11:19 quark/envelope/__init__.py
--rw-rw-rw-  2.0 fat    15111 b- defN 24-Mar-19 11:19 quark/envelope/assembler.py
--rw-rw-rw-  2.0 fat     4322 b- defN 24-Mar-19 11:19 quark/envelope/calculator.py
--rw-rw-rw-  2.0 fat     1106 b- defN 24-Mar-19 11:19 quark/envelope/device.py
--rw-rw-rw-  2.0 fat     3733 b- defN 24-Apr-25 14:44 quark/envelope/processor.py
--rw-rw-rw-  2.0 fat     4320 b- defN 24-Apr-25 14:44 quark/envelope/router.py
--rw-rw-rw-  2.0 fat     2841 b- defN 24-Mar-21 12:16 quark/envelope/systemq.py
--rw-rw-rw-  2.0 fat     1085 b- defN 24-Apr-29 13:34 vios-2.3.6.dist-info/LICENSE
--rw-rw-rw-  2.0 fat     1211 b- defN 24-Apr-29 13:34 vios-2.3.6.dist-info/METADATA
--rw-rw-rw-  2.0 fat       92 b- defN 24-Apr-29 13:34 vios-2.3.6.dist-info/WHEEL
--rw-rw-rw-  2.0 fat        6 b- defN 24-Apr-29 13:34 vios-2.3.6.dist-info/top_level.txt
--rw-rw-r--  2.0 fat     1923 b- defN 24-Apr-29 13:34 vios-2.3.6.dist-info/RECORD
-24 files, 124910 bytes uncompressed, 42339 bytes compressed:  66.1%
+Zip file size: 51657 bytes, number of entries: 24
+-rw-rw-rw-  2.0 fat    18481 b- defN 24-May-10 11:53 quark/proxy.py
+-rw-rw-rw-  2.0 fat    16469 b- defN 24-May-10 11:53 quark/app/__init__.py
+-rw-rw-rw-  2.0 fat     3591 b- defN 24-May-09 13:38 quark/app/_data.py
+-rw-rw-rw-  2.0 fat    11325 b- defN 24-May-09 13:38 quark/app/_demo.py
+-rw-rw-rw-  2.0 fat     9888 b- defN 24-May-09 13:38 quark/app/_task.py
+-rw-rw-rw-  2.0 fat     6622 b- defN 24-May-10 11:53 quark/app/uapi.py
+-rw-rw-rw-  2.0 fat     7528 b- defN 24-May-10 11:53 quark/driver/VirtualDevice.py
+-rw-rw-rw-  2.0 fat     1325 b- defN 24-May-10 11:53 quark/driver/__init__.py
+-rw-rw-rw-  2.0 fat     1386 b- defN 24-May-09 13:38 quark/driver/common/__init__.py
+-rw-rw-rw-  2.0 fat     5384 b- defN 24-May-10 11:53 quark/driver/common/basedriver.py
+-rw-rw-rw-  2.0 fat     5856 b- defN 24-May-09 13:38 quark/driver/common/quantity.py
+-rw-rw-rw-  2.0 fat     6473 b- defN 24-May-10 11:53 quark/driver/common/visadriver.py
+-rw-rw-rw-  2.0 fat     2150 b- defN 24-May-10 11:53 quark/envelope/__init__.py
+-rw-rw-rw-  2.0 fat    15109 b- defN 24-May-10 11:53 quark/envelope/assembler.py
+-rw-rw-rw-  2.0 fat     5196 b- defN 24-May-10 11:53 quark/envelope/calculator.py
+-rw-rw-rw-  2.0 fat     1984 b- defN 24-May-09 13:38 quark/envelope/device.py
+-rw-rw-rw-  2.0 fat     4689 b- defN 24-May-09 13:38 quark/envelope/processor.py
+-rw-rw-rw-  2.0 fat     5241 b- defN 24-May-10 11:53 quark/envelope/router.py
+-rw-rw-rw-  2.0 fat     3812 b- defN 24-May-09 13:38 quark/envelope/systemq.py
+-rw-rw-rw-  2.0 fat     1064 b- defN 24-May-10 11:53 vios-2.4.0.dist-info/LICENSE
+-rw-rw-rw-  2.0 fat     1177 b- defN 24-May-10 11:53 vios-2.4.0.dist-info/METADATA
+-rw-rw-rw-  2.0 fat       92 b- defN 24-May-10 11:53 vios-2.4.0.dist-info/WHEEL
+-rw-rw-rw-  2.0 fat        6 b- defN 24-May-10 11:53 vios-2.4.0.dist-info/top_level.txt
+-rw-rw-r--  2.0 fat     1925 b- defN 24-May-10 11:53 vios-2.4.0.dist-info/RECORD
+24 files, 136773 bytes uncompressed, 48587 bytes compressed:  64.5%
```

## zipnote {}

```diff
@@ -51,23 +51,23 @@
 
 Filename: quark/envelope/router.py
 Comment: 
 
 Filename: quark/envelope/systemq.py
 Comment: 
 
-Filename: vios-2.3.6.dist-info/LICENSE
+Filename: vios-2.4.0.dist-info/LICENSE
 Comment: 
 
-Filename: vios-2.3.6.dist-info/METADATA
+Filename: vios-2.4.0.dist-info/METADATA
 Comment: 
 
-Filename: vios-2.3.6.dist-info/WHEEL
+Filename: vios-2.4.0.dist-info/WHEEL
 Comment: 
 
-Filename: vios-2.3.6.dist-info/top_level.txt
+Filename: vios-2.4.0.dist-info/top_level.txt
 Comment: 
 
-Filename: vios-2.3.6.dist-info/RECORD
+Filename: vios-2.4.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## quark/proxy.py

```diff
@@ -1,29 +1,46 @@
-"""!!! note "**用户输入输出**"
+# MIT License
 
-- app: 用户函数或任务定义
-- driver: 设备驱动. **NOTE: 如发生改动, 需要重启server**
-    - 所有驱动继承自BaseDriver，类名统一为Driver，并要求实现open/close/read/write四个方法。样板见VirtualDevice
-    - 以设备或厂家为名新建文件夹(并于其内新建__init__.py文件)放于driver/common内，将厂家提供的底层库(若有)置于其内
+# Copyright (c) 2021 YL Feng
 
-- envelope: 执行流程，见各模块说明. **NOTE: 如发生改动, 需要重启server**
+# Permission is hereby granted, free of charge, to any person obtaining a copy
+# of this software and associated documentation files (the "Software"), to deal
+# in the Software without restriction, including without limitation the rights
+# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+# copies of the Software, and to permit persons to whom the Software is
+# furnished to do so, subject to the following conditions:
+
+# The above copyright notice and this permission notice shall be included in
+# all copies or substantial portions of the Software.
+
+# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+
+"""
+Abstract: **about proxy**
+    - `Task`: interact with the `QuarkServer` from the view of a task
 """
 
 
 import asyncio
 import inspect
 import json
 import string
 import sys
 import time
 from collections import defaultdict
 from functools import cached_property
 from multiprocessing.shared_memory import SharedMemory
 from pathlib import Path
-from threading import Lock, Thread, current_thread
+from threading import current_thread
 
 import numpy as np
 from loguru import logger
 
 QUARK = Path.home()/'quark'
 
 try:
@@ -118,16 +135,14 @@
         from tqdm import tqdm
 except Exception as e:
     # not installed or Probably IDLE
     from tqdm import tqdm
 
 
 class Progress(tqdm):
-    """兼容JupyterProgressBar接口(from kernel)的实现
-    """
     bar_format = '{desc} {percentage:3.0f}%|{bar}|{n_fmt}/{total_fmt} [{elapsed}<{remaining}, {rate_fmt}{postfix}]'
 
     def __init__(self, desc='test', total=100, postfix='running', disable: bool = False):
         super().__init__([], desc, total, ncols=None, colour='blue',
                          bar_format=self.bar_format, position=0, postfix=postfix, disable=disable)
 
     @property
@@ -144,70 +159,68 @@
 
     def finish(self, success: bool = True):
         self.colour = 'green' if success else 'red'
         # self.set_description_str(str(success))
 
 
 class Task(object):
-    """适用于大量任务连续提交(如量子云)
+    """tracking progress, get result and debug
     """
 
     handles = {}
     counter = defaultdict(lambda: 0)
     server = None
 
     def __init__(self, task: dict, timeout: float | None = None, plot: bool = False) -> None:
-        """实例化任务，用于跟踪进度、获取结果以及画图
+        """instantiate a task
 
         Args:
-            task (dict): 任务描述，详见submit函数
-            timeout (float | None, optional): 阻塞任务最大时间. Defaults to None.
-            plot (bool, optional): 是否实时画图. 默认为False.
+            task (dict): see **quark.app.submit**
+            timeout (float | None, optional): timeout for the task. Defaults to None.
+            plot (bool, optional): plot result in `quark studio` if True. Defaults to False.
         """
         self.task = task
         self.timeout = timeout
         self.plot = plot
 
-        self.data: dict[str, np.ndarray] = {}  # 从server取回的数据
-        self.meta = {}  # 坐标轴等描述类信息
-        self.index = 0  # 当前已取回的数据数量
-        self.last = 0  # 上一次获取的数据量
+        self.data: dict[str, np.ndarray] = {}  # retrieve data from server
+        self.meta = {}  # metainfo like axis
+        self.index = 0  # index of data already retrieved
+        self.last = 0  # last index of retrieved data
 
         self.thread = current_thread().name
 
     @cached_property
     def name(self):
         return self.task['metainfo'].get('name', 'Unknown')
 
     @cached_property
     def ctx(self):
         return self.step(-9, 'ctx')
 
     def run(self):
-        """提交任务，如果有正在执行的任务则需等待
+        """submit the task to the `QuarkServer`
         """
         self.stime = time.time()  # start time
         try:
             circuit = self.task['taskinfo']['CIRQ']
             if isinstance(circuit, list) and callable(circuit[0]):
                 circuit[0] = inspect.getsource(circuit[0])
         except Exception as e:
             logger.error(f'Failed to get circuit: {e}')
         self.tid = self.server.submit(self.task)
 
     def cancel(self):
-        """处理从server取回的数据
-        data (list[dict]): 一维数组, 其中每个元素均为dict, 即envelope.process函数返回值
+        """cancel the task
         """
         self.server.cancel(self.tid)
         # self.clear()
 
     def result(self):
-        """从server取回数据
-        data (list[dict]): 一维数组, 其中每个元素均为dict, 即envelope.process函数返回值.
+        """result of the task
         """
         meta = True if not self.meta else False
         res = self.server.fetch(self.tid, start=self.index, meta=meta)
 
         if isinstance(res, str):
             return self.data
         elif isinstance(res, tuple):
@@ -235,26 +248,26 @@
         else:
             return 'supported arguments are: {rumtime, compile}'
 
     def report(self):
         return self.server.report(self.tid)
 
     def step(self, index: int, stage: str = 'raw'):
-        """获取任务中某一步的详细信息
+        """step details
 
         Args:
-            index (int): 步数.
-            stage (str, optional): 任务执行所经历的阶段. Defaults to 'raw'.
+            index (int): step index
+            stage (str, optional): stage name. Defaults to 'raw'.
 
-        Examples: stage可取以下值
-            - ini: 编译生成的指令
-            - raw: 映射为硬件通道后的指令及收集好的相关参数
-            - ctx: 编译所用的上下文环境(ctx)
-            - debug: 由设备返回的原始数据
-            - trace: 每个指令执行所用时间
+        Examples: stage values
+            - ini: original instruction
+            - raw: preprocessed instruction
+            - ctx: compiler context
+            - debug: raw data returned from devices
+            - trace: time consumption for each channel
 
         Returns:
             _type_: _description_
         """
         if stage in ['ini', 'raw', 'ctx', 'byp']:
             return self.server.review(self.tid, index)[stage]
         elif stage in ['debug', 'trace']:
@@ -299,23 +312,25 @@
         try:
             self.progress.finish(success)
             self.handles[tid].cancel()
         except Exception as e:
             pass
 
     def bar(self, interval: float = 2.0, disable: bool = False):
-        """任务进度信息. 如果timeout非零, 则同步阻塞执行, 否则异步.
-        NOTE: 如果结果获取不到或者不全, 可能是save清空导致,可减小interval增加取数频率.
+        """task progress. 
+        
+        Tip: tips
+            - Reduce the interval if result is empty.
+            - If timeout is not None or not 0, task will be blocked, otherwise, the task will be executed asynchronously.
 
         Args:
-            interval (float, optional): 进度刷新时间间隔, 不宜也不必过快. Defaults to 2.0.
+            interval (float, optional): time period to retrieve data from `QuarkServer`. Defaults to 2.0.
 
         Raises:
-            TimeoutError: 如果任务超过了认定的最大时间还未完则停止.
-                实际还在执行, 只是Task不再获取数据及进度.如不需要执行, 可cancel任务.
+            TimeoutError: if TimeoutError is raised, the task progress bar will be stopped.
         """
         while True:
             try:
                 status = self.status()['status']
                 if status in ['Pending']:
                     time.sleep(interval)
                     continue
@@ -418,16 +433,14 @@
         msg = f'Failed to update chip info of quafu, {e}'
         logger.critical(msg)
 
     return f'compiler database of {backend} updated!\r\n{msg}'
 
 
 class QuarkProxy(object):
-    """云客户端
-    """
 
     def __init__(self) -> None:
         from .app import login
 
         self.server = login()
         setlog()
 
@@ -462,22 +475,14 @@
     def cancel(self, tid: int):
         return self.server.cancel(tid)
 
     def status(self, tid: int = 0):
         pass
 
     def result(self, tid: int, raw: bool = False):
-        """根据任务id获取结果
-
-        Args:
-            tid (int): 任务id
-
-        Returns:
-            dict: 数据及任务元信息
-        """
         from .app import get_data_by_tid
         try:
             result = get_data_by_tid(tid, 'count')
             return result if raw else self.process(result)
         except Exception as e:
             return f'No data found for {tid}!'
```

### encoding

```diff
@@ -1 +1 @@
-utf-8
+us-ascii
```

## quark/app/__init__.py

```diff
@@ -1,12 +1,35 @@
-"""!!! note "模块说明"
-- init模块: 提交任务(submit)/获取数据(get_data_by_tid)/回滚参数(rollback)/画图(plot)
-- demo模块: 一些任务定义的例子
-- task模块: 从kernel的App兼容而来的各种Scanner(原有使用行为不变)
-- uapi模块: 与前端进行交互, 如matplotlib画图、数据库查询等, 详见各函数说明. 
+# MIT License
+
+# Copyright (c) 2021 YL Feng
+
+# Permission is hereby granted, free of charge, to any person obtaining a copy
+# of this software and associated documentation files (the "Software"), to deal
+# in the Software without restriction, including without limitation the rights
+# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+# copies of the Software, and to permit persons to whom the Software is
+# furnished to do so, subject to the following conditions:
+
+# The above copyright notice and this permission notice shall be included in
+# all copies or substantial portions of the Software.
+
+# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+
+"""
+Abstract: about app
+    - **submit** task
+    - **get_data_by_tid**
+    - **rollback** paramters
+    - **plot** data
 """
 
 import time
 from collections import defaultdict
 from ipaddress import ip_address
 from pathlib import Path
 from threading import current_thread
@@ -23,81 +46,72 @@
 srv = startup.get('quarkserver', {})
 host, port = srv.get('host', '127.0.0.1'), srv.get('port', 2088)
 sp = defaultdict(lambda: connect('QuarkServer', host, port))
 _vs = connect('QuarkViewer', port=2086)
 
 
 def signup(user: str, system: str, **kwds):
-    """注册用户, 并绑定到指定的芯片系统
+    """register a new **user** on the **system**
 
     Args:
-        user (str): 用户名
-        system (str): 芯片系统名即cfg表名
+        user (str): name of the user
+        system (str): name of the system(i.e. the name of the cfg file)
     """
     s = sp[current_thread().name]
     logger.info(s.adduser(user, system, **kwds))
 
 
 def login(user: str = 'baqis', verbose: bool = True):
-    """登录到server
+    """login to the server as **user**
 
     Args:
-        user (str, optional): 用户名, 与signup中一致. Defaults to 'baqis'.
-        verbose (bool, optional): 是否打印登录信息. Defaults to True.
+        user (str, optional): name of the user(same as signup). Defaults to 'baqis'.
+        verbose (bool, optional): print login info if True. Defaults to True.
 
     Returns:
-        _type_: 到server的连接
+        _type_: a connection to the server
     """
     s = sp[current_thread().name]
     m = s.login(srv.get('user', user))
     if verbose:
         logger.info(m)
     return s
 
 
-def submit(app, block: bool = False,
-           shot: int = 0, reset: list = [], fillzero: bool = False,
-           preview: list = [], title: list[tuple] = [], interval: float = 2.0, **kwds):
-    """转换继承自App的任务为backend可执行任务
+def submit(task: dict, block: bool = False, preview: list = [], **kwds):
+    """submit a task to a backend
 
     Args:
-        app (dict): 任务描述或Scan|Scanner(`from quark.app.task import Scan, Scanner`).
-        block (bool, optional): 是否阻塞任务, 用于多个任务顺序执行.
-        shot (int, optional): 任务开始前设置shot, 一般不需要.
-        reset (bool, optional): 任务开始前执行，重置设备指令列表, 如[('WRITE','Q0.waveform.Z','zero()','au')].
-        fillzero (bool, optional): 是否在编译前将所有通道初始化为zero().
-        preview (list, optional): 需要实时显示的波形, 对应etc.preview.filter.
-        title (list[tuple], optional): 画图所显示的标题, 如不指定则由任务生成.
-        interval (float, optional): 画图刷新频率. 默认2秒.
+        task (dict): description of a task
+        block (bool, optional): block until the task is done if True
+        preview (list, optional): real time display of the waveform
 
     Keyword Arguments: Kwds
-        plot (bool): 是否需要实时显示结果(1D或2D), 默认为False.
-        column (int):  子图列数, 默认为4.
-        backend (connection): 指向某个backend的连接, 默认为本机.
-        dry_run (bool): 如果为True则跳过设备但波形正常计算并显示, 默认为False.
+        plot (bool): plot the result in the QuarkStudio if True(1D or 2D), defaults to False.
+        backend (connection): connection to a backend, defaults to local machine.
 
     Raises:
         TypeError: _description_
 
-    Example: 任务描述示例
+    Example: description of a task
         ``` {.py3 linenums="1"}
         {
-            'metainfo': {'name': f'{filename}: /s21',  # 冒号后为数据集名
-                                # 额外参数，如编译参数，与数据一起存于文件
+            'metainfo': {'name': f'{filename}: /s21',  # s21 is the name of the dataset
+                                # extra arguments for compiler and others
                                 'other': {'shots': 1234, 'signal': 'iq', 'autorun': False}},
-            'taskinfo': {'STEP': {'main': ['WRITE', ('freq', 'offset', 'power')],  # main为保留关键字，不得替换
-                                  'step2': ['WRITE', 'trig'],  # 触发
-                                  'step3': ['WAIT', 0.8101],  # 等待一段时间，单位为秒
+            'taskinfo': {'STEP': {'main': ['WRITE', ('freq', 'offset', 'power')],  # main is reserved
+                                  'step2': ['WRITE', 'trig'],
+                                  'step3': ['WAIT', 0.8101],  # wait for some time in the unit of second
                                   'READ': ['READ', 'read'],
                                   'step5': ['WAIT', 0.202]},
-                         'INIT': [('Trigger.CHAB.TRIG', 0, 'any')],  # 任务开始前设置
-                         'POST': [('Trigger.CHAB.TRIG', 0, 'any')],  # 任务结束后设置
-                         'CIRQ': ['cc'],  # 线路列表
+                         'INIT': [('Trigger.CHAB.TRIG', 0, 'any')],  # initialization of the task
+                         'POST': [('Trigger.CHAB.TRIG', 0, 'any')],  # reset of the task
+                         'CIRQ': ['cc'],  # list of circuits in the type of qlisp
                          'RULE': ['<gate.Measure.Q1.params.frequency> = <Q0.setting.LO>+<Q2.setting.LO> +1250'],
-                         'LOOPs': {'freq': [('Q0.setting.LO', np.linspace(0, 10, 2), 'Hz'),
+                         'LOOP': {'freq': [('Q0.setting.LO', np.linspace(0, 10, 2), 'Hz'),
                                             ('gate.Measure.Q1.index',  np.linspace(0, 1, 2), 'Hz')],
                                    'offset': [('M0.setting.TRIGD', np.linspace(0, 10, 1), 'Hz'),
                                               ('Q2.setting.LO', np.linspace(0, 10, 1), 'Hz')],
                                    'power': [('Q3.setting.LO', np.linspace(0, 10, 15), 'Hz'),
                                              ('Q4.setting.POW', np.linspace(0, 10, 15), 'Hz')],
                                    'trig': [('Trigger.CHAB.TRIG', 0, 'any')],
                                    'read': ['NA10.CH1.TraceIQ', 'M0.setting.POW']
@@ -114,169 +128,108 @@
         ss = kwds['backend']
         trig = []
     else:
         ss = login(verbose=False)
         trig = [(t, 0, 'au') for t in ss.query('station.triggercmds')]
 
     if preview:
-        ss.update('etc.preview.filter', preview)  # 待预览波形
-
-    if reset:
-        ss.feed(0, 0, {'reset': reset})  # 任务提交前的设置
-
-    if isinstance(app, dict):
-        app['taskinfo']['LOOP']['trig'] = trig
-        t = Task(app)
-        t.server = ss
-        t.plot = plot if kwds.get('plot', False) else False
-        t.timeout = 1e9 if block else None
-        t.run()
-        return t
-
-    from kernel.task import Scan, Scanner
-
-    if not isinstance(app, (Scan, Scanner)):
-        return logger.critical('Unknown type of App, Scan or Scanner required!')
-
-    app.toserver = 'ready'
-    app.run(dry_run=True, quiet=True)
-    time.sleep(3)
-
-    filepath = Path.cwd()/f'circuit/{app.name.replace(".", "_")}.cirq'
-    filepath.parent.mkdir(parents=True, exist_ok=True)
-    qubits, circuits = app.dumps(filepath, ip_address(host).is_loopback)
-
-    # loops = app.variables()
-    loops, deps = app.resolve()
-    sample = ss.query('station.sample')
-
-    init = [(f'{t.split(".")[0]}.CH1.Shot', app.shots, 'any')
-            for t in trig] if shot else []
-
-    t = Task({'metainfo': {'name': f'{sample}:/{filepath.stem}',
-                           'tid': app.id,
-                           'priority': app.task_priority,
-                           'other': {'shots': app.shots,
-                                     'signal': app.signal,
-                                     #  'lib': app.lib, # WindowsPath error on Mac
-                                     'align_right': app.align_right,  # 波形对齐方式
-                                     'waveform_length': app.waveform_length,  # 波形长度
-                                     'fillzero': fillzero,
-                                     'autorun': not kwds.get('dry_run', False),
-                                     'hold': app.runtime.keep_last_status,
-                                     'timeout': 1000.0}  # 编译超时
-                           },
-
-              'taskinfo': {'STEP': {'main': ['WRITE', tuple(loops)],  # 主循环，写波形等设置
-                                    'trig': ['WRITE', 'trig'],  # 触发
-                                    # 'wait':['WAIT',0.5],
-                                    'READ': ['READ', 'read'],  # 读取
-                                    },
-                           'INIT': init,  # 任务开始前的初始化
-                           'RULE': deps,
-                           'CIRQ': circuits if circuits else str(filepath.resolve()),
-                           'LOOP': loops | {'trig': trig}
-                           }
-              }
-             )
+        ss.update('etc.preview.filter', preview)  # waveforms to be previewed
 
+    task['taskinfo']['LOOP']['trig'] = trig
+    t = Task(task)
     t.server = ss
-    t.timeout = 1e9 if block else None
     t.plot = plot if kwds.get('plot', False) else False
-    t.column = kwds.get('column', 4)
-
-    t.app = app
-    t.title = title if title else qubits
-    app.toserver = t
-    app.run()
-    app.bar(interval)
+    t.timeout = 1e9 if block else None
+    t.run()
+    return t
 
 
 def rollback(tid: int):
-    """将cfg表回滚至指定的任务id
+    """rollback the parameters with given task id
 
     Args:
-        tid (int): 任务id,与submit中tid相同
+        tid (int): task id
     """
     _s = login(verbose=False)
 
     try:
         config = get_config_by_tid(tid)
         _s.clear()
         for k, v in config.items():
             _s.create(k, v)
     except Exception as e:
         logger.error(f'Failed to rollback: {e}')
 
 
 def get_data_by_tid(tid: int, signal: str, shape: tuple | list = [], **kwds) -> dict:
-    """根据任务id从hdf5获取数据
+    """load data with given **task id(tid)** and **signal**
 
     Args:
-        tid (int): 任务id
-        signal (str): 指定需要画的数据.
-        shape (tuple|list): data shape, 如果不指定尝试从记录中推出,形如(*sweeps, *(shots, qubits))
+        tid (int): task id
+        signal (str): signal of the data
+        shape (tuple|list): data shape like (*sweeps, *(shots, qubits))
 
     Keyword Arguments: Kwds
-        plot (bool, optional): 是否需要实时显示结果(1D或2D).
+        plot (bool, optional): plot the result in QuarkStudio after the data is loaded(1D or 2D).
 
     Returns:
-        dict: 数据体、元信息、cfg表
+        dict: data、metainfo
     """
     info, data = get_dataset_by_tid(tid, signal, shape)
 
     if kwds.get('plot', False) and signal:
         task = Task({'metainfo': info['meta']})
         task.meta = info['meta']
         task.data = {signal: data[signal]}
         task.index = len(data[signal]) + 1
         plot(task)
 
     return {'data': data, 'meta': info['meta']}
 
 
 def update_remote_wheel(filenames: list[str], host: str = '127.0.0.1'):
-    """更新远端设备的库并打印更新信息(失败或成功)
+    """update the package on remote device
 
     Args:
-        filenames (list[str]): 本地库文件名
-        host (str, optional): 远端设备ip地址. Defaults to '127.0.0.1'.
+        filenames (list[str]): packages (downloaded from PyPI) location
+        host (str, optional): IP address of remote device. Defaults to '127.0.0.1'.
     """
     wheel = {}
     for filename in filenames:
         with open(filename, 'rb') as f:
             wheel[filename] = f.read()
     rs = connect('QuarkRemote', host=host, port=2087)
     print(rs.install(wheel))
 
 
 def plot(task: Task, append: bool = False):
-    """实时画图
+    """real time display of the result
 
     Args:
-        append (bool, optional): 绘图方法, 首次画图(False)或增量数据画图(True).
-
-    Note: 
-        子图数量不宜太多(建议最大6*6), 单条曲线数据点亦不宜过多(建议不超过5000)
+        append (bool, optional): append new data to the canvas if True
 
-    Tip: 使用说明
-        - 输入的数据为[[dict]]结构, 即二维的list, 其中每个元素均为dict
-        - 外层list表示每行子图数
-        - 内层list表示每列子图数
-        - 每个dict存储子图数据, 可为一维(可以多条曲线)或二维
-        - 每条曲线或二维图的属性(颜色/线宽等)与matplotlib中名称一致(大多情况下)
+    Note: for better performance
+        - subplot number should not be too large(6*6 at maximum) 
+        - data points should not be too many(5000 at maxmum)
+
+    Tip: data structure of plot
+        - [[dict]], namely a 2D list whose element is a dict
+        - length of the outter list is the row number of the subplot
+        - length of the inner list is the column number of the subplot
+        - each element(the dict) stores the data, 1D(multiple curves is allowed) or 2D
+        - the attributes of the lines or image(line color/width and so on) is the same as those in matplotlib **in most cases**
     """
     if 'population' in str(task.meta['other']['signal']):
         signal = 'population'
     else:
         signal = str(task.meta['other']['signal']).split('.')[-1]
     raw = np.asarray(task.data[signal][task.last:task.index])
 
     if signal == 'iq':
-        state = {0: 'b', 1: 'r', 2: 'g'}  # 012态颜色
+        state = {0: 'b', 1: 'r', 2: 'g'}  # color for state 0,1,2
         label = []
         xlabel, ylabel = 'real', 'imag'
         append = False
     else:
         raw = np.abs(raw)
 
         axis = task.meta['axis']
@@ -294,49 +247,49 @@
             if not hasattr(task, 'xdata'):
                 task.xdata = np.asarray(list(axis[xlabel].values())).T
                 task.ydata = np.asarray(list(axis[ylabel].values())).T
             # ydata = axis[ylabel][ylabel]
             xdata = task.xdata
             ydata = task.ydata
             zdata = raw
-        if len(label) > 3:  # 画图最多二维
+        if len(label) > 3:  # 2D image at maximum
             return
 
     uname = f'{task.name}_{xlabel}'
     if task.last == 0:
         if uname not in task.counter or len(label) == 2 or signal == 'iq':
-            _vs.clear()  # 清空画板
-            task.counter.clear()  # 清空任务历史
+            _vs.clear()  # clear the canvas
+            task.counter.clear()  # clear the task history
         else:
             task.counter[uname] += 1
         _vs.info(task.task)
 
-    col = task.column
+    col = task.column if hasattr(task, 'column') else 4
     div, mod = divmod(raw.shape[-1], col)
     row = div if mod == 0 else div+1
-    time.sleep(0.1)  # 防止刷新过快导致卡顿
+    time.sleep(0.1)  # reduce the frame rate per second for better performance
     try:
-        data = []  # 外层list
+        data = []  # outter list
         for r in range(row):
-            rd = []  # 内层list
+            rd = []  # inner list
             for c in range(col):
                 idx = r*col+c
 
                 try:
                     _name = task.app.name.split('.')[-1]
                     rid = task.app.record_id
                     _title = f'{_name}_{rid}_{task.title[idx][1]}'
                 except Exception as e:
                     _title = f'{r}_{c}'
 
                 # >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
-                cell = {}  # 子图数据
+                cell = {}  # one of the subplot
                 line = {}
 
-                if signal == 'iq':  # 散点图
+                if signal == 'iq':  # scatter plot
                     try:
                         for i, iq in enumerate(raw[..., idx]):
                             si = i + task.last
                             cell[si] = {'xdata': iq.real.squeeze(),
                                         'ydata': iq.imag.squeeze(),
                                         'xlabel': xlabel,
                                         'ylabel': ylabel,
@@ -344,49 +297,50 @@
                                         'linestyle': 'none',
                                         'marker': 'o',
                                         'markersize': 5,
                                         'markercolor': state[si]}
                     except Exception as e:
                         continue
 
-                if len(label) == 1:  # 一维图
+                if len(label) == 1:  # 1D curve
                     try:
                         line['xdata'] = xdata[..., idx].squeeze()
                         line['ydata'] = ydata[..., idx].squeeze()
                         if task.last == 0:
-                            line['linecolor'] = 'r'  # 线条颜色
-                            line['linewidth'] = 2  # 线条宽度
+                            line['linecolor'] = 'r'  # line color
+                            line['linewidth'] = 2  # line width
                             line['fadecolor'] = (int('5b', 16), int(
-                                'b5', 16), int('f7', 16))  # RGB渐变色, 16进制转10进制
+                                'b5', 16), int('f7', 16))  # RGB color, hex to decimal
                     except Exception as e:
                         continue
 
-                if len(label) == 2:  # 二维图
+                if len(label) == 2:  # 2D image
                     try:
                         if task.last == 0:
                             line['xdata'] = xdata[..., idx]
                             line['ydata'] = ydata[..., idx]
-                            line['colormap'] = 'RdBu'  # 二维图配色, 见matplotlib
+                            # colormap of the image, see matplotlib
+                            line['colormap'] = 'RdBu'
                         line['zdata'] = zdata[..., idx]
                     except Exception as e:
                         continue
 
                 if task.last == 0:
                     line['title'] = _title
                     line['xlabel'] = xlabel
                     line['ylabel'] = ylabel
                 cell[f'{uname}{task.counter[uname]}'] = line
                 # <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
 
                 rd.append(cell)
             data.append(rd)
         if not append:
-            _vs.plot(data)  # 直接画图
+            _vs.plot(data)  # create a new canvas
         else:
-            _vs.append(data)  # 增量数据画图
+            _vs.append(data)  # append new data to the canvas
     except Exception as e:
         logger.error(f'Failed to update viewer: {e}')
 
 
 def network():
     nodes = {}
     for i in range(5):
@@ -398,15 +352,15 @@
     edges = {(i, i+1): (255, 0, 255, 180, 21) for i in range(24)}
 
     _vs.graph(dict(nodes=nodes, edges=edges))
 
 
 # >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
 def plotdemo():
-    """实时画图demo
+    """demo for plot
 
     Example: iq scatter
         ``` {.py3 linenums="1"}
         _vs.clear()
         iq = np.random.randn(1024)+np.random.randn(1024)*1j
         _vs.plot([[
                 {'i':{'xdata':iq.real-3,'ydata':iq.imag,'linestyle':'none','marker':'o','markersize':15,'markercolor':'b'},
@@ -423,19 +377,19 @@
         vals = np.hstack([np.random.normal(size=500), np.random.normal(size=260, loc=4)])
         # compute standard histogram, len(y)+1 = len(x)
         y,x = np.histogram(vals, bins=np.linspace(-3, 8, 40))
         data = [[{'hist':{'xdata':x,'ydata':y,'step':'center','fillvalue':0,'fillcolor':'g','linewidth':0}}]]
         _vs.plot(data)
         ```
     """
-    row = 3  # 每行子图数
-    col = 3  # 每列子图数
-    # _vs.clear() # 清空画布
-    for i in range(10):  # 步数
-        time.sleep(.2)  # 防止刷新过快导致卡顿
+    row = 3  # row number
+    col = 3  # column number
+    # _vs.clear() # clear canvas
+    for i in range(10):  # step number
+        time.sleep(.2)
         try:
             data = []
             for r in range(row):
                 rd = []
                 for c in range(col):
                     cell = {}
                     for j in range(1):
```

## quark/app/_data.py

```diff
@@ -1,81 +1,102 @@
-
-import sqlite3
-from pathlib import Path
-
-import h5py
-import numpy as np
-from loguru import logger
-from quark import loads
-
-from quark.proxy import QUARK, startup
-
-sql = sqlite3.connect(QUARK/'checkpoint.db', check_same_thread=False)
-
-
-def get_dataset_by_tid(tid: int, signal: str, shape: tuple | list = []):
-    filename, dataset = get_record_by_tid(tid)[7:9]
-
-    info, data = {}, {}
-    with h5py.File(filename) as f:
-        group = f[dataset]
-        info = loads(dict(group.attrs).get('snapshot', '{}'))
-        if not shape:
-            if not info:
-                shape = -1
-                info['meta'] = {}
-            else:
-                shape = []
-                for k, v in info['meta']['axis'].items():
-                    shape.extend(tuple(v.values())[0].shape)
-
-        for k in group.keys():
-            if k != signal or not signal:
-                continue
-            ds = group[f'{k}']
-            if shape == -1:
-                data[k] = ds[:]
-                continue
-            data[k] = np.full((*shape, *ds.shape[1:]), 0, ds.dtype)
-            data[k][np.unravel_index(np.arange(ds.shape[0]), shape)] = ds[:]
-    return info, data
-
-
-def get_config_by_tid(tid: int = 0):
-    try:
-        import git
-
-        srv = startup['quarkserver']
-        ckpt = '/'.join([srv['home'], 'cfg', srv['checkpoint']])
-        file = Path(ckpt).with_suffix('.json')
-
-        repo = git.Repo(file.resolve().parent)
-        if not tid:
-            tree = repo.head.commit.tree
-        else:
-            tree = repo.commit(get_record_by_tid(tid)[-1]).tree
-        config: dict = loads(tree[file.name].data_stream.read().decode())
-        return config
-    except Exception as e:
-        logger.error(f'Failed to get config: {e}')
-        return {}
-
-
-def get_record_by_tid(tid: int, table: str = 'task'):
-    try:
-        return sql.execute(f'select * from {table} where tid="{tid}"').fetchall()[0]
-    except Exception as e:
-        logger.error(f'Record not found: {e}!')
-
-
-def get_record_list_by_name(task: str, start: str, stop: str, table: str = 'task'):
-    try:
-        return sql.execute(f'select * from {table} where name like "%{task}%" and created between "{start}" and "{stop}" limit 100').fetchall()
-    except Exception as e:
-        logger.error(f'Records not found: {e}!')
-
-
-def get_record_set_by_name():
-    try:
-        return sql.execute('select distinct task.name from task').fetchall()
-    except Exception as e:
-        logger.error(f'Records not found: {e}!')
+# MIT License
+
+# Copyright (c) 2021 YL Feng
+
+# Permission is hereby granted, free of charge, to any person obtaining a copy
+# of this software and associated documentation files (the "Software"), to deal
+# in the Software without restriction, including without limitation the rights
+# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+# copies of the Software, and to permit persons to whom the Software is
+# furnished to do so, subject to the following conditions:
+
+# The above copyright notice and this permission notice shall be included in
+# all copies or substantial portions of the Software.
+
+# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+
+import sqlite3
+from pathlib import Path
+
+import h5py
+import numpy as np
+from loguru import logger
+from quark import loads
+
+from quark.proxy import QUARK, startup
+
+sql = sqlite3.connect(QUARK/'checkpoint.db', check_same_thread=False)
+
+
+def get_dataset_by_tid(tid: int, signal: str, shape: tuple | list = []):
+    filename, dataset = get_record_by_tid(tid)[7:9]
+
+    info, data = {}, {}
+    with h5py.File(filename) as f:
+        group = f[dataset]
+        info = loads(dict(group.attrs).get('snapshot', '{}'))
+        if not shape:
+            if not info:
+                shape = -1
+                info['meta'] = {}
+            else:
+                shape = []
+                for k, v in info['meta']['axis'].items():
+                    shape.extend(tuple(v.values())[0].shape)
+
+        for k in group.keys():
+            if k != signal or not signal:
+                continue
+            ds = group[f'{k}']
+            if shape == -1:
+                data[k] = ds[:]
+                continue
+            data[k] = np.full((*shape, *ds.shape[1:]), 0, ds.dtype)
+            data[k][np.unravel_index(np.arange(ds.shape[0]), shape)] = ds[:]
+    return info, data
+
+
+def get_config_by_tid(tid: int = 0):
+    try:
+        import git
+
+        srv = startup['quarkserver']
+        ckpt = '/'.join([srv['home'], 'cfg', srv['checkpoint']])
+        file = Path(ckpt).with_suffix('.json')
+
+        repo = git.Repo(file.resolve().parent)
+        if not tid:
+            tree = repo.head.commit.tree
+        else:
+            tree = repo.commit(get_record_by_tid(tid)[-1]).tree
+        config: dict = loads(tree[file.name].data_stream.read().decode())
+        return config
+    except Exception as e:
+        logger.error(f'Failed to get config: {e}')
+        return {}
+
+
+def get_record_by_tid(tid: int, table: str = 'task'):
+    try:
+        return sql.execute(f'select * from {table} where tid="{tid}"').fetchall()[0]
+    except Exception as e:
+        logger.error(f'Record not found: {e}!')
+
+
+def get_record_list_by_name(task: str, start: str, stop: str, table: str = 'task'):
+    try:
+        return sql.execute(f'select * from {table} where name like "%{task}%" and created between "{start}" and "{stop}" limit 100').fetchall()
+    except Exception as e:
+        logger.error(f'Records not found: {e}!')
+
+
+def get_record_set_by_name():
+    try:
+        return sql.execute('select distinct task.name from task').fetchall()
+    except Exception as e:
+        logger.error(f'Records not found: {e}!')
```

## quark/app/_demo.py

```diff
@@ -1,7 +1,29 @@
+# MIT License
+
+# Copyright (c) 2021 YL Feng
+
+# Permission is hereby granted, free of charge, to any person obtaining a copy
+# of this software and associated documentation files (the "Software"), to deal
+# in the Software without restriction, including without limitation the rights
+# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+# copies of the Software, and to permit persons to whom the Software is
+# furnished to do so, subject to the following conditions:
+
+# The above copyright notice and this permission notice shall be included in
+# all copies or substantial portions of the Software.
+
+# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+
 """任务demo, 详见submit函数说明"""
 
 import numpy as np
 from qos_tools.experiment.libs.tools import generate_spanlist
 
 from quark.app import _s
```

## quark/app/_task.py

```diff
@@ -1,7 +1,29 @@
+# MIT License
+
+# Copyright (c) 2021 YL Feng
+
+# Permission is hereby granted, free of charge, to any person obtaining a copy
+# of this software and associated documentation files (the "Software"), to deal
+# in the Software without restriction, including without limitation the rights
+# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+# copies of the Software, and to permit persons to whom the Software is
+# furnished to do so, subject to the following conditions:
+
+# The above copyright notice and this permission notice shall be included in
+# all copies or substantial portions of the Software.
+
+# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+
 """扩展各Scanner以用于submit
 """
 
 from abc import ABC, abstractmethod
 from pathlib import Path
 
 import dill
```

## quark/app/uapi.py

```diff
@@ -1,61 +1,69 @@
+# MIT License
+
+# Copyright (c) 2021 YL Feng
+
+# Permission is hereby granted, free of charge, to any person obtaining a copy
+# of this software and associated documentation files (the "Software"), to deal
+# in the Software without restriction, including without limitation the rights
+# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+# copies of the Software, and to permit persons to whom the Software is
+# furnished to do so, subject to the following conditions:
+
+# The above copyright notice and this permission notice shall be included in
+# all copies or substantial portions of the Software.
+
+# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+
 import random
 import time
 from datetime import datetime
 from pathlib import Path
 
 import matplotlib.image as mim
 import matplotlib.pyplot as plt
 import numpy as np
 from quark import loads
 
 from ._data import get_record_list_by_name, get_record_set_by_name
 
 
 def query(app: str = None,  start: datetime = None, stop: datetime = None, page: int = 1):
-    """从数据库查询测量记录
+    """query records from database
 
     Args:
-        app (str, optional): 类别. Defaults to None.
-        after (datetime, optional): 起始时间. Defaults to None.
-        before (datetime, optional): 终止时间. Defaults to None.
-        page (int, optional): 页码. Defaults to 1.
+        app (str, optional): task name. Defaults to None.
+        start (datetime, optional): start time. Defaults to None.
+        stop (datetime, optional): end time. Defaults to None.
+        page (int, optional): page number. Defaults to 1.
 
     Returns:
-        tuple: 表头，表内容，总页数，类别列表
+        tuple: header, table content, pages, task names
     """
     print(app, start, stop, page)
     if not app:
         return [], [], 0, [r[0] for r in get_record_set_by_name()]
     records = get_record_list_by_name(app, start.strftime(
         '%Y-%m-%d-%H-%M-%S'), stop.strftime('%Y-%m-%d-%H-%M-%S'))
     headers = ['id', 'tid', 'name', 'user', 'priority', 'system', 'status',
                'filename', 'dataset', 'created', 'finished', 'committed']
     return headers, records, len(records)//50, {}
 
 
 def update(rid: int, tags: str):
-    """更新记录标签
-
-    Args:
-        rid (int): 记录id，为连续递增的整数
-        tags (str): 标签，以逗号分隔
-    """
     pass
 
 
 def load(rid: int):
-    """结果索引id，返回结果暂存于剪贴板。
-
-    Args:
-        rid (int): 记录id，为连续递增的整数
-
-    Returns:
-        _type_: _description_
-    """
     return f'get_data_by_id({rid})'
 
 
 # region plot
 
 def mplot(fig, data):
     ax = fig.add_subplot(1, 1, 1)
@@ -137,16 +145,14 @@
                 linestyle=random.choice(
             ['-', '.', '--', '-.', '-..', 'none']),
             linecolor=random.choice(
                     ['r', 'g', 'b', 'k', 'c', 'm', 'y', (31, 119, 180)]))
 
 
 def qplot(fig, dataset: list):
-    """Plot 1D array
-    """
     # print('ptype', dataset)
     return demo(fig)
 
     data, meta = dataset
     cfg = loads(meta)
     data = np.asarray(data)
```

### encoding

```diff
@@ -1 +1 @@
-utf-8
+us-ascii
```

## quark/driver/VirtualDevice.py

```diff
@@ -1,211 +1,210 @@
-"""定义驱动模板
-"""
-
-
-import time
-
-import numpy as np
-
-from waveforms import Waveform, WaveVStack, wave_eval
-from waveforms.math.signal import getFTMatrix, shift
-
-from .common import BaseDriver, Quantity
-
-
-def get_coef(coef_info, sampleRate):
-    start, stop = coef_info['start'], coef_info['stop']
-    numberOfPoints = int(
-        (stop - start) * sampleRate)
-    if numberOfPoints % 1024 != 0:
-        numberOfPoints = numberOfPoints + 1024 - numberOfPoints % 1024
-    t = np.arange(numberOfPoints) / sampleRate + start
-
-    fList = []
-    wList = []
-    phases = []
-
-    for kw in coef_info['wList']:
-        Delta, t0, weight, w, phase = kw['Delta'], kw['t0'], kw['weight'], kw['w'], kw['phase']
-        fList.append(Delta)
-
-        if w is not None:
-            w = np.zeros(numberOfPoints, dtype=complex)
-            w[:len(w)] = w
-            w = shift(w, t0 - start)
-            phases.append(np.mod(phase + 2 * np.pi * Delta * start, 2*np.pi))
-        else:
-            weight = weight
-            if isinstance(weight, np.ndarray):
-                pass
-            else:
-                if isinstance(weight, str):
-                    fun = wave_eval(weight) >> t0
-                elif isinstance(weight, Waveform):
-                    fun = weight >> t0
-                else:
-                    raise TypeError(f'Unsupported type {weight}')
-                weight = fun(t)
-            phase += 2 * np.pi * Delta * start
-            w = getFTMatrix([Delta],
-                            numberOfPoints,
-                            phaseList=[phase],
-                            weight=weight,
-                            sampleRate=sampleRate)[:, 0]
-            phases.append(np.mod(phase, 2*np.pi))
-        wList.append(w)
-    return np.asarray(wList), fList, numberOfPoints, phases
-
-
-# class Quantity(object):
-#     def __init__(self, name: str, value=None, ch: int = None, unit: str = ''):
-#         self.name = name
-#         self.default = dict(value=value, ch=ch, unit=unit)
-
-
-def tolist(wv: WaveVStack) -> list:
-    ret = [wv.start, wv.stop, wv.sample_rate, len(wv.wlist)]
-    for w in wv.wlist:
-        ret.extend(w.tolist())
-    return ret
-
-
-def fromlist(wl: list) -> WaveVStack:
-    wv, wpos = WaveVStack([]), 4
-    wv.start, wv.stop, wv.sample_rate, n = wl[:wpos]
-    for _ in range(n):
-        wav, pos = Waveform.fromlist(wl[wpos:], True)
-        wv.wlist.append(wav)
-        wpos += pos
-    return wv
-
-
-class Driver(BaseDriver):
-    """设备驱动模板，类名统一为Driver，文件名为设备名称，如VirtualDevice.
-
-    Warning:
-        所有的驱动均继承自基类，必须实现open/close/read/write四个接口
-    """
-    segment = ('na', '101|102|103')
-    # 设备可用通道数量
-    CHs = list(range(36))
-
-    # 设备常见读写属性，可自行增加，对应在read/write中实现不同的方法即可
-    # 属性名中的单词均以大写开头，缩写全为大写，用于说明有哪些可读写设置
-    # 应给每个属性加上注释，方便了解设置的作用
-    quants = [
-        # 微波源(MW)
-        Quantity('Frequency', value=0, ch=1, unit='Hz'),  # 频率，float
-        Quantity('Power', value=0, ch=1, unit='dBm'),  # 功率，float
-        Quantity('Output', value='OFF', ch=1),  # 输出开关，str
-
-        # 任意波形发生器(AWG)
-        Quantity('Amplitude', value=0, ch=1, unit='Vpp'),  # 振幅，float
-        Quantity('Offset', value=0, ch=1, unit='V'),  # 偏置，float
-        Quantity('Waveform', value=np.array([]), ch=1),  # 波形，np.array
-        Quantity('Marker1', value=[], ch=1),  # Marker1，np.array
-        Quantity('Marker2', value=[], ch=1),  # Marker2，np.array
-
-        # 数据采集(ADC)
-        Quantity('PointNumber', value=1024, ch=1, unit='point'),  # 采样点数，int
-        Quantity('TriggerDelay', value=0, ch=1, unit='s'),  # 采样延迟，float
-        Quantity('Shot', value=512, ch=1),  # 采样次数，int
-        Quantity('TraceIQ', value=np.array([]), ch=1),  # 时域采样，np.array
-        Quantity('Trace', value=np.array([]), ch=1),  # 时域采样，np.array
-        Quantity('IQ', value=np.array([]), ch=1),  # 解调后数据，np.array
-        Quantity('Coefficient', value=np.array([]), ch=1),  # 解调所需系数，np.array
-        Quantity('StartCapture', value=1, ch=1,),  # 开始采集，value随机，通知采集卡准备就绪
-        # 采集模式，str，raw->TraceIQ, alg-> IQ
-        Quantity('CaptureMode', value='raw', ch=1),
-
-        # test
-        Quantity('Classify', value=0, ch=1),
-        Quantity('Counts', value=[], ch=1),
-
-        # 触发(TRIG)
-        Quantity('TRIG'),
-        Quantity('TriggerMode'),  # burst or continuous
-        Quantity('Wait', value=0, ch=1),  # wait
-    ]
-
-    def __init__(self, addr: str = '', timeout: float = 3.0, **kw):
-        """
-
-        Args:
-            addr (str, optional): 设备地址. Defaults to ''.
-            timeout (float, optional): 设备执行超时时间. Defaults to 3.0.
-        """
-
-        super().__init__(addr=addr, timeout=timeout, **kw)
-        self.model = 'VirtualDevice'  # 默认为设备名字
-        self.timeout = 1.0
-        self.srate = 1e9  # 设备采样率
-
-    def open(self, **kw):
-        """打开并初始化仪器设置，获取仪器操作句柄，必须实现，可以为空(pass)但不能没有
-        """
-        self.handle = 'DeviceHandler'
-        # test = 1/0
-
-    def close(self, **kw):
-        """关闭仪器，必须实现，可以为空(pass)但不能没有
-        """
-        self.handle.close()
-
-    def write(self, name: str, value, **kw):
-        """设置仪器，额外的参数(如通道指定)可通过kw传入。必须实现，如
-
-        if name == '属性名':
-            执行操作
-        elif name == '属性名':
-            执行操作
-        """
-        if name == 'Wait':
-            time.sleep(value)
-        elif name == 'Waveform':
-            if isinstance(value, list):
-                t0 = time.time()
-                wf = fromlist(value)
-                t1 = time.time()
-                wf.sample()
-            if isinstance(value, Waveform):
-                t0 = time.time()
-                value.sample()
-            # 如，self.set_offset(value, ch=1)
-        elif name == 'Shot':
-            pass
-        elif name == 'Coefficient':
-            data, f_list, numberOfPoints, phase = get_coef(value, self.srate)
-            # coef_data = np.moveaxis([data.real,data.imag],0,-2)
-            self.setValue('PointNumber', numberOfPoints, **kw)
-            # self.update('Coefficient', data, channel=ch)
-            return data
-            # 如，self.set_shot(value, ch=2)
-        return value
-
-    def read(self, name: str, **kw):
-        """读取仪器，额外的参数(如通道指定)可通过kw传入。必须实现，如
-
-        if name == '属性名':
-            return 执行操作
-        elif name == '属性名':
-            return 执行操作
-        """
-        if name == 'TraceIQ':
-            shot = self.getValue('Shot', **kw)
-            point = self.getValue('PointNumber', **kw)
-            # test = 1/0
-            return np.ones((shot, point)), np.ones((shot, point))
-        elif name == 'IQ':
-            shot = self.getValue('Shot', **kw)
-            fnum = self.getValue('Coefficient', **kw).shape[0]
-            # time.sleep(0.1)
-            si = np.random.randint(20)+np.random.randn(shot, fnum)
-            sq = np.random.randint(20)+np.random.randn(shot, fnum)
-            return si, sq
-
-    # *#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*# user defined #*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#
-    def get_iq(self):
-        pass
-
-    def get_trace(self):
-        pass
+# MIT License
+
+# Copyright (c) 2021 YL Feng
+
+# Permission is hereby granted, free of charge, to any person obtaining a copy
+# of this software and associated documentation files (the "Software"), to deal
+# in the Software without restriction, including without limitation the rights
+# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+# copies of the Software, and to permit persons to whom the Software is
+# furnished to do so, subject to the following conditions:
+
+# The above copyright notice and this permission notice shall be included in
+# all copies or substantial portions of the Software.
+
+# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+
+
+import time
+
+import numpy as np
+
+from waveforms import Waveform, WaveVStack, wave_eval
+from waveforms.math.signal import getFTMatrix, shift
+
+from .common import BaseDriver, Quantity
+
+
+def get_coef(coef_info, sampleRate):
+    start, stop = coef_info['start'], coef_info['stop']
+    numberOfPoints = int(
+        (stop - start) * sampleRate)
+    if numberOfPoints % 1024 != 0:
+        numberOfPoints = numberOfPoints + 1024 - numberOfPoints % 1024
+    t = np.arange(numberOfPoints) / sampleRate + start
+
+    fList = []
+    wList = []
+    phases = []
+
+    for kw in coef_info['wList']:
+        Delta, t0, weight, w, phase = kw['Delta'], kw['t0'], kw['weight'], kw['w'], kw['phase']
+        fList.append(Delta)
+
+        if w is not None:
+            w = np.zeros(numberOfPoints, dtype=complex)
+            w[:len(w)] = w
+            w = shift(w, t0 - start)
+            phases.append(np.mod(phase + 2 * np.pi * Delta * start, 2*np.pi))
+        else:
+            weight = weight
+            if isinstance(weight, np.ndarray):
+                pass
+            else:
+                if isinstance(weight, str):
+                    fun = wave_eval(weight) >> t0
+                elif isinstance(weight, Waveform):
+                    fun = weight >> t0
+                else:
+                    raise TypeError(f'Unsupported type {weight}')
+                weight = fun(t)
+            phase += 2 * np.pi * Delta * start
+            w = getFTMatrix([Delta],
+                            numberOfPoints,
+                            phaseList=[phase],
+                            weight=weight,
+                            sampleRate=sampleRate)[:, 0]
+            phases.append(np.mod(phase, 2*np.pi))
+        wList.append(w)
+    return np.asarray(wList), fList, numberOfPoints, phases
+
+
+# class Quantity(object):
+#     def __init__(self, name: str, value=None, ch: int = None, unit: str = ''):
+#         self.name = name
+#         self.default = dict(value=value, ch=ch, unit=unit)
+
+
+def tolist(wv: WaveVStack) -> list:
+    ret = [wv.start, wv.stop, wv.sample_rate, len(wv.wlist)]
+    for w in wv.wlist:
+        ret.extend(w.tolist())
+    return ret
+
+
+def fromlist(wl: list) -> WaveVStack:
+    wv, wpos = WaveVStack([]), 4
+    wv.start, wv.stop, wv.sample_rate, n = wl[:wpos]
+    for _ in range(n):
+        wav, pos = Waveform.fromlist(wl[wpos:], True)
+        wv.wlist.append(wav)
+        wpos += pos
+    return wv
+
+
+class Driver(BaseDriver):
+    """driver template
+
+    Warning:
+        All drivers must inherit from the base class(with fixed class name ***Driver***) and methods open/close/read/write must be implemented!
+    """
+    segment = ('na', '101|102|103')
+    # number of available channels
+    CHs = list(range(36))
+
+    quants = [
+        # Microwave source(MW)
+        Quantity('Frequency', value=0, ch=1, unit='Hz'),  # float
+        Quantity('Power', value=0, ch=1, unit='dBm'),  # loat
+        Quantity('Output', value='OFF', ch=1),  # str
+
+        # 任意波形发生器(AWG)
+        Quantity('Amplitude', value=0, ch=1, unit='Vpp'),  # float
+        Quantity('Offset', value=0, ch=1, unit='V'),  # float
+        Quantity('Waveform', value=np.array([]), ch=1),  # np.array or Waveform
+        Quantity('Marker1', value=[], ch=1),  # Marker1，np.array
+        Quantity('Marker2', value=[], ch=1),  # Marker2，np.array
+
+        # Data Acquisition(ADC)
+        Quantity('PointNumber', value=1024, ch=1, unit='point'),  # int
+        Quantity('TriggerDelay', value=0, ch=1, unit='s'),  # float
+        Quantity('Shot', value=512, ch=1),  # int
+        Quantity('TraceIQ', value=np.array([]), ch=1),  # np.array
+        Quantity('Trace', value=np.array([]), ch=1),  # np.array
+        Quantity('IQ', value=np.array([]), ch=1),  # np.array
+        Quantity('Coefficient', value=np.array([]), ch=1),  # np.array
+        Quantity('StartCapture', value=1, ch=1,),  # int
+        
+        Quantity('CaptureMode', value='raw', ch=1), # raw->TraceIQ, alg-> IQ
+
+        # test
+        Quantity('Classify', value=0, ch=1),
+        Quantity('Counts', value=[], ch=1),
+
+        # Trigger(TRIG)
+        Quantity('TRIG'),
+        Quantity('TriggerMode'),  # burst or continuous
+        Quantity('Wait', value=0, ch=1),  # wait
+    ]
+
+    def __init__(self, addr: str = '', timeout: float = 3.0, **kw):
+        super().__init__(addr=addr, timeout=timeout, **kw)
+        self.model = 'VirtualDevice'  # device model
+        self.timeout = 1.0
+        self.srate = 1e9  # sampling rate
+
+    def open(self, **kw):
+        """open device
+        """
+        self.handle = 'DeviceHandler'
+        # test = 1/0
+
+    def close(self, **kw):
+        """close device
+        """
+        self.handle.close()
+
+    def write(self, name: str, value, **kw):
+        """write to device
+        """
+        if name == 'Wait':
+            time.sleep(value)
+        elif name == 'Waveform':
+            if isinstance(value, list):
+                t0 = time.time()
+                wf = fromlist(value)
+                t1 = time.time()
+                wf.sample()
+            if isinstance(value, Waveform):
+                t0 = time.time()
+                value.sample()
+            # 如，self.set_offset(value, ch=1)
+        elif name == 'Shot':
+            pass
+        elif name == 'Coefficient':
+            data, f_list, numberOfPoints, phase = get_coef(value, self.srate)
+            # coef_data = np.moveaxis([data.real,data.imag],0,-2)
+            self.setValue('PointNumber', numberOfPoints, **kw)
+            # self.update('Coefficient', data, channel=ch)
+            return data
+            # 如，self.set_shot(value, ch=2)
+        return value
+
+    def read(self, name: str, **kw):
+        """read from device
+        """
+        if name == 'TraceIQ':
+            shot = self.getValue('Shot', **kw)
+            point = self.getValue('PointNumber', **kw)
+            # test = 1/0
+            return np.ones((shot, point)), np.ones((shot, point))
+        elif name == 'IQ':
+            shot = self.getValue('Shot', **kw)
+            fnum = self.getValue('Coefficient', **kw).shape[0]
+            # time.sleep(0.1)
+            si = np.random.randint(20)+np.random.randn(shot, fnum)
+            sq = np.random.randint(20)+np.random.randn(shot, fnum)
+            return si, sq
+
+    # *#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*# user defined #*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#
+    def get_iq(self):
+        pass
+
+    def get_trace(self):
+        pass
```

## quark/driver/__init__.py

```diff
@@ -1,10 +1,32 @@
-"""!!! note "模块说明"
-- 所有驱动继承自BaseDriver，类名统一为Driver，并要求实现open/close/read/write四个方法。样板见VirtualDevice
-- 所有厂家提供的底层库，均放于driver/common内，各自新建文件夹分别放置
+# MIT License
+
+# Copyright (c) 2021 YL Feng
+
+# Permission is hereby granted, free of charge, to any person obtaining a copy
+# of this software and associated documentation files (the "Software"), to deal
+# in the Software without restriction, including without limitation the rights
+# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+# copies of the Software, and to permit persons to whom the Software is
+# furnished to do so, subject to the following conditions:
+
+# The above copyright notice and this permission notice shall be included in
+# all copies or substantial portions of the Software.
+
+# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+
+"""
+Abstract: about driver
+    - all drivers should be placed in systemq/dev
 """
 
 
 try:
     # import URL from dev in systemq
     from dev import URL
 except Exception as e:
```

### encoding

```diff
@@ -1 +1 @@
-utf-8
+us-ascii
```

## quark/driver/common/__init__.py

```diff
@@ -1,4 +1,32 @@
-from .basedriver import BaseDriver
-from .quantity import (QBool, QInteger, QList, QOption, QReal, QString,
-                       Quantity, QVector, newcfg)
-from .visadriver import IEEE_488_2_BinBlock, VisaDriver
+# MIT License
+
+# Copyright (c) 2021 YL Feng
+
+# Permission is hereby granted, free of charge, to any person obtaining a copy
+# of this software and associated documentation files (the "Software"), to deal
+# in the Software without restriction, including without limitation the rights
+# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+# copies of the Software, and to permit persons to whom the Software is
+# furnished to do so, subject to the following conditions:
+
+# The above copyright notice and this permission notice shall be included in
+# all copies or substantial portions of the Software.
+
+# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+
+"""
+Abstract: about common
+    - define the base driver and quantity
+"""
+
+
+from .basedriver import BaseDriver
+from .quantity import (QBool, QInteger, QList, QOption, QReal, QString,
+                       Quantity, QVector, newcfg)
+from .visadriver import IEEE_488_2_BinBlock, VisaDriver
```

## quark/driver/common/basedriver.py

```diff
@@ -1,37 +1,59 @@
+# MIT License
+
+# Copyright (c) 2021 YL Feng
+
+# Permission is hereby granted, free of charge, to any person obtaining a copy
+# of this software and associated documentation files (the "Software"), to deal
+# in the Software without restriction, including without limitation the rights
+# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+# copies of the Software, and to permit persons to whom the Software is
+# furnished to do so, subject to the following conditions:
+
+# The above copyright notice and this permission notice shall be included in
+# all copies or substantial portions of the Software.
+
+# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+
 import re
 from abc import ABC, abstractmethod
 from copy import deepcopy
 from typing import Any
 
 from .. import URL
 from .quantity import newcfg
 
 PATTERN = r'^192\.168\.({seg})\.((2(5[0-5]|[0-4]\d))|[0-1]?\d{{1,2}})'
 
 
 class BaseDriver(ABC):
-    """设备驱动基类，所有设备驱动均需继承此基类，类名统一为Driver，并要求实现open/close/read/write四个方法。
+    """Base class for all drivers and methods open/close/read/write are required.
 
-    模板见VirtualDevice
+    See template **VirtualDevice**
     """
     # 设备网段,(设备种类缩写，指定ip段)
     segment = ('na', '103|104')
 
     # 设备通道数量
     CHs = [1]
 
     # 设备读写属性列表
     quants = []
 
     def __init__(self, addr: str = '192.168.1.42', **kw):
-        """初始化设备
+        """initialization of the driver
 
         Args:
-            addr (str, optional): 设备地址. Defaults to '192.168.1.42'.
+            addr (str, optional): ip address of the device. Defaults to '192.168.1.42'.
         """
         self.addr = addr
         self.port = kw.get('port', 0)  # for remote device
         self.timeout = kw.get('timeout', 3.0)
         self.model = kw.get('model', 'None')
         self.srate = kw.get('srate', -1)
 
@@ -83,57 +105,53 @@
         for ch in self.CHs:
             conn[f'CH{ch}'] = channel
         conn['CHglobal'] = chx
         return conn
 
     @abstractmethod
     def open(self, **kw):
-        """设备打开时的操作，必须由子类实现
+        """how device is opened
         """
         pass
 
     @abstractmethod
     def close(self, **kw):
-        """设备关闭时的操作，必须由子类实现
+        """how device is closed
         """
         pass
 
     @abstractmethod
     def write(self, name: str, value, **kw):
-        """设备写操作，必须由子类实现
+        """write a command(specified by name and value) to the device
         """
         pass
 
     @abstractmethod
     def read(self, name: str, **kw):
-        """设备读操作，必须由子类实现
+        """read a value(specified by name) from the device
         """
         pass
 
     def check(self, name: str, channel: int):
         assert name in self.quantities, f'{self}: quantity({name}) not Found!'
         assert channel in self.CHs or channel == 'global', f"{self}: channel({channel}) not found!"
 
     def update(self, name: str, value: Any, channel: int = 1):
         self.config[name][channel]['value'] = value
 
     def setValue(self, name: str, value: Any, **kw):
-        """Deprecation Warning: will be removed in the future!
-        """
         channel = kw.get('ch', 1)
         self.check(name, channel)
         opc = self.write(name, value, **kw)
         self.update(name, opc, channel)
         if kw.get('sid', 0) in kw.get('track', [0]):
             return opc
         # return opc
 
     def getValue(self, name: str, **kw):
-        """Deprecation Warning: will be removed in the future!
-        """
         if name == 'quantity':
             return self.dict_from_quantity()
         elif hasattr(self, name):
             return getattr(self, name)
 
         channel = kw.get('ch', 1)
         self.check(name, channel)
```

## quark/driver/common/quantity.py

```diff
@@ -1,13 +1,37 @@
+# MIT License
+
+# Copyright (c) 2021 YL Feng
+
+# Permission is hereby granted, free of charge, to any person obtaining a copy
+# of this software and associated documentation files (the "Software"), to deal
+# in the Software without restriction, including without limitation the rights
+# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+# copies of the Software, and to permit persons to whom the Software is
+# furnished to do so, subject to the following conditions:
+
+# The above copyright notice and this permission notice shall be included in
+# all copies or substantial portions of the Software.
+
+# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+
 from copy import deepcopy
 
 import numpy as np
 
 
 class Quantity(object):
+    """Quantity is used to describe the attributes of a driver
+    """
 
     def __init__(self, name: str, value=None, ch: int = 0, unit: str = ''):
         self.name = name
         self.isglobal, _ch = (True, 'global') if not ch else (False, ch)
         self.default = dict(value=value, unit=unit, ch=_ch)
 
     def __repr__(self):
```

## quark/driver/common/visadriver.py

```diff
@@ -1,19 +1,40 @@
+# MIT License
+
+# Copyright (c) 2021 YL Feng
+
+# Permission is hereby granted, free of charge, to any person obtaining a copy
+# of this software and associated documentation files (the "Software"), to deal
+# in the Software without restriction, including without limitation the rights
+# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+# copies of the Software, and to permit persons to whom the Software is
+# furnished to do so, subject to the following conditions:
+
+# The above copyright notice and this permission notice shall be included in
+# all copies or substantial portions of the Software.
+
+# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+
 import struct
 
 import numpy as np
 import pyvisa as visa
 
 from .basedriver import BaseDriver
 
 
 class VisaDriver(BaseDriver):
 
     error_command = 'SYST:ERR?'
-    """The SCPI command to query errors."""
 
     def __init__(self, addr,  **kw):
         super().__init__(addr, **kw)
         self.visa_backend = kw.get('visa_backend', '')
 
     def open(self, **kw):
         self.addr_hash = hash(self.addr)
@@ -56,15 +77,14 @@
 
     def set_timeout(self, t):
         self.timeout = t
         if self.handle is not None:
             self.handle.timeout = t * 1000
 
     def errors(self):
-        """返回错误列表"""
         e = []
         if self.error_command == '':
             return e
         while True:
             s = self.handle.query(self.error_command)
             _ = s[:-1].split(',"')
             code = int(_[0])
```

## quark/envelope/__init__.py

```diff
@@ -1,18 +1,40 @@
-"""!!! note "模块说明"
-本模块为实验中可由用户实现的部分构成. 模块调用所需参数见各自模块的说明文档. 
-每个实验Step的执行依次流经以下环节(@标注, &表示相应环节所执行方法, 箭头表示执行顺序). 
+# MIT License
 
-Examples: workflow
-    >>> pipeline
+# Copyright (c) 2021 YL Feng
+
+# Permission is hereby granted, free of charge, to any person obtaining a copy
+# of this software and associated documentation files (the "Software"), to deal
+# in the Software without restriction, including without limitation the rights
+# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+# copies of the Software, and to permit persons to whom the Software is
+# furnished to do so, subject to the following conditions:
+
+# The above copyright notice and this permission notice shall be included in
+# all copies or substantial portions of the Software.
+
+# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+
+"""
+Abstract: about envelope
+    Each step of a task will be executed in a **pipeline**
+
+    ``` {.py3 linenums="1" title="pipeline"}
     --->@assembler      @calculator       @device          @processor       @router
             ↓           ↑    ↓            ↑  ↓             ↑     ↓          ↑   ↓ 
             &ccompile   ↑    &calculate -->  &read|write -->     &process -->   &postprocess --->
             ↓           ↑
             &assemble -->
+    ```
 """
 
 
 import dill
 
 from quark.proxy import dumpv, loadv
```

## quark/envelope/assembler.py

```diff
@@ -1,380 +1,399 @@
-"""### 指令生成及处理
-- 线路编绎, 并返回编绎后的结果及相关额外参数
-- 将1得到的结果进行硬件解析, 并整合所需参数, 最后送入calculator处理
-"""
-
-import os
-import time
-from typing import Any
-
-import numpy as np
-from loguru import logger
-
-from quark.proxy import dumpv
-
-from .systemq import (CompilerContext, Waveform, WaveVStack, _form_signal,
-                      get_all_channels, qcompile, square, stdlib, wave_eval)
-
-cfg = CompilerContext({})  # cfg (CompilerContext): 线路编绎所需配置
-
-
-def initialize(snapshot, **kwds):
-    """初始化编译上下文环境, 即每个线路对应的当前的cfg表. 
-    NOTE:对于每个任务, 都会冻结一个cfg快照snapshot, 任务执行时对cfg表的操作不会影响此次任务.
-
-    Args:
-        snapshot (_type_): 当前的cfg表
-
-    Returns:
-        cfg (CompilerContext): 用于编译的上下文环境
-
-    """
-    if isinstance(snapshot, int):
-        return os.getpid()
-    cfg.reset(snapshot)
-    cfg.initial = kwds.get('initial', {'restore': []})
-    cfg.bypass = kwds.get('bypass', {})
-    cfg._keys = kwds.get('keys', [])
-    return cfg
-
-
-def ccompile(sid: int, instruction: dict, circuit: list, **kwds):
-    """编绎线路, 生成可执行的指令, 包括波形生成、采集卡参数、触发设置等
-
-    Args:
-        sid (int): 任务步数
-        instruction (dict): 默认执行步骤, 与编译后的结果(即compiled)合并, 便于扩展额外指令
-        circuit (list): 用户定义的线路(@HK)
-
-    Returns:
-        tuple: 编绎后的线路, 数据处理所需参数
-
-    Example: 线路编译示例
-        ``` {.py3 linenums="1"}
-        from quark import connect
-        s = connect('QuarkServer')
-        cfg = initialize(s.snapshot())
-        circuit = [(('Measure',0),'Q0503')]
-        instruction, datamap =ccompile(0,circuit,signal='iq')
-
-        print(instruction) # before assemble
-        {'main': [('WRITE', 'Q0503.waveform.DDS', <waveforms.waveform.Waveform at 0x291381b6c80>, ''),
-                ('WRITE', 'M5.waveform.DDS', <waveforms.waveform.Waveform at 0x291381b7f40>, ''),
-                ('WRITE', 'ADx86_159.CH5.Shot', 1024, ''),
-                ('WRITE', 'ADx86_159.CH5.Coefficient', {'start': 2.4000000000000003e-08,
-                                                        'stop': 4.0299999999999995e-06,
-                                                        'wList': [{'Delta': 6932860000.0,
-                                                                    'phase': 0,
-                                                                    'weight': 'const(1)',
-                                                                    'window': (0, 1024),
-                                                                    'w': None,
-                                                                    't0': 3e-08,
-                                                                    'phi': -0.7873217091999384,
-                                                                    'threshold': 2334194991.172387}]}, ''),
-                ('WRITE', 'ADx86_159.CH5.TriggerDelay', 7e-07, ''),
-                ('WRITE', 'ADx86_159.CH5.CaptureMode', 'alg', ''),
-                ('WRITE', 'ADx86_159.CH5.StartCapture', 54328, '')],
-        'READ': [('READ', 'ADx86_159.CH5.IQ', 'READ', '')]
-        }
-
-        print(datamap)
-        {'dataMap': {'cbits': {0: ('READ.ADx86_159.CH5', 
-                                    0, 
-                                    6932860000.0, 
-                                    {'duration': 4e-06,
-                                     'amp': 0.083,
-                                     'frequency': 6932860000.0,
-                                     'phase': [[-1, 1], [-1, 1]],
-                                     'weight': 'const(1)',
-                                     'phi': -0.7873217091999384,
-                                     'threshold': 2334194991.172387,
-                                     'ring_up_amp': 0.083,
-                                     'ring_up_waist': 0.083,
-                                     'ring_up_time': 5e-07,
-                                     'w': None},
-                                    3e-08,
-                                    2.4000000000000003e-08,
-                                    4.0299999999999995e-06)
-                                },
-                    'signal': 2,
-                    'arch': 'baqis'
-                    }
-        }
-        ```
-
-    """
-    # kwds['signal'] = _form_signal(kwds.get('signal'))
-    # kwds['lib'] = kwds.get('lib', stdlib)
-
-    ctx = kwds.pop('ctx', cfg)
-    ctx.snapshot().cache = kwds.pop('cache', {})
-
-    # align_right = kwds.pop('align_right', True)
-    # waveform_length = kwds.pop('waveform_length', 98e-6)
-    if kwds.get('fillzero', False):  # 是否将所有通道初始化为zero()
-        compiled = {'main': [('WRITE', target, 'zero()', '')
-                             for target in get_all_channels(ctx)]}
-    else:
-        compiled = {}
-
-    # code = _compile(circuit, cfg=ctx, **kwds)
-
-    # if align_right:
-    #     delay = waveform_length - code.end
-
-    #     code.waveforms = {k: v >> delay for k, v in code.waveforms.items()}
-    #     code.measures = {
-    #         k:
-    #         Capture(v.qubit, v.cbit, v.time + delay, v.signal,
-    #                 v.params, v.hardware, v.shift + delay)
-    #         for k, v in code.measures.items()
-    #     }
-
-    # cmds, datamap = assembly_code(code)
-    code, (cmds, datamap) = qcompile(circuit,
-                                     lib=kwds.get('lib', stdlib),
-                                     cfg=kwds.get('cfg', ctx),
-                                     signal=_form_signal(kwds.get('signal')),
-                                     shots=kwds.get('shots', 1024),
-                                     context=kwds.get('context', {}),
-                                     arch=kwds.get('arch', 'baqis'),
-                                     align_right=kwds.get('align_right', True),
-                                     waveform_length=kwds.get('waveform_length', 98e-6))
-
-    for cmd in cmds:
-        ctype = type(cmd).__name__  # WRITE,TRIG,READ
-        if ctype == 'WRITE':
-            step = 'main'
-        else:
-            step = ctype
-        op = (ctype, cmd.address, cmd.value, 'au')
-        if step in compiled:
-            compiled[step].append(op)
-        else:
-            compiled[step] = [op]
-
-    # merge loop body with compiled result
-    for step, _cmds in compiled.items():
-        if step in instruction:
-            instruction[step].extend(_cmds)
-        else:
-            instruction[step] = _cmds
-    assemble(sid, instruction, prep=False, hold=kwds.get('hold', False))
-    if sid == 0:
-        kwds['restore'] = cfg.initial
-        kwds['clear'] = True
-    logger.info(f'Step {sid} compiled >>>>>>>>>>>>>')
-    return instruction, {'dataMap': datamap} | kwds
-
-
-def assemble(sid: int, instruction: dict[str, list[str, str, Any, str]], **kw):
-    """重组编译(ccompile)生成的指令集合(见cccompile), 并生成相应的硬件操作指令
-
-    Args:
-        sid (int): 任务步数
-        instruction (dict[str, list[str, str, Any, str]]): 编译生成的指令集合(见ccompile), 可能包括额外的操作
-
-    Raises:
-        TypeError: srate应为浮点数, 否则设置为-1.0
-    """
-
-    try:
-        query = kw.get('ctx', cfg).query
-    except AttributeError as e:
-        query = cfg.query
-
-    for step, operations in instruction.items():
-        if not isinstance(operations, list):
-            break
-        scmd = {}
-        for ctype, target, value, unit in operations:
-            kwds = {'sid': sid, 'target': target,
-                    'track': query('etc.track'),
-                    'shared': query('etc.shared'),
-                    'filter': query('etc.filter')}
-            if 'CH' in target or ctype == 'WAIT':
-                _target = target
-            else:
-                try:
-                    # 逻辑通道转为硬件通道并提取相关参数用于后续计算
-                    context = query(target.split('.', 1)[0])
-                    mapping = query('etc.mapping')
-                    _target = decode(target, context, mapping)
-                    kwds.update({"context": context})
-                except (ValueError, KeyError) as e:
-                    continue
-
-                # 获取初始值以在任务结束时恢复仪器设置
-                if sid == 0 and not kw.get('hold', False):
-                    init = query(target.removesuffix(
-                        '.I').removesuffix('.Q'))
-                    cfg.initial['restore'].append((ctype, target, init, unit))
-
-            # 从dev中获取设备相应的采样率
-            if ctype != 'WAIT':
-                dev = _target.split('.', 1)[0]
-                kwds['srate'] = query(f'dev.{dev}.srate')
-                if not kwds['srate']:
-                    logger.critical(f'Failed to get srate for {dev}!')
-            cmd = [ctype, value, unit, kwds]
-
-            # 处理多指令共用通道逻辑(如多个波形同一通道)
-            try:
-                if _target in scmd and 'waveform' in target.lower():
-                    if isinstance(scmd[_target][1], str):
-                        scmd[_target][1] = wave_eval(scmd[_target][1])
-                    if isinstance(cmd[1], str):
-                        cmd[1] = wave_eval(cmd[1])
-                    scmd[_target][1] += cmd[1]
-                else:
-                    scmd[_target] = cmd
-            except Exception as e:
-                logger.warning(f'Channel[{_target}] mutiplexing error: {e}')
-                scmd[_target] = cmd
-        instruction[step] = scmd
-
-    # 是否进行预处理
-    if kw.get('prep', True):
-        return preprocess(sid, instruction)
-
-
-# 设备通道与config表中字段的映射关系
-MAPPING = {
-    "setting_LO": "LO.Frequency",
-    "setting_POW": "LO.Power",
-    "setting_OFFSET": "ZBIAS.Offset",
-    "waveform_RF_I": "I.Waveform",
-    "waveform_RF_Q": "Q.Waveform",
-    "waveform_TRIG": "TRIG.Marker1",
-    "waveform_DDS": "DDS.Waveform",
-    "waveform_SW": "SW.Marker1",
-    "waveform_Z": "Z.Waveform",
-    "setting_PNT": "ADC.PointNumber",
-    "setting_SHOT": "ADC.Shot",
-    "setting_TRIGD": "ADC.TriggerDelay"
-}
-
-
-# 指令过滤
-SUFFIX = ('Waveform', 'Shot', 'Coefficient', 'TriggerDelay')
-
-
-def decode(target: str, context: dict, mapping: dict = MAPPING):
-    """Qubit等属性与硬件通道之间的映射转换
-
-    Args:
-        target (str): 待解析对象, 如Q0.setting.LO
-        context (dict): 对象所在cfg的字段
-        mapping (dict, optional): 通道和硬件属性的映射关系. Defaults to MAPPING.
-
-    Raises:
-        KeyError: 通道映射不存在
-        ValueError: 通道不存在
-
-    Returns:
-        str: 通道, 如AD.CH1.TraceIQ
-    """
-    try:
-        mkey = target.split('.', 1)[-1].replace('.', '_')
-        chkey, quantity = mapping[mkey].split('.', 1)
-    except KeyError as e:
-        raise KeyError(f'{e} not found in mapping!')
-
-    try:
-        channel = context.get('channel', {})[chkey]
-    except KeyError as e:
-        raise KeyError(f'{chkey} not found!')
-
-    if channel is None:
-        raise ValueError('ChannelNotFound')
-    elif not isinstance(channel, str):
-        raise TypeError(
-            f'Wrong type of channel of {target}, string needed got {channel}')
-    elif 'Marker' not in channel:
-        channel = '.'.join((channel, quantity))
-
-    return channel
-
-
-WINDOW = square(500e-3) >> 150e-3
-
-
-def equal(a, b):
-    if isinstance(a, WaveVStack) or isinstance(b, WaveVStack):
-        return False
-    if isinstance(a, Waveform) and isinstance(b, Waveform):
-        return (a*WINDOW) == (b*WINDOW)
-    try:
-        return a == b
-    except Exception as e:
-        # logger.warning(f'Failed to compare {e}')
-        return False
-
-
-def preprocess(sid: int, instruction: dict[str, dict[str, list[str, Any, str, dict]]]):
-    """预处理,包括过滤/参数查取等, 处理完毕送往calculator进行采样等计算. 
-
-    Args:
-        sid (int):任务步数
-        instruction (dict):指令集合, 形如{step: {target: [ctype, value, unit, kwds]}}
-
-    Example: instruction具体含义如下
-        - step (str): 执行步骤, 如main/step1/step2
-        - target (list): 设备通道属性, 如AWG.CH1.Waveform、AD.CH2.TraceIQ
-            - ctype (str): 操作类型, 共三种, 分别为READ/WRITE/WAIT
-            - value (Any): 待操作值, READ无值, WAIT为浮点数单位为秒, WRITE值任意, 详见driver
-            - unit (str): 指令单位, 暂无作用
-            - kwds (dict): 来自assemble, 主要包括以下内容
-                - sid (int): 任务步数
-                - track (list): 指定要保留中间执行过程详细的步数
-                - target (str): 原始指令如Q0101.waveform.Z
-                - filter (list): calculator中波形是否采样并显示到canvas
-                - srate (float): 对应设备采样率,来自dev
-                - context (dict): cfg表中字段, 如Q0101
-    """
-    if sid == 0:
-        cfg.bypass.clear()
-    bypass = cfg.bypass
-
-    shared = []
-    for step, operations in instruction.items():
-        if not isinstance(operations, dict):
-            break
-        scmd = {}
-        for target, cmd in operations.items():
-            try:
-                kwds = cmd[-1]
-                # 重复指令缓存比较, 如果与上一步相同, 则跳过执行
-                if target in bypass and target.endswith(SUFFIX) and equal(bypass[target][0], cmd[1]):
-                    continue
-                bypass[target] = (cmd[1], kwds['target'])
-
-                # context设置, 用于calculator.calculate
-                context = kwds.pop('context', {})  # 即cfg表中的Qubit、Coupler等
-                if context:
-                    kwds['LEN'] = context['waveform']['LEN']
-                    kwds['calibration'] = context['calibration']
-
-                # if isinstance(cmd[1], Waveform):
-                #     cmd[1].sample_rate = kwds['srate']
-                #     cmd[1].start = 0
-                #     cmd[1].stop = 1e-3  # kwds['LEN']
-                #     cmd[1] = cmd[1].sample()
-
-                if kwds['shared']:
-                    sm, value = dumpv(cmd[1])
-                    if sm:
-                        shared.append(sm)
-                        cmd[1] = value
-            except Exception as e:
-                logger.error(f'Failed to preprocess {target}, {e}!')
-            scmd[target] = cmd
-        instruction[step] = scmd
-
-    return shared
-
-
-# %%
-if __name__ == "__main__":
-    import doctest
-    doctest.testmod()
+# MIT License
+
+# Copyright (c) 2021 YL Feng
+
+# Permission is hereby granted, free of charge, to any person obtaining a copy
+# of this software and associated documentation files (the "Software"), to deal
+# in the Software without restriction, including without limitation the rights
+# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+# copies of the Software, and to permit persons to whom the Software is
+# furnished to do so, subject to the following conditions:
+
+# The above copyright notice and this permission notice shall be included in
+# all copies or substantial portions of the Software.
+
+# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+
+import os
+import time
+from typing import Any
+
+import numpy as np
+from loguru import logger
+
+from quark.proxy import dumpv
+
+from .systemq import (CompilerContext, Waveform, WaveVStack, _form_signal,
+                      get_all_channels, qcompile, square, stdlib, wave_eval)
+
+cfg = CompilerContext({})  # cfg (CompilerContext): 线路编绎所需配置
+
+
+def initialize(snapshot, **kwds):
+    """compiler context for current task
+
+    Note:
+        every task has its own context
+
+    Args:
+        snapshot (_type_): frozen snapshot for current task
+
+    Returns:
+        cfg (CompilerContext): CompilerContext to be used in compilation
+
+    """
+    if isinstance(snapshot, int):
+        return os.getpid()
+    cfg.reset(snapshot)
+    cfg.initial = kwds.get('initial', {'restore': []})
+    cfg.bypass = kwds.get('bypass', {})
+    cfg._keys = kwds.get('keys', [])
+    return cfg
+
+
+def ccompile(sid: int, instruction: dict, circuit: list, **kwds):
+    """compile circuits to commands(saved in **instruction**)
+
+    Args:
+        sid (int): step index(starts from 0)
+        instruction (dict): where commands are saved
+        circuit (list): qlisp circuit(@HK)
+
+    Returns:
+        tuple: instruction, extra arguments
+
+    Example: compile a circuit to instruction
+        ``` {.py3 linenums="1"}
+        from quark import connect
+        s = connect('QuarkServer')
+        cfg = initialize(s.snapshot())
+        circuit = [(('Measure',0),'Q0503')]
+        instruction, datamap =ccompile(0,circuit,signal='iq')
+
+        print(instruction) # before assemble
+        {'main': [('WRITE', 'Q0503.waveform.DDS', <waveforms.waveform.Waveform at 0x291381b6c80>, ''),
+                ('WRITE', 'M5.waveform.DDS', <waveforms.waveform.Waveform at 0x291381b7f40>, ''),
+                ('WRITE', 'ADx86_159.CH5.Shot', 1024, ''),
+                ('WRITE', 'ADx86_159.CH5.Coefficient', {'start': 2.4000000000000003e-08,
+                                                        'stop': 4.0299999999999995e-06,
+                                                        'wList': [{'Delta': 6932860000.0,
+                                                                    'phase': 0,
+                                                                    'weight': 'const(1)',
+                                                                    'window': (0, 1024),
+                                                                    'w': None,
+                                                                    't0': 3e-08,
+                                                                    'phi': -0.7873217091999384,
+                                                                    'threshold': 2334194991.172387}]}, ''),
+                ('WRITE', 'ADx86_159.CH5.TriggerDelay', 7e-07, ''),
+                ('WRITE', 'ADx86_159.CH5.CaptureMode', 'alg', ''),
+                ('WRITE', 'ADx86_159.CH5.StartCapture', 54328, '')],
+        'READ': [('READ', 'ADx86_159.CH5.IQ', 'READ', '')]
+        }
+
+        print(datamap)
+        {'dataMap': {'cbits': {0: ('READ.ADx86_159.CH5', 
+                                    0, 
+                                    6932860000.0, 
+                                    {'duration': 4e-06,
+                                     'amp': 0.083,
+                                     'frequency': 6932860000.0,
+                                     'phase': [[-1, 1], [-1, 1]],
+                                     'weight': 'const(1)',
+                                     'phi': -0.7873217091999384,
+                                     'threshold': 2334194991.172387,
+                                     'ring_up_amp': 0.083,
+                                     'ring_up_waist': 0.083,
+                                     'ring_up_time': 5e-07,
+                                     'w': None},
+                                    3e-08,
+                                    2.4000000000000003e-08,
+                                    4.0299999999999995e-06)
+                                },
+                    'signal': 2,
+                    'arch': 'baqis'
+                    }
+        }
+        ```
+
+    """
+    # kwds['signal'] = _form_signal(kwds.get('signal'))
+    # kwds['lib'] = kwds.get('lib', stdlib)
+
+    ctx = kwds.pop('ctx', cfg)
+    ctx.snapshot().cache = kwds.pop('cache', {})
+
+    # align_right = kwds.pop('align_right', True)
+    # waveform_length = kwds.pop('waveform_length', 98e-6)
+    if kwds.get('fillzero', False):  # whether to initialize all channels to zero()
+        compiled = {'main': [('WRITE', target, 'zero()', '')
+                             for target in get_all_channels(ctx)]}
+    else:
+        compiled = {}
+
+    # code = _compile(circuit, cfg=ctx, **kwds)
+
+    # if align_right:
+    #     delay = waveform_length - code.end
+
+    #     code.waveforms = {k: v >> delay for k, v in code.waveforms.items()}
+    #     code.measures = {
+    #         k:
+    #         Capture(v.qubit, v.cbit, v.time + delay, v.signal,
+    #                 v.params, v.hardware, v.shift + delay)
+    #         for k, v in code.measures.items()
+    #     }
+
+    # cmds, datamap = assembly_code(code)
+    code, (cmds, datamap) = qcompile(circuit,
+                                     lib=kwds.get('lib', stdlib),
+                                     cfg=kwds.get('cfg', ctx),
+                                     signal=_form_signal(kwds.get('signal')),
+                                     shots=kwds.get('shots', 1024),
+                                     context=kwds.get('context', {}),
+                                     arch=kwds.get('arch', 'baqis'),
+                                     align_right=kwds.get('align_right', True),
+                                     waveform_length=kwds.get('waveform_length', 98e-6))
+
+    for cmd in cmds:
+        ctype = type(cmd).__name__  # WRITE,TRIG,READ
+        if ctype == 'WRITE':
+            step = 'main'
+        else:
+            step = ctype
+        op = (ctype, cmd.address, cmd.value, 'au')
+        if step in compiled:
+            compiled[step].append(op)
+        else:
+            compiled[step] = [op]
+
+    # merge loop body with compiled result
+    for step, _cmds in compiled.items():
+        if step in instruction:
+            instruction[step].extend(_cmds)
+        else:
+            instruction[step] = _cmds
+    assemble(sid, instruction, prep=False, hold=kwds.get('hold', False))
+    if sid == 0:
+        kwds['restore'] = cfg.initial
+        kwds['clear'] = True
+    logger.info(f'Step {sid} compiled >>>>>>>>>>>>>')
+    return instruction, {'dataMap': datamap} | kwds
+
+
+def assemble(sid: int, instruction: dict[str, list[str, str, Any, str]], **kw):
+    """assemble compiled instruction(see cccompile) to corresponding devices
+
+    Args:
+        sid (int): step index
+        instruction (dict[str, list[str, str, Any, str]]): see cccompile
+
+    Raises:
+        TypeError: srate should be float, defaults to -1.0
+    """
+
+    try:
+        query = kw.get('ctx', cfg).query
+    except AttributeError as e:
+        query = cfg.query
+
+    for step, operations in instruction.items():
+        if not isinstance(operations, list):
+            break
+        scmd = {}
+        for ctype, target, value, unit in operations:
+            kwds = {'sid': sid, 'target': target,
+                    'track': query('etc.track'),
+                    'shared': query('etc.shared'),
+                    'filter': query('etc.filter')}
+            if 'CH' in target or ctype == 'WAIT':
+                _target = target
+            else:
+                try:
+                    # logical channel to hardware channel
+                    context = query(target.split('.', 1)[0])
+                    mapping = query('etc.mapping')
+                    _target = decode(target, context, mapping)
+                    kwds.update({"context": context})
+                except (ValueError, KeyError) as e:
+                    continue
+
+                # save initial value to restore
+                if sid == 0 and not kw.get('hold', False):
+                    init = query(target.removesuffix(
+                        '.I').removesuffix('.Q'))
+                    cfg.initial['restore'].append((ctype, target, init, unit))
+
+            # get sample rate from device
+            if ctype != 'WAIT':
+                dev = _target.split('.', 1)[0]
+                kwds['srate'] = query(f'dev.{dev}.srate')
+                if not kwds['srate']:
+                    logger.critical(f'Failed to get srate for {dev}!')
+            cmd = [ctype, value, unit, kwds]
+
+            # shared channels
+            try:
+                if _target in scmd and 'waveform' in target.lower():
+                    if isinstance(scmd[_target][1], str):
+                        scmd[_target][1] = wave_eval(scmd[_target][1])
+                    if isinstance(cmd[1], str):
+                        cmd[1] = wave_eval(cmd[1])
+                    scmd[_target][1] += cmd[1]
+                else:
+                    scmd[_target] = cmd
+            except Exception as e:
+                logger.warning(f'Channel[{_target}] mutiplexing error: {e}')
+                scmd[_target] = cmd
+        instruction[step] = scmd
+
+    # preprocess if True
+    if kw.get('prep', True):
+        return preprocess(sid, instruction)
+
+
+# mapping logical attribute to hardware attribute
+MAPPING = {
+    "setting_LO": "LO.Frequency",
+    "setting_POW": "LO.Power",
+    "setting_OFFSET": "ZBIAS.Offset",
+    "waveform_RF_I": "I.Waveform",
+    "waveform_RF_Q": "Q.Waveform",
+    "waveform_TRIG": "TRIG.Marker1",
+    "waveform_DDS": "DDS.Waveform",
+    "waveform_SW": "SW.Marker1",
+    "waveform_Z": "Z.Waveform",
+    "setting_PNT": "ADC.PointNumber",
+    "setting_SHOT": "ADC.Shot",
+    "setting_TRIGD": "ADC.TriggerDelay"
+}
+
+
+# commands filters
+SUFFIX = ('Waveform', 'Shot', 'Coefficient', 'TriggerDelay')
+
+
+def decode(target: str, context: dict, mapping: dict = MAPPING):
+    """decode target to hardware channel
+
+    Args:
+        target (str): target to be decoded like **Q0.setting.LO**
+        context (dict): target location like **Q0**
+        mapping (dict, optional): mapping relations. Defaults to MAPPING.
+
+    Raises:
+        KeyError: mapping not found
+        ValueError: channel not found
+
+    Returns:
+        str: hardware channel like **AD.CH1.TraceIQ**
+    """
+    try:
+        mkey = target.split('.', 1)[-1].replace('.', '_')
+        chkey, quantity = mapping[mkey].split('.', 1)
+    except KeyError as e:
+        raise KeyError(f'{e} not found in mapping!')
+
+    try:
+        channel = context.get('channel', {})[chkey]
+    except KeyError as e:
+        raise KeyError(f'{chkey} not found!')
+
+    if channel is None:
+        raise ValueError('ChannelNotFound')
+    elif not isinstance(channel, str):
+        raise TypeError(
+            f'Wrong type of channel of {target}, string needed got {channel}')
+    elif 'Marker' not in channel:
+        channel = '.'.join((channel, quantity))
+
+    return channel
+
+
+WINDOW = square(500e-3) >> 150e-3
+
+
+def equal(a, b):
+    if isinstance(a, WaveVStack) or isinstance(b, WaveVStack):
+        return False
+    if isinstance(a, Waveform) and isinstance(b, Waveform):
+        return (a*WINDOW) == (b*WINDOW)
+    try:
+        return a == b
+    except Exception as e:
+        # logger.warning(f'Failed to compare {e}')
+        return False
+
+
+def preprocess(sid: int, instruction: dict[str, dict[str, list[str, Any, str, dict]]]):
+    """filters and paramters 
+
+    Args:
+        sid (int): step index
+        instruction (dict):instruction set like **{step: {target: [ctype, value, unit, kwds]}}**
+
+    Example: instruction structure
+        - step (str): step name, e.g., main/step1/step2
+        - target (list): hardware channel, e.g., AWG.CH1.Waveform、AD.CH2.TraceIQ
+            - ctype (str): command type, must be one of READ/WRITE/WAIT
+            - value (Any): command value, None for READ, seconds for WAIT, arbitary for WRITE, see corresponding driver
+            - unit (str): command unit, useless for now
+            - kwds (dict):
+                - sid (int): step index
+                - track (list): list of sid to be tracked
+                - target (str): original target like Q0101.waveform.Z
+                - filter (list): sample waveform in the filter list to show in `QuarkCanvas`
+                - srate (float): sampling rate
+                - context (dict): target location like Q0101
+    """
+    if sid == 0:
+        cfg.bypass.clear()
+    bypass = cfg.bypass
+
+    shared = []
+    for step, operations in instruction.items():
+        if not isinstance(operations, dict):
+            break
+        scmd = {}
+        for target, cmd in operations.items():
+            try:
+                kwds = cmd[-1]
+                # 重复指令缓存比较, 如果与上一步相同, 则跳过执行
+                if target in bypass and target.endswith(SUFFIX) and equal(bypass[target][0], cmd[1]):
+                    continue
+                bypass[target] = (cmd[1], kwds['target'])
+
+                # context设置, 用于calculator.calculate
+                context = kwds.pop('context', {})  # 即cfg表中的Qubit、Coupler等
+                if context:
+                    kwds['LEN'] = context['waveform']['LEN']
+                    kwds['calibration'] = context['calibration']
+
+                # if isinstance(cmd[1], Waveform):
+                #     cmd[1].sample_rate = kwds['srate']
+                #     cmd[1].start = 0
+                #     cmd[1].stop = 1e-3  # kwds['LEN']
+                #     cmd[1] = cmd[1].sample()
+
+                if kwds['shared']:
+                    sm, value = dumpv(cmd[1])
+                    if sm:
+                        shared.append(sm)
+                        cmd[1] = value
+            except Exception as e:
+                logger.error(f'Failed to preprocess {target}, {e}!')
+            scmd[target] = cmd
+        instruction[step] = scmd
+
+    return shared
+
+
+# %%
+if __name__ == "__main__":
+    import doctest
+    doctest.testmod()
```

## quark/envelope/calculator.py

```diff
@@ -1,139 +1,155 @@
-"""### 采样计算
-- 采样、失真、串扰等处理
-- 送入设备执行(见device模块)
-- 分流数据至波形监测器
-"""
-
-import numpy as np
-from loguru import logger
-
-from quark.proxy import loadv
-
-from .systemq import Waveform, sample_waveform, wave_eval
-
-
-def calculate(step: str, target: str, cmd: list, preview: dict = {}):
-    """指令的预处理
-
-    Args:
-        step (str): 步骤名, 如main/step1/...
-        target (str): 设备通道, 如AWG.CH1.Offset
-        cmd (list): 操作指令, 格式为(操作类型, 值, 单位, kwds). 其中
-            操作类型包括WRITE/READ/WAIT, kwds见assembler.preprocess说明. 
-
-    Returns:
-        tuple: (预处理结果, 采样后送到canvas显示的波形)
-
-    Examples:
-        >>> calculate('main', 'AWG.CH1.Waveform',('WRITE',square(100e-6),'au',{'calibration':{}}))
-    """
-    ctype, value, unit, kwds = cmd
-
-    line = {}
-
-    if ctype != 'WRITE':
-        return (step, target, cmd), line
-
-    if isinstance(value, str):
-        try:
-            func = wave_eval(value)
-        except SyntaxError as e:
-            func = value
-    else:
-        func = value
-
-    delay = 0
-
-    # sm, _value = loadv(func) # _value[:] = _value*10
-
-    if isinstance(func, Waveform):
-        if target.startswith(tuple(kwds.get('filter', ['zzzzz']))):
-            support_waveform_object = True
-        else:
-            support_waveform_object = False
-
-        try:
-            ch = kwds['target'].split('.')[-1]
-            delay = kwds['calibration'][ch].get('delay', 0)
-            cmd[1] = sample_waveform(func, kwds['calibration'][ch],
-                                     sample_rate=kwds['srate'],
-                                     start=0, stop=kwds['LEN'],
-                                     support_waveform_object=support_waveform_object)
-        except Exception as e:
-            # KeyError: 'calibration'
-            logger.error(f'Failed to sample waveform: {e}')
-            func.start = 0
-            func.stop = 100e-6
-            func.sample_rate = kwds['srate']
-
-            if support_waveform_object:
-                cmd[1] = func
-            else:
-                cmd[1] = func.sample()
-    else:
-        cmd[1] = func
-
-    cmd[-1] = {'sid': kwds['sid'], 'target': kwds['target'], 'srate': kwds['srate'],
-               'track': kwds['track'], 'shared': kwds['shared']}
-
-    try:
-        line = plot(target, cmd, preview, delay)
-    except Exception as e:
-        logger.error(
-            f"{'>'*30}'  failed to calculate waveform', {e}, {type(e).__name__}")
-
-    return (step, target, cmd), line
-
-
-def plot(target: str, cmd: dict, preview: dict = {}, delay: float = 0.0):
-    """收集需要实时显示的波形
-
-    Args:
-        target (str): 设备.通道.属性, 波形目标地址.
-        cmd (dict): 见calculator返回值.
-        preview (dict, optional): 即etc.preview. Defaults to {}.
-        delay (float, optional): 通道延时, 扣除后即为从设备输出的波形. Defaults to 0.0.
-
-    Returns:
-        _type_: _description_
-    """
-    if not preview.get('filter', []):
-        return {}
-
-    if cmd[-1]['target'].split('.')[0] not in preview['filter'] or cmd[-1]['sid'] < 0:
-        return {}
-
-    if target.endswith('Waveform'):
-
-        srate = cmd[-1]['srate']
-        t1, t2 = preview['range']
-        xr = slice(int(t1*srate), int(t2*srate))
-
-        val = cmd[1]
-        if isinstance(val, Waveform):
-            val = val.sample()
-
-        xt = (np.arange(len(val))/srate)[xr] - delay
-        yt = val[xr]
-
-        try:
-            nz = np.argwhere(np.abs(np.diff(yt)) > 1e-6).squeeze()
-            nz = np.hstack((0, nz-1, nz, nz+1, len(yt)-1))
-            # nz.sort(kind='mergesort')
-            nz = np.unique(nz[nz >= 0])
-            xx, yy = xt[nz], yt[nz]
-        except Exception as e:
-            xx, yy = xt, yt
-
-        line = {'xdata': xx, 'ydata': yy, 'suptitle': cmd[-1]["sid"]}
-        color = preview.get('color', None)
-        if color and isinstance(color, (list, tuple)):
-            line['color'] = tuple(color)
-
-        return {cmd[-1]['target']: line}
-    return {}
-
-
-if __name__ == "__main__":
-    import doctest
-    doctest.testmod()
+# MIT License
+
+# Copyright (c) 2021 YL Feng
+
+# Permission is hereby granted, free of charge, to any person obtaining a copy
+# of this software and associated documentation files (the "Software"), to deal
+# in the Software without restriction, including without limitation the rights
+# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+# copies of the Software, and to permit persons to whom the Software is
+# furnished to do so, subject to the following conditions:
+
+# The above copyright notice and this permission notice shall be included in
+# all copies or substantial portions of the Software.
+
+# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+
+import numpy as np
+from loguru import logger
+
+from quark.proxy import loadv
+
+from .systemq import Waveform, sample_waveform, wave_eval
+
+
+def calculate(step: str, target: str, cmd: list, preview: dict = {}):
+    """preprocess each command such as predistortion and sampling
+
+    Args:
+        step (str): step name, e.g., main/step1/...
+        target (str): hardware channel like **AWG.CH1.Offset**
+        cmd (list): command, in the type of tuple (ctype, value, unit, kwds), where ctype
+            must be one of WRITE/READ/WAIT, see assembler.preprocess for more details. 
+
+    Returns:
+        tuple: (preprocessed result, sampled waveform to be shown in the `QuarkCanvas`)
+
+    Examples:
+        >>> calculate('main', 'AWG.CH1.Waveform',('WRITE',square(100e-6),'au',{'calibration':{}}))
+    """
+    ctype, value, unit, kwds = cmd
+
+    line = {}
+
+    if ctype != 'WRITE':
+        return (step, target, cmd), line
+
+    if isinstance(value, str):
+        try:
+            func = wave_eval(value)
+        except SyntaxError as e:
+            func = value
+    else:
+        func = value
+
+    delay = 0
+
+    # sm, _value = loadv(func) # _value[:] = _value*10
+
+    if isinstance(func, Waveform):
+        if target.startswith(tuple(kwds.get('filter', ['zzzzz']))):
+            support_waveform_object = True
+        else:
+            support_waveform_object = False
+
+        try:
+            ch = kwds['target'].split('.')[-1]
+            delay = kwds['calibration'][ch].get('delay', 0)
+            cmd[1] = sample_waveform(func, kwds['calibration'][ch],
+                                     sample_rate=kwds['srate'],
+                                     start=0, stop=kwds['LEN'],
+                                     support_waveform_object=support_waveform_object)
+        except Exception as e:
+            # KeyError: 'calibration'
+            logger.error(f'Failed to sample waveform: {e}')
+            func.start = 0
+            func.stop = 100e-6
+            func.sample_rate = kwds['srate']
+
+            if support_waveform_object:
+                cmd[1] = func
+            else:
+                cmd[1] = func.sample()
+    else:
+        cmd[1] = func
+
+    cmd[-1] = {'sid': kwds['sid'], 'target': kwds['target'], 'srate': kwds['srate'],
+               'track': kwds['track'], 'shared': kwds['shared']}
+
+    try:
+        line = plot(target, cmd, preview, delay)
+    except Exception as e:
+        logger.error(
+            f"{'>'*30}'  failed to calculate waveform', {e}, {type(e).__name__}")
+
+    return (step, target, cmd), line
+
+
+def plot(target: str, cmd: dict, preview: dict = {}, delay: float = 0.0):
+    """sample waveforms needed to be shown in the `QuarkCanvas`
+
+    Args:
+        target (str): hardware channel
+        cmd (dict): see calculator
+        preview (dict, optional): from **etc.preview**. Defaults to {}.
+        delay (float, optional): time delay for the channel. Defaults to 0.0.
+
+    Returns:
+        _type_: _description_
+    """
+    if not preview.get('filter', []):
+        return {}
+
+    if cmd[-1]['target'].split('.')[0] not in preview['filter'] or cmd[-1]['sid'] < 0:
+        return {}
+
+    if target.endswith('Waveform'):
+
+        srate = cmd[-1]['srate']
+        t1, t2 = preview['range']
+        xr = slice(int(t1*srate), int(t2*srate))
+
+        val = cmd[1]
+        if isinstance(val, Waveform):
+            val = val.sample()
+
+        xt = (np.arange(len(val))/srate)[xr] - delay
+        yt = val[xr]
+
+        try:
+            nz = np.argwhere(np.abs(np.diff(yt)) > 1e-6).squeeze()
+            nz = np.hstack((0, nz-1, nz, nz+1, len(yt)-1))
+            # nz.sort(kind='mergesort')
+            nz = np.unique(nz[nz >= 0])
+            xx, yy = xt[nz], yt[nz]
+        except Exception as e:
+            xx, yy = xt, yt
+
+        line = {'xdata': xx, 'ydata': yy, 'suptitle': cmd[-1]["sid"]}
+        color = preview.get('color', None)
+        if color and isinstance(color, (list, tuple)):
+            line['color'] = tuple(color)
+
+        return {cmd[-1]['target']: line}
+    return {}
+
+
+if __name__ == "__main__":
+    import doctest
+    doctest.testmod()
```

### encoding

```diff
@@ -1 +1 @@
-utf-8
+us-ascii
```

## quark/envelope/device.py

```diff
@@ -1,35 +1,51 @@
-"""### 设备读写
-- 设备驱动独立于测控系统, 本模块接口是设备与系统的交接处(此外还有open/close). 
-- 系统发给设备的所有指令均会经过以下两个函数, 即read和write. 
-- 设备执行结果交由processor模块处理. 
-"""
-
-from typing import Any
-
-from quark.driver.common import BaseDriver
-
-
-def read(device: BaseDriver, quantity: str, channel: int = 1, **kwds):
-    """从设备读取
-
-    Args:
-        device (_type_): 设备
-        quantity (str): 设备属性, 如Waveform/Power/Offset
-        channel (int, optional): 设备通道. Defaults to 1.
-
-    Returns:
-        _type_: 读取结果
-    """
-    return device.getValue(quantity, ch=channel, **kwds)
-
-
-def write(device: BaseDriver, quantity: str, value: Any, channel: int = 1, **kwds):
-    """向设备写入
-
-    Args:
-        device (_type_): 设备
-        quantity (str): 设备属性
-        value (Any): 待写入的数据
-        channel (int, optional): 设备通道. Defaults to 1.
-    """
-    return device.setValue(quantity, value, ch=channel, **kwds)
+# MIT License
+
+# Copyright (c) 2021 YL Feng
+
+# Permission is hereby granted, free of charge, to any person obtaining a copy
+# of this software and associated documentation files (the "Software"), to deal
+# in the Software without restriction, including without limitation the rights
+# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+# copies of the Software, and to permit persons to whom the Software is
+# furnished to do so, subject to the following conditions:
+
+# The above copyright notice and this permission notice shall be included in
+# all copies or substantial portions of the Software.
+
+# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+
+from typing import Any
+
+from quark.driver.common import BaseDriver
+
+
+def read(device: BaseDriver, quantity: str, channel: int = 1, **kwds):
+    """read from the device
+
+    Args:
+        device (_type_): device handler
+        quantity (str): hardware attribute, e.g., Waveform/Power/Offset
+        channel (int, optional): channel number. Defaults to 1.
+
+    Returns:
+        _type_: result from the device
+    """
+    return device.getValue(quantity, ch=channel, **kwds)
+
+
+def write(device: BaseDriver, quantity: str, value: Any, channel: int = 1, **kwds):
+    """write to the device
+
+    Args:
+        device (_type_): device handler
+        quantity (str): hardware attribute, e.g., Waveform/Power/Offset
+        value (Any): value to be written
+        channel (int, optional): channel number. Defaults to 1.
+    """
+    return device.setValue(quantity, value, ch=channel, **kwds)
```

### encoding

```diff
@@ -1 +1 @@
-utf-8
+us-ascii
```

## quark/envelope/processor.py

```diff
@@ -1,12 +1,27 @@
-"""### 数据处理
-- read操作返回见各设备驱动,
-- write操作返回None)
-- 原始结果传给process进行处理
-"""
+# MIT License
+
+# Copyright (c) 2021 YL Feng
+
+# Permission is hereby granted, free of charge, to any person obtaining a copy
+# of this software and associated documentation files (the "Software"), to deal
+# in the Software without restriction, including without limitation the rights
+# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+# copies of the Software, and to permit persons to whom the Software is
+# furnished to do so, subject to the following conditions:
+
+# The above copyright notice and this permission notice shall be included in
+# all copies or substantial portions of the Software.
+
+# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 
 
 import numpy as np
 from loguru import logger
 
 from .systemq import baqisArchitecture, get_arch, register_arch
 
@@ -14,23 +29,23 @@
 
 
 def demodulate(raw_data, **kwds):
     pass
 
 
 def process(raw_data, **kwds):
-    """处理数据
+    """processing data
 
     Args:
-        raw_data (dict): 从设备获取的原始结果
+        raw_data (dict): result from devices
 
     Returns:
-        result (dict): 处理后的数据, 形式为{'key1':np.array,'key2':np.array, ...}
+        result (dict): processed data in the form of {'key1':np.array,'key2':np.array, ...}
 
-    Example: raw_data例子
+    Example: raw_data
         ``` {.py3 linenums="1"}
         {'main': {'DAx86_153': {'CH1.Waveform': None}, 
                                 'DAx86_50': {'CH1.Waveform': None}, 
                                 'ADx86_159': {'CH10.CaptureMode': None,
                                               'CH11.CaptureMode': None, 
                                               'CH10.StartCapture': None, 
                                               'CH11.StartCapture': None}},
```

### encoding

```diff
@@ -1 +1 @@
-utf-8
+us-ascii
```

## quark/envelope/router.py

```diff
@@ -1,10 +1,28 @@
-"""### 数据后处理
-- 任务结束之后对结果进行后处理, 如返回云端或其他处理.
-"""
+# MIT License
+
+# Copyright (c) 2021 YL Feng
+
+# Permission is hereby granted, free of charge, to any person obtaining a copy
+# of this software and associated documentation files (the "Software"), to deal
+# in the Software without restriction, including without limitation the rights
+# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+# copies of the Software, and to permit persons to whom the Software is
+# furnished to do so, subject to the following conditions:
+
+# The above copyright notice and this permission notice shall be included in
+# all copies or substantial portions of the Software.
+
+# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
 
 import json
 import shutil
 import time
 from pathlib import Path
 
 import numpy as np
@@ -23,25 +41,25 @@
     ax = ax.flatten()
     for a in ax:
         a.plot([1, 2, 3])
     plt.savefig('test.png')
 
 
 def schedule():
-    """执行事先设定好的定时任务, 默认为每天凌晨2点到6点.
+    """Execute pre-set scheduled jobs
 
-    Example: `定时规则由etc.schedule指定`
-        - year(int | str): 年(4位数字)
-        - month(int | str): 月(范围1-12)
-        - day(int | str): 日(范围1-31)
-        - week(int | str): 周(范围1-53)
-        - day_of_week(int | str): 周内第几天或者星期几(0-6 或 mon,tue,wed,thu,fri,stat,sun)
-        - hour(int | str): 时(0-23)
-        - minute(int | str): 分(0-59)
-        - second(int | str): 秒(0-59)
+    Example: `the scheduling rules are specified by etc.schedule`
+        - year(int | str): Year(4-digit number)
+        - month(int | str): Month(1-12)
+        - day(int | str): Day(1-31)
+        - week(int | str): Week(1-53)
+        - day_of_week(int | str): day of the week(0-6 or mon,tue,wed,thu,fri,stat,sun)
+        - hour(int | str): Hour(0-23)
+        - minute(int | str): Minute(0-59)
+        - second(int | str): Second(0-59)
     """
     # dst = shutil.move(Path('../../home/dat/144v3-swj-221013-normalJJ_2023-03-01-22-37-23.hdf5'),Path.home())
     # for path in sorted(Path('../../home/dat').glob('**/*.hdf5')):
     #     print((time.time() - path.stat().st_mtime)/(24*60*60),shutil.disk_usage(path))
     def test1():
         print(time.strftime('%Y-%m-%d %H:%M:%S'), 'do something1 ...')
 
@@ -49,20 +67,20 @@
         print(time.strftime('%Y-%m-%d %H:%M:%S'), 'do something2 ...')
 
     return {}  # {'job1': test1,'job2': test2}
     # return [(r'C:\Usersddd\sesam\Desktop\home\dat\baqis\testtask_2023-08-31-12-35-12.hdf5',r'\home\dat\baqis\testtask_2023-08-31-12-35-12.hdf5')]
 
 
 def postprocess(result: dict):
-    """任务执行完后对数据的操作, 如存储到自定义路径或回传到云平台等
+    """Send result back to cloud or whatever you wanna do
 
     Args:
-        result (dict): 任务结果
+        result (dict): task result
 
-    Example: result例子
+    Example: result
         ``` {.py3 linenums="1"}
         {'data': {'iq_avg': array([[ 6.98367485 +3.05121544j, 17.98372871+14.02688919j],
                                    [14.9855748 +16.99029603j, 12.00005981+10.98745889j],
                                    [ 5.05074742 +0.96293022j, 18.00112126 +5.98929904j]])},
          'meta': {'tid': 202403122306141782,
                   'name': 'testtask:/PowerRabi1D',
                   'user': 'baqis',
```

### encoding

```diff
@@ -1 +1 @@
-utf-8
+us-ascii
```

## quark/envelope/systemq.py

```diff
@@ -1,10 +1,30 @@
-"""### 与systemq交互的接口
-- 如果接口路径发生变动以便于修改
-- 主要导入lib(来自systemq)，qlisp|qlispc(systemq或独立安装)，waveforms
+# MIT License
+
+# Copyright (c) 2021 YL Feng
+
+# Permission is hereby granted, free of charge, to any person obtaining a copy
+# of this software and associated documentation files (the "Software"), to deal
+# in the Software without restriction, including without limitation the rights
+# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+# copies of the Software, and to permit persons to whom the Software is
+# furnished to do so, subject to the following conditions:
+
+# The above copyright notice and this permission notice shall be included in
+# all copies or substantial portions of the Software.
+
+# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+
+"""### interface with systemq
 """
 
 
 from copy import deepcopy
 
 from loguru import logger
 
@@ -32,29 +52,29 @@
 
 # waveforms.math: waveforms or waveform-math
 from waveforms import Waveform, WaveVStack, square, wave_eval
 from waveforms.namespace import DictDriver
 
 
 class CompilerContext(QuarkLocalConfig):
-    """编译所需上下文环境，即cfg表信息
+    """context used by compiler
     """
 
     def __init__(self, data) -> None:
         super().__init__(data)
         self.reset(data)
         self.initial = {}
         self.bypass = {}
         self._keys = []
 
     def reset(self, snapshot):
-        """每个任务重置一次
+        """reset for every task
 
         Args:
-            snapshot (_type_): server中实时获取的cfg
+            snapshot (_type_): frozen snapshot from server for the task
         """
         self._getGateConfig.cache_clear()
         if isinstance(snapshot, dict):
             self._QuarkLocalConfig__driver = DictDriver(deepcopy(snapshot))
         else:
             self._QuarkLocalConfig__driver = snapshot
```

## Comparing `vios-2.3.6.dist-info/LICENSE` & `vios-2.4.0.dist-info/LICENSE`

 * *Files 20% similar despite different names*

```diff
@@ -1,21 +1,20 @@
-MIT License
-
-Copyright (c) 2023 YL Feng
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in all
-copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-SOFTWARE.
+MIT License
+
+Copyright (c) 2021 YL Feng
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
```

## Comparing `vios-2.3.6.dist-info/METADATA` & `vios-2.4.0.dist-info/METADATA`

 * *Files 9% similar despite different names*

```diff
@@ -1,14 +1,13 @@
 Metadata-Version: 2.1
 Name: vios
-Version: 2.3.6
+Version: 2.4.0
 Summary: runtime requirements for systemq
 Author-email: YL Feng <fengyl@baqis.ac.cn>
-Project-URL: homepage, https://gitee.com
-Project-URL: bugs, https://gitee.com
+Project-URL: homepage, https://quarkstudio.readthedocs.io/en/latest
 Classifier: Development Status :: 5 - Production/Stable
 Classifier: Intended Audience :: Developers
 Classifier: Intended Audience :: Science/Research
 Classifier: License :: OSI Approved :: MIT License
 Classifier: Natural Language :: Chinese (Simplified)
 Classifier: Natural Language :: English
 Classifier: Operating System :: Microsoft :: Windows
@@ -18,15 +17,14 @@
 Classifier: Topic :: Scientific/Engineering :: Physics
 Requires-Python: >=3.10
 Description-Content-Type: text/markdown
 License-File: LICENSE
 Requires-Dist: dill
 Requires-Dist: tqdm
 Requires-Dist: loguru
-Requires-Dist: cython
 Requires-Dist: gitpython
 Requires-Dist: waveforms
 Requires-Dist: pyvisa
 Requires-Dist: pyserial
 Provides-Extra: full
 Requires-Dist: quarkstudio[full] >=6.5.0 ; extra == 'full'
 Requires-Dist: waveforms-math >=1.0.0 ; extra == 'full'
```

