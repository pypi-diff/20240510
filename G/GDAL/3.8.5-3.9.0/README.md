# Comparing `tmp/GDAL-3.8.5.tar.gz` & `tmp/GDAL-3.9.0.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "GDAL-3.8.5.tar", last modified: Thu Apr  4 17:20:23 2024, max compression
+gzip compressed data, was "GDAL-3.9.0.tar", last modified: Fri May 10 13:50:42 2024, max compression
```

## Comparing `GDAL-3.8.5.tar` & `GDAL-3.9.0.tar`

### file list

```diff
@@ -1,143 +1,145 @@
-drwxrwxr-x   0 even      (1000) even      (1000)        0 2024-04-04 17:20:23.381591 GDAL-3.8.5/
--rw-r--r--   0 even      (1000) even      (1000)     5375 2024-04-04 17:20:23.381591 GDAL-3.8.5/PKG-INFO
--rw-rw-r--   0 even      (1000) even      (1000)     4488 2024-04-04 17:09:42.000000 GDAL-3.8.5/README.rst
-drwxrwxr-x   0 even      (1000) even      (1000)        0 2024-04-04 17:20:23.353591 GDAL-3.8.5/extensions/
--rw-rw-r--   0 even      (1000) even      (1000)   276603 2024-04-04 17:18:42.000000 GDAL-3.8.5/extensions/gdal_array_wrap.cpp
--rw-rw-r--   0 even      (1000) even      (1000)  1899878 2024-04-04 17:18:40.000000 GDAL-3.8.5/extensions/gdal_wrap.cpp
--rw-rw-r--   0 even      (1000) even      (1000)   126303 2024-04-04 17:18:40.000000 GDAL-3.8.5/extensions/gdalconst_wrap.c
--rw-rw-r--   0 even      (1000) even      (1000)   229118 2024-04-04 17:18:40.000000 GDAL-3.8.5/extensions/gnm_wrap.cpp
--rw-rw-r--   0 even      (1000) even      (1000)  1447479 2024-04-04 17:18:42.000000 GDAL-3.8.5/extensions/ogr_wrap.cpp
--rw-rw-r--   0 even      (1000) even      (1000)   770259 2024-04-04 17:18:41.000000 GDAL-3.8.5/extensions/osr_wrap.cpp
-drwxrwxr-x   0 even      (1000) even      (1000)        0 2024-04-04 17:20:23.349591 GDAL-3.8.5/gdal-utils/
-drwxrwxr-x   0 even      (1000) even      (1000)        0 2024-04-04 17:20:23.381591 GDAL-3.8.5/gdal-utils/GDAL.egg-info/
--rw-r--r--   0 even      (1000) even      (1000)     5375 2024-04-04 17:20:23.000000 GDAL-3.8.5/gdal-utils/GDAL.egg-info/PKG-INFO
--rw-rw-r--   0 even      (1000) even      (1000)     5239 2024-04-04 17:20:23.000000 GDAL-3.8.5/gdal-utils/GDAL.egg-info/SOURCES.txt
--rw-rw-r--   0 even      (1000) even      (1000)        1 2024-04-04 17:20:23.000000 GDAL-3.8.5/gdal-utils/GDAL.egg-info/dependency_links.txt
--rw-rw-r--   0 even      (1000) even      (1000)        1 2023-11-13 17:29:26.000000 GDAL-3.8.5/gdal-utils/GDAL.egg-info/not-zip-safe
--rw-rw-r--   0 even      (1000) even      (1000)       21 2024-04-04 17:20:23.000000 GDAL-3.8.5/gdal-utils/GDAL.egg-info/requires.txt
--rw-rw-r--   0 even      (1000) even      (1000)       18 2024-04-04 17:20:23.000000 GDAL-3.8.5/gdal-utils/GDAL.egg-info/top_level.txt
-drwxrwxr-x   0 even      (1000) even      (1000)        0 2024-04-04 17:20:23.361591 GDAL-3.8.5/gdal-utils/osgeo_utils/
--rw-rw-r--   0 even      (1000) even      (1000)      432 2024-04-02 10:04:14.000000 GDAL-3.8.5/gdal-utils/osgeo_utils/__init__.py
-drwxrwxr-x   0 even      (1000) even      (1000)        0 2024-04-04 17:20:23.365591 GDAL-3.8.5/gdal-utils/osgeo_utils/auxiliary/
--rw-rw-r--   0 even      (1000) even      (1000)        0 2023-11-06 10:54:53.000000 GDAL-3.8.5/gdal-utils/osgeo_utils/auxiliary/__init__.py
--rw-rw-r--   0 even      (1000) even      (1000)     2635 2023-11-06 10:54:53.000000 GDAL-3.8.5/gdal-utils/osgeo_utils/auxiliary/array_util.py
--rw-rw-r--   0 even      (1000) even      (1000)     4164 2023-11-06 10:54:53.000000 GDAL-3.8.5/gdal-utils/osgeo_utils/auxiliary/base.py
--rw-rw-r--   0 even      (1000) even      (1000)     3447 2023-11-06 10:54:53.000000 GDAL-3.8.5/gdal-utils/osgeo_utils/auxiliary/batch_creator.py
--rw-rw-r--   0 even      (1000) even      (1000)    15215 2023-11-06 10:54:53.000000 GDAL-3.8.5/gdal-utils/osgeo_utils/auxiliary/color_palette.py
--rw-rw-r--   0 even      (1000) even      (1000)     5649 2023-11-06 10:54:53.000000 GDAL-3.8.5/gdal-utils/osgeo_utils/auxiliary/color_table.py
--rw-rw-r--   0 even      (1000) even      (1000)     5384 2023-11-06 10:54:53.000000 GDAL-3.8.5/gdal-utils/osgeo_utils/auxiliary/extent_util.py
--rw-rw-r--   0 even      (1000) even      (1000)     8436 2023-11-06 10:54:53.000000 GDAL-3.8.5/gdal-utils/osgeo_utils/auxiliary/gdal_argparse.py
--rw-rw-r--   0 even      (1000) even      (1000)     2891 2023-11-06 10:54:53.000000 GDAL-3.8.5/gdal-utils/osgeo_utils/auxiliary/numpy_util.py
--rw-rw-r--   0 even      (1000) even      (1000)     5467 2023-11-06 10:54:53.000000 GDAL-3.8.5/gdal-utils/osgeo_utils/auxiliary/osr_util.py
--rw-rw-r--   0 even      (1000) even      (1000)     3340 2023-11-06 10:54:53.000000 GDAL-3.8.5/gdal-utils/osgeo_utils/auxiliary/progress.py
--rw-rw-r--   0 even      (1000) even      (1000)     6671 2023-11-06 10:54:53.000000 GDAL-3.8.5/gdal-utils/osgeo_utils/auxiliary/raster_creation.py
--rw-rw-r--   0 even      (1000) even      (1000)     8828 2023-11-06 10:54:53.000000 GDAL-3.8.5/gdal-utils/osgeo_utils/auxiliary/rectangle.py
--rw-rw-r--   0 even      (1000) even      (1000)    16654 2023-11-06 10:54:53.000000 GDAL-3.8.5/gdal-utils/osgeo_utils/auxiliary/util.py
--rw-rw-r--   0 even      (1000) even      (1000)   166757 2024-03-01 13:42:35.000000 GDAL-3.8.5/gdal-utils/osgeo_utils/gdal2tiles.py
--rw-rw-r--   0 even      (1000) even      (1000)    15776 2023-11-06 10:54:53.000000 GDAL-3.8.5/gdal-utils/osgeo_utils/gdal2xyz.py
--rw-rw-r--   0 even      (1000) even      (1000)    36481 2023-11-06 10:54:53.000000 GDAL-3.8.5/gdal-utils/osgeo_utils/gdal_calc.py
--rw-rw-r--   0 even      (1000) even      (1000)    16078 2024-02-07 21:55:33.000000 GDAL-3.8.5/gdal-utils/osgeo_utils/gdal_edit.py
--rw-rw-r--   0 even      (1000) even      (1000)     9085 2023-11-06 10:54:53.000000 GDAL-3.8.5/gdal-utils/osgeo_utils/gdal_fillnodata.py
--rw-rw-r--   0 even      (1000) even      (1000)    18738 2023-11-06 10:54:53.000000 GDAL-3.8.5/gdal-utils/osgeo_utils/gdal_merge.py
--rw-rw-r--   0 even      (1000) even      (1000)    12426 2023-11-09 10:15:22.000000 GDAL-3.8.5/gdal-utils/osgeo_utils/gdal_pansharpen.py
--rw-rw-r--   0 even      (1000) even      (1000)    12411 2023-11-06 10:54:53.000000 GDAL-3.8.5/gdal-utils/osgeo_utils/gdal_polygonize.py
--rw-rw-r--   0 even      (1000) even      (1000)     7587 2023-11-06 10:54:53.000000 GDAL-3.8.5/gdal-utils/osgeo_utils/gdal_proximity.py
--rw-rw-r--   0 even      (1000) even      (1000)    38844 2023-11-09 10:15:22.000000 GDAL-3.8.5/gdal-utils/osgeo_utils/gdal_retile.py
--rw-rw-r--   0 even      (1000) even      (1000)     6682 2023-11-17 17:32:44.000000 GDAL-3.8.5/gdal-utils/osgeo_utils/gdal_sieve.py
--rw-rw-r--   0 even      (1000) even      (1000)     5200 2024-04-01 22:32:12.000000 GDAL-3.8.5/gdal-utils/osgeo_utils/gdalattachpct.py
--rw-rw-r--   0 even      (1000) even      (1000)    20209 2023-11-17 17:32:44.000000 GDAL-3.8.5/gdal-utils/osgeo_utils/gdalcompare.py
--rw-rw-r--   0 even      (1000) even      (1000)    10018 2023-11-17 17:32:44.000000 GDAL-3.8.5/gdal-utils/osgeo_utils/gdalmove.py
--rw-rw-r--   0 even      (1000) even      (1000)    19311 2023-11-09 10:15:22.000000 GDAL-3.8.5/gdal-utils/osgeo_utils/ogr_layer_algebra.py
--rw-rw-r--   0 even      (1000) even      (1000)    43981 2023-11-09 10:15:22.000000 GDAL-3.8.5/gdal-utils/osgeo_utils/ogrmerge.py
--rw-rw-r--   0 even      (1000) even      (1000)     7753 2023-12-01 17:57:11.000000 GDAL-3.8.5/gdal-utils/osgeo_utils/pct2rgb.py
--rw-rw-r--   0 even      (1000) even      (1000)     7145 2023-11-06 10:54:53.000000 GDAL-3.8.5/gdal-utils/osgeo_utils/rgb2pct.py
-drwxrwxr-x   0 even      (1000) even      (1000)        0 2024-04-04 17:20:23.377591 GDAL-3.8.5/gdal-utils/osgeo_utils/samples/
--rw-rw-r--   0 even      (1000) even      (1000)        0 2023-11-06 10:54:53.000000 GDAL-3.8.5/gdal-utils/osgeo_utils/samples/__init__.py
--rw-rw-r--   0 even      (1000) even      (1000)     4632 2023-11-06 10:54:53.000000 GDAL-3.8.5/gdal-utils/osgeo_utils/samples/assemblepoly.py
--rw-rw-r--   0 even      (1000) even      (1000)    17347 2023-11-06 10:54:53.000000 GDAL-3.8.5/gdal-utils/osgeo_utils/samples/build_jp2_from_xml.py
--rw-rw-r--   0 even      (1000) even      (1000)     2828 2023-11-06 10:54:53.000000 GDAL-3.8.5/gdal-utils/osgeo_utils/samples/classify.py
--rw-rw-r--   0 even      (1000) even      (1000)    12326 2023-11-06 10:54:53.000000 GDAL-3.8.5/gdal-utils/osgeo_utils/samples/crs2crs2grid.py
--rw-rw-r--   0 even      (1000) even      (1000)    16769 2023-11-06 10:54:53.000000 GDAL-3.8.5/gdal-utils/osgeo_utils/samples/densify.py
--rw-rw-r--   0 even      (1000) even      (1000)     8126 2023-11-06 10:54:53.000000 GDAL-3.8.5/gdal-utils/osgeo_utils/samples/dump_jp2.py
--rw-rw-r--   0 even      (1000) even      (1000)     9915 2023-11-06 10:54:53.000000 GDAL-3.8.5/gdal-utils/osgeo_utils/samples/epsg_tr.py
--rw-rw-r--   0 even      (1000) even      (1000)     3238 2023-11-06 10:54:53.000000 GDAL-3.8.5/gdal-utils/osgeo_utils/samples/esri2wkt.py
--rw-rw-r--   0 even      (1000) even      (1000)     4274 2023-11-06 10:54:53.000000 GDAL-3.8.5/gdal-utils/osgeo_utils/samples/fft.py
--rw-rw-r--   0 even      (1000) even      (1000)     3008 2023-11-06 10:54:53.000000 GDAL-3.8.5/gdal-utils/osgeo_utils/samples/fix_gpkg.py
--rw-rw-r--   0 even      (1000) even      (1000)     3193 2023-11-06 10:54:53.000000 GDAL-3.8.5/gdal-utils/osgeo_utils/samples/gcps2ogr.py
--rw-rw-r--   0 even      (1000) even      (1000)     5419 2023-11-06 10:54:53.000000 GDAL-3.8.5/gdal-utils/osgeo_utils/samples/gcps2vec.py
--rw-rw-r--   0 even      (1000) even      (1000)     2580 2023-11-06 10:54:53.000000 GDAL-3.8.5/gdal-utils/osgeo_utils/samples/gcps2wld.py
--rw-rw-r--   0 even      (1000) even      (1000)     5281 2023-11-06 10:54:53.000000 GDAL-3.8.5/gdal-utils/osgeo_utils/samples/gdal2grd.py
--rw-rw-r--   0 even      (1000) even      (1000)     4451 2023-11-06 10:54:53.000000 GDAL-3.8.5/gdal-utils/osgeo_utils/samples/gdal_auth.py
--rw-rw-r--   0 even      (1000) even      (1000)     8460 2023-11-06 10:54:53.000000 GDAL-3.8.5/gdal-utils/osgeo_utils/samples/gdal_cp.py
--rw-rw-r--   0 even      (1000) even      (1000)     2561 2023-11-06 10:54:53.000000 GDAL-3.8.5/gdal-utils/osgeo_utils/samples/gdal_create_pdf.py
--rw-rw-r--   0 even      (1000) even      (1000)     8693 2023-11-06 10:54:53.000000 GDAL-3.8.5/gdal-utils/osgeo_utils/samples/gdal_ls.py
--rw-rw-r--   0 even      (1000) even      (1000)     6670 2023-11-06 10:54:53.000000 GDAL-3.8.5/gdal-utils/osgeo_utils/samples/gdal_lut.py
--rw-rw-r--   0 even      (1000) even      (1000)     2403 2023-11-06 10:54:53.000000 GDAL-3.8.5/gdal-utils/osgeo_utils/samples/gdal_mkdir.py
--rw-rw-r--   0 even      (1000) even      (1000)     4426 2023-11-06 10:54:53.000000 GDAL-3.8.5/gdal-utils/osgeo_utils/samples/gdal_remove_towgs84.py
--rw-rw-r--   0 even      (1000) even      (1000)     4035 2023-11-06 10:54:53.000000 GDAL-3.8.5/gdal-utils/osgeo_utils/samples/gdal_rm.py
--rw-rw-r--   0 even      (1000) even      (1000)     2538 2023-11-06 10:54:53.000000 GDAL-3.8.5/gdal-utils/osgeo_utils/samples/gdal_rmdir.py
--rw-rw-r--   0 even      (1000) even      (1000)    11900 2023-11-06 10:54:53.000000 GDAL-3.8.5/gdal-utils/osgeo_utils/samples/gdal_vrtmerge.py
--rw-rw-r--   0 even      (1000) even      (1000)     3004 2023-11-06 10:54:53.000000 GDAL-3.8.5/gdal-utils/osgeo_utils/samples/gdalchksum.py
--rw-rw-r--   0 even      (1000) even      (1000)     3004 2023-11-06 10:54:53.000000 GDAL-3.8.5/gdal-utils/osgeo_utils/samples/gdalcopyproj.py
--rw-rw-r--   0 even      (1000) even      (1000)     6067 2023-11-06 10:54:53.000000 GDAL-3.8.5/gdal-utils/osgeo_utils/samples/gdalfilter.py
--rw-rw-r--   0 even      (1000) even      (1000)     3021 2023-11-06 10:54:53.000000 GDAL-3.8.5/gdal-utils/osgeo_utils/samples/gdalident.py
--rw-rw-r--   0 even      (1000) even      (1000)     3036 2023-11-06 10:54:53.000000 GDAL-3.8.5/gdal-utils/osgeo_utils/samples/gdalimport.py
--rw-rw-r--   0 even      (1000) even      (1000)    22270 2023-11-06 10:54:53.000000 GDAL-3.8.5/gdal-utils/osgeo_utils/samples/gdalinfo.py
--rw-rw-r--   0 even      (1000) even      (1000)    20066 2023-11-06 10:54:53.000000 GDAL-3.8.5/gdal-utils/osgeo_utils/samples/gdallocationinfo.py
--rw-rw-r--   0 even      (1000) even      (1000)     4095 2023-11-06 10:54:53.000000 GDAL-3.8.5/gdal-utils/osgeo_utils/samples/get_soundg.py
--rw-rw-r--   0 even      (1000) even      (1000)     3374 2023-11-06 10:54:53.000000 GDAL-3.8.5/gdal-utils/osgeo_utils/samples/histrep.py
--rw-rw-r--   0 even      (1000) even      (1000)     8150 2023-11-06 10:54:53.000000 GDAL-3.8.5/gdal-utils/osgeo_utils/samples/hsv_merge.py
--rw-rw-r--   0 even      (1000) even      (1000)    10510 2023-11-06 10:54:53.000000 GDAL-3.8.5/gdal-utils/osgeo_utils/samples/jpeg_in_tiff_extract.py
--rw-rw-r--   0 even      (1000) even      (1000)     6440 2023-11-06 10:54:53.000000 GDAL-3.8.5/gdal-utils/osgeo_utils/samples/load2odbc.py
--rw-rw-r--   0 even      (1000) even      (1000)     8849 2023-11-06 10:54:53.000000 GDAL-3.8.5/gdal-utils/osgeo_utils/samples/loslas2ntv2.py
--rw-rw-r--   0 even      (1000) even      (1000)     2739 2023-11-06 10:54:53.000000 GDAL-3.8.5/gdal-utils/osgeo_utils/samples/magphase.py
--rw-rw-r--   0 even      (1000) even      (1000)     2167 2023-11-06 10:54:53.000000 GDAL-3.8.5/gdal-utils/osgeo_utils/samples/make_fuzzer_friendly_archive.py
--rw-rw-r--   0 even      (1000) even      (1000)     7547 2023-11-06 10:54:53.000000 GDAL-3.8.5/gdal-utils/osgeo_utils/samples/mkgraticule.py
--rw-rw-r--   0 even      (1000) even      (1000)    70444 2023-11-06 10:54:53.000000 GDAL-3.8.5/gdal-utils/osgeo_utils/samples/ogr2ogr.py
--rw-rw-r--   0 even      (1000) even      (1000)    12810 2023-11-06 10:54:53.000000 GDAL-3.8.5/gdal-utils/osgeo_utils/samples/ogr2vrt.py
--rw-rw-r--   0 even      (1000) even      (1000)     7567 2023-11-06 10:54:53.000000 GDAL-3.8.5/gdal-utils/osgeo_utils/samples/ogr_build_junction_table.py
--rw-rw-r--   0 even      (1000) even      (1000)    14349 2023-11-06 10:54:53.000000 GDAL-3.8.5/gdal-utils/osgeo_utils/samples/ogr_dispatch.py
--rw-rw-r--   0 even      (1000) even      (1000)    21229 2023-11-06 10:54:53.000000 GDAL-3.8.5/gdal-utils/osgeo_utils/samples/ogrinfo.py
--rw-rw-r--   0 even      (1000) even      (1000)    19843 2023-11-06 10:54:53.000000 GDAL-3.8.5/gdal-utils/osgeo_utils/samples/ogrupdate.py
--rw-rw-r--   0 even      (1000) even      (1000)     7724 2023-11-06 10:54:53.000000 GDAL-3.8.5/gdal-utils/osgeo_utils/samples/rel.py
--rw-rw-r--   0 even      (1000) even      (1000)     7578 2023-11-06 10:54:53.000000 GDAL-3.8.5/gdal-utils/osgeo_utils/samples/tigerpoly.py
--rw-rw-r--   0 even      (1000) even      (1000)     4368 2023-11-06 10:54:53.000000 GDAL-3.8.5/gdal-utils/osgeo_utils/samples/tile_extent_from_raster.py
--rw-rw-r--   0 even      (1000) even      (1000)     4055 2023-11-06 10:54:53.000000 GDAL-3.8.5/gdal-utils/osgeo_utils/samples/tolatlong.py
--rw-rw-r--   0 even      (1000) even      (1000)     4344 2023-11-06 10:54:53.000000 GDAL-3.8.5/gdal-utils/osgeo_utils/samples/val_repl.py
--rw-rw-r--   0 even      (1000) even      (1000)    18476 2023-11-06 10:54:53.000000 GDAL-3.8.5/gdal-utils/osgeo_utils/samples/validate_cloud_optimized_geotiff.py
--rw-rw-r--   0 even      (1000) even      (1000)    16548 2023-11-06 10:54:53.000000 GDAL-3.8.5/gdal-utils/osgeo_utils/samples/validate_geoparquet.py
--rw-rw-r--   0 even      (1000) even      (1000)   113359 2023-11-06 10:54:53.000000 GDAL-3.8.5/gdal-utils/osgeo_utils/samples/validate_gpkg.py
--rw-rw-r--   0 even      (1000) even      (1000)    70659 2023-11-06 10:54:53.000000 GDAL-3.8.5/gdal-utils/osgeo_utils/samples/validate_jp2.py
--rw-rw-r--   0 even      (1000) even      (1000)     4768 2023-11-06 10:54:53.000000 GDAL-3.8.5/gdal-utils/osgeo_utils/samples/vec_tr.py
--rw-rw-r--   0 even      (1000) even      (1000)     4843 2023-11-06 10:54:53.000000 GDAL-3.8.5/gdal-utils/osgeo_utils/samples/vec_tr_spat.py
--rw-rw-r--   0 even      (1000) even      (1000)     7103 2023-11-06 10:54:53.000000 GDAL-3.8.5/gdal-utils/osgeo_utils/samples/wcs_virtds_params.py
-drwxrwxr-x   0 even      (1000) even      (1000)        0 2024-04-04 17:20:23.381591 GDAL-3.8.5/gdal-utils/scripts/
--rwxrwxr-x   0 even      (1000) even      (1000)      579 2023-11-06 10:54:53.000000 GDAL-3.8.5/gdal-utils/scripts/gdal2tiles.py
--rwxrwxr-x   0 even      (1000) even      (1000)      311 2023-11-06 10:54:53.000000 GDAL-3.8.5/gdal-utils/scripts/gdal2xyz.py
--rwxrwxr-x   0 even      (1000) even      (1000)      315 2023-11-06 10:54:53.000000 GDAL-3.8.5/gdal-utils/scripts/gdal_calc.py
--rwxrwxr-x   0 even      (1000) even      (1000)      315 2023-11-06 10:54:53.000000 GDAL-3.8.5/gdal-utils/scripts/gdal_edit.py
--rwxrwxr-x   0 even      (1000) even      (1000)      339 2023-11-06 10:54:53.000000 GDAL-3.8.5/gdal-utils/scripts/gdal_fillnodata.py
--rwxrwxr-x   0 even      (1000) even      (1000)      319 2023-11-06 10:54:53.000000 GDAL-3.8.5/gdal-utils/scripts/gdal_merge.py
--rwxrwxr-x   0 even      (1000) even      (1000)      339 2023-11-06 10:54:53.000000 GDAL-3.8.5/gdal-utils/scripts/gdal_pansharpen.py
--rwxrwxr-x   0 even      (1000) even      (1000)      339 2023-11-06 10:54:53.000000 GDAL-3.8.5/gdal-utils/scripts/gdal_polygonize.py
--rwxrwxr-x   0 even      (1000) even      (1000)      335 2023-11-06 10:54:53.000000 GDAL-3.8.5/gdal-utils/scripts/gdal_proximity.py
--rwxrwxr-x   0 even      (1000) even      (1000)      323 2023-11-06 10:54:53.000000 GDAL-3.8.5/gdal-utils/scripts/gdal_retile.py
--rwxrwxr-x   0 even      (1000) even      (1000)      319 2023-11-06 10:54:53.000000 GDAL-3.8.5/gdal-utils/scripts/gdal_sieve.py
--rwxrwxr-x   0 even      (1000) even      (1000)      331 2023-11-06 10:54:53.000000 GDAL-3.8.5/gdal-utils/scripts/gdalattachpct.py
--rwxrwxr-x   0 even      (1000) even      (1000)      323 2023-11-06 10:54:53.000000 GDAL-3.8.5/gdal-utils/scripts/gdalcompare.py
--rwxrwxr-x   0 even      (1000) even      (1000)      311 2023-11-06 10:54:53.000000 GDAL-3.8.5/gdal-utils/scripts/gdalmove.py
--rwxrwxr-x   0 even      (1000) even      (1000)      347 2023-11-06 10:54:53.000000 GDAL-3.8.5/gdal-utils/scripts/ogr_layer_algebra.py
--rwxrwxr-x   0 even      (1000) even      (1000)      311 2023-11-06 10:54:53.000000 GDAL-3.8.5/gdal-utils/scripts/ogrmerge.py
--rwxrwxr-x   0 even      (1000) even      (1000)      307 2023-11-06 10:54:53.000000 GDAL-3.8.5/gdal-utils/scripts/pct2rgb.py
--rwxrwxr-x   0 even      (1000) even      (1000)      307 2023-11-06 10:54:53.000000 GDAL-3.8.5/gdal-utils/scripts/rgb2pct.py
-drwxrwxr-x   0 even      (1000) even      (1000)        0 2024-04-04 17:20:23.381591 GDAL-3.8.5/osgeo/
--rw-rw-r--   0 even      (1000) even      (1000)     4758 2024-04-04 17:18:42.000000 GDAL-3.8.5/osgeo/__init__.py
--rw-rw-r--   0 even      (1000) even      (1000)   248626 2024-04-04 17:18:42.000000 GDAL-3.8.5/osgeo/gdal.py
--rw-rw-r--   0 even      (1000) even      (1000)    32601 2024-04-04 17:18:42.000000 GDAL-3.8.5/osgeo/gdal_array.py
--rw-rw-r--   0 even      (1000) even      (1000)    12420 2024-04-04 17:18:42.000000 GDAL-3.8.5/osgeo/gdalconst.py
--rw-rw-r--   0 even      (1000) even      (1000)      214 2024-04-04 17:18:42.000000 GDAL-3.8.5/osgeo/gdalnumeric.py
--rw-rw-r--   0 even      (1000) even      (1000)    13770 2024-04-04 17:18:42.000000 GDAL-3.8.5/osgeo/gnm.py
--rw-rw-r--   0 even      (1000) even      (1000)   228585 2024-04-04 17:18:42.000000 GDAL-3.8.5/osgeo/ogr.py
--rw-rw-r--   0 even      (1000) even      (1000)    58490 2024-04-04 17:18:42.000000 GDAL-3.8.5/osgeo/osr.py
--rw-rw-r--   0 even      (1000) even      (1000)       38 2024-04-04 17:20:23.381591 GDAL-3.8.5/setup.cfg
--rw-rw-r--   0 even      (1000) even      (1000)    14340 2024-04-04 17:09:42.000000 GDAL-3.8.5/setup.py
+drwxrwxr-x   0 even      (1000) even      (1000)        0 2024-05-10 13:50:42.655029 GDAL-3.9.0/
+-rw-r--r--   0 even      (1000) even      (1000)     7316 2024-05-10 13:50:42.655029 GDAL-3.9.0/PKG-INFO
+-rw-rw-r--   0 even      (1000) even      (1000)     6066 2024-05-06 12:37:20.000000 GDAL-3.9.0/README.rst
+drwxrwxr-x   0 even      (1000) even      (1000)        0 2024-05-10 13:50:42.627029 GDAL-3.9.0/extensions/
+-rw-rw-r--   0 even      (1000) even      (1000)   276336 2024-05-06 12:38:38.000000 GDAL-3.9.0/extensions/gdal_array_wrap.cpp
+-rw-rw-r--   0 even      (1000) even      (1000)  1989152 2024-05-06 12:38:37.000000 GDAL-3.9.0/extensions/gdal_wrap.cpp
+-rw-rw-r--   0 even      (1000) even      (1000)   126303 2024-05-06 12:38:35.000000 GDAL-3.9.0/extensions/gdalconst_wrap.c
+-rw-rw-r--   0 even      (1000) even      (1000)   229118 2024-05-06 12:38:36.000000 GDAL-3.9.0/extensions/gnm_wrap.cpp
+-rw-rw-r--   0 even      (1000) even      (1000)  1500217 2024-05-06 12:38:37.000000 GDAL-3.9.0/extensions/ogr_wrap.cpp
+-rw-rw-r--   0 even      (1000) even      (1000)   805678 2024-05-06 12:38:38.000000 GDAL-3.9.0/extensions/osr_wrap.cpp
+drwxrwxr-x   0 even      (1000) even      (1000)        0 2024-05-10 13:50:42.619029 GDAL-3.9.0/gdal-utils/
+drwxrwxr-x   0 even      (1000) even      (1000)        0 2024-05-10 13:50:42.655029 GDAL-3.9.0/gdal-utils/GDAL.egg-info/
+-rw-r--r--   0 even      (1000) even      (1000)     7316 2024-05-10 13:50:42.000000 GDAL-3.9.0/gdal-utils/GDAL.egg-info/PKG-INFO
+-rw-rw-r--   0 even      (1000) even      (1000)     5306 2024-05-10 13:50:42.000000 GDAL-3.9.0/gdal-utils/GDAL.egg-info/SOURCES.txt
+-rw-rw-r--   0 even      (1000) even      (1000)        1 2024-05-10 13:50:42.000000 GDAL-3.9.0/gdal-utils/GDAL.egg-info/dependency_links.txt
+-rw-rw-r--   0 even      (1000) even      (1000)      790 2024-05-10 13:50:42.000000 GDAL-3.9.0/gdal-utils/GDAL.egg-info/entry_points.txt
+-rw-rw-r--   0 even      (1000) even      (1000)        1 2024-04-25 18:04:28.000000 GDAL-3.9.0/gdal-utils/GDAL.egg-info/not-zip-safe
+-rw-rw-r--   0 even      (1000) even      (1000)       21 2024-05-10 13:50:42.000000 GDAL-3.9.0/gdal-utils/GDAL.egg-info/requires.txt
+-rw-rw-r--   0 even      (1000) even      (1000)       18 2024-05-10 13:50:42.000000 GDAL-3.9.0/gdal-utils/GDAL.egg-info/top_level.txt
+drwxrwxr-x   0 even      (1000) even      (1000)        0 2024-05-10 13:50:42.631029 GDAL-3.9.0/gdal-utils/osgeo_utils/
+-rw-rw-r--   0 even      (1000) even      (1000)      432 2024-04-22 11:23:11.000000 GDAL-3.9.0/gdal-utils/osgeo_utils/__init__.py
+drwxrwxr-x   0 even      (1000) even      (1000)        0 2024-05-10 13:50:42.635029 GDAL-3.9.0/gdal-utils/osgeo_utils/auxiliary/
+-rw-rw-r--   0 even      (1000) even      (1000)        0 2024-04-22 11:23:11.000000 GDAL-3.9.0/gdal-utils/osgeo_utils/auxiliary/__init__.py
+-rw-rw-r--   0 even      (1000) even      (1000)     2635 2024-04-22 11:23:11.000000 GDAL-3.9.0/gdal-utils/osgeo_utils/auxiliary/array_util.py
+-rw-rw-r--   0 even      (1000) even      (1000)     4164 2024-04-22 11:23:11.000000 GDAL-3.9.0/gdal-utils/osgeo_utils/auxiliary/base.py
+-rw-rw-r--   0 even      (1000) even      (1000)     3447 2024-04-22 11:23:11.000000 GDAL-3.9.0/gdal-utils/osgeo_utils/auxiliary/batch_creator.py
+-rw-rw-r--   0 even      (1000) even      (1000)    15215 2024-04-22 11:23:11.000000 GDAL-3.9.0/gdal-utils/osgeo_utils/auxiliary/color_palette.py
+-rw-rw-r--   0 even      (1000) even      (1000)     5649 2024-04-22 11:23:11.000000 GDAL-3.9.0/gdal-utils/osgeo_utils/auxiliary/color_table.py
+-rw-rw-r--   0 even      (1000) even      (1000)     5384 2024-04-22 11:23:11.000000 GDAL-3.9.0/gdal-utils/osgeo_utils/auxiliary/extent_util.py
+-rw-rw-r--   0 even      (1000) even      (1000)     8619 2024-04-22 11:23:11.000000 GDAL-3.9.0/gdal-utils/osgeo_utils/auxiliary/gdal_argparse.py
+-rw-rw-r--   0 even      (1000) even      (1000)     2891 2024-04-22 11:23:11.000000 GDAL-3.9.0/gdal-utils/osgeo_utils/auxiliary/numpy_util.py
+-rw-rw-r--   0 even      (1000) even      (1000)     5467 2024-04-22 11:23:11.000000 GDAL-3.9.0/gdal-utils/osgeo_utils/auxiliary/osr_util.py
+-rw-rw-r--   0 even      (1000) even      (1000)     3340 2024-04-22 11:23:11.000000 GDAL-3.9.0/gdal-utils/osgeo_utils/auxiliary/progress.py
+-rw-rw-r--   0 even      (1000) even      (1000)     6671 2024-04-22 11:23:11.000000 GDAL-3.9.0/gdal-utils/osgeo_utils/auxiliary/raster_creation.py
+-rw-rw-r--   0 even      (1000) even      (1000)     8828 2024-04-22 11:23:11.000000 GDAL-3.9.0/gdal-utils/osgeo_utils/auxiliary/rectangle.py
+-rw-rw-r--   0 even      (1000) even      (1000)    17013 2024-04-22 11:23:11.000000 GDAL-3.9.0/gdal-utils/osgeo_utils/auxiliary/util.py
+-rw-rw-r--   0 even      (1000) even      (1000)   172627 2024-05-06 12:01:44.000000 GDAL-3.9.0/gdal-utils/osgeo_utils/gdal2tiles.py
+-rw-rw-r--   0 even      (1000) even      (1000)    15774 2024-04-22 11:23:11.000000 GDAL-3.9.0/gdal-utils/osgeo_utils/gdal2xyz.py
+-rw-rw-r--   0 even      (1000) even      (1000)    36481 2024-04-22 11:23:11.000000 GDAL-3.9.0/gdal-utils/osgeo_utils/gdal_calc.py
+-rwxrwxr-x   0 even      (1000) even      (1000)    17297 2024-04-22 11:23:11.000000 GDAL-3.9.0/gdal-utils/osgeo_utils/gdal_edit.py
+-rw-rw-r--   0 even      (1000) even      (1000)     9421 2024-04-22 11:23:11.000000 GDAL-3.9.0/gdal-utils/osgeo_utils/gdal_fillnodata.py
+-rw-rw-r--   0 even      (1000) even      (1000)    18738 2024-04-22 11:23:11.000000 GDAL-3.9.0/gdal-utils/osgeo_utils/gdal_merge.py
+-rw-rw-r--   0 even      (1000) even      (1000)    12426 2024-04-22 11:23:11.000000 GDAL-3.9.0/gdal-utils/osgeo_utils/gdal_pansharpen.py
+-rw-rw-r--   0 even      (1000) even      (1000)    12525 2024-04-22 11:23:11.000000 GDAL-3.9.0/gdal-utils/osgeo_utils/gdal_polygonize.py
+-rw-rw-r--   0 even      (1000) even      (1000)     7587 2024-04-22 11:23:11.000000 GDAL-3.9.0/gdal-utils/osgeo_utils/gdal_proximity.py
+-rw-rw-r--   0 even      (1000) even      (1000)    38844 2024-04-22 11:23:11.000000 GDAL-3.9.0/gdal-utils/osgeo_utils/gdal_retile.py
+-rw-rw-r--   0 even      (1000) even      (1000)     6682 2024-04-22 11:23:11.000000 GDAL-3.9.0/gdal-utils/osgeo_utils/gdal_sieve.py
+-rw-rw-r--   0 even      (1000) even      (1000)     5200 2024-04-22 11:23:11.000000 GDAL-3.9.0/gdal-utils/osgeo_utils/gdalattachpct.py
+-rw-rw-r--   0 even      (1000) even      (1000)    20209 2024-04-22 11:23:11.000000 GDAL-3.9.0/gdal-utils/osgeo_utils/gdalcompare.py
+-rw-rw-r--   0 even      (1000) even      (1000)    10018 2024-04-22 11:23:11.000000 GDAL-3.9.0/gdal-utils/osgeo_utils/gdalmove.py
+-rw-rw-r--   0 even      (1000) even      (1000)    19311 2024-04-22 11:23:11.000000 GDAL-3.9.0/gdal-utils/osgeo_utils/ogr_layer_algebra.py
+-rw-rw-r--   0 even      (1000) even      (1000)    43981 2024-04-22 11:23:11.000000 GDAL-3.9.0/gdal-utils/osgeo_utils/ogrmerge.py
+-rw-rw-r--   0 even      (1000) even      (1000)     7753 2024-04-22 11:23:11.000000 GDAL-3.9.0/gdal-utils/osgeo_utils/pct2rgb.py
+-rw-rw-r--   0 even      (1000) even      (1000)     7145 2024-04-22 11:23:11.000000 GDAL-3.9.0/gdal-utils/osgeo_utils/rgb2pct.py
+drwxrwxr-x   0 even      (1000) even      (1000)        0 2024-05-10 13:50:42.647029 GDAL-3.9.0/gdal-utils/osgeo_utils/samples/
+-rw-rw-r--   0 even      (1000) even      (1000)        0 2024-04-22 11:23:11.000000 GDAL-3.9.0/gdal-utils/osgeo_utils/samples/__init__.py
+-rw-rw-r--   0 even      (1000) even      (1000)     4632 2024-04-22 11:23:11.000000 GDAL-3.9.0/gdal-utils/osgeo_utils/samples/assemblepoly.py
+-rw-rw-r--   0 even      (1000) even      (1000)    17347 2024-04-22 11:23:11.000000 GDAL-3.9.0/gdal-utils/osgeo_utils/samples/build_jp2_from_xml.py
+-rw-rw-r--   0 even      (1000) even      (1000)     2828 2024-04-22 11:23:11.000000 GDAL-3.9.0/gdal-utils/osgeo_utils/samples/classify.py
+-rw-rw-r--   0 even      (1000) even      (1000)    12326 2024-04-22 11:23:11.000000 GDAL-3.9.0/gdal-utils/osgeo_utils/samples/crs2crs2grid.py
+-rw-rw-r--   0 even      (1000) even      (1000)    16769 2024-04-22 11:23:11.000000 GDAL-3.9.0/gdal-utils/osgeo_utils/samples/densify.py
+-rw-rw-r--   0 even      (1000) even      (1000)     8126 2024-04-22 11:23:11.000000 GDAL-3.9.0/gdal-utils/osgeo_utils/samples/dump_jp2.py
+-rw-rw-r--   0 even      (1000) even      (1000)     9915 2024-04-22 11:23:11.000000 GDAL-3.9.0/gdal-utils/osgeo_utils/samples/epsg_tr.py
+-rw-rw-r--   0 even      (1000) even      (1000)     3238 2024-04-22 11:23:11.000000 GDAL-3.9.0/gdal-utils/osgeo_utils/samples/esri2wkt.py
+-rw-rw-r--   0 even      (1000) even      (1000)     4274 2024-04-22 11:23:11.000000 GDAL-3.9.0/gdal-utils/osgeo_utils/samples/fft.py
+-rw-rw-r--   0 even      (1000) even      (1000)     3008 2024-04-22 11:23:11.000000 GDAL-3.9.0/gdal-utils/osgeo_utils/samples/fix_gpkg.py
+-rw-rw-r--   0 even      (1000) even      (1000)     3193 2024-04-22 11:23:11.000000 GDAL-3.9.0/gdal-utils/osgeo_utils/samples/gcps2ogr.py
+-rw-rw-r--   0 even      (1000) even      (1000)     5419 2024-04-22 11:23:11.000000 GDAL-3.9.0/gdal-utils/osgeo_utils/samples/gcps2vec.py
+-rw-rw-r--   0 even      (1000) even      (1000)     2580 2024-04-22 11:23:11.000000 GDAL-3.9.0/gdal-utils/osgeo_utils/samples/gcps2wld.py
+-rw-rw-r--   0 even      (1000) even      (1000)     5281 2024-04-22 11:23:11.000000 GDAL-3.9.0/gdal-utils/osgeo_utils/samples/gdal2grd.py
+-rw-rw-r--   0 even      (1000) even      (1000)     4451 2024-04-22 11:23:11.000000 GDAL-3.9.0/gdal-utils/osgeo_utils/samples/gdal_auth.py
+-rw-rw-r--   0 even      (1000) even      (1000)     8460 2024-04-22 11:23:11.000000 GDAL-3.9.0/gdal-utils/osgeo_utils/samples/gdal_cp.py
+-rw-rw-r--   0 even      (1000) even      (1000)     2561 2024-04-22 11:23:11.000000 GDAL-3.9.0/gdal-utils/osgeo_utils/samples/gdal_create_pdf.py
+-rw-rw-r--   0 even      (1000) even      (1000)     8693 2024-04-22 11:23:11.000000 GDAL-3.9.0/gdal-utils/osgeo_utils/samples/gdal_ls.py
+-rw-rw-r--   0 even      (1000) even      (1000)     6670 2024-04-22 11:23:11.000000 GDAL-3.9.0/gdal-utils/osgeo_utils/samples/gdal_lut.py
+-rw-rw-r--   0 even      (1000) even      (1000)     2403 2024-04-22 11:23:11.000000 GDAL-3.9.0/gdal-utils/osgeo_utils/samples/gdal_mkdir.py
+-rw-rw-r--   0 even      (1000) even      (1000)     4426 2024-04-22 11:23:11.000000 GDAL-3.9.0/gdal-utils/osgeo_utils/samples/gdal_remove_towgs84.py
+-rw-rw-r--   0 even      (1000) even      (1000)     4035 2024-04-22 11:23:11.000000 GDAL-3.9.0/gdal-utils/osgeo_utils/samples/gdal_rm.py
+-rw-rw-r--   0 even      (1000) even      (1000)     2538 2024-04-22 11:23:11.000000 GDAL-3.9.0/gdal-utils/osgeo_utils/samples/gdal_rmdir.py
+-rw-rw-r--   0 even      (1000) even      (1000)    11900 2024-04-22 11:23:11.000000 GDAL-3.9.0/gdal-utils/osgeo_utils/samples/gdal_vrtmerge.py
+-rwxrwxr-x   0 even      (1000) even      (1000)    11908 2024-04-22 11:23:11.000000 GDAL-3.9.0/gdal-utils/osgeo_utils/samples/gdalbuildvrtofvrt.py
+-rw-rw-r--   0 even      (1000) even      (1000)     3004 2024-04-22 11:23:11.000000 GDAL-3.9.0/gdal-utils/osgeo_utils/samples/gdalchksum.py
+-rw-rw-r--   0 even      (1000) even      (1000)     3004 2024-04-22 11:23:11.000000 GDAL-3.9.0/gdal-utils/osgeo_utils/samples/gdalcopyproj.py
+-rw-rw-r--   0 even      (1000) even      (1000)     6067 2024-04-22 11:23:11.000000 GDAL-3.9.0/gdal-utils/osgeo_utils/samples/gdalfilter.py
+-rw-rw-r--   0 even      (1000) even      (1000)     3021 2024-04-22 11:23:11.000000 GDAL-3.9.0/gdal-utils/osgeo_utils/samples/gdalident.py
+-rw-rw-r--   0 even      (1000) even      (1000)     3036 2024-04-22 11:23:11.000000 GDAL-3.9.0/gdal-utils/osgeo_utils/samples/gdalimport.py
+-rw-rw-r--   0 even      (1000) even      (1000)    22270 2024-04-22 11:23:11.000000 GDAL-3.9.0/gdal-utils/osgeo_utils/samples/gdalinfo.py
+-rw-rw-r--   0 even      (1000) even      (1000)    20066 2024-04-22 11:23:11.000000 GDAL-3.9.0/gdal-utils/osgeo_utils/samples/gdallocationinfo.py
+-rw-rw-r--   0 even      (1000) even      (1000)     4095 2024-04-22 11:23:11.000000 GDAL-3.9.0/gdal-utils/osgeo_utils/samples/get_soundg.py
+-rw-rw-r--   0 even      (1000) even      (1000)     3374 2024-04-22 11:23:11.000000 GDAL-3.9.0/gdal-utils/osgeo_utils/samples/histrep.py
+-rw-rw-r--   0 even      (1000) even      (1000)     8150 2024-04-22 11:23:11.000000 GDAL-3.9.0/gdal-utils/osgeo_utils/samples/hsv_merge.py
+-rw-rw-r--   0 even      (1000) even      (1000)    10510 2024-04-22 11:23:11.000000 GDAL-3.9.0/gdal-utils/osgeo_utils/samples/jpeg_in_tiff_extract.py
+-rw-rw-r--   0 even      (1000) even      (1000)     6440 2024-04-22 11:23:11.000000 GDAL-3.9.0/gdal-utils/osgeo_utils/samples/load2odbc.py
+-rw-rw-r--   0 even      (1000) even      (1000)     8849 2024-04-22 11:23:11.000000 GDAL-3.9.0/gdal-utils/osgeo_utils/samples/loslas2ntv2.py
+-rw-rw-r--   0 even      (1000) even      (1000)     2739 2024-04-22 11:23:11.000000 GDAL-3.9.0/gdal-utils/osgeo_utils/samples/magphase.py
+-rw-rw-r--   0 even      (1000) even      (1000)     2167 2024-04-22 11:23:11.000000 GDAL-3.9.0/gdal-utils/osgeo_utils/samples/make_fuzzer_friendly_archive.py
+-rw-rw-r--   0 even      (1000) even      (1000)     7547 2024-04-22 11:23:11.000000 GDAL-3.9.0/gdal-utils/osgeo_utils/samples/mkgraticule.py
+-rw-rw-r--   0 even      (1000) even      (1000)    12810 2024-04-22 11:23:11.000000 GDAL-3.9.0/gdal-utils/osgeo_utils/samples/ogr2vrt.py
+-rw-rw-r--   0 even      (1000) even      (1000)     7567 2024-04-22 11:23:11.000000 GDAL-3.9.0/gdal-utils/osgeo_utils/samples/ogr_build_junction_table.py
+-rw-rw-r--   0 even      (1000) even      (1000)    14349 2024-04-22 11:23:11.000000 GDAL-3.9.0/gdal-utils/osgeo_utils/samples/ogr_dispatch.py
+-rw-rw-r--   0 even      (1000) even      (1000)    21229 2024-04-22 11:23:11.000000 GDAL-3.9.0/gdal-utils/osgeo_utils/samples/ogrinfo.py
+-rw-rw-r--   0 even      (1000) even      (1000)    19843 2024-04-22 11:23:11.000000 GDAL-3.9.0/gdal-utils/osgeo_utils/samples/ogrupdate.py
+-rw-rw-r--   0 even      (1000) even      (1000)     7724 2024-04-22 11:23:11.000000 GDAL-3.9.0/gdal-utils/osgeo_utils/samples/rel.py
+-rw-rw-r--   0 even      (1000) even      (1000)     7578 2024-04-22 11:23:11.000000 GDAL-3.9.0/gdal-utils/osgeo_utils/samples/tigerpoly.py
+-rw-rw-r--   0 even      (1000) even      (1000)     4368 2024-04-22 11:23:11.000000 GDAL-3.9.0/gdal-utils/osgeo_utils/samples/tile_extent_from_raster.py
+-rw-rw-r--   0 even      (1000) even      (1000)     4055 2024-04-22 11:23:11.000000 GDAL-3.9.0/gdal-utils/osgeo_utils/samples/tolatlong.py
+-rw-rw-r--   0 even      (1000) even      (1000)     4344 2024-04-22 11:23:11.000000 GDAL-3.9.0/gdal-utils/osgeo_utils/samples/val_repl.py
+-rw-rw-r--   0 even      (1000) even      (1000)    18476 2024-04-22 11:23:11.000000 GDAL-3.9.0/gdal-utils/osgeo_utils/samples/validate_cloud_optimized_geotiff.py
+-rw-rw-r--   0 even      (1000) even      (1000)    21281 2024-04-22 11:23:11.000000 GDAL-3.9.0/gdal-utils/osgeo_utils/samples/validate_geoparquet.py
+-rw-rw-r--   0 even      (1000) even      (1000)   113359 2024-04-22 11:23:11.000000 GDAL-3.9.0/gdal-utils/osgeo_utils/samples/validate_gpkg.py
+-rw-rw-r--   0 even      (1000) even      (1000)    70659 2024-04-22 11:23:11.000000 GDAL-3.9.0/gdal-utils/osgeo_utils/samples/validate_jp2.py
+-rw-rw-r--   0 even      (1000) even      (1000)     4768 2024-04-22 11:23:11.000000 GDAL-3.9.0/gdal-utils/osgeo_utils/samples/vec_tr.py
+-rw-rw-r--   0 even      (1000) even      (1000)     4843 2024-04-22 11:23:11.000000 GDAL-3.9.0/gdal-utils/osgeo_utils/samples/vec_tr_spat.py
+-rw-rw-r--   0 even      (1000) even      (1000)     7103 2024-04-22 11:23:11.000000 GDAL-3.9.0/gdal-utils/osgeo_utils/samples/wcs_virtds_params.py
+drwxrwxr-x   0 even      (1000) even      (1000)        0 2024-05-10 13:50:42.651029 GDAL-3.9.0/gdal-utils/scripts/
+-rwxrwxr-x   0 even      (1000) even      (1000)      579 2024-04-22 11:23:11.000000 GDAL-3.9.0/gdal-utils/scripts/gdal2tiles.py
+-rwxrwxr-x   0 even      (1000) even      (1000)      311 2024-04-22 11:23:11.000000 GDAL-3.9.0/gdal-utils/scripts/gdal2xyz.py
+-rwxrwxr-x   0 even      (1000) even      (1000)      315 2024-04-22 11:23:11.000000 GDAL-3.9.0/gdal-utils/scripts/gdal_calc.py
+-rwxrwxr-x   0 even      (1000) even      (1000)      315 2024-04-22 11:23:11.000000 GDAL-3.9.0/gdal-utils/scripts/gdal_edit.py
+-rwxrwxr-x   0 even      (1000) even      (1000)      339 2024-04-22 11:23:11.000000 GDAL-3.9.0/gdal-utils/scripts/gdal_fillnodata.py
+-rwxrwxr-x   0 even      (1000) even      (1000)      319 2024-04-22 11:23:11.000000 GDAL-3.9.0/gdal-utils/scripts/gdal_merge.py
+-rwxrwxr-x   0 even      (1000) even      (1000)      339 2024-04-22 11:23:11.000000 GDAL-3.9.0/gdal-utils/scripts/gdal_pansharpen.py
+-rwxrwxr-x   0 even      (1000) even      (1000)      339 2024-04-22 11:23:11.000000 GDAL-3.9.0/gdal-utils/scripts/gdal_polygonize.py
+-rwxrwxr-x   0 even      (1000) even      (1000)      335 2024-04-22 11:23:11.000000 GDAL-3.9.0/gdal-utils/scripts/gdal_proximity.py
+-rwxrwxr-x   0 even      (1000) even      (1000)      323 2024-04-22 11:23:11.000000 GDAL-3.9.0/gdal-utils/scripts/gdal_retile.py
+-rwxrwxr-x   0 even      (1000) even      (1000)      319 2024-04-22 11:23:11.000000 GDAL-3.9.0/gdal-utils/scripts/gdal_sieve.py
+-rwxrwxr-x   0 even      (1000) even      (1000)      331 2024-04-22 11:23:11.000000 GDAL-3.9.0/gdal-utils/scripts/gdalattachpct.py
+-rwxrwxr-x   0 even      (1000) even      (1000)      323 2024-04-22 11:23:11.000000 GDAL-3.9.0/gdal-utils/scripts/gdalcompare.py
+-rwxrwxr-x   0 even      (1000) even      (1000)      311 2024-04-22 11:23:11.000000 GDAL-3.9.0/gdal-utils/scripts/gdalmove.py
+-rwxrwxr-x   0 even      (1000) even      (1000)      347 2024-04-22 11:23:11.000000 GDAL-3.9.0/gdal-utils/scripts/ogr_layer_algebra.py
+-rwxrwxr-x   0 even      (1000) even      (1000)      311 2024-04-22 11:23:11.000000 GDAL-3.9.0/gdal-utils/scripts/ogrmerge.py
+-rwxrwxr-x   0 even      (1000) even      (1000)      307 2024-04-22 11:23:11.000000 GDAL-3.9.0/gdal-utils/scripts/pct2rgb.py
+-rwxrwxr-x   0 even      (1000) even      (1000)      307 2024-04-22 11:23:11.000000 GDAL-3.9.0/gdal-utils/scripts/rgb2pct.py
+drwxrwxr-x   0 even      (1000) even      (1000)        0 2024-05-10 13:50:42.651029 GDAL-3.9.0/osgeo/
+-rw-rw-r--   0 even      (1000) even      (1000)     4758 2024-05-06 12:38:38.000000 GDAL-3.9.0/osgeo/__init__.py
+-rw-rw-r--   0 even      (1000) even      (1000)   324800 2024-05-06 12:38:38.000000 GDAL-3.9.0/osgeo/gdal.py
+-rw-rw-r--   0 even      (1000) even      (1000)    32601 2024-05-06 12:38:38.000000 GDAL-3.9.0/osgeo/gdal_array.py
+-rw-rw-r--   0 even      (1000) even      (1000)    12420 2024-05-06 12:38:38.000000 GDAL-3.9.0/osgeo/gdalconst.py
+-rw-rw-r--   0 even      (1000) even      (1000)      214 2024-05-06 12:38:38.000000 GDAL-3.9.0/osgeo/gdalnumeric.py
+-rw-rw-r--   0 even      (1000) even      (1000)    13770 2024-05-06 12:38:38.000000 GDAL-3.9.0/osgeo/gnm.py
+-rw-rw-r--   0 even      (1000) even      (1000)   234847 2024-05-06 12:38:38.000000 GDAL-3.9.0/osgeo/ogr.py
+-rw-rw-r--   0 even      (1000) even      (1000)    81743 2024-05-06 12:38:38.000000 GDAL-3.9.0/osgeo/osr.py
+-rw-rw-r--   0 even      (1000) even      (1000)     1407 2024-05-06 12:37:20.000000 GDAL-3.9.0/pyproject.toml
+-rw-rw-r--   0 even      (1000) even      (1000)       38 2024-05-10 13:50:42.655029 GDAL-3.9.0/setup.cfg
+-rw-rw-r--   0 even      (1000) even      (1000)    17372 2024-05-06 12:37:20.000000 GDAL-3.9.0/setup.py
```

### Comparing `GDAL-3.8.5/PKG-INFO` & `GDAL-3.9.0/PKG-INFO`

 * *Files 23% similar despite different names*

```diff
@@ -1,28 +1,34 @@
 Metadata-Version: 2.1
 Name: GDAL
-Version: 3.8.5
+Version: 3.9.0
 Summary: GDAL: Geospatial Data Abstraction Library
 Home-page: http://www.gdal.org
-Author: Frank Warmerdam
+Author: Frank Warmerdam, Howard Butler, Even Rouault
 Author-email: warmerdam@pobox.com
-Maintainer: Howard Butler
-Maintainer-email: hobu.inc@gmail.com
+Maintainer: GDAL contributors
+Maintainer-email: GDAL contributors <gdal-dev@lists.osgeo.org>
 License: MIT
+Project-URL: Homepage, https://gdal.org
+Project-URL: Documentation, https://gdal.org
+Project-URL: Repository, https://github.com/OSGeo/GDAL.git
+Project-URL: Changelog, https://github.com/OSGeo/gdal/blob/master/NEWS.md
+Project-URL: Issues, https://github.com/OSGeo/gdal/issues
+Keywords: gis,raster,vector
 Classifier: Development Status :: 5 - Production/Stable
 Classifier: Intended Audience :: Developers
 Classifier: Intended Audience :: Science/Research
 Classifier: License :: OSI Approved :: MIT License
 Classifier: Operating System :: OS Independent
 Classifier: Programming Language :: Python :: 3
 Classifier: Programming Language :: C
 Classifier: Programming Language :: C++
 Classifier: Topic :: Scientific/Engineering :: GIS
 Classifier: Topic :: Scientific/Engineering :: Information Analysis
-Requires-Python: >=3.6.0
+Requires-Python: >=3.8.0
 Description-Content-Type: text/x-rst
 Provides-Extra: numpy
 Requires-Dist: numpy>1.0.0; extra == "numpy"
 
 
 GDAL/OGR in Python
 ==================
@@ -34,15 +40,15 @@
 bindings for GDAL/OGR. Generally speaking the classes and methods mostly
 match those of the GDAL and OGR C++ classes. There is no Python specific
 reference documentation, but the https://gdal.org/api/python_bindings.html#tutorials includes Python examples.
 
 Dependencies
 ------------
 
- * libgdal (3.8.5 or greater) and header files (gdal-devel)
+ * libgdal (3.9.0 or greater) and header files (gdal-devel)
  * numpy (1.0.0 or greater) and header files (numpy-devel) (not explicitly
    required, but many examples and utilities will not work without it)
 
 Installation
 ------------
 
 Conda
@@ -57,37 +63,76 @@
 
 https://conda-forge.org/
 
 Once you have Anaconda or Miniconda installed, you should be able to install GDAL with:
 
 ``conda install -c conda-forge gdal``
 
-Unix
-~~~~
-
-The GDAL Python bindings requires setuptools.
 
 pip
 ~~~
 
+Due to the complex nature of GDAL and its components, different bindings may require additional packages and installation steps.
 GDAL can be installed from the `Python Package Index <https://pypi.org/project/GDAL>`__:
 
 ::
 
-    pip install GDAL
+    pip install gdal
+
+
+In order to enable numpy-based raster support, libgdal and its development headers must be installed as well as the Python packages numpy, setuptools, and wheel.
+To install the Python dependencies and build numpy-based raster support:
+
+
+::
+
+    pip install numpy>1.0.0 wheel setuptools>=67
+    pip install gdal[numpy]=="$(gdal-config --version).*"
+
+
+Users can verify that numpy-based raster support has been installed with:
+
+::
+
+    python3 -c 'from osgeo import gdal_array'
 
-It will be necessary to have libgdal and its development headers installed
-if pip is expected to do a source build because no wheel is available
-for your specified platform and Python version.
 
-To install the version of the Python bindings matching your native GDAL library:
+If this command raises an ImportError, numpy-based raster support has not been properly installed:
 
 ::
 
-    pip install GDAL=="$(gdal-config --version).*"
+    Traceback (most recent call last):
+    File "<string>", line 1, in <module>
+    File "/usr/local/lib/python3.12/dist-packages/osgeo/gdal_array.py", line 10, in <module>
+      from . import _gdal_array
+    ImportError: cannot import name '_gdal_array' from 'osgeo' (/usr/local/lib/python3.12/dist-packages/osgeo/__init__.py)
+
+
+This is most often due to pip reusing a cached GDAL installation.
+Verify that the necessary dependencies have been installed and then run the following to force a clean build:
+
+::
+    pip install --no-cache --force-reinstall gdal[numpy]=="$(gdal-config --version).*"
+
+
+Potential issues with GDAL >= 3.9, Python >= 3.9 and NumPy 2.0
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+The pyproject.toml file of GDAL 3.9 requires numpy >= 2.0.0rc1 (for Python >= 3.9)
+at build time to be able to build bindings that are compatible of both NumPy 1
+and NumPy 2.
+If for some reason the numpy >= 2.0.0rc1 build dependency can not be installed,
+it is possible to manually install the build requirements, and invoke ``pip install``
+with the ``--no-build-isolation`` flag.
+
+::
+
+    pip install numpy==<required_version> wheel setuptools>=67
+    pip install gdal[numpy]=="$(gdal-config --version).*" --no-build-isolation
+
 
 Building as part of the GDAL library source tree
 ------------------------------------------------
 
 Python bindings are generated by default when building GDAL from source.
 For more detail, see `Python bindings options <https://gdal.org/development/building_from_source.html#building-python-bindings>`__
```

### Comparing `GDAL-3.8.5/README.rst` & `GDAL-3.9.0/README.rst`

 * *Files 17% similar despite different names*

```diff
@@ -9,15 +9,15 @@
 bindings for GDAL/OGR. Generally speaking the classes and methods mostly
 match those of the GDAL and OGR C++ classes. There is no Python specific
 reference documentation, but the https://gdal.org/api/python_bindings.html#tutorials includes Python examples.
 
 Dependencies
 ------------
 
- * libgdal (3.8.5 or greater) and header files (gdal-devel)
+ * libgdal (3.9.0 or greater) and header files (gdal-devel)
  * numpy (1.0.0 or greater) and header files (numpy-devel) (not explicitly
    required, but many examples and utilities will not work without it)
 
 Installation
 ------------
 
 Conda
@@ -32,37 +32,76 @@
 
 https://conda-forge.org/
 
 Once you have Anaconda or Miniconda installed, you should be able to install GDAL with:
 
 ``conda install -c conda-forge gdal``
 
-Unix
-~~~~
-
-The GDAL Python bindings requires setuptools.
 
 pip
 ~~~
 
+Due to the complex nature of GDAL and its components, different bindings may require additional packages and installation steps.
 GDAL can be installed from the `Python Package Index <https://pypi.org/project/GDAL>`__:
 
 ::
 
-    pip install GDAL
+    pip install gdal
+
+
+In order to enable numpy-based raster support, libgdal and its development headers must be installed as well as the Python packages numpy, setuptools, and wheel.
+To install the Python dependencies and build numpy-based raster support:
+
+
+::
+
+    pip install numpy>1.0.0 wheel setuptools>=67
+    pip install gdal[numpy]=="$(gdal-config --version).*"
+
+
+Users can verify that numpy-based raster support has been installed with:
+
+::
+
+    python3 -c 'from osgeo import gdal_array'
 
-It will be necessary to have libgdal and its development headers installed
-if pip is expected to do a source build because no wheel is available
-for your specified platform and Python version.
 
-To install the version of the Python bindings matching your native GDAL library:
+If this command raises an ImportError, numpy-based raster support has not been properly installed:
 
 ::
 
-    pip install GDAL=="$(gdal-config --version).*"
+    Traceback (most recent call last):
+    File "<string>", line 1, in <module>
+    File "/usr/local/lib/python3.12/dist-packages/osgeo/gdal_array.py", line 10, in <module>
+      from . import _gdal_array
+    ImportError: cannot import name '_gdal_array' from 'osgeo' (/usr/local/lib/python3.12/dist-packages/osgeo/__init__.py)
+
+
+This is most often due to pip reusing a cached GDAL installation.
+Verify that the necessary dependencies have been installed and then run the following to force a clean build:
+
+::
+    pip install --no-cache --force-reinstall gdal[numpy]=="$(gdal-config --version).*"
+
+
+Potential issues with GDAL >= 3.9, Python >= 3.9 and NumPy 2.0
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+The pyproject.toml file of GDAL 3.9 requires numpy >= 2.0.0rc1 (for Python >= 3.9)
+at build time to be able to build bindings that are compatible of both NumPy 1
+and NumPy 2.
+If for some reason the numpy >= 2.0.0rc1 build dependency can not be installed,
+it is possible to manually install the build requirements, and invoke ``pip install``
+with the ``--no-build-isolation`` flag.
+
+::
+
+    pip install numpy==<required_version> wheel setuptools>=67
+    pip install gdal[numpy]=="$(gdal-config --version).*" --no-build-isolation
+
 
 Building as part of the GDAL library source tree
 ------------------------------------------------
 
 Python bindings are generated by default when building GDAL from source.
 For more detail, see `Python bindings options <https://gdal.org/development/building_from_source.html#building-python-bindings>`__
```

### Comparing `GDAL-3.8.5/extensions/gdal_array_wrap.cpp` & `GDAL-3.9.0/extensions/gdal_array_wrap.cpp`

 * *Files 0% similar despite different names*

```diff
@@ -3149,25 +3149,14 @@
       _obj = obj;
       return *this;      
     }
   };
 }
 
 
-// Define this unconditionally of whether DEBUG_BOOL is defined or not,
-// since we do not pass -DDEBUG_BOOL when building the bindings
-#define DO_NOT_USE_DEBUG_BOOL
-
-// So that override is properly defined
-#ifndef GDAL_COMPILATION
-#define GDAL_COMPILATION
-#endif
-
-
-
 #include "gdal.h"
 
 typedef struct
 {
     CPLVirtualMem *vmem;
     int            bAuto;
     GDALDataType   eBufType;
```

### Comparing `GDAL-3.8.5/extensions/gdal_wrap.cpp` & `GDAL-3.9.0/extensions/gdal_wrap.cpp`

 * *Files 2% similar despite different names*

```diff
@@ -3013,60 +3013,64 @@
 #define SWIGTYPE_p_GDALNearblackOptions swig_types[26]
 #define SWIGTYPE_p_GDALProgressFunc swig_types[27]
 #define SWIGTYPE_p_GDALRasterAttributeTableShadow swig_types[28]
 #define SWIGTYPE_p_GDALRasterBandShadow swig_types[29]
 #define SWIGTYPE_p_GDALRasterizeOptions swig_types[30]
 #define SWIGTYPE_p_GDALRelationshipShadow swig_types[31]
 #define SWIGTYPE_p_GDALSubdatasetInfo swig_types[32]
-#define SWIGTYPE_p_GDALTransformerInfoShadow swig_types[33]
-#define SWIGTYPE_p_GDALTranslateOptions swig_types[34]
-#define SWIGTYPE_p_GDALVectorInfoOptions swig_types[35]
-#define SWIGTYPE_p_GDALVectorTranslateOptions swig_types[36]
-#define SWIGTYPE_p_GDALViewshedMode swig_types[37]
-#define SWIGTYPE_p_GDALViewshedOutputType swig_types[38]
-#define SWIGTYPE_p_GDALWarpAppOptions swig_types[39]
-#define SWIGTYPE_p_GDAL_GCP swig_types[40]
-#define SWIGTYPE_p_GIntBig swig_types[41]
-#define SWIGTYPE_p_GUIntBig swig_types[42]
-#define SWIGTYPE_p_OGRFeatureShadow swig_types[43]
-#define SWIGTYPE_p_OGRFieldDomainShadow swig_types[44]
-#define SWIGTYPE_p_OGRGeometryShadow swig_types[45]
-#define SWIGTYPE_p_OGRLayerShadow swig_types[46]
-#define SWIGTYPE_p_OGRStyleTableShadow swig_types[47]
-#define SWIGTYPE_p_OSRSpatialReferenceShadow swig_types[48]
-#define SWIGTYPE_p_StatBuf swig_types[49]
-#define SWIGTYPE_p_Statistics swig_types[50]
-#define SWIGTYPE_p_SuggestedWarpOutputRes swig_types[51]
-#define SWIGTYPE_p_VSIDIR swig_types[52]
-#define SWIGTYPE_p_VSILFILE swig_types[53]
-#define SWIGTYPE_p_char swig_types[54]
-#define SWIGTYPE_p_double swig_types[55]
-#define SWIGTYPE_p_f_double_p_q_const__char_p_void__int swig_types[56]
-#define SWIGTYPE_p_int swig_types[57]
-#define SWIGTYPE_p_p_GByte swig_types[58]
-#define SWIGTYPE_p_p_GDALDatasetShadow swig_types[59]
-#define SWIGTYPE_p_p_GDALDimensionHS swig_types[60]
-#define SWIGTYPE_p_p_GDALEDTComponentHS swig_types[61]
-#define SWIGTYPE_p_p_GDALRasterBandShadow swig_types[62]
-#define SWIGTYPE_p_p_GDAL_GCP swig_types[63]
-#define SWIGTYPE_p_p_GUIntBig swig_types[64]
-#define SWIGTYPE_p_p_OGRLayerShadow swig_types[65]
-#define SWIGTYPE_p_p_OSRSpatialReferenceShadow swig_types[66]
-#define SWIGTYPE_p_p_char swig_types[67]
-#define SWIGTYPE_p_p_double swig_types[68]
-#define SWIGTYPE_p_p_int swig_types[69]
-#define SWIGTYPE_p_p_p_GDALAttributeHS swig_types[70]
-#define SWIGTYPE_p_p_p_GDALDimensionHS swig_types[71]
-#define SWIGTYPE_p_p_p_GDALEDTComponentHS swig_types[72]
-#define SWIGTYPE_p_p_p_GDALMDArrayHS swig_types[73]
-#define SWIGTYPE_p_p_void swig_types[74]
-#define SWIGTYPE_p_size_t swig_types[75]
-#define SWIGTYPE_p_vsi_l_offset swig_types[76]
-static swig_type_info *swig_types[78];
-static swig_module_info swig_module = {swig_types, 77, 0, 0, 0, 0};
+#define SWIGTYPE_p_GDALTileIndexOptions swig_types[33]
+#define SWIGTYPE_p_GDALTransformerInfoShadow swig_types[34]
+#define SWIGTYPE_p_GDALTranslateOptions swig_types[35]
+#define SWIGTYPE_p_GDALVectorInfoOptions swig_types[36]
+#define SWIGTYPE_p_GDALVectorTranslateOptions swig_types[37]
+#define SWIGTYPE_p_GDALViewshedMode swig_types[38]
+#define SWIGTYPE_p_GDALViewshedOutputType swig_types[39]
+#define SWIGTYPE_p_GDALWarpAppOptions swig_types[40]
+#define SWIGTYPE_p_GDAL_GCP swig_types[41]
+#define SWIGTYPE_p_GIntBig swig_types[42]
+#define SWIGTYPE_p_GUIntBig swig_types[43]
+#define SWIGTYPE_p_OGRFeatureShadow swig_types[44]
+#define SWIGTYPE_p_OGRFieldDomainShadow swig_types[45]
+#define SWIGTYPE_p_OGRGeomFieldDefnShadow swig_types[46]
+#define SWIGTYPE_p_OGRGeometryShadow swig_types[47]
+#define SWIGTYPE_p_OGRLayerShadow swig_types[48]
+#define SWIGTYPE_p_OGRStyleTableShadow swig_types[49]
+#define SWIGTYPE_p_OSRSpatialReferenceShadow swig_types[50]
+#define SWIGTYPE_p_StatBuf swig_types[51]
+#define SWIGTYPE_p_Statistics swig_types[52]
+#define SWIGTYPE_p_SuggestedWarpOutputRes swig_types[53]
+#define SWIGTYPE_p_VSIDIR swig_types[54]
+#define SWIGTYPE_p_VSILFILE swig_types[55]
+#define SWIGTYPE_p_bool swig_types[56]
+#define SWIGTYPE_p_char swig_types[57]
+#define SWIGTYPE_p_double swig_types[58]
+#define SWIGTYPE_p_f_double_p_q_const__char_p_void__int swig_types[59]
+#define SWIGTYPE_p_int swig_types[60]
+#define SWIGTYPE_p_p_GByte swig_types[61]
+#define SWIGTYPE_p_p_GDALDatasetShadow swig_types[62]
+#define SWIGTYPE_p_p_GDALDimensionHS swig_types[63]
+#define SWIGTYPE_p_p_GDALEDTComponentHS swig_types[64]
+#define SWIGTYPE_p_p_GDALMDArrayHS swig_types[65]
+#define SWIGTYPE_p_p_GDALRasterBandShadow swig_types[66]
+#define SWIGTYPE_p_p_GDAL_GCP swig_types[67]
+#define SWIGTYPE_p_p_GUIntBig swig_types[68]
+#define SWIGTYPE_p_p_OGRLayerShadow swig_types[69]
+#define SWIGTYPE_p_p_OSRSpatialReferenceShadow swig_types[70]
+#define SWIGTYPE_p_p_char swig_types[71]
+#define SWIGTYPE_p_p_double swig_types[72]
+#define SWIGTYPE_p_p_int swig_types[73]
+#define SWIGTYPE_p_p_p_GDALAttributeHS swig_types[74]
+#define SWIGTYPE_p_p_p_GDALDimensionHS swig_types[75]
+#define SWIGTYPE_p_p_p_GDALEDTComponentHS swig_types[76]
+#define SWIGTYPE_p_p_p_GDALMDArrayHS swig_types[77]
+#define SWIGTYPE_p_p_void swig_types[78]
+#define SWIGTYPE_p_size_t swig_types[79]
+#define SWIGTYPE_p_vsi_l_offset swig_types[80]
+static swig_type_info *swig_types[82];
+static swig_module_info swig_module = {swig_types, 81, 0, 0, 0, 0};
 #define SWIG_TypeQuery(name) SWIG_TypeQueryModule(&swig_module, &swig_module, name)
 #define SWIG_MangledTypeQuery(name) SWIG_MangledTypeQueryModule(&swig_module, &swig_module, name)
 
 /* -------- TYPES TABLE (END) -------- */
 
 #ifdef SWIG_TypeQuery
 # undef SWIG_TypeQuery
@@ -3263,14 +3267,15 @@
 typedef void OGRLayerShadow;
 typedef void OGRFeatureShadow;
 typedef void OGRGeometryShadow;
 #endif
 
 typedef struct OGRStyleTableHS OGRStyleTableShadow;
 typedef struct OGRFieldDomainHS OGRFieldDomainShadow;
+typedef struct OGRGeomFieldDefnHS OGRGeomFieldDefnShadow;
 
 
 /* use this to not return the int returned by GDAL */
 typedef int RETURN_NONE;
 /* return value that is used for VSI methods that return -1 on error (and set errno) */
 typedef int VSI_RETVAL;
 
@@ -5685,14 +5690,21 @@
     OGRLayerShadow* layer = (OGRLayerShadow*) GDALDatasetCreateLayer( self,
                                   name,
                                   srs,
                                   geom_type,
                                   options);
     return layer;
   }
+SWIGINTERN OGRLayerShadow *GDALDatasetShadow_CreateLayerFromGeomFieldDefn(GDALDatasetShadow *self,char const *name,OGRGeomFieldDefnShadow *geom_field,char **options=0){
+    OGRLayerShadow* layer = (OGRLayerShadow*) GDALDatasetCreateLayerFromGeomFieldDefn( self,
+                                  name,
+                                  geom_field,
+                                  options);
+    return layer;
+  }
 SWIGINTERN OGRLayerShadow *GDALDatasetShadow_CopyLayer(GDALDatasetShadow *self,OGRLayerShadow *src_layer,char const *new_name,char **options=0){
     OGRLayerShadow* layer = (OGRLayerShadow*) GDALDatasetCopyLayer( self,
                                                       src_layer,
                                                       new_name,
                                                       options);
     return layer;
   }
@@ -5726,32 +5738,17 @@
   case OGRERR_NON_EXISTING_FEATURE:
     return "OGR Error: Non existing feature";
   default:
     return "OGR Error: Unknown";
   }
 }
 
-SWIGINTERN int GDALDatasetShadow_GetLayerCount(GDALDatasetShadow *self){
-    return GDALDatasetGetLayerCount(self);
-  }
 SWIGINTERN bool GDALDatasetShadow_IsLayerPrivate(GDALDatasetShadow *self,int index){
     return GDALDatasetIsLayerPrivate(self, index);
   }
-SWIGINTERN OGRLayerShadow *GDALDatasetShadow_GetLayerByIndex(GDALDatasetShadow *self,int index=0){
-
-    OGRLayerShadow* layer = (OGRLayerShadow*) GDALDatasetGetLayer(self, index);
-    return layer;
-  }
-SWIGINTERN OGRLayerShadow *GDALDatasetShadow_GetLayerByName(GDALDatasetShadow *self,char const *layer_name){
-    OGRLayerShadow* layer = (OGRLayerShadow*) GDALDatasetGetLayerByName(self, layer_name);
-    return layer;
-  }
-SWIGINTERN void GDALDatasetShadow_ResetReading(GDALDatasetShadow *self){
-    GDALDatasetResetReading( self );
-  }
 
 SWIGINTERN int
 SWIG_AsVal_bool (PyObject *obj, bool *val)
 {
   int r;
   if (!PyBool_Check(obj))
     return SWIG_ERROR;
@@ -5782,14 +5779,31 @@
 SWIGINTERN OGRStyleTableShadow *GDALDatasetShadow_GetStyleTable(GDALDatasetShadow *self){
     return (OGRStyleTableShadow*) GDALDatasetGetStyleTable(self);
   }
 SWIGINTERN void GDALDatasetShadow_SetStyleTable(GDALDatasetShadow *self,OGRStyleTableShadow *table){
     if( table != NULL )
         GDALDatasetSetStyleTable(self, (OGRStyleTableH) table);
   }
+SWIGINTERN OGRLayerShadow *GDALDatasetShadow_GetLayerByIndex(GDALDatasetShadow *self,int index=0){
+
+
+
+    OGRLayerShadow* layer = (OGRLayerShadow*) GDALDatasetGetLayer(self, index);
+    return layer;
+  }
+SWIGINTERN OGRLayerShadow *GDALDatasetShadow_GetLayerByName(GDALDatasetShadow *self,char const *layer_name){
+    OGRLayerShadow* layer = (OGRLayerShadow*) GDALDatasetGetLayerByName(self, layer_name);
+    return layer;
+  }
+SWIGINTERN void GDALDatasetShadow_ResetReading(GDALDatasetShadow *self){
+    GDALDatasetResetReading(self);
+  }
+SWIGINTERN int GDALDatasetShadow_GetLayerCount(GDALDatasetShadow *self){
+    return GDALDatasetGetLayerCount(self);
+  }
 SWIGINTERN OGRErr GDALDatasetShadow_AbortSQL(GDALDatasetShadow *self){
     return GDALDatasetAbortSQL(self);
 }
 SWIGINTERN OGRErr GDALDatasetShadow_StartTransaction(GDALDatasetShadow *self,int force=FALSE){
     return GDALDatasetStartTransaction(self, force);
   }
 SWIGINTERN OGRErr GDALDatasetShadow_CommitTransaction(GDALDatasetShadow *self){
@@ -5882,15 +5896,15 @@
             memset(data, 0, buf_size);
         }
         else if( band_list > 1 && band_space != 0 )
         {
             if( line_space != 0 && band_space > line_space * nysize )
                 memset(data, 0, buf_size);
             else if( pixel_space != 0 && band_space < pixel_space &&
-                     pixel_space != GDALGetRasterCount(self) * ntypesize )
+                     pixel_space != (GIntBig)GDALGetRasterCount(self) * ntypesize )
                 memset(data, 0, buf_size);
         }
     }
 
     GDALRasterIOExtraArg sExtraArg;
     INIT_RASTERIO_EXTRA_ARG(sExtraArg);
     sExtraArg.eResampleAlg = resample_alg;
@@ -5927,14 +5941,99 @@
 int GDALDatasetShadow_RasterYSize_get( GDALDatasetShadow *h ) {
   return GDALGetRasterYSize( h );
 }
 int GDALDatasetShadow_RasterCount_get( GDALDatasetShadow *h ) {
   return GDALGetRasterCount( h );
 }
 
+SWIGINTERN GDALRasterAttributeTableShadow *new_GDALRasterAttributeTableShadow(){
+        return (GDALRasterAttributeTableShadow*)
+		GDALCreateRasterAttributeTable();
+    }
+SWIGINTERN void delete_GDALRasterAttributeTableShadow(GDALRasterAttributeTableShadow *self){
+        GDALDestroyRasterAttributeTable(self);
+    }
+SWIGINTERN GDALRasterAttributeTableShadow *GDALRasterAttributeTableShadow_Clone(GDALRasterAttributeTableShadow *self){
+        return (GDALRasterAttributeTableShadow*) GDALRATClone(self);
+    }
+SWIGINTERN int GDALRasterAttributeTableShadow_GetColumnCount(GDALRasterAttributeTableShadow *self){
+        return GDALRATGetColumnCount( self );
+    }
+SWIGINTERN char const *GDALRasterAttributeTableShadow_GetNameOfCol(GDALRasterAttributeTableShadow *self,int iCol){
+        return GDALRATGetNameOfCol( self, iCol );
+    }
+SWIGINTERN GDALRATFieldUsage GDALRasterAttributeTableShadow_GetUsageOfCol(GDALRasterAttributeTableShadow *self,int iCol){
+        return GDALRATGetUsageOfCol( self, iCol );
+    }
+SWIGINTERN GDALRATFieldType GDALRasterAttributeTableShadow_GetTypeOfCol(GDALRasterAttributeTableShadow *self,int iCol){
+        return GDALRATGetTypeOfCol( self, iCol );
+    }
+SWIGINTERN int GDALRasterAttributeTableShadow_GetColOfUsage(GDALRasterAttributeTableShadow *self,GDALRATFieldUsage eUsage){
+        return GDALRATGetColOfUsage( self, eUsage );
+    }
+SWIGINTERN int GDALRasterAttributeTableShadow_GetRowCount(GDALRasterAttributeTableShadow *self){
+        return GDALRATGetRowCount( self );
+    }
+SWIGINTERN char const *GDALRasterAttributeTableShadow_GetValueAsString(GDALRasterAttributeTableShadow *self,int iRow,int iCol){
+        return GDALRATGetValueAsString( self, iRow, iCol );
+    }
+SWIGINTERN int GDALRasterAttributeTableShadow_GetValueAsInt(GDALRasterAttributeTableShadow *self,int iRow,int iCol){
+        return GDALRATGetValueAsInt( self, iRow, iCol );
+    }
+SWIGINTERN double GDALRasterAttributeTableShadow_GetValueAsDouble(GDALRasterAttributeTableShadow *self,int iRow,int iCol){
+        return GDALRATGetValueAsDouble( self, iRow, iCol );
+    }
+SWIGINTERN CPLErr GDALRasterAttributeTableShadow_ReadValuesIOAsString(GDALRasterAttributeTableShadow *self,int iField,int iStartRow,int iLength,char **ppszData){
+        return GDALRATValuesIOAsString(self, GF_Read, iField, iStartRow, iLength, ppszData);
+    }
+SWIGINTERN CPLErr GDALRasterAttributeTableShadow_ReadValuesIOAsInteger(GDALRasterAttributeTableShadow *self,int iField,int iStartRow,int iLength,int *pnData){
+        return GDALRATValuesIOAsInteger(self, GF_Read, iField, iStartRow, iLength, pnData);
+    }
+SWIGINTERN CPLErr GDALRasterAttributeTableShadow_ReadValuesIOAsDouble(GDALRasterAttributeTableShadow *self,int iField,int iStartRow,int iLength,double *pdfData){
+        return GDALRATValuesIOAsDouble(self, GF_Read, iField, iStartRow, iLength, pdfData);
+    }
+SWIGINTERN void GDALRasterAttributeTableShadow_SetValueAsString(GDALRasterAttributeTableShadow *self,int iRow,int iCol,char const *pszValue){
+        GDALRATSetValueAsString( self, iRow, iCol, pszValue );
+    }
+SWIGINTERN void GDALRasterAttributeTableShadow_SetValueAsInt(GDALRasterAttributeTableShadow *self,int iRow,int iCol,int nValue){
+        GDALRATSetValueAsInt( self, iRow, iCol, nValue );
+    }
+SWIGINTERN void GDALRasterAttributeTableShadow_SetValueAsDouble(GDALRasterAttributeTableShadow *self,int iRow,int iCol,double dfValue){
+        GDALRATSetValueAsDouble( self, iRow, iCol, dfValue );
+    }
+SWIGINTERN void GDALRasterAttributeTableShadow_SetRowCount(GDALRasterAttributeTableShadow *self,int nCount){
+        GDALRATSetRowCount( self, nCount );
+    }
+SWIGINTERN int GDALRasterAttributeTableShadow_CreateColumn(GDALRasterAttributeTableShadow *self,char const *pszName,GDALRATFieldType eType,GDALRATFieldUsage eUsage){
+        return GDALRATCreateColumn( self, pszName, eType, eUsage );
+    }
+SWIGINTERN bool GDALRasterAttributeTableShadow_GetLinearBinning(GDALRasterAttributeTableShadow *self,double *pdfRow0Min,double *pdfBinSize){
+        return (GDALRATGetLinearBinning(self, pdfRow0Min, pdfBinSize) != 0) ? true : false;
+    }
+SWIGINTERN int GDALRasterAttributeTableShadow_SetLinearBinning(GDALRasterAttributeTableShadow *self,double dfRow0Min,double dfBinSize){
+        return GDALRATSetLinearBinning(self, dfRow0Min, dfBinSize);
+    }
+SWIGINTERN int GDALRasterAttributeTableShadow_GetRowOfValue(GDALRasterAttributeTableShadow *self,double dfValue){
+        return GDALRATGetRowOfValue( self, dfValue );
+    }
+SWIGINTERN int GDALRasterAttributeTableShadow_ChangesAreWrittenToFile(GDALRasterAttributeTableShadow *self){
+        return GDALRATChangesAreWrittenToFile( self );
+    }
+SWIGINTERN void GDALRasterAttributeTableShadow_DumpReadable(GDALRasterAttributeTableShadow *self){
+        GDALRATDumpReadable( self, NULL );
+    }
+SWIGINTERN void GDALRasterAttributeTableShadow_SetTableType(GDALRasterAttributeTableShadow *self,GDALRATTableType eTableType){
+        GDALRATSetTableType( self, eTableType );
+    }
+SWIGINTERN GDALRATTableType GDALRasterAttributeTableShadow_GetTableType(GDALRasterAttributeTableShadow *self){
+        return GDALRATGetTableType( self );
+    }
+SWIGINTERN void GDALRasterAttributeTableShadow_RemoveStatistics(GDALRasterAttributeTableShadow *self){
+        GDALRATRemoveStatistics(self);
+    }
 SWIGINTERN void delete_GDALGroupHS(GDALGroupHS *self){
     GDALGroupRelease(self);
   }
 SWIGINTERN char const *GDALGroupHS_GetName(GDALGroupHS *self){
     return GDALGroupGetName(self);
   }
 SWIGINTERN char const *GDALGroupHS_GetFullName(GDALGroupHS *self){
@@ -7097,14 +7196,27 @@
 SWIGINTERN size_t GDALEDTComponentHS_GetOffset(GDALEDTComponentHS *self){
     return GDALEDTComponentGetOffset(self);
   }
 SWIGINTERN GDALExtendedDataTypeHS *GDALEDTComponentHS_GetType(GDALEDTComponentHS *self){
     return GDALEDTComponentGetType(self);
   }
 
+GDALRasterAttributeTableShadow* CreateRasterAttributeTableFromMDArrays(
+    GDALRATTableType eTableType, int nArrays, GDALMDArrayHS **ahArrays,
+    int nUsages = 0, GDALRATFieldUsage *paeUsages = NULL )
+{
+  if( nUsages != 0 && nUsages != nArrays )
+  {
+      CPLError(CE_Failure, CPLE_AppDefined, "nUsages != nArrays");
+      return NULL;
+  }
+  return GDALCreateRasterAttributeTableFromMDArrays( eTableType, nArrays, (const GDALMDArrayH *)ahArrays, paeUsages );
+}
+
+
 /* Returned size is in bytes or 0 if an error occurred. */
 static
 GIntBig ComputeBandRasterIOSize (int buf_xsize, int buf_ysize, int nPixelSize,
                                  GIntBig nPixelSpace, GIntBig nLineSpace,
                                  int bSpacingShouldBeMultipleOfPixelSize )
 {
     if (buf_xsize <= 0 || buf_ysize <= 0)
@@ -7582,87 +7694,14 @@
     }
 SWIGINTERN void GDALColorTableShadow_SetColorEntry(GDALColorTableShadow *self,int entry,GDALColorEntry const *centry){
         GDALSetColorEntry(self, entry, centry);
     }
 SWIGINTERN void GDALColorTableShadow_CreateColorRamp(GDALColorTableShadow *self,int nStartIndex,GDALColorEntry const *startcolor,int nEndIndex,GDALColorEntry const *endcolor){
         GDALCreateColorRamp(self, nStartIndex, startcolor, nEndIndex, endcolor);
     }
-SWIGINTERN GDALRasterAttributeTableShadow *new_GDALRasterAttributeTableShadow(){
-        return (GDALRasterAttributeTableShadow*)
-		GDALCreateRasterAttributeTable();
-    }
-SWIGINTERN void delete_GDALRasterAttributeTableShadow(GDALRasterAttributeTableShadow *self){
-        GDALDestroyRasterAttributeTable(self);
-    }
-SWIGINTERN GDALRasterAttributeTableShadow *GDALRasterAttributeTableShadow_Clone(GDALRasterAttributeTableShadow *self){
-        return (GDALRasterAttributeTableShadow*) GDALRATClone(self);
-    }
-SWIGINTERN int GDALRasterAttributeTableShadow_GetColumnCount(GDALRasterAttributeTableShadow *self){
-        return GDALRATGetColumnCount( self );
-    }
-SWIGINTERN char const *GDALRasterAttributeTableShadow_GetNameOfCol(GDALRasterAttributeTableShadow *self,int iCol){
-        return GDALRATGetNameOfCol( self, iCol );
-    }
-SWIGINTERN GDALRATFieldUsage GDALRasterAttributeTableShadow_GetUsageOfCol(GDALRasterAttributeTableShadow *self,int iCol){
-        return GDALRATGetUsageOfCol( self, iCol );
-    }
-SWIGINTERN GDALRATFieldType GDALRasterAttributeTableShadow_GetTypeOfCol(GDALRasterAttributeTableShadow *self,int iCol){
-        return GDALRATGetTypeOfCol( self, iCol );
-    }
-SWIGINTERN int GDALRasterAttributeTableShadow_GetColOfUsage(GDALRasterAttributeTableShadow *self,GDALRATFieldUsage eUsage){
-        return GDALRATGetColOfUsage( self, eUsage );
-    }
-SWIGINTERN int GDALRasterAttributeTableShadow_GetRowCount(GDALRasterAttributeTableShadow *self){
-        return GDALRATGetRowCount( self );
-    }
-SWIGINTERN char const *GDALRasterAttributeTableShadow_GetValueAsString(GDALRasterAttributeTableShadow *self,int iRow,int iCol){
-        return GDALRATGetValueAsString( self, iRow, iCol );
-    }
-SWIGINTERN int GDALRasterAttributeTableShadow_GetValueAsInt(GDALRasterAttributeTableShadow *self,int iRow,int iCol){
-        return GDALRATGetValueAsInt( self, iRow, iCol );
-    }
-SWIGINTERN double GDALRasterAttributeTableShadow_GetValueAsDouble(GDALRasterAttributeTableShadow *self,int iRow,int iCol){
-        return GDALRATGetValueAsDouble( self, iRow, iCol );
-    }
-SWIGINTERN void GDALRasterAttributeTableShadow_SetValueAsString(GDALRasterAttributeTableShadow *self,int iRow,int iCol,char const *pszValue){
-        GDALRATSetValueAsString( self, iRow, iCol, pszValue );
-    }
-SWIGINTERN void GDALRasterAttributeTableShadow_SetValueAsInt(GDALRasterAttributeTableShadow *self,int iRow,int iCol,int nValue){
-        GDALRATSetValueAsInt( self, iRow, iCol, nValue );
-    }
-SWIGINTERN void GDALRasterAttributeTableShadow_SetValueAsDouble(GDALRasterAttributeTableShadow *self,int iRow,int iCol,double dfValue){
-        GDALRATSetValueAsDouble( self, iRow, iCol, dfValue );
-    }
-SWIGINTERN void GDALRasterAttributeTableShadow_SetRowCount(GDALRasterAttributeTableShadow *self,int nCount){
-        GDALRATSetRowCount( self, nCount );
-    }
-SWIGINTERN int GDALRasterAttributeTableShadow_CreateColumn(GDALRasterAttributeTableShadow *self,char const *pszName,GDALRATFieldType eType,GDALRATFieldUsage eUsage){
-        return GDALRATCreateColumn( self, pszName, eType, eUsage );
-    }
-SWIGINTERN bool GDALRasterAttributeTableShadow_GetLinearBinning(GDALRasterAttributeTableShadow *self,double *pdfRow0Min,double *pdfBinSize){
-        return (GDALRATGetLinearBinning(self, pdfRow0Min, pdfBinSize) != 0) ? true : false;
-    }
-SWIGINTERN int GDALRasterAttributeTableShadow_SetLinearBinning(GDALRasterAttributeTableShadow *self,double dfRow0Min,double dfBinSize){
-        return GDALRATSetLinearBinning(self, dfRow0Min, dfBinSize);
-    }
-SWIGINTERN int GDALRasterAttributeTableShadow_GetRowOfValue(GDALRasterAttributeTableShadow *self,double dfValue){
-        return GDALRATGetRowOfValue( self, dfValue );
-    }
-SWIGINTERN int GDALRasterAttributeTableShadow_ChangesAreWrittenToFile(GDALRasterAttributeTableShadow *self){
-        return GDALRATChangesAreWrittenToFile( self );
-    }
-SWIGINTERN void GDALRasterAttributeTableShadow_DumpReadable(GDALRasterAttributeTableShadow *self){
-        GDALRATDumpReadable( self, NULL );
-    }
-SWIGINTERN void GDALRasterAttributeTableShadow_SetTableType(GDALRasterAttributeTableShadow *self,GDALRATTableType eTableType){
-        GDALRATSetTableType( self, eTableType );
-    }
-SWIGINTERN GDALRATTableType GDALRasterAttributeTableShadow_GetTableType(GDALRasterAttributeTableShadow *self){
-        return GDALRATGetTableType( self );
-    }
 
 #include "gdalsubdatasetinfo.h"
 
 SWIGINTERN void delete_GDALSubdatasetInfoShadow(GDALSubdatasetInfoShadow *self){
             GDALDestroySubdatasetInfo(reinterpret_cast<GDALSubdatasetInfoH>(self));
         }
 SWIGINTERN retStringAndCPLFree *GDALSubdatasetInfoShadow_GetPathComponent(GDALSubdatasetInfoShadow *self){
@@ -8095,14 +8134,24 @@
   if (ds == 0) {
     /*throw CPLGetLastErrorMsg(); causes a SWIG_exception later*/
   }
   return ds;
 }
 
 
+void IsLineOfSightVisible(GDALRasterBandShadow *band,
+                          int xA, int yA, double zA,
+                          int xB, int yB, double zB,
+                          bool *pbVisible, int *pnXIntersection, int *pnYIntersection,
+                          char** options = NULL)
+{
+    *pbVisible = GDALIsLineOfSightVisible(band, xA, yA, zA, xB, yB, zB, pnXIntersection, pnYIntersection, options);
+}
+
+
 GDALDatasetShadow *AutoCreateWarpedVRT( GDALDatasetShadow *src_ds,
                                         const char *src_wkt = 0,
                                         const char *dst_wkt = 0,
                                         GDALResampleAlg eResampleAlg = GRA_NearestNeighbour,
                                         double maxerror = 0.0 ) {
   GDALDatasetShadow *ds = GDALAutoCreateWarpedVRT( src_ds, src_wkt,
                                                    dst_wkt,
@@ -9268,14 +9317,62 @@
     {
         PopStackingErrorHandler(&aoErrors, hDSRet != NULL);
     }
 #endif
     return hDSRet;
 }
 
+SWIGINTERN GDALTileIndexOptions *new_GDALTileIndexOptions(char **options){
+        return GDALTileIndexOptionsNew(options, NULL);
+    }
+SWIGINTERN void delete_GDALTileIndexOptions(GDALTileIndexOptions *self){
+        GDALTileIndexOptionsFree( self );
+    }
+
+GDALDatasetShadow* wrapper_TileIndex_names( const char* dest,
+                                            char ** source_filenames,
+                                            GDALTileIndexOptions* options,
+                                            GDALProgressFunc callback=NULL,
+                                            void* callback_data=NULL)
+{
+    int usageError; /* ignored */
+#if 0
+    bool bFreeOptions = false;
+    if( callback )
+    {
+        if( options == NULL )
+        {
+            bFreeOptions = true;
+            options = GDALTileIndexOptionsNew(NULL, NULL);
+        }
+        GDALTileIndexOptionsSetProgress(options, callback, callback_data);
+    }
+#endif
+
+#ifdef SWIGPYTHON
+    std::vector<ErrorStruct> aoErrors;
+    if( GetUseExceptions() )
+    {
+        PushStackingErrorHandler(&aoErrors);
+    }
+#endif
+    GDALDatasetH hDSRet = GDALTileIndex(dest, CSLCount(source_filenames), source_filenames, options, &usageError);
+#if 0
+    if( bFreeOptions )
+        GDALTileIndexOptionsFree(options);
+#endif
+#ifdef SWIGPYTHON
+    if( GetUseExceptions() )
+    {
+        PopStackingErrorHandler(&aoErrors, hDSRet != NULL);
+    }
+#endif
+    return hDSRet;
+}
+
 SWIGINTERN GDALMultiDimTranslateOptions *new_GDALMultiDimTranslateOptions(char **options){
         return GDALMultiDimTranslateOptionsNew(options, NULL);
     }
 SWIGINTERN void delete_GDALMultiDimTranslateOptions(GDALMultiDimTranslateOptions *self){
         GDALMultiDimTranslateOptionsFree( self );
     }
 
@@ -22829,14 +22926,112 @@
     /* %typemap(freearg) char **dict */
     CSLDestroy( arg5 );
   }
   return NULL;
 }
 
 
+SWIGINTERN PyObject *_wrap_Dataset_CreateLayerFromGeomFieldDefn(PyObject *self, PyObject *args) {
+  PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
+  GDALDatasetShadow *arg1 = (GDALDatasetShadow *) 0 ;
+  char *arg2 = (char *) 0 ;
+  OGRGeomFieldDefnShadow *arg3 = (OGRGeomFieldDefnShadow *) 0 ;
+  char **arg4 = (char **) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  int res2 ;
+  char *buf2 = 0 ;
+  int alloc2 = 0 ;
+  void *argp3 = 0 ;
+  int res3 = 0 ;
+  PyObject *swig_obj[4] ;
+  OGRLayerShadow *result = 0 ;
+  
+  if (!SWIG_Python_UnpackTuple(args, "Dataset_CreateLayerFromGeomFieldDefn", 3, 4, swig_obj)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_GDALDatasetShadow, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Dataset_CreateLayerFromGeomFieldDefn" "', argument " "1"" of type '" "GDALDatasetShadow *""'"); 
+  }
+  arg1 = reinterpret_cast< GDALDatasetShadow * >(argp1);
+  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, NULL, &alloc2);
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Dataset_CreateLayerFromGeomFieldDefn" "', argument " "2"" of type '" "char const *""'");
+  }
+  arg2 = reinterpret_cast< char * >(buf2);
+  res3 = SWIG_ConvertPtr(swig_obj[2], &argp3,SWIGTYPE_p_OGRGeomFieldDefnShadow, 0 |  0 );
+  if (!SWIG_IsOK(res3)) {
+    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Dataset_CreateLayerFromGeomFieldDefn" "', argument " "3"" of type '" "OGRGeomFieldDefnShadow *""'"); 
+  }
+  arg3 = reinterpret_cast< OGRGeomFieldDefnShadow * >(argp3);
+  if (swig_obj[3]) {
+    {
+      /* %typemap(in) char **dict */
+      arg4 = NULL;
+      if ( PySequence_Check( swig_obj[3] ) ) {
+        int bErr = FALSE;
+        arg4 = CSLFromPySequence(swig_obj[3], &bErr);
+        if ( bErr )
+        {
+          SWIG_fail;
+        }
+      }
+      else if ( PyMapping_Check( swig_obj[3] ) ) {
+        int bErr = FALSE;
+        arg4 = CSLFromPyMapping(swig_obj[3], &bErr);
+        if ( bErr )
+        {
+          SWIG_fail;
+        }
+      }
+      else {
+        PyErr_SetString(PyExc_TypeError,"Argument must be dictionary or sequence of strings");
+        SWIG_fail;
+      }
+    }
+  }
+  {
+    const int bLocalUseExceptions = GetUseExceptions();
+    if ( bLocalUseExceptions ) {
+      pushErrorHandler();
+    }
+    {
+      SWIG_PYTHON_THREAD_BEGIN_ALLOW;
+      result = (OGRLayerShadow *)GDALDatasetShadow_CreateLayerFromGeomFieldDefn(arg1,(char const *)arg2,arg3,arg4);
+      SWIG_PYTHON_THREAD_END_ALLOW;
+    }
+    if ( bLocalUseExceptions ) {
+      popErrorHandler();
+    }
+#ifndef SED_HACKS
+    if ( bLocalUseExceptions ) {
+      CPLErr eclass = CPLGetLastErrorType();
+      if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+        SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+      }
+    }
+#endif
+  }
+  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OGRLayerShadow, 0 |  0 );
+  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+  {
+    /* %typemap(freearg) char **dict */
+    CSLDestroy( arg4 );
+  }
+  if ( ReturnSame(bLocalUseExceptionsCode) ) { CPLErr eclass = CPLGetLastErrorType(); if ( eclass == CE_Failure || eclass == CE_Fatal ) { Py_XDECREF(resultobj); SWIG_Error( SWIG_RuntimeError, CPLGetLastErrorMsg() ); return NULL; } }
+  return resultobj;
+fail:
+  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+  {
+    /* %typemap(freearg) char **dict */
+    CSLDestroy( arg4 );
+  }
+  return NULL;
+}
+
+
 SWIGINTERN PyObject *_wrap_Dataset_CopyLayer(PyObject *self, PyObject *args, PyObject *kwargs) {
   PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
   GDALDatasetShadow *arg1 = (GDALDatasetShadow *) 0 ;
   OGRLayerShadow *arg2 = (OGRLayerShadow *) 0 ;
   char *arg3 = (char *) 0 ;
   char **arg4 = (char **) 0 ;
   void *argp1 = 0 ;
@@ -23006,59 +23201,14 @@
   if ( ReturnSame(bLocalUseExceptionsCode) ) { CPLErr eclass = CPLGetLastErrorType(); if ( eclass == CE_Failure || eclass == CE_Fatal ) { Py_XDECREF(resultobj); SWIG_Error( SWIG_RuntimeError, CPLGetLastErrorMsg() ); return NULL; } }
   return resultobj;
 fail:
   return NULL;
 }
 
 
-SWIGINTERN PyObject *_wrap_Dataset_GetLayerCount(PyObject *self, PyObject *args) {
-  PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
-  GDALDatasetShadow *arg1 = (GDALDatasetShadow *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject *swig_obj[1] ;
-  int result;
-  
-  if (!args) SWIG_fail;
-  swig_obj[0] = args;
-  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_GDALDatasetShadow, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Dataset_GetLayerCount" "', argument " "1"" of type '" "GDALDatasetShadow *""'"); 
-  }
-  arg1 = reinterpret_cast< GDALDatasetShadow * >(argp1);
-  {
-    const int bLocalUseExceptions = GetUseExceptions();
-    if ( bLocalUseExceptions ) {
-      pushErrorHandler();
-    }
-    {
-      SWIG_PYTHON_THREAD_BEGIN_ALLOW;
-      result = (int)GDALDatasetShadow_GetLayerCount(arg1);
-      SWIG_PYTHON_THREAD_END_ALLOW;
-    }
-    if ( bLocalUseExceptions ) {
-      popErrorHandler();
-    }
-#ifndef SED_HACKS
-    if ( bLocalUseExceptions ) {
-      CPLErr eclass = CPLGetLastErrorType();
-      if ( eclass == CE_Failure || eclass == CE_Fatal ) {
-        SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
-      }
-    }
-#endif
-  }
-  resultobj = SWIG_From_int(static_cast< int >(result));
-  if ( ReturnSame(bLocalUseExceptionsCode) ) { CPLErr eclass = CPLGetLastErrorType(); if ( eclass == CE_Failure || eclass == CE_Fatal ) { Py_XDECREF(resultobj); SWIG_Error( SWIG_RuntimeError, CPLGetLastErrorMsg() ); return NULL; } }
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
 SWIGINTERN PyObject *_wrap_Dataset_IsLayerPrivate(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
   GDALDatasetShadow *arg1 = (GDALDatasetShadow *) 0 ;
   int arg2 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   int val2 ;
@@ -23103,167 +23253,14 @@
   if ( ReturnSame(bLocalUseExceptionsCode) ) { CPLErr eclass = CPLGetLastErrorType(); if ( eclass == CE_Failure || eclass == CE_Fatal ) { Py_XDECREF(resultobj); SWIG_Error( SWIG_RuntimeError, CPLGetLastErrorMsg() ); return NULL; } }
   return resultobj;
 fail:
   return NULL;
 }
 
 
-SWIGINTERN PyObject *_wrap_Dataset_GetLayerByIndex(PyObject *self, PyObject *args) {
-  PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
-  GDALDatasetShadow *arg1 = (GDALDatasetShadow *) 0 ;
-  int arg2 = (int) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  PyObject *swig_obj[2] ;
-  OGRLayerShadow *result = 0 ;
-  
-  if (!SWIG_Python_UnpackTuple(args, "Dataset_GetLayerByIndex", 1, 2, swig_obj)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_GDALDatasetShadow, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Dataset_GetLayerByIndex" "', argument " "1"" of type '" "GDALDatasetShadow *""'"); 
-  }
-  arg1 = reinterpret_cast< GDALDatasetShadow * >(argp1);
-  if (swig_obj[1]) {
-    ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
-    if (!SWIG_IsOK(ecode2)) {
-      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Dataset_GetLayerByIndex" "', argument " "2"" of type '" "int""'");
-    } 
-    arg2 = static_cast< int >(val2);
-  }
-  {
-    const int bLocalUseExceptions = GetUseExceptions();
-    if ( bLocalUseExceptions ) {
-      pushErrorHandler();
-    }
-    {
-      SWIG_PYTHON_THREAD_BEGIN_ALLOW;
-      result = (OGRLayerShadow *)GDALDatasetShadow_GetLayerByIndex(arg1,arg2);
-      SWIG_PYTHON_THREAD_END_ALLOW;
-    }
-    if ( bLocalUseExceptions ) {
-      popErrorHandler();
-    }
-#ifndef SED_HACKS
-    if ( bLocalUseExceptions ) {
-      CPLErr eclass = CPLGetLastErrorType();
-      if ( eclass == CE_Failure || eclass == CE_Fatal ) {
-        SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
-      }
-    }
-#endif
-  }
-  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OGRLayerShadow, 0 |  0 );
-  if ( ReturnSame(bLocalUseExceptionsCode) ) { CPLErr eclass = CPLGetLastErrorType(); if ( eclass == CE_Failure || eclass == CE_Fatal ) { Py_XDECREF(resultobj); SWIG_Error( SWIG_RuntimeError, CPLGetLastErrorMsg() ); return NULL; } }
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_Dataset_GetLayerByName(PyObject *self, PyObject *args) {
-  PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
-  GDALDatasetShadow *arg1 = (GDALDatasetShadow *) 0 ;
-  char *arg2 = (char *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int res2 ;
-  char *buf2 = 0 ;
-  int alloc2 = 0 ;
-  PyObject *swig_obj[2] ;
-  OGRLayerShadow *result = 0 ;
-  
-  if (!SWIG_Python_UnpackTuple(args, "Dataset_GetLayerByName", 2, 2, swig_obj)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_GDALDatasetShadow, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Dataset_GetLayerByName" "', argument " "1"" of type '" "GDALDatasetShadow *""'"); 
-  }
-  arg1 = reinterpret_cast< GDALDatasetShadow * >(argp1);
-  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, NULL, &alloc2);
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Dataset_GetLayerByName" "', argument " "2"" of type '" "char const *""'");
-  }
-  arg2 = reinterpret_cast< char * >(buf2);
-  {
-    const int bLocalUseExceptions = GetUseExceptions();
-    if ( bLocalUseExceptions ) {
-      pushErrorHandler();
-    }
-    {
-      SWIG_PYTHON_THREAD_BEGIN_ALLOW;
-      result = (OGRLayerShadow *)GDALDatasetShadow_GetLayerByName(arg1,(char const *)arg2);
-      SWIG_PYTHON_THREAD_END_ALLOW;
-    }
-    if ( bLocalUseExceptions ) {
-      popErrorHandler();
-    }
-#ifndef SED_HACKS
-    if ( bLocalUseExceptions ) {
-      CPLErr eclass = CPLGetLastErrorType();
-      if ( eclass == CE_Failure || eclass == CE_Fatal ) {
-        SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
-      }
-    }
-#endif
-  }
-  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OGRLayerShadow, 0 |  0 );
-  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
-  if ( ReturnSame(bLocalUseExceptionsCode) ) { CPLErr eclass = CPLGetLastErrorType(); if ( eclass == CE_Failure || eclass == CE_Fatal ) { Py_XDECREF(resultobj); SWIG_Error( SWIG_RuntimeError, CPLGetLastErrorMsg() ); return NULL; } }
-  return resultobj;
-fail:
-  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_Dataset_ResetReading(PyObject *self, PyObject *args) {
-  PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
-  GDALDatasetShadow *arg1 = (GDALDatasetShadow *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject *swig_obj[1] ;
-  
-  if (!args) SWIG_fail;
-  swig_obj[0] = args;
-  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_GDALDatasetShadow, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Dataset_ResetReading" "', argument " "1"" of type '" "GDALDatasetShadow *""'"); 
-  }
-  arg1 = reinterpret_cast< GDALDatasetShadow * >(argp1);
-  {
-    const int bLocalUseExceptions = GetUseExceptions();
-    if ( bLocalUseExceptions ) {
-      pushErrorHandler();
-    }
-    {
-      SWIG_PYTHON_THREAD_BEGIN_ALLOW;
-      GDALDatasetShadow_ResetReading(arg1);
-      SWIG_PYTHON_THREAD_END_ALLOW;
-    }
-    if ( bLocalUseExceptions ) {
-      popErrorHandler();
-    }
-#ifndef SED_HACKS
-    if ( bLocalUseExceptions ) {
-      CPLErr eclass = CPLGetLastErrorType();
-      if ( eclass == CE_Failure || eclass == CE_Fatal ) {
-        SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
-      }
-    }
-#endif
-  }
-  resultobj = SWIG_Py_Void();
-  if ( ReturnSame(bLocalUseExceptionsCode) ) { CPLErr eclass = CPLGetLastErrorType(); if ( eclass == CE_Failure || eclass == CE_Fatal ) { Py_XDECREF(resultobj); SWIG_Error( SWIG_RuntimeError, CPLGetLastErrorMsg() ); return NULL; } }
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
 SWIGINTERN PyObject *_wrap_Dataset_GetNextFeature(PyObject *self, PyObject *args, PyObject *kwargs) {
   PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
   GDALDatasetShadow *arg1 = (GDALDatasetShadow *) 0 ;
   bool arg2 = (bool) true ;
   bool arg3 = (bool) false ;
   OGRLayerShadow **arg4 = (OGRLayerShadow **) NULL ;
   double *arg5 = (double *) NULL ;
@@ -23727,14 +23724,212 @@
   if ( ReturnSame(bLocalUseExceptionsCode) ) { CPLErr eclass = CPLGetLastErrorType(); if ( eclass == CE_Failure || eclass == CE_Fatal ) { Py_XDECREF(resultobj); SWIG_Error( SWIG_RuntimeError, CPLGetLastErrorMsg() ); return NULL; } }
   return resultobj;
 fail:
   return NULL;
 }
 
 
+SWIGINTERN PyObject *_wrap_Dataset_GetLayerByIndex(PyObject *self, PyObject *args) {
+  PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
+  GDALDatasetShadow *arg1 = (GDALDatasetShadow *) 0 ;
+  int arg2 = (int) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  int val2 ;
+  int ecode2 = 0 ;
+  PyObject *swig_obj[2] ;
+  OGRLayerShadow *result = 0 ;
+  
+  if (!SWIG_Python_UnpackTuple(args, "Dataset_GetLayerByIndex", 1, 2, swig_obj)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_GDALDatasetShadow, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Dataset_GetLayerByIndex" "', argument " "1"" of type '" "GDALDatasetShadow *""'"); 
+  }
+  arg1 = reinterpret_cast< GDALDatasetShadow * >(argp1);
+  if (swig_obj[1]) {
+    ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
+    if (!SWIG_IsOK(ecode2)) {
+      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Dataset_GetLayerByIndex" "', argument " "2"" of type '" "int""'");
+    } 
+    arg2 = static_cast< int >(val2);
+  }
+  {
+    const int bLocalUseExceptions = GetUseExceptions();
+    if ( bLocalUseExceptions ) {
+      pushErrorHandler();
+    }
+    {
+      SWIG_PYTHON_THREAD_BEGIN_ALLOW;
+      result = (OGRLayerShadow *)GDALDatasetShadow_GetLayerByIndex(arg1,arg2);
+      SWIG_PYTHON_THREAD_END_ALLOW;
+    }
+    if ( bLocalUseExceptions ) {
+      popErrorHandler();
+    }
+#ifndef SED_HACKS
+    if ( bLocalUseExceptions ) {
+      CPLErr eclass = CPLGetLastErrorType();
+      if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+        SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+      }
+    }
+#endif
+  }
+  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OGRLayerShadow, 0 |  0 );
+  if ( ReturnSame(bLocalUseExceptionsCode) ) { CPLErr eclass = CPLGetLastErrorType(); if ( eclass == CE_Failure || eclass == CE_Fatal ) { Py_XDECREF(resultobj); SWIG_Error( SWIG_RuntimeError, CPLGetLastErrorMsg() ); return NULL; } }
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_Dataset_GetLayerByName(PyObject *self, PyObject *args) {
+  PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
+  GDALDatasetShadow *arg1 = (GDALDatasetShadow *) 0 ;
+  char *arg2 = (char *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  int res2 ;
+  char *buf2 = 0 ;
+  int alloc2 = 0 ;
+  PyObject *swig_obj[2] ;
+  OGRLayerShadow *result = 0 ;
+  
+  if (!SWIG_Python_UnpackTuple(args, "Dataset_GetLayerByName", 2, 2, swig_obj)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_GDALDatasetShadow, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Dataset_GetLayerByName" "', argument " "1"" of type '" "GDALDatasetShadow *""'"); 
+  }
+  arg1 = reinterpret_cast< GDALDatasetShadow * >(argp1);
+  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, NULL, &alloc2);
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Dataset_GetLayerByName" "', argument " "2"" of type '" "char const *""'");
+  }
+  arg2 = reinterpret_cast< char * >(buf2);
+  {
+    const int bLocalUseExceptions = GetUseExceptions();
+    if ( bLocalUseExceptions ) {
+      pushErrorHandler();
+    }
+    {
+      SWIG_PYTHON_THREAD_BEGIN_ALLOW;
+      result = (OGRLayerShadow *)GDALDatasetShadow_GetLayerByName(arg1,(char const *)arg2);
+      SWIG_PYTHON_THREAD_END_ALLOW;
+    }
+    if ( bLocalUseExceptions ) {
+      popErrorHandler();
+    }
+#ifndef SED_HACKS
+    if ( bLocalUseExceptions ) {
+      CPLErr eclass = CPLGetLastErrorType();
+      if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+        SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+      }
+    }
+#endif
+  }
+  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OGRLayerShadow, 0 |  0 );
+  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+  if ( ReturnSame(bLocalUseExceptionsCode) ) { CPLErr eclass = CPLGetLastErrorType(); if ( eclass == CE_Failure || eclass == CE_Fatal ) { Py_XDECREF(resultobj); SWIG_Error( SWIG_RuntimeError, CPLGetLastErrorMsg() ); return NULL; } }
+  return resultobj;
+fail:
+  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_Dataset_ResetReading(PyObject *self, PyObject *args) {
+  PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
+  GDALDatasetShadow *arg1 = (GDALDatasetShadow *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject *swig_obj[1] ;
+  
+  if (!args) SWIG_fail;
+  swig_obj[0] = args;
+  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_GDALDatasetShadow, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Dataset_ResetReading" "', argument " "1"" of type '" "GDALDatasetShadow *""'"); 
+  }
+  arg1 = reinterpret_cast< GDALDatasetShadow * >(argp1);
+  {
+    const int bLocalUseExceptions = GetUseExceptions();
+    if ( bLocalUseExceptions ) {
+      pushErrorHandler();
+    }
+    {
+      SWIG_PYTHON_THREAD_BEGIN_ALLOW;
+      GDALDatasetShadow_ResetReading(arg1);
+      SWIG_PYTHON_THREAD_END_ALLOW;
+    }
+    if ( bLocalUseExceptions ) {
+      popErrorHandler();
+    }
+#ifndef SED_HACKS
+    if ( bLocalUseExceptions ) {
+      CPLErr eclass = CPLGetLastErrorType();
+      if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+        SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+      }
+    }
+#endif
+  }
+  resultobj = SWIG_Py_Void();
+  if ( ReturnSame(bLocalUseExceptionsCode) ) { CPLErr eclass = CPLGetLastErrorType(); if ( eclass == CE_Failure || eclass == CE_Fatal ) { Py_XDECREF(resultobj); SWIG_Error( SWIG_RuntimeError, CPLGetLastErrorMsg() ); return NULL; } }
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_Dataset_GetLayerCount(PyObject *self, PyObject *args) {
+  PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
+  GDALDatasetShadow *arg1 = (GDALDatasetShadow *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject *swig_obj[1] ;
+  int result;
+  
+  if (!args) SWIG_fail;
+  swig_obj[0] = args;
+  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_GDALDatasetShadow, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Dataset_GetLayerCount" "', argument " "1"" of type '" "GDALDatasetShadow *""'"); 
+  }
+  arg1 = reinterpret_cast< GDALDatasetShadow * >(argp1);
+  {
+    const int bLocalUseExceptions = GetUseExceptions();
+    if ( bLocalUseExceptions ) {
+      pushErrorHandler();
+    }
+    {
+      SWIG_PYTHON_THREAD_BEGIN_ALLOW;
+      result = (int)GDALDatasetShadow_GetLayerCount(arg1);
+      SWIG_PYTHON_THREAD_END_ALLOW;
+    }
+    if ( bLocalUseExceptions ) {
+      popErrorHandler();
+    }
+#ifndef SED_HACKS
+    if ( bLocalUseExceptions ) {
+      CPLErr eclass = CPLGetLastErrorType();
+      if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+        SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+      }
+    }
+#endif
+  }
+  resultobj = SWIG_From_int(static_cast< int >(result));
+  if ( ReturnSame(bLocalUseExceptionsCode) ) { CPLErr eclass = CPLGetLastErrorType(); if ( eclass == CE_Failure || eclass == CE_Fatal ) { Py_XDECREF(resultobj); SWIG_Error( SWIG_RuntimeError, CPLGetLastErrorMsg() ); return NULL; } }
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
 SWIGINTERN PyObject *_wrap_Dataset_AbortSQL(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
   GDALDatasetShadow *arg1 = (GDALDatasetShadow *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   PyObject *swig_obj[1] ;
   OGRErr result;
@@ -25008,14 +25203,1695 @@
 SWIGINTERN PyObject *Dataset_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
   PyObject *obj;
   if (!SWIG_Python_UnpackTuple(args, "swigregister", 1, 1, &obj)) return NULL;
   SWIG_TypeNewClientData(SWIGTYPE_p_GDALDatasetShadow, SWIG_NewClientData(obj));
   return SWIG_Py_Void();
 }
 
+SWIGINTERN PyObject *_wrap_new_RasterAttributeTable(PyObject *self, PyObject *args) {
+  PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
+  GDALRasterAttributeTableShadow *result = 0 ;
+  
+  if (!SWIG_Python_UnpackTuple(args, "new_RasterAttributeTable", 0, 0, 0)) SWIG_fail;
+  {
+    const int bLocalUseExceptions = GetUseExceptions();
+    if ( bLocalUseExceptions ) {
+      pushErrorHandler();
+    }
+    {
+      SWIG_PYTHON_THREAD_BEGIN_ALLOW;
+      result = (GDALRasterAttributeTableShadow *)new_GDALRasterAttributeTableShadow();
+      SWIG_PYTHON_THREAD_END_ALLOW;
+    }
+    if ( bLocalUseExceptions ) {
+      popErrorHandler();
+    }
+#ifndef SED_HACKS
+    if ( bLocalUseExceptions ) {
+      CPLErr eclass = CPLGetLastErrorType();
+      if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+        SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+      }
+    }
+#endif
+  }
+  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_GDALRasterAttributeTableShadow, SWIG_POINTER_NEW |  0 );
+  if ( ReturnSame(bLocalUseExceptionsCode) ) { CPLErr eclass = CPLGetLastErrorType(); if ( eclass == CE_Failure || eclass == CE_Fatal ) { Py_XDECREF(resultobj); SWIG_Error( SWIG_RuntimeError, CPLGetLastErrorMsg() ); return NULL; } }
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_delete_RasterAttributeTable(PyObject *self, PyObject *args) {
+  PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
+  GDALRasterAttributeTableShadow *arg1 = (GDALRasterAttributeTableShadow *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject *swig_obj[1] ;
+  
+  if (!args) SWIG_fail;
+  swig_obj[0] = args;
+  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_GDALRasterAttributeTableShadow, SWIG_POINTER_DISOWN |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_RasterAttributeTable" "', argument " "1"" of type '" "GDALRasterAttributeTableShadow *""'"); 
+  }
+  arg1 = reinterpret_cast< GDALRasterAttributeTableShadow * >(argp1);
+  {
+    const int bLocalUseExceptions = GetUseExceptions();
+    if ( bLocalUseExceptions ) {
+      pushErrorHandler();
+    }
+    {
+      SWIG_PYTHON_THREAD_BEGIN_ALLOW;
+      delete_GDALRasterAttributeTableShadow(arg1);
+      SWIG_PYTHON_THREAD_END_ALLOW;
+    }
+    if ( bLocalUseExceptions ) {
+      popErrorHandler();
+    }
+#ifndef SED_HACKS
+    if ( bLocalUseExceptions ) {
+      CPLErr eclass = CPLGetLastErrorType();
+      if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+        SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+      }
+    }
+#endif
+  }
+  resultobj = SWIG_Py_Void();
+  if ( ReturnSame(bLocalUseExceptionsCode) ) { CPLErr eclass = CPLGetLastErrorType(); if ( eclass == CE_Failure || eclass == CE_Fatal ) { Py_XDECREF(resultobj); SWIG_Error( SWIG_RuntimeError, CPLGetLastErrorMsg() ); return NULL; } }
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_RasterAttributeTable_Clone(PyObject *self, PyObject *args) {
+  PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
+  GDALRasterAttributeTableShadow *arg1 = (GDALRasterAttributeTableShadow *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject *swig_obj[1] ;
+  GDALRasterAttributeTableShadow *result = 0 ;
+  
+  if (!args) SWIG_fail;
+  swig_obj[0] = args;
+  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_GDALRasterAttributeTableShadow, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RasterAttributeTable_Clone" "', argument " "1"" of type '" "GDALRasterAttributeTableShadow *""'"); 
+  }
+  arg1 = reinterpret_cast< GDALRasterAttributeTableShadow * >(argp1);
+  {
+    const int bLocalUseExceptions = GetUseExceptions();
+    if ( bLocalUseExceptions ) {
+      pushErrorHandler();
+    }
+    {
+      SWIG_PYTHON_THREAD_BEGIN_ALLOW;
+      result = (GDALRasterAttributeTableShadow *)GDALRasterAttributeTableShadow_Clone(arg1);
+      SWIG_PYTHON_THREAD_END_ALLOW;
+    }
+    if ( bLocalUseExceptions ) {
+      popErrorHandler();
+    }
+#ifndef SED_HACKS
+    if ( bLocalUseExceptions ) {
+      CPLErr eclass = CPLGetLastErrorType();
+      if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+        SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+      }
+    }
+#endif
+  }
+  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_GDALRasterAttributeTableShadow, SWIG_POINTER_OWN |  0 );
+  if ( ReturnSame(bLocalUseExceptionsCode) ) { CPLErr eclass = CPLGetLastErrorType(); if ( eclass == CE_Failure || eclass == CE_Fatal ) { Py_XDECREF(resultobj); SWIG_Error( SWIG_RuntimeError, CPLGetLastErrorMsg() ); return NULL; } }
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_RasterAttributeTable_GetColumnCount(PyObject *self, PyObject *args) {
+  PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
+  GDALRasterAttributeTableShadow *arg1 = (GDALRasterAttributeTableShadow *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject *swig_obj[1] ;
+  int result;
+  
+  if (!args) SWIG_fail;
+  swig_obj[0] = args;
+  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_GDALRasterAttributeTableShadow, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RasterAttributeTable_GetColumnCount" "', argument " "1"" of type '" "GDALRasterAttributeTableShadow *""'"); 
+  }
+  arg1 = reinterpret_cast< GDALRasterAttributeTableShadow * >(argp1);
+  {
+    const int bLocalUseExceptions = GetUseExceptions();
+    if ( bLocalUseExceptions ) {
+      pushErrorHandler();
+    }
+    {
+      SWIG_PYTHON_THREAD_BEGIN_ALLOW;
+      result = (int)GDALRasterAttributeTableShadow_GetColumnCount(arg1);
+      SWIG_PYTHON_THREAD_END_ALLOW;
+    }
+    if ( bLocalUseExceptions ) {
+      popErrorHandler();
+    }
+#ifndef SED_HACKS
+    if ( bLocalUseExceptions ) {
+      CPLErr eclass = CPLGetLastErrorType();
+      if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+        SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+      }
+    }
+#endif
+  }
+  resultobj = SWIG_From_int(static_cast< int >(result));
+  if ( ReturnSame(bLocalUseExceptionsCode) ) { CPLErr eclass = CPLGetLastErrorType(); if ( eclass == CE_Failure || eclass == CE_Fatal ) { Py_XDECREF(resultobj); SWIG_Error( SWIG_RuntimeError, CPLGetLastErrorMsg() ); return NULL; } }
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_RasterAttributeTable_GetNameOfCol(PyObject *self, PyObject *args) {
+  PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
+  GDALRasterAttributeTableShadow *arg1 = (GDALRasterAttributeTableShadow *) 0 ;
+  int arg2 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  int val2 ;
+  int ecode2 = 0 ;
+  PyObject *swig_obj[2] ;
+  char *result = 0 ;
+  
+  if (!SWIG_Python_UnpackTuple(args, "RasterAttributeTable_GetNameOfCol", 2, 2, swig_obj)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_GDALRasterAttributeTableShadow, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RasterAttributeTable_GetNameOfCol" "', argument " "1"" of type '" "GDALRasterAttributeTableShadow *""'"); 
+  }
+  arg1 = reinterpret_cast< GDALRasterAttributeTableShadow * >(argp1);
+  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "RasterAttributeTable_GetNameOfCol" "', argument " "2"" of type '" "int""'");
+  } 
+  arg2 = static_cast< int >(val2);
+  {
+    const int bLocalUseExceptions = GetUseExceptions();
+    if ( bLocalUseExceptions ) {
+      pushErrorHandler();
+    }
+    {
+      SWIG_PYTHON_THREAD_BEGIN_ALLOW;
+      result = (char *)GDALRasterAttributeTableShadow_GetNameOfCol(arg1,arg2);
+      SWIG_PYTHON_THREAD_END_ALLOW;
+    }
+    if ( bLocalUseExceptions ) {
+      popErrorHandler();
+    }
+#ifndef SED_HACKS
+    if ( bLocalUseExceptions ) {
+      CPLErr eclass = CPLGetLastErrorType();
+      if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+        SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+      }
+    }
+#endif
+  }
+  resultobj = SWIG_FromCharPtr((const char *)result);
+  if ( ReturnSame(bLocalUseExceptionsCode) ) { CPLErr eclass = CPLGetLastErrorType(); if ( eclass == CE_Failure || eclass == CE_Fatal ) { Py_XDECREF(resultobj); SWIG_Error( SWIG_RuntimeError, CPLGetLastErrorMsg() ); return NULL; } }
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_RasterAttributeTable_GetUsageOfCol(PyObject *self, PyObject *args) {
+  PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
+  GDALRasterAttributeTableShadow *arg1 = (GDALRasterAttributeTableShadow *) 0 ;
+  int arg2 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  int val2 ;
+  int ecode2 = 0 ;
+  PyObject *swig_obj[2] ;
+  GDALRATFieldUsage result;
+  
+  if (!SWIG_Python_UnpackTuple(args, "RasterAttributeTable_GetUsageOfCol", 2, 2, swig_obj)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_GDALRasterAttributeTableShadow, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RasterAttributeTable_GetUsageOfCol" "', argument " "1"" of type '" "GDALRasterAttributeTableShadow *""'"); 
+  }
+  arg1 = reinterpret_cast< GDALRasterAttributeTableShadow * >(argp1);
+  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "RasterAttributeTable_GetUsageOfCol" "', argument " "2"" of type '" "int""'");
+  } 
+  arg2 = static_cast< int >(val2);
+  {
+    const int bLocalUseExceptions = GetUseExceptions();
+    if ( bLocalUseExceptions ) {
+      pushErrorHandler();
+    }
+    {
+      SWIG_PYTHON_THREAD_BEGIN_ALLOW;
+      result = (GDALRATFieldUsage)GDALRasterAttributeTableShadow_GetUsageOfCol(arg1,arg2);
+      SWIG_PYTHON_THREAD_END_ALLOW;
+    }
+    if ( bLocalUseExceptions ) {
+      popErrorHandler();
+    }
+#ifndef SED_HACKS
+    if ( bLocalUseExceptions ) {
+      CPLErr eclass = CPLGetLastErrorType();
+      if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+        SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+      }
+    }
+#endif
+  }
+  resultobj = SWIG_From_int(static_cast< int >(result));
+  if ( ReturnSame(bLocalUseExceptionsCode) ) { CPLErr eclass = CPLGetLastErrorType(); if ( eclass == CE_Failure || eclass == CE_Fatal ) { Py_XDECREF(resultobj); SWIG_Error( SWIG_RuntimeError, CPLGetLastErrorMsg() ); return NULL; } }
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_RasterAttributeTable_GetTypeOfCol(PyObject *self, PyObject *args) {
+  PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
+  GDALRasterAttributeTableShadow *arg1 = (GDALRasterAttributeTableShadow *) 0 ;
+  int arg2 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  int val2 ;
+  int ecode2 = 0 ;
+  PyObject *swig_obj[2] ;
+  GDALRATFieldType result;
+  
+  if (!SWIG_Python_UnpackTuple(args, "RasterAttributeTable_GetTypeOfCol", 2, 2, swig_obj)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_GDALRasterAttributeTableShadow, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RasterAttributeTable_GetTypeOfCol" "', argument " "1"" of type '" "GDALRasterAttributeTableShadow *""'"); 
+  }
+  arg1 = reinterpret_cast< GDALRasterAttributeTableShadow * >(argp1);
+  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "RasterAttributeTable_GetTypeOfCol" "', argument " "2"" of type '" "int""'");
+  } 
+  arg2 = static_cast< int >(val2);
+  {
+    const int bLocalUseExceptions = GetUseExceptions();
+    if ( bLocalUseExceptions ) {
+      pushErrorHandler();
+    }
+    {
+      SWIG_PYTHON_THREAD_BEGIN_ALLOW;
+      result = (GDALRATFieldType)GDALRasterAttributeTableShadow_GetTypeOfCol(arg1,arg2);
+      SWIG_PYTHON_THREAD_END_ALLOW;
+    }
+    if ( bLocalUseExceptions ) {
+      popErrorHandler();
+    }
+#ifndef SED_HACKS
+    if ( bLocalUseExceptions ) {
+      CPLErr eclass = CPLGetLastErrorType();
+      if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+        SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+      }
+    }
+#endif
+  }
+  resultobj = SWIG_From_int(static_cast< int >(result));
+  if ( ReturnSame(bLocalUseExceptionsCode) ) { CPLErr eclass = CPLGetLastErrorType(); if ( eclass == CE_Failure || eclass == CE_Fatal ) { Py_XDECREF(resultobj); SWIG_Error( SWIG_RuntimeError, CPLGetLastErrorMsg() ); return NULL; } }
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_RasterAttributeTable_GetColOfUsage(PyObject *self, PyObject *args) {
+  PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
+  GDALRasterAttributeTableShadow *arg1 = (GDALRasterAttributeTableShadow *) 0 ;
+  GDALRATFieldUsage arg2 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  int val2 ;
+  int ecode2 = 0 ;
+  PyObject *swig_obj[2] ;
+  int result;
+  
+  if (!SWIG_Python_UnpackTuple(args, "RasterAttributeTable_GetColOfUsage", 2, 2, swig_obj)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_GDALRasterAttributeTableShadow, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RasterAttributeTable_GetColOfUsage" "', argument " "1"" of type '" "GDALRasterAttributeTableShadow *""'"); 
+  }
+  arg1 = reinterpret_cast< GDALRasterAttributeTableShadow * >(argp1);
+  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "RasterAttributeTable_GetColOfUsage" "', argument " "2"" of type '" "GDALRATFieldUsage""'");
+  } 
+  arg2 = static_cast< GDALRATFieldUsage >(val2);
+  {
+    const int bLocalUseExceptions = GetUseExceptions();
+    if ( bLocalUseExceptions ) {
+      pushErrorHandler();
+    }
+    {
+      SWIG_PYTHON_THREAD_BEGIN_ALLOW;
+      result = (int)GDALRasterAttributeTableShadow_GetColOfUsage(arg1,arg2);
+      SWIG_PYTHON_THREAD_END_ALLOW;
+    }
+    if ( bLocalUseExceptions ) {
+      popErrorHandler();
+    }
+#ifndef SED_HACKS
+    if ( bLocalUseExceptions ) {
+      CPLErr eclass = CPLGetLastErrorType();
+      if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+        SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+      }
+    }
+#endif
+  }
+  resultobj = SWIG_From_int(static_cast< int >(result));
+  if ( ReturnSame(bLocalUseExceptionsCode) ) { CPLErr eclass = CPLGetLastErrorType(); if ( eclass == CE_Failure || eclass == CE_Fatal ) { Py_XDECREF(resultobj); SWIG_Error( SWIG_RuntimeError, CPLGetLastErrorMsg() ); return NULL; } }
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_RasterAttributeTable_GetRowCount(PyObject *self, PyObject *args) {
+  PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
+  GDALRasterAttributeTableShadow *arg1 = (GDALRasterAttributeTableShadow *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject *swig_obj[1] ;
+  int result;
+  
+  if (!args) SWIG_fail;
+  swig_obj[0] = args;
+  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_GDALRasterAttributeTableShadow, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RasterAttributeTable_GetRowCount" "', argument " "1"" of type '" "GDALRasterAttributeTableShadow *""'"); 
+  }
+  arg1 = reinterpret_cast< GDALRasterAttributeTableShadow * >(argp1);
+  {
+    const int bLocalUseExceptions = GetUseExceptions();
+    if ( bLocalUseExceptions ) {
+      pushErrorHandler();
+    }
+    {
+      SWIG_PYTHON_THREAD_BEGIN_ALLOW;
+      result = (int)GDALRasterAttributeTableShadow_GetRowCount(arg1);
+      SWIG_PYTHON_THREAD_END_ALLOW;
+    }
+    if ( bLocalUseExceptions ) {
+      popErrorHandler();
+    }
+#ifndef SED_HACKS
+    if ( bLocalUseExceptions ) {
+      CPLErr eclass = CPLGetLastErrorType();
+      if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+        SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+      }
+    }
+#endif
+  }
+  resultobj = SWIG_From_int(static_cast< int >(result));
+  if ( ReturnSame(bLocalUseExceptionsCode) ) { CPLErr eclass = CPLGetLastErrorType(); if ( eclass == CE_Failure || eclass == CE_Fatal ) { Py_XDECREF(resultobj); SWIG_Error( SWIG_RuntimeError, CPLGetLastErrorMsg() ); return NULL; } }
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_RasterAttributeTable_GetValueAsString(PyObject *self, PyObject *args) {
+  PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
+  GDALRasterAttributeTableShadow *arg1 = (GDALRasterAttributeTableShadow *) 0 ;
+  int arg2 ;
+  int arg3 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  int val2 ;
+  int ecode2 = 0 ;
+  int val3 ;
+  int ecode3 = 0 ;
+  PyObject *swig_obj[3] ;
+  char *result = 0 ;
+  
+  if (!SWIG_Python_UnpackTuple(args, "RasterAttributeTable_GetValueAsString", 3, 3, swig_obj)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_GDALRasterAttributeTableShadow, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RasterAttributeTable_GetValueAsString" "', argument " "1"" of type '" "GDALRasterAttributeTableShadow *""'"); 
+  }
+  arg1 = reinterpret_cast< GDALRasterAttributeTableShadow * >(argp1);
+  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "RasterAttributeTable_GetValueAsString" "', argument " "2"" of type '" "int""'");
+  } 
+  arg2 = static_cast< int >(val2);
+  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
+  if (!SWIG_IsOK(ecode3)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "RasterAttributeTable_GetValueAsString" "', argument " "3"" of type '" "int""'");
+  } 
+  arg3 = static_cast< int >(val3);
+  {
+    const int bLocalUseExceptions = GetUseExceptions();
+    if ( bLocalUseExceptions ) {
+      pushErrorHandler();
+    }
+    {
+      SWIG_PYTHON_THREAD_BEGIN_ALLOW;
+      result = (char *)GDALRasterAttributeTableShadow_GetValueAsString(arg1,arg2,arg3);
+      SWIG_PYTHON_THREAD_END_ALLOW;
+    }
+    if ( bLocalUseExceptions ) {
+      popErrorHandler();
+    }
+#ifndef SED_HACKS
+    if ( bLocalUseExceptions ) {
+      CPLErr eclass = CPLGetLastErrorType();
+      if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+        SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+      }
+    }
+#endif
+  }
+  resultobj = SWIG_FromCharPtr((const char *)result);
+  if ( ReturnSame(bLocalUseExceptionsCode) ) { CPLErr eclass = CPLGetLastErrorType(); if ( eclass == CE_Failure || eclass == CE_Fatal ) { Py_XDECREF(resultobj); SWIG_Error( SWIG_RuntimeError, CPLGetLastErrorMsg() ); return NULL; } }
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_RasterAttributeTable_GetValueAsInt(PyObject *self, PyObject *args) {
+  PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
+  GDALRasterAttributeTableShadow *arg1 = (GDALRasterAttributeTableShadow *) 0 ;
+  int arg2 ;
+  int arg3 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  int val2 ;
+  int ecode2 = 0 ;
+  int val3 ;
+  int ecode3 = 0 ;
+  PyObject *swig_obj[3] ;
+  int result;
+  
+  if (!SWIG_Python_UnpackTuple(args, "RasterAttributeTable_GetValueAsInt", 3, 3, swig_obj)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_GDALRasterAttributeTableShadow, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RasterAttributeTable_GetValueAsInt" "', argument " "1"" of type '" "GDALRasterAttributeTableShadow *""'"); 
+  }
+  arg1 = reinterpret_cast< GDALRasterAttributeTableShadow * >(argp1);
+  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "RasterAttributeTable_GetValueAsInt" "', argument " "2"" of type '" "int""'");
+  } 
+  arg2 = static_cast< int >(val2);
+  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
+  if (!SWIG_IsOK(ecode3)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "RasterAttributeTable_GetValueAsInt" "', argument " "3"" of type '" "int""'");
+  } 
+  arg3 = static_cast< int >(val3);
+  {
+    const int bLocalUseExceptions = GetUseExceptions();
+    if ( bLocalUseExceptions ) {
+      pushErrorHandler();
+    }
+    {
+      SWIG_PYTHON_THREAD_BEGIN_ALLOW;
+      result = (int)GDALRasterAttributeTableShadow_GetValueAsInt(arg1,arg2,arg3);
+      SWIG_PYTHON_THREAD_END_ALLOW;
+    }
+    if ( bLocalUseExceptions ) {
+      popErrorHandler();
+    }
+#ifndef SED_HACKS
+    if ( bLocalUseExceptions ) {
+      CPLErr eclass = CPLGetLastErrorType();
+      if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+        SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+      }
+    }
+#endif
+  }
+  resultobj = SWIG_From_int(static_cast< int >(result));
+  if ( ReturnSame(bLocalUseExceptionsCode) ) { CPLErr eclass = CPLGetLastErrorType(); if ( eclass == CE_Failure || eclass == CE_Fatal ) { Py_XDECREF(resultobj); SWIG_Error( SWIG_RuntimeError, CPLGetLastErrorMsg() ); return NULL; } }
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_RasterAttributeTable_GetValueAsDouble(PyObject *self, PyObject *args) {
+  PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
+  GDALRasterAttributeTableShadow *arg1 = (GDALRasterAttributeTableShadow *) 0 ;
+  int arg2 ;
+  int arg3 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  int val2 ;
+  int ecode2 = 0 ;
+  int val3 ;
+  int ecode3 = 0 ;
+  PyObject *swig_obj[3] ;
+  double result;
+  
+  if (!SWIG_Python_UnpackTuple(args, "RasterAttributeTable_GetValueAsDouble", 3, 3, swig_obj)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_GDALRasterAttributeTableShadow, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RasterAttributeTable_GetValueAsDouble" "', argument " "1"" of type '" "GDALRasterAttributeTableShadow *""'"); 
+  }
+  arg1 = reinterpret_cast< GDALRasterAttributeTableShadow * >(argp1);
+  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "RasterAttributeTable_GetValueAsDouble" "', argument " "2"" of type '" "int""'");
+  } 
+  arg2 = static_cast< int >(val2);
+  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
+  if (!SWIG_IsOK(ecode3)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "RasterAttributeTable_GetValueAsDouble" "', argument " "3"" of type '" "int""'");
+  } 
+  arg3 = static_cast< int >(val3);
+  {
+    const int bLocalUseExceptions = GetUseExceptions();
+    if ( bLocalUseExceptions ) {
+      pushErrorHandler();
+    }
+    {
+      SWIG_PYTHON_THREAD_BEGIN_ALLOW;
+      result = (double)GDALRasterAttributeTableShadow_GetValueAsDouble(arg1,arg2,arg3);
+      SWIG_PYTHON_THREAD_END_ALLOW;
+    }
+    if ( bLocalUseExceptions ) {
+      popErrorHandler();
+    }
+#ifndef SED_HACKS
+    if ( bLocalUseExceptions ) {
+      CPLErr eclass = CPLGetLastErrorType();
+      if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+        SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+      }
+    }
+#endif
+  }
+  resultobj = SWIG_From_double(static_cast< double >(result));
+  if ( ReturnSame(bLocalUseExceptionsCode) ) { CPLErr eclass = CPLGetLastErrorType(); if ( eclass == CE_Failure || eclass == CE_Fatal ) { Py_XDECREF(resultobj); SWIG_Error( SWIG_RuntimeError, CPLGetLastErrorMsg() ); return NULL; } }
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_RasterAttributeTable_ReadValuesIOAsString(PyObject *self, PyObject *args) {
+  PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
+  GDALRasterAttributeTableShadow *arg1 = (GDALRasterAttributeTableShadow *) 0 ;
+  int arg2 ;
+  int arg3 ;
+  int arg4 ;
+  char **arg5 = (char **) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  int val2 ;
+  int ecode2 = 0 ;
+  int val3 ;
+  int ecode3 = 0 ;
+  int iLength4 ;
+  PyObject *swig_obj[4] ;
+  CPLErr result;
+  
+  if (!SWIG_Python_UnpackTuple(args, "RasterAttributeTable_ReadValuesIOAsString", 4, 4, swig_obj)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_GDALRasterAttributeTableShadow, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RasterAttributeTable_ReadValuesIOAsString" "', argument " "1"" of type '" "GDALRasterAttributeTableShadow *""'"); 
+  }
+  arg1 = reinterpret_cast< GDALRasterAttributeTableShadow * >(argp1);
+  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "RasterAttributeTable_ReadValuesIOAsString" "', argument " "2"" of type '" "int""'");
+  } 
+  arg2 = static_cast< int >(val2);
+  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
+  if (!SWIG_IsOK(ecode3)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "RasterAttributeTable_ReadValuesIOAsString" "', argument " "3"" of type '" "int""'");
+  } 
+  arg3 = static_cast< int >(val3);
+  {
+    /* %typemap(in,numinputs=1) (int iLength4, char **ppszData) (int iLength4) */
+    if ( !PyArg_Parse(swig_obj[3],"i",&iLength4) )
+    {
+      PyErr_SetString(PyExc_TypeError, "not a integer");
+      SWIG_fail;
+    }
+    if( iLength4 <= 0 || iLength4 > INT_MAX - 1 )
+    {
+      PyErr_SetString(PyExc_TypeError, "invalid length");
+      SWIG_fail;
+    }
+    arg4 = iLength4;
+    arg5 = (char**)VSICalloc(iLength4 + 1, sizeof(char*));
+    if( !arg5 )
+    {
+      PyErr_SetString(PyExc_MemoryError, "cannot allocate temporary buffer");
+      SWIG_fail;
+    }
+  }
+  {
+    const int bLocalUseExceptions = GetUseExceptions();
+    if ( bLocalUseExceptions ) {
+      pushErrorHandler();
+    }
+    {
+      SWIG_PYTHON_THREAD_BEGIN_ALLOW;
+      CPL_IGNORE_RET_VAL(result = (CPLErr)GDALRasterAttributeTableShadow_ReadValuesIOAsString(arg1,arg2,arg3,arg4,arg5));
+      SWIG_PYTHON_THREAD_END_ALLOW;
+    }
+    if ( bLocalUseExceptions ) {
+      popErrorHandler();
+    }
+#ifndef SED_HACKS
+    if ( bLocalUseExceptions ) {
+      CPLErr eclass = CPLGetLastErrorType();
+      if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+        SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+      }
+    }
+#endif
+  }
+  resultobj = SWIG_From_int(static_cast< int >(result));
+  {
+    /* %typemap(argout) (int iLength, char **ppszData) */
+    Py_DECREF(resultobj);
+    PyObject *out = PyList_New( arg4 );
+    if( !out ) {
+      SWIG_fail;
+    }
+    for( int i=0; i<arg4; i++ ) {
+      if( arg5[i] )
+      {
+        PyObject *val = GDALPythonObjectFromCStr( arg5[i] );
+        PyList_SetItem( out, i, val );
+      }
+      else
+      {
+        Py_INCREF(Py_None);
+        PyList_SetItem( out, i, Py_None );
+      }
+    }
+    resultobj = out;
+  }
+  {
+    /* %typemap(freearg) (int iLength, char **ppszData) */
+    CSLDestroy(arg5);
+  }
+  if ( ReturnSame(bLocalUseExceptionsCode) ) { CPLErr eclass = CPLGetLastErrorType(); if ( eclass == CE_Failure || eclass == CE_Fatal ) { Py_XDECREF(resultobj); SWIG_Error( SWIG_RuntimeError, CPLGetLastErrorMsg() ); return NULL; } }
+  return resultobj;
+fail:
+  {
+    /* %typemap(freearg) (int iLength, char **ppszData) */
+    CSLDestroy(arg5);
+  }
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_RasterAttributeTable_ReadValuesIOAsInteger(PyObject *self, PyObject *args) {
+  PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
+  GDALRasterAttributeTableShadow *arg1 = (GDALRasterAttributeTableShadow *) 0 ;
+  int arg2 ;
+  int arg3 ;
+  int arg4 ;
+  int *arg5 = (int *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  int val2 ;
+  int ecode2 = 0 ;
+  int val3 ;
+  int ecode3 = 0 ;
+  int iLength4 ;
+  PyObject *swig_obj[4] ;
+  CPLErr result;
+  
+  if (!SWIG_Python_UnpackTuple(args, "RasterAttributeTable_ReadValuesIOAsInteger", 4, 4, swig_obj)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_GDALRasterAttributeTableShadow, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RasterAttributeTable_ReadValuesIOAsInteger" "', argument " "1"" of type '" "GDALRasterAttributeTableShadow *""'"); 
+  }
+  arg1 = reinterpret_cast< GDALRasterAttributeTableShadow * >(argp1);
+  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "RasterAttributeTable_ReadValuesIOAsInteger" "', argument " "2"" of type '" "int""'");
+  } 
+  arg2 = static_cast< int >(val2);
+  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
+  if (!SWIG_IsOK(ecode3)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "RasterAttributeTable_ReadValuesIOAsInteger" "', argument " "3"" of type '" "int""'");
+  } 
+  arg3 = static_cast< int >(val3);
+  {
+    /* %typemap(in,numinputs=1) (int iLength4, int *pnData) (int iLength4) */
+    if ( !PyArg_Parse(swig_obj[3],"i",&iLength4) ) {
+      PyErr_SetString(PyExc_TypeError, "not a integer");
+      SWIG_fail;
+    }
+    if( iLength4 <= 0 )
+    {
+      PyErr_SetString(PyExc_TypeError, "invalid length");
+      SWIG_fail;
+    }
+    arg4 = iLength4;
+    arg5 = (int*)VSICalloc(iLength4, sizeof(int));
+    if( !arg5 )
+    {
+      PyErr_SetString(PyExc_MemoryError, "cannot allocate temporary buffer");
+      SWIG_fail;
+    }
+  }
+  {
+    const int bLocalUseExceptions = GetUseExceptions();
+    if ( bLocalUseExceptions ) {
+      pushErrorHandler();
+    }
+    {
+      SWIG_PYTHON_THREAD_BEGIN_ALLOW;
+      CPL_IGNORE_RET_VAL(result = (CPLErr)GDALRasterAttributeTableShadow_ReadValuesIOAsInteger(arg1,arg2,arg3,arg4,arg5));
+      SWIG_PYTHON_THREAD_END_ALLOW;
+    }
+    if ( bLocalUseExceptions ) {
+      popErrorHandler();
+    }
+#ifndef SED_HACKS
+    if ( bLocalUseExceptions ) {
+      CPLErr eclass = CPLGetLastErrorType();
+      if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+        SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+      }
+    }
+#endif
+  }
+  resultobj = SWIG_From_int(static_cast< int >(result));
+  {
+    /* %typemap(argout) (int iLength, int *pnData) */
+    Py_DECREF(resultobj);
+    PyObject *out = PyList_New( arg4 );
+    if( !out ) {
+      SWIG_fail;
+    }
+    for( int i=0; i<arg4; i++ ) {
+      PyObject *val = PyLong_FromLong( (arg5)[i] );
+      PyList_SetItem( out, i, val );
+    }
+    resultobj = out;
+  }
+  {
+    /* %typemap(freearg) (int iLength, int *pnData) */
+    CPLFree(arg5);
+  }
+  if ( ReturnSame(bLocalUseExceptionsCode) ) { CPLErr eclass = CPLGetLastErrorType(); if ( eclass == CE_Failure || eclass == CE_Fatal ) { Py_XDECREF(resultobj); SWIG_Error( SWIG_RuntimeError, CPLGetLastErrorMsg() ); return NULL; } }
+  return resultobj;
+fail:
+  {
+    /* %typemap(freearg) (int iLength, int *pnData) */
+    CPLFree(arg5);
+  }
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_RasterAttributeTable_ReadValuesIOAsDouble(PyObject *self, PyObject *args) {
+  PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
+  GDALRasterAttributeTableShadow *arg1 = (GDALRasterAttributeTableShadow *) 0 ;
+  int arg2 ;
+  int arg3 ;
+  int arg4 ;
+  double *arg5 = (double *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  int val2 ;
+  int ecode2 = 0 ;
+  int val3 ;
+  int ecode3 = 0 ;
+  int iLength4 ;
+  PyObject *swig_obj[4] ;
+  CPLErr result;
+  
+  if (!SWIG_Python_UnpackTuple(args, "RasterAttributeTable_ReadValuesIOAsDouble", 4, 4, swig_obj)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_GDALRasterAttributeTableShadow, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RasterAttributeTable_ReadValuesIOAsDouble" "', argument " "1"" of type '" "GDALRasterAttributeTableShadow *""'"); 
+  }
+  arg1 = reinterpret_cast< GDALRasterAttributeTableShadow * >(argp1);
+  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "RasterAttributeTable_ReadValuesIOAsDouble" "', argument " "2"" of type '" "int""'");
+  } 
+  arg2 = static_cast< int >(val2);
+  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
+  if (!SWIG_IsOK(ecode3)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "RasterAttributeTable_ReadValuesIOAsDouble" "', argument " "3"" of type '" "int""'");
+  } 
+  arg3 = static_cast< int >(val3);
+  {
+    /* %typemap(in,numinputs=1) (int iLength4, double *pdfData) (int iLength4) */
+    if ( !PyArg_Parse(swig_obj[3],"i",&iLength4) ) {
+      PyErr_SetString(PyExc_TypeError, "not a integer");
+      SWIG_fail;
+    }
+    if( iLength4 <= 0 )
+    {
+      PyErr_SetString(PyExc_TypeError, "invalid length");
+      SWIG_fail;
+    }
+    arg4 = iLength4;
+    arg5 = (double*)CPLCalloc(iLength4, sizeof(double));
+    if( !arg5 )
+    {
+      PyErr_SetString(PyExc_MemoryError, "cannot allocate temporary buffer");
+      SWIG_fail;
+    }
+  }
+  {
+    const int bLocalUseExceptions = GetUseExceptions();
+    if ( bLocalUseExceptions ) {
+      pushErrorHandler();
+    }
+    {
+      SWIG_PYTHON_THREAD_BEGIN_ALLOW;
+      CPL_IGNORE_RET_VAL(result = (CPLErr)GDALRasterAttributeTableShadow_ReadValuesIOAsDouble(arg1,arg2,arg3,arg4,arg5));
+      SWIG_PYTHON_THREAD_END_ALLOW;
+    }
+    if ( bLocalUseExceptions ) {
+      popErrorHandler();
+    }
+#ifndef SED_HACKS
+    if ( bLocalUseExceptions ) {
+      CPLErr eclass = CPLGetLastErrorType();
+      if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+        SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+      }
+    }
+#endif
+  }
+  resultobj = SWIG_From_int(static_cast< int >(result));
+  {
+    /* %typemap(argout) (int iLength, double *pdfData)  */
+    Py_DECREF(resultobj);
+    PyObject *out = PyList_New( arg4 );
+    if( !out ) {
+      SWIG_fail;
+    }
+    for( int i=0; i<arg4; i++ ) {
+      PyObject *val = PyFloat_FromDouble( (arg5)[i] );
+      PyList_SetItem( out, i, val );
+    }
+    resultobj = out;
+  }
+  {
+    /* %typemap(freearg) (int iLength, double *pdfData) */
+    CPLFree(arg5);
+  }
+  if ( ReturnSame(bLocalUseExceptionsCode) ) { CPLErr eclass = CPLGetLastErrorType(); if ( eclass == CE_Failure || eclass == CE_Fatal ) { Py_XDECREF(resultobj); SWIG_Error( SWIG_RuntimeError, CPLGetLastErrorMsg() ); return NULL; } }
+  return resultobj;
+fail:
+  {
+    /* %typemap(freearg) (int iLength, double *pdfData) */
+    CPLFree(arg5);
+  }
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_RasterAttributeTable_SetValueAsString(PyObject *self, PyObject *args) {
+  PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
+  GDALRasterAttributeTableShadow *arg1 = (GDALRasterAttributeTableShadow *) 0 ;
+  int arg2 ;
+  int arg3 ;
+  char *arg4 = (char *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  int val2 ;
+  int ecode2 = 0 ;
+  int val3 ;
+  int ecode3 = 0 ;
+  PyObject *str4 = 0 ;
+  int bToFree4 = 0 ;
+  PyObject *swig_obj[4] ;
+  
+  if (!SWIG_Python_UnpackTuple(args, "RasterAttributeTable_SetValueAsString", 4, 4, swig_obj)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_GDALRasterAttributeTableShadow, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RasterAttributeTable_SetValueAsString" "', argument " "1"" of type '" "GDALRasterAttributeTableShadow *""'"); 
+  }
+  arg1 = reinterpret_cast< GDALRasterAttributeTableShadow * >(argp1);
+  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "RasterAttributeTable_SetValueAsString" "', argument " "2"" of type '" "int""'");
+  } 
+  arg2 = static_cast< int >(val2);
+  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
+  if (!SWIG_IsOK(ecode3)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "RasterAttributeTable_SetValueAsString" "', argument " "3"" of type '" "int""'");
+  } 
+  arg3 = static_cast< int >(val3);
+  {
+    /* %typemap(in) (tostring argin) */
+    str4 = PyObject_Str( swig_obj[3] );
+    if ( str4 == 0 ) {
+      PyErr_SetString( PyExc_RuntimeError, "Unable to format argument as string");
+      SWIG_fail;
+    }
+    
+    arg4 = GDALPythonObjectToCStr(str4, &bToFree4);
+  }
+  {
+    const int bLocalUseExceptions = GetUseExceptions();
+    if ( bLocalUseExceptions ) {
+      pushErrorHandler();
+    }
+    {
+      SWIG_PYTHON_THREAD_BEGIN_ALLOW;
+      GDALRasterAttributeTableShadow_SetValueAsString(arg1,arg2,arg3,(char const *)arg4);
+      SWIG_PYTHON_THREAD_END_ALLOW;
+    }
+    if ( bLocalUseExceptions ) {
+      popErrorHandler();
+    }
+#ifndef SED_HACKS
+    if ( bLocalUseExceptions ) {
+      CPLErr eclass = CPLGetLastErrorType();
+      if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+        SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+      }
+    }
+#endif
+  }
+  resultobj = SWIG_Py_Void();
+  {
+    /* %typemap(freearg) (tostring argin) */
+    if ( str4 != NULL)
+    {
+      Py_DECREF(str4);
+    }
+    GDALPythonFreeCStr(arg4, bToFree4);
+  }
+  if ( ReturnSame(bLocalUseExceptionsCode) ) { CPLErr eclass = CPLGetLastErrorType(); if ( eclass == CE_Failure || eclass == CE_Fatal ) { Py_XDECREF(resultobj); SWIG_Error( SWIG_RuntimeError, CPLGetLastErrorMsg() ); return NULL; } }
+  return resultobj;
+fail:
+  {
+    /* %typemap(freearg) (tostring argin) */
+    if ( str4 != NULL)
+    {
+      Py_DECREF(str4);
+    }
+    GDALPythonFreeCStr(arg4, bToFree4);
+  }
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_RasterAttributeTable_SetValueAsInt(PyObject *self, PyObject *args) {
+  PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
+  GDALRasterAttributeTableShadow *arg1 = (GDALRasterAttributeTableShadow *) 0 ;
+  int arg2 ;
+  int arg3 ;
+  int arg4 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  int val2 ;
+  int ecode2 = 0 ;
+  int val3 ;
+  int ecode3 = 0 ;
+  int val4 ;
+  int ecode4 = 0 ;
+  PyObject *swig_obj[4] ;
+  
+  if (!SWIG_Python_UnpackTuple(args, "RasterAttributeTable_SetValueAsInt", 4, 4, swig_obj)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_GDALRasterAttributeTableShadow, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RasterAttributeTable_SetValueAsInt" "', argument " "1"" of type '" "GDALRasterAttributeTableShadow *""'"); 
+  }
+  arg1 = reinterpret_cast< GDALRasterAttributeTableShadow * >(argp1);
+  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "RasterAttributeTable_SetValueAsInt" "', argument " "2"" of type '" "int""'");
+  } 
+  arg2 = static_cast< int >(val2);
+  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
+  if (!SWIG_IsOK(ecode3)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "RasterAttributeTable_SetValueAsInt" "', argument " "3"" of type '" "int""'");
+  } 
+  arg3 = static_cast< int >(val3);
+  ecode4 = SWIG_AsVal_int(swig_obj[3], &val4);
+  if (!SWIG_IsOK(ecode4)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "RasterAttributeTable_SetValueAsInt" "', argument " "4"" of type '" "int""'");
+  } 
+  arg4 = static_cast< int >(val4);
+  {
+    const int bLocalUseExceptions = GetUseExceptions();
+    if ( bLocalUseExceptions ) {
+      pushErrorHandler();
+    }
+    {
+      SWIG_PYTHON_THREAD_BEGIN_ALLOW;
+      GDALRasterAttributeTableShadow_SetValueAsInt(arg1,arg2,arg3,arg4);
+      SWIG_PYTHON_THREAD_END_ALLOW;
+    }
+    if ( bLocalUseExceptions ) {
+      popErrorHandler();
+    }
+#ifndef SED_HACKS
+    if ( bLocalUseExceptions ) {
+      CPLErr eclass = CPLGetLastErrorType();
+      if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+        SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+      }
+    }
+#endif
+  }
+  resultobj = SWIG_Py_Void();
+  if ( ReturnSame(bLocalUseExceptionsCode) ) { CPLErr eclass = CPLGetLastErrorType(); if ( eclass == CE_Failure || eclass == CE_Fatal ) { Py_XDECREF(resultobj); SWIG_Error( SWIG_RuntimeError, CPLGetLastErrorMsg() ); return NULL; } }
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_RasterAttributeTable_SetValueAsDouble(PyObject *self, PyObject *args) {
+  PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
+  GDALRasterAttributeTableShadow *arg1 = (GDALRasterAttributeTableShadow *) 0 ;
+  int arg2 ;
+  int arg3 ;
+  double arg4 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  int val2 ;
+  int ecode2 = 0 ;
+  int val3 ;
+  int ecode3 = 0 ;
+  double val4 ;
+  int ecode4 = 0 ;
+  PyObject *swig_obj[4] ;
+  
+  if (!SWIG_Python_UnpackTuple(args, "RasterAttributeTable_SetValueAsDouble", 4, 4, swig_obj)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_GDALRasterAttributeTableShadow, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RasterAttributeTable_SetValueAsDouble" "', argument " "1"" of type '" "GDALRasterAttributeTableShadow *""'"); 
+  }
+  arg1 = reinterpret_cast< GDALRasterAttributeTableShadow * >(argp1);
+  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "RasterAttributeTable_SetValueAsDouble" "', argument " "2"" of type '" "int""'");
+  } 
+  arg2 = static_cast< int >(val2);
+  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
+  if (!SWIG_IsOK(ecode3)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "RasterAttributeTable_SetValueAsDouble" "', argument " "3"" of type '" "int""'");
+  } 
+  arg3 = static_cast< int >(val3);
+  ecode4 = SWIG_AsVal_double(swig_obj[3], &val4);
+  if (!SWIG_IsOK(ecode4)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "RasterAttributeTable_SetValueAsDouble" "', argument " "4"" of type '" "double""'");
+  } 
+  arg4 = static_cast< double >(val4);
+  {
+    const int bLocalUseExceptions = GetUseExceptions();
+    if ( bLocalUseExceptions ) {
+      pushErrorHandler();
+    }
+    {
+      SWIG_PYTHON_THREAD_BEGIN_ALLOW;
+      GDALRasterAttributeTableShadow_SetValueAsDouble(arg1,arg2,arg3,arg4);
+      SWIG_PYTHON_THREAD_END_ALLOW;
+    }
+    if ( bLocalUseExceptions ) {
+      popErrorHandler();
+    }
+#ifndef SED_HACKS
+    if ( bLocalUseExceptions ) {
+      CPLErr eclass = CPLGetLastErrorType();
+      if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+        SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+      }
+    }
+#endif
+  }
+  resultobj = SWIG_Py_Void();
+  if ( ReturnSame(bLocalUseExceptionsCode) ) { CPLErr eclass = CPLGetLastErrorType(); if ( eclass == CE_Failure || eclass == CE_Fatal ) { Py_XDECREF(resultobj); SWIG_Error( SWIG_RuntimeError, CPLGetLastErrorMsg() ); return NULL; } }
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_RasterAttributeTable_SetRowCount(PyObject *self, PyObject *args) {
+  PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
+  GDALRasterAttributeTableShadow *arg1 = (GDALRasterAttributeTableShadow *) 0 ;
+  int arg2 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  int val2 ;
+  int ecode2 = 0 ;
+  PyObject *swig_obj[2] ;
+  
+  if (!SWIG_Python_UnpackTuple(args, "RasterAttributeTable_SetRowCount", 2, 2, swig_obj)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_GDALRasterAttributeTableShadow, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RasterAttributeTable_SetRowCount" "', argument " "1"" of type '" "GDALRasterAttributeTableShadow *""'"); 
+  }
+  arg1 = reinterpret_cast< GDALRasterAttributeTableShadow * >(argp1);
+  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "RasterAttributeTable_SetRowCount" "', argument " "2"" of type '" "int""'");
+  } 
+  arg2 = static_cast< int >(val2);
+  {
+    const int bLocalUseExceptions = GetUseExceptions();
+    if ( bLocalUseExceptions ) {
+      pushErrorHandler();
+    }
+    {
+      SWIG_PYTHON_THREAD_BEGIN_ALLOW;
+      GDALRasterAttributeTableShadow_SetRowCount(arg1,arg2);
+      SWIG_PYTHON_THREAD_END_ALLOW;
+    }
+    if ( bLocalUseExceptions ) {
+      popErrorHandler();
+    }
+#ifndef SED_HACKS
+    if ( bLocalUseExceptions ) {
+      CPLErr eclass = CPLGetLastErrorType();
+      if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+        SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+      }
+    }
+#endif
+  }
+  resultobj = SWIG_Py_Void();
+  if ( ReturnSame(bLocalUseExceptionsCode) ) { CPLErr eclass = CPLGetLastErrorType(); if ( eclass == CE_Failure || eclass == CE_Fatal ) { Py_XDECREF(resultobj); SWIG_Error( SWIG_RuntimeError, CPLGetLastErrorMsg() ); return NULL; } }
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_RasterAttributeTable_CreateColumn(PyObject *self, PyObject *args) {
+  PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
+  GDALRasterAttributeTableShadow *arg1 = (GDALRasterAttributeTableShadow *) 0 ;
+  char *arg2 = (char *) 0 ;
+  GDALRATFieldType arg3 ;
+  GDALRATFieldUsage arg4 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  int res2 ;
+  char *buf2 = 0 ;
+  int alloc2 = 0 ;
+  int val3 ;
+  int ecode3 = 0 ;
+  int val4 ;
+  int ecode4 = 0 ;
+  PyObject *swig_obj[4] ;
+  int result;
+  
+  if (!SWIG_Python_UnpackTuple(args, "RasterAttributeTable_CreateColumn", 4, 4, swig_obj)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_GDALRasterAttributeTableShadow, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RasterAttributeTable_CreateColumn" "', argument " "1"" of type '" "GDALRasterAttributeTableShadow *""'"); 
+  }
+  arg1 = reinterpret_cast< GDALRasterAttributeTableShadow * >(argp1);
+  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, NULL, &alloc2);
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "RasterAttributeTable_CreateColumn" "', argument " "2"" of type '" "char const *""'");
+  }
+  arg2 = reinterpret_cast< char * >(buf2);
+  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
+  if (!SWIG_IsOK(ecode3)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "RasterAttributeTable_CreateColumn" "', argument " "3"" of type '" "GDALRATFieldType""'");
+  } 
+  arg3 = static_cast< GDALRATFieldType >(val3);
+  ecode4 = SWIG_AsVal_int(swig_obj[3], &val4);
+  if (!SWIG_IsOK(ecode4)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "RasterAttributeTable_CreateColumn" "', argument " "4"" of type '" "GDALRATFieldUsage""'");
+  } 
+  arg4 = static_cast< GDALRATFieldUsage >(val4);
+  {
+    const int bLocalUseExceptions = GetUseExceptions();
+    if ( bLocalUseExceptions ) {
+      pushErrorHandler();
+    }
+    {
+      SWIG_PYTHON_THREAD_BEGIN_ALLOW;
+      result = (int)GDALRasterAttributeTableShadow_CreateColumn(arg1,(char const *)arg2,arg3,arg4);
+      SWIG_PYTHON_THREAD_END_ALLOW;
+    }
+    if ( bLocalUseExceptions ) {
+      popErrorHandler();
+    }
+#ifndef SED_HACKS
+    if ( bLocalUseExceptions ) {
+      CPLErr eclass = CPLGetLastErrorType();
+      if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+        SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+      }
+    }
+#endif
+  }
+  resultobj = SWIG_From_int(static_cast< int >(result));
+  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+  if ( ReturnSame(bLocalUseExceptionsCode) ) { CPLErr eclass = CPLGetLastErrorType(); if ( eclass == CE_Failure || eclass == CE_Fatal ) { Py_XDECREF(resultobj); SWIG_Error( SWIG_RuntimeError, CPLGetLastErrorMsg() ); return NULL; } }
+  return resultobj;
+fail:
+  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_RasterAttributeTable_GetLinearBinning(PyObject *self, PyObject *args) {
+  PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
+  GDALRasterAttributeTableShadow *arg1 = (GDALRasterAttributeTableShadow *) 0 ;
+  double *arg2 = (double *) 0 ;
+  double *arg3 = (double *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  double temp2 ;
+  int res2 = SWIG_TMPOBJ ;
+  double temp3 ;
+  int res3 = SWIG_TMPOBJ ;
+  PyObject *swig_obj[1] ;
+  bool result;
+  
+  arg2 = &temp2;
+  arg3 = &temp3;
+  if (!args) SWIG_fail;
+  swig_obj[0] = args;
+  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_GDALRasterAttributeTableShadow, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RasterAttributeTable_GetLinearBinning" "', argument " "1"" of type '" "GDALRasterAttributeTableShadow *""'"); 
+  }
+  arg1 = reinterpret_cast< GDALRasterAttributeTableShadow * >(argp1);
+  {
+    const int bLocalUseExceptions = GetUseExceptions();
+    if ( bLocalUseExceptions ) {
+      pushErrorHandler();
+    }
+    {
+      SWIG_PYTHON_THREAD_BEGIN_ALLOW;
+      result = (bool)GDALRasterAttributeTableShadow_GetLinearBinning(arg1,arg2,arg3);
+      SWIG_PYTHON_THREAD_END_ALLOW;
+    }
+    if ( bLocalUseExceptions ) {
+      popErrorHandler();
+    }
+#ifndef SED_HACKS
+    if ( bLocalUseExceptions ) {
+      CPLErr eclass = CPLGetLastErrorType();
+      if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+        SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+      }
+    }
+#endif
+  }
+  resultobj = SWIG_From_bool(static_cast< bool >(result));
+  if (ReturnSame(SWIG_IsTmpObj(res2))) {
+    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg2)));
+  } else {
+    int new_flags = SWIG_IsNewObj(res2) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
+    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_double, new_flags));
+  }
+  if (ReturnSame(SWIG_IsTmpObj(res3))) {
+    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg3)));
+  } else {
+    int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
+    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_double, new_flags));
+  }
+  if ( ReturnSame(bLocalUseExceptionsCode) ) { CPLErr eclass = CPLGetLastErrorType(); if ( eclass == CE_Failure || eclass == CE_Fatal ) { Py_XDECREF(resultobj); SWIG_Error( SWIG_RuntimeError, CPLGetLastErrorMsg() ); return NULL; } }
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_RasterAttributeTable_SetLinearBinning(PyObject *self, PyObject *args) {
+  PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
+  GDALRasterAttributeTableShadow *arg1 = (GDALRasterAttributeTableShadow *) 0 ;
+  double arg2 ;
+  double arg3 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  double val2 ;
+  int ecode2 = 0 ;
+  double val3 ;
+  int ecode3 = 0 ;
+  PyObject *swig_obj[3] ;
+  int result;
+  
+  if (!SWIG_Python_UnpackTuple(args, "RasterAttributeTable_SetLinearBinning", 3, 3, swig_obj)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_GDALRasterAttributeTableShadow, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RasterAttributeTable_SetLinearBinning" "', argument " "1"" of type '" "GDALRasterAttributeTableShadow *""'"); 
+  }
+  arg1 = reinterpret_cast< GDALRasterAttributeTableShadow * >(argp1);
+  ecode2 = SWIG_AsVal_double(swig_obj[1], &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "RasterAttributeTable_SetLinearBinning" "', argument " "2"" of type '" "double""'");
+  } 
+  arg2 = static_cast< double >(val2);
+  ecode3 = SWIG_AsVal_double(swig_obj[2], &val3);
+  if (!SWIG_IsOK(ecode3)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "RasterAttributeTable_SetLinearBinning" "', argument " "3"" of type '" "double""'");
+  } 
+  arg3 = static_cast< double >(val3);
+  {
+    const int bLocalUseExceptions = GetUseExceptions();
+    if ( bLocalUseExceptions ) {
+      pushErrorHandler();
+    }
+    {
+      SWIG_PYTHON_THREAD_BEGIN_ALLOW;
+      result = (int)GDALRasterAttributeTableShadow_SetLinearBinning(arg1,arg2,arg3);
+      SWIG_PYTHON_THREAD_END_ALLOW;
+    }
+    if ( bLocalUseExceptions ) {
+      popErrorHandler();
+    }
+#ifndef SED_HACKS
+    if ( bLocalUseExceptions ) {
+      CPLErr eclass = CPLGetLastErrorType();
+      if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+        SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+      }
+    }
+#endif
+  }
+  resultobj = SWIG_From_int(static_cast< int >(result));
+  if ( ReturnSame(bLocalUseExceptionsCode) ) { CPLErr eclass = CPLGetLastErrorType(); if ( eclass == CE_Failure || eclass == CE_Fatal ) { Py_XDECREF(resultobj); SWIG_Error( SWIG_RuntimeError, CPLGetLastErrorMsg() ); return NULL; } }
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_RasterAttributeTable_GetRowOfValue(PyObject *self, PyObject *args) {
+  PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
+  GDALRasterAttributeTableShadow *arg1 = (GDALRasterAttributeTableShadow *) 0 ;
+  double arg2 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  double val2 ;
+  int ecode2 = 0 ;
+  PyObject *swig_obj[2] ;
+  int result;
+  
+  if (!SWIG_Python_UnpackTuple(args, "RasterAttributeTable_GetRowOfValue", 2, 2, swig_obj)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_GDALRasterAttributeTableShadow, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RasterAttributeTable_GetRowOfValue" "', argument " "1"" of type '" "GDALRasterAttributeTableShadow *""'"); 
+  }
+  arg1 = reinterpret_cast< GDALRasterAttributeTableShadow * >(argp1);
+  ecode2 = SWIG_AsVal_double(swig_obj[1], &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "RasterAttributeTable_GetRowOfValue" "', argument " "2"" of type '" "double""'");
+  } 
+  arg2 = static_cast< double >(val2);
+  {
+    const int bLocalUseExceptions = GetUseExceptions();
+    if ( bLocalUseExceptions ) {
+      pushErrorHandler();
+    }
+    {
+      SWIG_PYTHON_THREAD_BEGIN_ALLOW;
+      result = (int)GDALRasterAttributeTableShadow_GetRowOfValue(arg1,arg2);
+      SWIG_PYTHON_THREAD_END_ALLOW;
+    }
+    if ( bLocalUseExceptions ) {
+      popErrorHandler();
+    }
+#ifndef SED_HACKS
+    if ( bLocalUseExceptions ) {
+      CPLErr eclass = CPLGetLastErrorType();
+      if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+        SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+      }
+    }
+#endif
+  }
+  resultobj = SWIG_From_int(static_cast< int >(result));
+  if ( ReturnSame(bLocalUseExceptionsCode) ) { CPLErr eclass = CPLGetLastErrorType(); if ( eclass == CE_Failure || eclass == CE_Fatal ) { Py_XDECREF(resultobj); SWIG_Error( SWIG_RuntimeError, CPLGetLastErrorMsg() ); return NULL; } }
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_RasterAttributeTable_ChangesAreWrittenToFile(PyObject *self, PyObject *args) {
+  PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
+  GDALRasterAttributeTableShadow *arg1 = (GDALRasterAttributeTableShadow *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject *swig_obj[1] ;
+  int result;
+  
+  if (!args) SWIG_fail;
+  swig_obj[0] = args;
+  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_GDALRasterAttributeTableShadow, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RasterAttributeTable_ChangesAreWrittenToFile" "', argument " "1"" of type '" "GDALRasterAttributeTableShadow *""'"); 
+  }
+  arg1 = reinterpret_cast< GDALRasterAttributeTableShadow * >(argp1);
+  {
+    const int bLocalUseExceptions = GetUseExceptions();
+    if ( bLocalUseExceptions ) {
+      pushErrorHandler();
+    }
+    {
+      SWIG_PYTHON_THREAD_BEGIN_ALLOW;
+      result = (int)GDALRasterAttributeTableShadow_ChangesAreWrittenToFile(arg1);
+      SWIG_PYTHON_THREAD_END_ALLOW;
+    }
+    if ( bLocalUseExceptions ) {
+      popErrorHandler();
+    }
+#ifndef SED_HACKS
+    if ( bLocalUseExceptions ) {
+      CPLErr eclass = CPLGetLastErrorType();
+      if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+        SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+      }
+    }
+#endif
+  }
+  resultobj = SWIG_From_int(static_cast< int >(result));
+  if ( ReturnSame(bLocalUseExceptionsCode) ) { CPLErr eclass = CPLGetLastErrorType(); if ( eclass == CE_Failure || eclass == CE_Fatal ) { Py_XDECREF(resultobj); SWIG_Error( SWIG_RuntimeError, CPLGetLastErrorMsg() ); return NULL; } }
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_RasterAttributeTable_DumpReadable(PyObject *self, PyObject *args) {
+  PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
+  GDALRasterAttributeTableShadow *arg1 = (GDALRasterAttributeTableShadow *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject *swig_obj[1] ;
+  
+  if (!args) SWIG_fail;
+  swig_obj[0] = args;
+  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_GDALRasterAttributeTableShadow, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RasterAttributeTable_DumpReadable" "', argument " "1"" of type '" "GDALRasterAttributeTableShadow *""'"); 
+  }
+  arg1 = reinterpret_cast< GDALRasterAttributeTableShadow * >(argp1);
+  {
+    const int bLocalUseExceptions = GetUseExceptions();
+    if ( bLocalUseExceptions ) {
+      pushErrorHandler();
+    }
+    {
+      SWIG_PYTHON_THREAD_BEGIN_ALLOW;
+      GDALRasterAttributeTableShadow_DumpReadable(arg1);
+      SWIG_PYTHON_THREAD_END_ALLOW;
+    }
+    if ( bLocalUseExceptions ) {
+      popErrorHandler();
+    }
+#ifndef SED_HACKS
+    if ( bLocalUseExceptions ) {
+      CPLErr eclass = CPLGetLastErrorType();
+      if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+        SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+      }
+    }
+#endif
+  }
+  resultobj = SWIG_Py_Void();
+  if ( ReturnSame(bLocalUseExceptionsCode) ) { CPLErr eclass = CPLGetLastErrorType(); if ( eclass == CE_Failure || eclass == CE_Fatal ) { Py_XDECREF(resultobj); SWIG_Error( SWIG_RuntimeError, CPLGetLastErrorMsg() ); return NULL; } }
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_RasterAttributeTable_SetTableType(PyObject *self, PyObject *args) {
+  PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
+  GDALRasterAttributeTableShadow *arg1 = (GDALRasterAttributeTableShadow *) 0 ;
+  GDALRATTableType arg2 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  int val2 ;
+  int ecode2 = 0 ;
+  PyObject *swig_obj[2] ;
+  
+  if (!SWIG_Python_UnpackTuple(args, "RasterAttributeTable_SetTableType", 2, 2, swig_obj)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_GDALRasterAttributeTableShadow, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RasterAttributeTable_SetTableType" "', argument " "1"" of type '" "GDALRasterAttributeTableShadow *""'"); 
+  }
+  arg1 = reinterpret_cast< GDALRasterAttributeTableShadow * >(argp1);
+  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "RasterAttributeTable_SetTableType" "', argument " "2"" of type '" "GDALRATTableType""'");
+  } 
+  arg2 = static_cast< GDALRATTableType >(val2);
+  {
+    const int bLocalUseExceptions = GetUseExceptions();
+    if ( bLocalUseExceptions ) {
+      pushErrorHandler();
+    }
+    {
+      SWIG_PYTHON_THREAD_BEGIN_ALLOW;
+      GDALRasterAttributeTableShadow_SetTableType(arg1,arg2);
+      SWIG_PYTHON_THREAD_END_ALLOW;
+    }
+    if ( bLocalUseExceptions ) {
+      popErrorHandler();
+    }
+#ifndef SED_HACKS
+    if ( bLocalUseExceptions ) {
+      CPLErr eclass = CPLGetLastErrorType();
+      if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+        SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+      }
+    }
+#endif
+  }
+  resultobj = SWIG_Py_Void();
+  if ( ReturnSame(bLocalUseExceptionsCode) ) { CPLErr eclass = CPLGetLastErrorType(); if ( eclass == CE_Failure || eclass == CE_Fatal ) { Py_XDECREF(resultobj); SWIG_Error( SWIG_RuntimeError, CPLGetLastErrorMsg() ); return NULL; } }
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_RasterAttributeTable_GetTableType(PyObject *self, PyObject *args) {
+  PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
+  GDALRasterAttributeTableShadow *arg1 = (GDALRasterAttributeTableShadow *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject *swig_obj[1] ;
+  GDALRATTableType result;
+  
+  if (!args) SWIG_fail;
+  swig_obj[0] = args;
+  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_GDALRasterAttributeTableShadow, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RasterAttributeTable_GetTableType" "', argument " "1"" of type '" "GDALRasterAttributeTableShadow *""'"); 
+  }
+  arg1 = reinterpret_cast< GDALRasterAttributeTableShadow * >(argp1);
+  {
+    const int bLocalUseExceptions = GetUseExceptions();
+    if ( bLocalUseExceptions ) {
+      pushErrorHandler();
+    }
+    {
+      SWIG_PYTHON_THREAD_BEGIN_ALLOW;
+      result = (GDALRATTableType)GDALRasterAttributeTableShadow_GetTableType(arg1);
+      SWIG_PYTHON_THREAD_END_ALLOW;
+    }
+    if ( bLocalUseExceptions ) {
+      popErrorHandler();
+    }
+#ifndef SED_HACKS
+    if ( bLocalUseExceptions ) {
+      CPLErr eclass = CPLGetLastErrorType();
+      if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+        SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+      }
+    }
+#endif
+  }
+  resultobj = SWIG_From_int(static_cast< int >(result));
+  if ( ReturnSame(bLocalUseExceptionsCode) ) { CPLErr eclass = CPLGetLastErrorType(); if ( eclass == CE_Failure || eclass == CE_Fatal ) { Py_XDECREF(resultobj); SWIG_Error( SWIG_RuntimeError, CPLGetLastErrorMsg() ); return NULL; } }
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_RasterAttributeTable_RemoveStatistics(PyObject *self, PyObject *args) {
+  PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
+  GDALRasterAttributeTableShadow *arg1 = (GDALRasterAttributeTableShadow *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject *swig_obj[1] ;
+  
+  if (!args) SWIG_fail;
+  swig_obj[0] = args;
+  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_GDALRasterAttributeTableShadow, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RasterAttributeTable_RemoveStatistics" "', argument " "1"" of type '" "GDALRasterAttributeTableShadow *""'"); 
+  }
+  arg1 = reinterpret_cast< GDALRasterAttributeTableShadow * >(argp1);
+  {
+    const int bLocalUseExceptions = GetUseExceptions();
+    if ( bLocalUseExceptions ) {
+      pushErrorHandler();
+    }
+    {
+      SWIG_PYTHON_THREAD_BEGIN_ALLOW;
+      GDALRasterAttributeTableShadow_RemoveStatistics(arg1);
+      SWIG_PYTHON_THREAD_END_ALLOW;
+    }
+    if ( bLocalUseExceptions ) {
+      popErrorHandler();
+    }
+#ifndef SED_HACKS
+    if ( bLocalUseExceptions ) {
+      CPLErr eclass = CPLGetLastErrorType();
+      if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+        SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+      }
+    }
+#endif
+  }
+  resultobj = SWIG_Py_Void();
+  if ( ReturnSame(bLocalUseExceptionsCode) ) { CPLErr eclass = CPLGetLastErrorType(); if ( eclass == CE_Failure || eclass == CE_Fatal ) { Py_XDECREF(resultobj); SWIG_Error( SWIG_RuntimeError, CPLGetLastErrorMsg() ); return NULL; } }
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *RasterAttributeTable_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *obj;
+  if (!SWIG_Python_UnpackTuple(args, "swigregister", 1, 1, &obj)) return NULL;
+  SWIG_TypeNewClientData(SWIGTYPE_p_GDALRasterAttributeTableShadow, SWIG_NewClientData(obj));
+  return SWIG_Py_Void();
+}
+
+SWIGINTERN PyObject *RasterAttributeTable_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  return SWIG_Python_InitShadowInstance(args);
+}
+
 SWIGINTERN PyObject *_wrap_delete_Group(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
   GDALGroupHS *arg1 = (GDALGroupHS *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   PyObject *swig_obj[1] ;
   
@@ -34019,14 +35895,155 @@
 SWIGINTERN PyObject *EDTComponent_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
   PyObject *obj;
   if (!SWIG_Python_UnpackTuple(args, "swigregister", 1, 1, &obj)) return NULL;
   SWIG_TypeNewClientData(SWIGTYPE_p_GDALEDTComponentHS, SWIG_NewClientData(obj));
   return SWIG_Py_Void();
 }
 
+SWIGINTERN PyObject *_wrap_CreateRasterAttributeTableFromMDArrays(PyObject *self, PyObject *args) {
+  PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
+  GDALRATTableType arg1 ;
+  int arg2 ;
+  GDALMDArrayHS **arg3 = (GDALMDArrayHS **) 0 ;
+  int arg4 = (int) 0 ;
+  GDALRATFieldUsage *arg5 = (GDALRATFieldUsage *) NULL ;
+  int val1 ;
+  int ecode1 = 0 ;
+  PyObject *swig_obj[3] ;
+  GDALRasterAttributeTableShadow *result = 0 ;
+  
+  if (!SWIG_Python_UnpackTuple(args, "CreateRasterAttributeTableFromMDArrays", 2, 3, swig_obj)) SWIG_fail;
+  ecode1 = SWIG_AsVal_int(swig_obj[0], &val1);
+  if (!SWIG_IsOK(ecode1)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "CreateRasterAttributeTableFromMDArrays" "', argument " "1"" of type '" "GDALRATTableType""'");
+  } 
+  arg1 = static_cast< GDALRATTableType >(val1);
+  {
+    /*  OBJECT_LIST_INPUT %typemap(in) (int itemcount, GDALMDArrayHS *optional_##GDALMDArrayHS)*/
+    if ( !PySequence_Check(swig_obj[1]) ) {
+      PyErr_SetString(PyExc_TypeError, "not a sequence");
+      SWIG_fail;
+    }
+    Py_ssize_t size = PySequence_Size(swig_obj[1]);
+    if( size > (Py_ssize_t)INT_MAX ) {
+      PyErr_SetString(PyExc_TypeError, "too big sequence");
+      SWIG_fail;
+    }
+    if( (size_t)size > SIZE_MAX / sizeof(GDALMDArrayHS*) ) {
+      PyErr_SetString(PyExc_TypeError, "too big sequence");
+      SWIG_fail;
+    }
+    arg2 = (int)size;
+    arg3 = (GDALMDArrayHS**) VSIMalloc(arg2*sizeof(GDALMDArrayHS*));
+    if( !arg3) {
+      PyErr_SetString(PyExc_MemoryError, "cannot allocate temporary buffer");
+      SWIG_fail;
+    }
+    
+    for( int i = 0; i<arg2; i++ ) {
+      PyObject *o = PySequence_GetItem(swig_obj[1],i);
+      GDALMDArrayHS* rawobjectpointer = NULL;
+      CPL_IGNORE_RET_VAL(SWIG_ConvertPtr( o, (void**)&rawobjectpointer, SWIGTYPE_p_GDALMDArrayHS, SWIG_POINTER_EXCEPTION | 0 ));
+      if (!rawobjectpointer) {
+        Py_DECREF(o);
+        PyErr_SetString(PyExc_TypeError, "object of wrong GDALMDArrayHS");
+        SWIG_fail;
+      }
+      arg3[i] = rawobjectpointer;
+      Py_DECREF(o);
+      
+    }
+  }
+  if (swig_obj[2]) {
+    {
+      /*  %typemap(in) (int nUsages, GDALRATFieldUsage *paeUsages)*/
+      if ( !PySequence_Check(swig_obj[2]) ) {
+        PyErr_SetString(PyExc_TypeError, "not a sequence");
+        SWIG_fail;
+      }
+      Py_ssize_t size = PySequence_Size(swig_obj[2]);
+      if( size > (Py_ssize_t)INT_MAX ) {
+        PyErr_SetString(PyExc_TypeError, "too big sequence");
+        SWIG_fail;
+      }
+      if( (size_t)size > SIZE_MAX / sizeof(int) ) {
+        PyErr_SetString(PyExc_TypeError, "too big sequence");
+        SWIG_fail;
+      }
+      arg4 = (int)size;
+      arg5 = (GDALRATFieldUsage*) VSIMalloc(arg4*sizeof(GDALRATFieldUsage));
+      if( !arg5) {
+        PyErr_SetString(PyExc_MemoryError, "cannot allocate temporary buffer");
+        SWIG_fail;
+      }
+      
+      for( int i = 0; i<arg4; i++ ) {
+        PyObject *o = PySequence_GetItem(swig_obj[2],i);
+        int nVal = 0;
+        if ( !PyArg_Parse(o,"i",&nVal) ) {
+          PyErr_SetString(PyExc_TypeError, "not a valid GDALRATFieldUsage");
+          Py_DECREF(o);
+          SWIG_fail;
+        }
+        Py_DECREF(o);
+        if( nVal < 0 || nVal >= GFU_MaxCount )
+        {
+          PyErr_SetString(PyExc_TypeError, "not a valid GDALRATFieldUsage");
+          SWIG_fail;
+        }
+        (arg5)[i] = static_cast<GDALRATFieldUsage>(nVal);
+      }
+    }
+  }
+  {
+    const int bLocalUseExceptions = GetUseExceptions();
+    if ( bLocalUseExceptions ) {
+      pushErrorHandler();
+    }
+    {
+      SWIG_PYTHON_THREAD_BEGIN_ALLOW;
+      result = (GDALRasterAttributeTableShadow *)CreateRasterAttributeTableFromMDArrays(arg1,arg2,arg3,arg4,arg5);
+      SWIG_PYTHON_THREAD_END_ALLOW;
+    }
+    if ( bLocalUseExceptions ) {
+      popErrorHandler();
+    }
+#ifndef SED_HACKS
+    if ( bLocalUseExceptions ) {
+      CPLErr eclass = CPLGetLastErrorType();
+      if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+        SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+      }
+    }
+#endif
+  }
+  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_GDALRasterAttributeTableShadow, SWIG_POINTER_OWN |  0 );
+  {
+    /* OBJECT_LIST_INPUT %typemap(freearg) (int object_list_count, GDALMDArrayHS **poObjects)*/
+    CPLFree( arg3 );
+  }
+  {
+    /* %typemap(freearg) (int nUsages, GDALRATFieldUsage *paeUsages)*/
+    CPLFree( arg5 );
+  }
+  if ( ReturnSame(bLocalUseExceptionsCode) ) { CPLErr eclass = CPLGetLastErrorType(); if ( eclass == CE_Failure || eclass == CE_Fatal ) { Py_XDECREF(resultobj); SWIG_Error( SWIG_RuntimeError, CPLGetLastErrorMsg() ); return NULL; } }
+  return resultobj;
+fail:
+  {
+    /* OBJECT_LIST_INPUT %typemap(freearg) (int object_list_count, GDALMDArrayHS **poObjects)*/
+    CPLFree( arg3 );
+  }
+  {
+    /* %typemap(freearg) (int nUsages, GDALRATFieldUsage *paeUsages)*/
+    CPLFree( arg5 );
+  }
+  return NULL;
+}
+
+
 SWIGINTERN PyObject *_wrap_Band_XSize_get(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
   GDALRasterBandShadow *arg1 = (GDALRasterBandShadow *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   PyObject *swig_obj[1] ;
   int result;
@@ -39472,1333 +41489,14 @@
   return SWIG_Py_Void();
 }
 
 SWIGINTERN PyObject *ColorTable_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
   return SWIG_Python_InitShadowInstance(args);
 }
 
-SWIGINTERN PyObject *_wrap_new_RasterAttributeTable(PyObject *self, PyObject *args) {
-  PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
-  GDALRasterAttributeTableShadow *result = 0 ;
-  
-  if (!SWIG_Python_UnpackTuple(args, "new_RasterAttributeTable", 0, 0, 0)) SWIG_fail;
-  {
-    const int bLocalUseExceptions = GetUseExceptions();
-    if ( bLocalUseExceptions ) {
-      pushErrorHandler();
-    }
-    {
-      SWIG_PYTHON_THREAD_BEGIN_ALLOW;
-      result = (GDALRasterAttributeTableShadow *)new_GDALRasterAttributeTableShadow();
-      SWIG_PYTHON_THREAD_END_ALLOW;
-    }
-    if ( bLocalUseExceptions ) {
-      popErrorHandler();
-    }
-#ifndef SED_HACKS
-    if ( bLocalUseExceptions ) {
-      CPLErr eclass = CPLGetLastErrorType();
-      if ( eclass == CE_Failure || eclass == CE_Fatal ) {
-        SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
-      }
-    }
-#endif
-  }
-  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_GDALRasterAttributeTableShadow, SWIG_POINTER_NEW |  0 );
-  if ( ReturnSame(bLocalUseExceptionsCode) ) { CPLErr eclass = CPLGetLastErrorType(); if ( eclass == CE_Failure || eclass == CE_Fatal ) { Py_XDECREF(resultobj); SWIG_Error( SWIG_RuntimeError, CPLGetLastErrorMsg() ); return NULL; } }
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_delete_RasterAttributeTable(PyObject *self, PyObject *args) {
-  PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
-  GDALRasterAttributeTableShadow *arg1 = (GDALRasterAttributeTableShadow *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject *swig_obj[1] ;
-  
-  if (!args) SWIG_fail;
-  swig_obj[0] = args;
-  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_GDALRasterAttributeTableShadow, SWIG_POINTER_DISOWN |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_RasterAttributeTable" "', argument " "1"" of type '" "GDALRasterAttributeTableShadow *""'"); 
-  }
-  arg1 = reinterpret_cast< GDALRasterAttributeTableShadow * >(argp1);
-  {
-    const int bLocalUseExceptions = GetUseExceptions();
-    if ( bLocalUseExceptions ) {
-      pushErrorHandler();
-    }
-    {
-      SWIG_PYTHON_THREAD_BEGIN_ALLOW;
-      delete_GDALRasterAttributeTableShadow(arg1);
-      SWIG_PYTHON_THREAD_END_ALLOW;
-    }
-    if ( bLocalUseExceptions ) {
-      popErrorHandler();
-    }
-#ifndef SED_HACKS
-    if ( bLocalUseExceptions ) {
-      CPLErr eclass = CPLGetLastErrorType();
-      if ( eclass == CE_Failure || eclass == CE_Fatal ) {
-        SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
-      }
-    }
-#endif
-  }
-  resultobj = SWIG_Py_Void();
-  if ( ReturnSame(bLocalUseExceptionsCode) ) { CPLErr eclass = CPLGetLastErrorType(); if ( eclass == CE_Failure || eclass == CE_Fatal ) { Py_XDECREF(resultobj); SWIG_Error( SWIG_RuntimeError, CPLGetLastErrorMsg() ); return NULL; } }
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_RasterAttributeTable_Clone(PyObject *self, PyObject *args) {
-  PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
-  GDALRasterAttributeTableShadow *arg1 = (GDALRasterAttributeTableShadow *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject *swig_obj[1] ;
-  GDALRasterAttributeTableShadow *result = 0 ;
-  
-  if (!args) SWIG_fail;
-  swig_obj[0] = args;
-  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_GDALRasterAttributeTableShadow, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RasterAttributeTable_Clone" "', argument " "1"" of type '" "GDALRasterAttributeTableShadow *""'"); 
-  }
-  arg1 = reinterpret_cast< GDALRasterAttributeTableShadow * >(argp1);
-  {
-    const int bLocalUseExceptions = GetUseExceptions();
-    if ( bLocalUseExceptions ) {
-      pushErrorHandler();
-    }
-    {
-      SWIG_PYTHON_THREAD_BEGIN_ALLOW;
-      result = (GDALRasterAttributeTableShadow *)GDALRasterAttributeTableShadow_Clone(arg1);
-      SWIG_PYTHON_THREAD_END_ALLOW;
-    }
-    if ( bLocalUseExceptions ) {
-      popErrorHandler();
-    }
-#ifndef SED_HACKS
-    if ( bLocalUseExceptions ) {
-      CPLErr eclass = CPLGetLastErrorType();
-      if ( eclass == CE_Failure || eclass == CE_Fatal ) {
-        SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
-      }
-    }
-#endif
-  }
-  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_GDALRasterAttributeTableShadow, SWIG_POINTER_OWN |  0 );
-  if ( ReturnSame(bLocalUseExceptionsCode) ) { CPLErr eclass = CPLGetLastErrorType(); if ( eclass == CE_Failure || eclass == CE_Fatal ) { Py_XDECREF(resultobj); SWIG_Error( SWIG_RuntimeError, CPLGetLastErrorMsg() ); return NULL; } }
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_RasterAttributeTable_GetColumnCount(PyObject *self, PyObject *args) {
-  PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
-  GDALRasterAttributeTableShadow *arg1 = (GDALRasterAttributeTableShadow *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject *swig_obj[1] ;
-  int result;
-  
-  if (!args) SWIG_fail;
-  swig_obj[0] = args;
-  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_GDALRasterAttributeTableShadow, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RasterAttributeTable_GetColumnCount" "', argument " "1"" of type '" "GDALRasterAttributeTableShadow *""'"); 
-  }
-  arg1 = reinterpret_cast< GDALRasterAttributeTableShadow * >(argp1);
-  {
-    const int bLocalUseExceptions = GetUseExceptions();
-    if ( bLocalUseExceptions ) {
-      pushErrorHandler();
-    }
-    {
-      SWIG_PYTHON_THREAD_BEGIN_ALLOW;
-      result = (int)GDALRasterAttributeTableShadow_GetColumnCount(arg1);
-      SWIG_PYTHON_THREAD_END_ALLOW;
-    }
-    if ( bLocalUseExceptions ) {
-      popErrorHandler();
-    }
-#ifndef SED_HACKS
-    if ( bLocalUseExceptions ) {
-      CPLErr eclass = CPLGetLastErrorType();
-      if ( eclass == CE_Failure || eclass == CE_Fatal ) {
-        SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
-      }
-    }
-#endif
-  }
-  resultobj = SWIG_From_int(static_cast< int >(result));
-  if ( ReturnSame(bLocalUseExceptionsCode) ) { CPLErr eclass = CPLGetLastErrorType(); if ( eclass == CE_Failure || eclass == CE_Fatal ) { Py_XDECREF(resultobj); SWIG_Error( SWIG_RuntimeError, CPLGetLastErrorMsg() ); return NULL; } }
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_RasterAttributeTable_GetNameOfCol(PyObject *self, PyObject *args) {
-  PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
-  GDALRasterAttributeTableShadow *arg1 = (GDALRasterAttributeTableShadow *) 0 ;
-  int arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  PyObject *swig_obj[2] ;
-  char *result = 0 ;
-  
-  if (!SWIG_Python_UnpackTuple(args, "RasterAttributeTable_GetNameOfCol", 2, 2, swig_obj)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_GDALRasterAttributeTableShadow, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RasterAttributeTable_GetNameOfCol" "', argument " "1"" of type '" "GDALRasterAttributeTableShadow *""'"); 
-  }
-  arg1 = reinterpret_cast< GDALRasterAttributeTableShadow * >(argp1);
-  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "RasterAttributeTable_GetNameOfCol" "', argument " "2"" of type '" "int""'");
-  } 
-  arg2 = static_cast< int >(val2);
-  {
-    const int bLocalUseExceptions = GetUseExceptions();
-    if ( bLocalUseExceptions ) {
-      pushErrorHandler();
-    }
-    {
-      SWIG_PYTHON_THREAD_BEGIN_ALLOW;
-      result = (char *)GDALRasterAttributeTableShadow_GetNameOfCol(arg1,arg2);
-      SWIG_PYTHON_THREAD_END_ALLOW;
-    }
-    if ( bLocalUseExceptions ) {
-      popErrorHandler();
-    }
-#ifndef SED_HACKS
-    if ( bLocalUseExceptions ) {
-      CPLErr eclass = CPLGetLastErrorType();
-      if ( eclass == CE_Failure || eclass == CE_Fatal ) {
-        SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
-      }
-    }
-#endif
-  }
-  resultobj = SWIG_FromCharPtr((const char *)result);
-  if ( ReturnSame(bLocalUseExceptionsCode) ) { CPLErr eclass = CPLGetLastErrorType(); if ( eclass == CE_Failure || eclass == CE_Fatal ) { Py_XDECREF(resultobj); SWIG_Error( SWIG_RuntimeError, CPLGetLastErrorMsg() ); return NULL; } }
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_RasterAttributeTable_GetUsageOfCol(PyObject *self, PyObject *args) {
-  PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
-  GDALRasterAttributeTableShadow *arg1 = (GDALRasterAttributeTableShadow *) 0 ;
-  int arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  PyObject *swig_obj[2] ;
-  GDALRATFieldUsage result;
-  
-  if (!SWIG_Python_UnpackTuple(args, "RasterAttributeTable_GetUsageOfCol", 2, 2, swig_obj)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_GDALRasterAttributeTableShadow, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RasterAttributeTable_GetUsageOfCol" "', argument " "1"" of type '" "GDALRasterAttributeTableShadow *""'"); 
-  }
-  arg1 = reinterpret_cast< GDALRasterAttributeTableShadow * >(argp1);
-  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "RasterAttributeTable_GetUsageOfCol" "', argument " "2"" of type '" "int""'");
-  } 
-  arg2 = static_cast< int >(val2);
-  {
-    const int bLocalUseExceptions = GetUseExceptions();
-    if ( bLocalUseExceptions ) {
-      pushErrorHandler();
-    }
-    {
-      SWIG_PYTHON_THREAD_BEGIN_ALLOW;
-      result = (GDALRATFieldUsage)GDALRasterAttributeTableShadow_GetUsageOfCol(arg1,arg2);
-      SWIG_PYTHON_THREAD_END_ALLOW;
-    }
-    if ( bLocalUseExceptions ) {
-      popErrorHandler();
-    }
-#ifndef SED_HACKS
-    if ( bLocalUseExceptions ) {
-      CPLErr eclass = CPLGetLastErrorType();
-      if ( eclass == CE_Failure || eclass == CE_Fatal ) {
-        SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
-      }
-    }
-#endif
-  }
-  resultobj = SWIG_From_int(static_cast< int >(result));
-  if ( ReturnSame(bLocalUseExceptionsCode) ) { CPLErr eclass = CPLGetLastErrorType(); if ( eclass == CE_Failure || eclass == CE_Fatal ) { Py_XDECREF(resultobj); SWIG_Error( SWIG_RuntimeError, CPLGetLastErrorMsg() ); return NULL; } }
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_RasterAttributeTable_GetTypeOfCol(PyObject *self, PyObject *args) {
-  PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
-  GDALRasterAttributeTableShadow *arg1 = (GDALRasterAttributeTableShadow *) 0 ;
-  int arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  PyObject *swig_obj[2] ;
-  GDALRATFieldType result;
-  
-  if (!SWIG_Python_UnpackTuple(args, "RasterAttributeTable_GetTypeOfCol", 2, 2, swig_obj)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_GDALRasterAttributeTableShadow, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RasterAttributeTable_GetTypeOfCol" "', argument " "1"" of type '" "GDALRasterAttributeTableShadow *""'"); 
-  }
-  arg1 = reinterpret_cast< GDALRasterAttributeTableShadow * >(argp1);
-  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "RasterAttributeTable_GetTypeOfCol" "', argument " "2"" of type '" "int""'");
-  } 
-  arg2 = static_cast< int >(val2);
-  {
-    const int bLocalUseExceptions = GetUseExceptions();
-    if ( bLocalUseExceptions ) {
-      pushErrorHandler();
-    }
-    {
-      SWIG_PYTHON_THREAD_BEGIN_ALLOW;
-      result = (GDALRATFieldType)GDALRasterAttributeTableShadow_GetTypeOfCol(arg1,arg2);
-      SWIG_PYTHON_THREAD_END_ALLOW;
-    }
-    if ( bLocalUseExceptions ) {
-      popErrorHandler();
-    }
-#ifndef SED_HACKS
-    if ( bLocalUseExceptions ) {
-      CPLErr eclass = CPLGetLastErrorType();
-      if ( eclass == CE_Failure || eclass == CE_Fatal ) {
-        SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
-      }
-    }
-#endif
-  }
-  resultobj = SWIG_From_int(static_cast< int >(result));
-  if ( ReturnSame(bLocalUseExceptionsCode) ) { CPLErr eclass = CPLGetLastErrorType(); if ( eclass == CE_Failure || eclass == CE_Fatal ) { Py_XDECREF(resultobj); SWIG_Error( SWIG_RuntimeError, CPLGetLastErrorMsg() ); return NULL; } }
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_RasterAttributeTable_GetColOfUsage(PyObject *self, PyObject *args) {
-  PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
-  GDALRasterAttributeTableShadow *arg1 = (GDALRasterAttributeTableShadow *) 0 ;
-  GDALRATFieldUsage arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  PyObject *swig_obj[2] ;
-  int result;
-  
-  if (!SWIG_Python_UnpackTuple(args, "RasterAttributeTable_GetColOfUsage", 2, 2, swig_obj)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_GDALRasterAttributeTableShadow, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RasterAttributeTable_GetColOfUsage" "', argument " "1"" of type '" "GDALRasterAttributeTableShadow *""'"); 
-  }
-  arg1 = reinterpret_cast< GDALRasterAttributeTableShadow * >(argp1);
-  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "RasterAttributeTable_GetColOfUsage" "', argument " "2"" of type '" "GDALRATFieldUsage""'");
-  } 
-  arg2 = static_cast< GDALRATFieldUsage >(val2);
-  {
-    const int bLocalUseExceptions = GetUseExceptions();
-    if ( bLocalUseExceptions ) {
-      pushErrorHandler();
-    }
-    {
-      SWIG_PYTHON_THREAD_BEGIN_ALLOW;
-      result = (int)GDALRasterAttributeTableShadow_GetColOfUsage(arg1,arg2);
-      SWIG_PYTHON_THREAD_END_ALLOW;
-    }
-    if ( bLocalUseExceptions ) {
-      popErrorHandler();
-    }
-#ifndef SED_HACKS
-    if ( bLocalUseExceptions ) {
-      CPLErr eclass = CPLGetLastErrorType();
-      if ( eclass == CE_Failure || eclass == CE_Fatal ) {
-        SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
-      }
-    }
-#endif
-  }
-  resultobj = SWIG_From_int(static_cast< int >(result));
-  if ( ReturnSame(bLocalUseExceptionsCode) ) { CPLErr eclass = CPLGetLastErrorType(); if ( eclass == CE_Failure || eclass == CE_Fatal ) { Py_XDECREF(resultobj); SWIG_Error( SWIG_RuntimeError, CPLGetLastErrorMsg() ); return NULL; } }
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_RasterAttributeTable_GetRowCount(PyObject *self, PyObject *args) {
-  PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
-  GDALRasterAttributeTableShadow *arg1 = (GDALRasterAttributeTableShadow *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject *swig_obj[1] ;
-  int result;
-  
-  if (!args) SWIG_fail;
-  swig_obj[0] = args;
-  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_GDALRasterAttributeTableShadow, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RasterAttributeTable_GetRowCount" "', argument " "1"" of type '" "GDALRasterAttributeTableShadow *""'"); 
-  }
-  arg1 = reinterpret_cast< GDALRasterAttributeTableShadow * >(argp1);
-  {
-    const int bLocalUseExceptions = GetUseExceptions();
-    if ( bLocalUseExceptions ) {
-      pushErrorHandler();
-    }
-    {
-      SWIG_PYTHON_THREAD_BEGIN_ALLOW;
-      result = (int)GDALRasterAttributeTableShadow_GetRowCount(arg1);
-      SWIG_PYTHON_THREAD_END_ALLOW;
-    }
-    if ( bLocalUseExceptions ) {
-      popErrorHandler();
-    }
-#ifndef SED_HACKS
-    if ( bLocalUseExceptions ) {
-      CPLErr eclass = CPLGetLastErrorType();
-      if ( eclass == CE_Failure || eclass == CE_Fatal ) {
-        SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
-      }
-    }
-#endif
-  }
-  resultobj = SWIG_From_int(static_cast< int >(result));
-  if ( ReturnSame(bLocalUseExceptionsCode) ) { CPLErr eclass = CPLGetLastErrorType(); if ( eclass == CE_Failure || eclass == CE_Fatal ) { Py_XDECREF(resultobj); SWIG_Error( SWIG_RuntimeError, CPLGetLastErrorMsg() ); return NULL; } }
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_RasterAttributeTable_GetValueAsString(PyObject *self, PyObject *args) {
-  PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
-  GDALRasterAttributeTableShadow *arg1 = (GDALRasterAttributeTableShadow *) 0 ;
-  int arg2 ;
-  int arg3 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  int val3 ;
-  int ecode3 = 0 ;
-  PyObject *swig_obj[3] ;
-  char *result = 0 ;
-  
-  if (!SWIG_Python_UnpackTuple(args, "RasterAttributeTable_GetValueAsString", 3, 3, swig_obj)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_GDALRasterAttributeTableShadow, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RasterAttributeTable_GetValueAsString" "', argument " "1"" of type '" "GDALRasterAttributeTableShadow *""'"); 
-  }
-  arg1 = reinterpret_cast< GDALRasterAttributeTableShadow * >(argp1);
-  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "RasterAttributeTable_GetValueAsString" "', argument " "2"" of type '" "int""'");
-  } 
-  arg2 = static_cast< int >(val2);
-  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "RasterAttributeTable_GetValueAsString" "', argument " "3"" of type '" "int""'");
-  } 
-  arg3 = static_cast< int >(val3);
-  {
-    const int bLocalUseExceptions = GetUseExceptions();
-    if ( bLocalUseExceptions ) {
-      pushErrorHandler();
-    }
-    {
-      SWIG_PYTHON_THREAD_BEGIN_ALLOW;
-      result = (char *)GDALRasterAttributeTableShadow_GetValueAsString(arg1,arg2,arg3);
-      SWIG_PYTHON_THREAD_END_ALLOW;
-    }
-    if ( bLocalUseExceptions ) {
-      popErrorHandler();
-    }
-#ifndef SED_HACKS
-    if ( bLocalUseExceptions ) {
-      CPLErr eclass = CPLGetLastErrorType();
-      if ( eclass == CE_Failure || eclass == CE_Fatal ) {
-        SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
-      }
-    }
-#endif
-  }
-  resultobj = SWIG_FromCharPtr((const char *)result);
-  if ( ReturnSame(bLocalUseExceptionsCode) ) { CPLErr eclass = CPLGetLastErrorType(); if ( eclass == CE_Failure || eclass == CE_Fatal ) { Py_XDECREF(resultobj); SWIG_Error( SWIG_RuntimeError, CPLGetLastErrorMsg() ); return NULL; } }
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_RasterAttributeTable_GetValueAsInt(PyObject *self, PyObject *args) {
-  PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
-  GDALRasterAttributeTableShadow *arg1 = (GDALRasterAttributeTableShadow *) 0 ;
-  int arg2 ;
-  int arg3 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  int val3 ;
-  int ecode3 = 0 ;
-  PyObject *swig_obj[3] ;
-  int result;
-  
-  if (!SWIG_Python_UnpackTuple(args, "RasterAttributeTable_GetValueAsInt", 3, 3, swig_obj)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_GDALRasterAttributeTableShadow, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RasterAttributeTable_GetValueAsInt" "', argument " "1"" of type '" "GDALRasterAttributeTableShadow *""'"); 
-  }
-  arg1 = reinterpret_cast< GDALRasterAttributeTableShadow * >(argp1);
-  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "RasterAttributeTable_GetValueAsInt" "', argument " "2"" of type '" "int""'");
-  } 
-  arg2 = static_cast< int >(val2);
-  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "RasterAttributeTable_GetValueAsInt" "', argument " "3"" of type '" "int""'");
-  } 
-  arg3 = static_cast< int >(val3);
-  {
-    const int bLocalUseExceptions = GetUseExceptions();
-    if ( bLocalUseExceptions ) {
-      pushErrorHandler();
-    }
-    {
-      SWIG_PYTHON_THREAD_BEGIN_ALLOW;
-      result = (int)GDALRasterAttributeTableShadow_GetValueAsInt(arg1,arg2,arg3);
-      SWIG_PYTHON_THREAD_END_ALLOW;
-    }
-    if ( bLocalUseExceptions ) {
-      popErrorHandler();
-    }
-#ifndef SED_HACKS
-    if ( bLocalUseExceptions ) {
-      CPLErr eclass = CPLGetLastErrorType();
-      if ( eclass == CE_Failure || eclass == CE_Fatal ) {
-        SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
-      }
-    }
-#endif
-  }
-  resultobj = SWIG_From_int(static_cast< int >(result));
-  if ( ReturnSame(bLocalUseExceptionsCode) ) { CPLErr eclass = CPLGetLastErrorType(); if ( eclass == CE_Failure || eclass == CE_Fatal ) { Py_XDECREF(resultobj); SWIG_Error( SWIG_RuntimeError, CPLGetLastErrorMsg() ); return NULL; } }
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_RasterAttributeTable_GetValueAsDouble(PyObject *self, PyObject *args) {
-  PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
-  GDALRasterAttributeTableShadow *arg1 = (GDALRasterAttributeTableShadow *) 0 ;
-  int arg2 ;
-  int arg3 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  int val3 ;
-  int ecode3 = 0 ;
-  PyObject *swig_obj[3] ;
-  double result;
-  
-  if (!SWIG_Python_UnpackTuple(args, "RasterAttributeTable_GetValueAsDouble", 3, 3, swig_obj)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_GDALRasterAttributeTableShadow, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RasterAttributeTable_GetValueAsDouble" "', argument " "1"" of type '" "GDALRasterAttributeTableShadow *""'"); 
-  }
-  arg1 = reinterpret_cast< GDALRasterAttributeTableShadow * >(argp1);
-  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "RasterAttributeTable_GetValueAsDouble" "', argument " "2"" of type '" "int""'");
-  } 
-  arg2 = static_cast< int >(val2);
-  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "RasterAttributeTable_GetValueAsDouble" "', argument " "3"" of type '" "int""'");
-  } 
-  arg3 = static_cast< int >(val3);
-  {
-    const int bLocalUseExceptions = GetUseExceptions();
-    if ( bLocalUseExceptions ) {
-      pushErrorHandler();
-    }
-    {
-      SWIG_PYTHON_THREAD_BEGIN_ALLOW;
-      result = (double)GDALRasterAttributeTableShadow_GetValueAsDouble(arg1,arg2,arg3);
-      SWIG_PYTHON_THREAD_END_ALLOW;
-    }
-    if ( bLocalUseExceptions ) {
-      popErrorHandler();
-    }
-#ifndef SED_HACKS
-    if ( bLocalUseExceptions ) {
-      CPLErr eclass = CPLGetLastErrorType();
-      if ( eclass == CE_Failure || eclass == CE_Fatal ) {
-        SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
-      }
-    }
-#endif
-  }
-  resultobj = SWIG_From_double(static_cast< double >(result));
-  if ( ReturnSame(bLocalUseExceptionsCode) ) { CPLErr eclass = CPLGetLastErrorType(); if ( eclass == CE_Failure || eclass == CE_Fatal ) { Py_XDECREF(resultobj); SWIG_Error( SWIG_RuntimeError, CPLGetLastErrorMsg() ); return NULL; } }
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_RasterAttributeTable_SetValueAsString(PyObject *self, PyObject *args) {
-  PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
-  GDALRasterAttributeTableShadow *arg1 = (GDALRasterAttributeTableShadow *) 0 ;
-  int arg2 ;
-  int arg3 ;
-  char *arg4 = (char *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  int val3 ;
-  int ecode3 = 0 ;
-  PyObject *str4 = 0 ;
-  int bToFree4 = 0 ;
-  PyObject *swig_obj[4] ;
-  
-  if (!SWIG_Python_UnpackTuple(args, "RasterAttributeTable_SetValueAsString", 4, 4, swig_obj)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_GDALRasterAttributeTableShadow, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RasterAttributeTable_SetValueAsString" "', argument " "1"" of type '" "GDALRasterAttributeTableShadow *""'"); 
-  }
-  arg1 = reinterpret_cast< GDALRasterAttributeTableShadow * >(argp1);
-  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "RasterAttributeTable_SetValueAsString" "', argument " "2"" of type '" "int""'");
-  } 
-  arg2 = static_cast< int >(val2);
-  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "RasterAttributeTable_SetValueAsString" "', argument " "3"" of type '" "int""'");
-  } 
-  arg3 = static_cast< int >(val3);
-  {
-    /* %typemap(in) (tostring argin) */
-    str4 = PyObject_Str( swig_obj[3] );
-    if ( str4 == 0 ) {
-      PyErr_SetString( PyExc_RuntimeError, "Unable to format argument as string");
-      SWIG_fail;
-    }
-    
-    arg4 = GDALPythonObjectToCStr(str4, &bToFree4);
-  }
-  {
-    const int bLocalUseExceptions = GetUseExceptions();
-    if ( bLocalUseExceptions ) {
-      pushErrorHandler();
-    }
-    {
-      SWIG_PYTHON_THREAD_BEGIN_ALLOW;
-      GDALRasterAttributeTableShadow_SetValueAsString(arg1,arg2,arg3,(char const *)arg4);
-      SWIG_PYTHON_THREAD_END_ALLOW;
-    }
-    if ( bLocalUseExceptions ) {
-      popErrorHandler();
-    }
-#ifndef SED_HACKS
-    if ( bLocalUseExceptions ) {
-      CPLErr eclass = CPLGetLastErrorType();
-      if ( eclass == CE_Failure || eclass == CE_Fatal ) {
-        SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
-      }
-    }
-#endif
-  }
-  resultobj = SWIG_Py_Void();
-  {
-    /* %typemap(freearg) (tostring argin) */
-    if ( str4 != NULL)
-    {
-      Py_DECREF(str4);
-    }
-    GDALPythonFreeCStr(arg4, bToFree4);
-  }
-  if ( ReturnSame(bLocalUseExceptionsCode) ) { CPLErr eclass = CPLGetLastErrorType(); if ( eclass == CE_Failure || eclass == CE_Fatal ) { Py_XDECREF(resultobj); SWIG_Error( SWIG_RuntimeError, CPLGetLastErrorMsg() ); return NULL; } }
-  return resultobj;
-fail:
-  {
-    /* %typemap(freearg) (tostring argin) */
-    if ( str4 != NULL)
-    {
-      Py_DECREF(str4);
-    }
-    GDALPythonFreeCStr(arg4, bToFree4);
-  }
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_RasterAttributeTable_SetValueAsInt(PyObject *self, PyObject *args) {
-  PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
-  GDALRasterAttributeTableShadow *arg1 = (GDALRasterAttributeTableShadow *) 0 ;
-  int arg2 ;
-  int arg3 ;
-  int arg4 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  int val3 ;
-  int ecode3 = 0 ;
-  int val4 ;
-  int ecode4 = 0 ;
-  PyObject *swig_obj[4] ;
-  
-  if (!SWIG_Python_UnpackTuple(args, "RasterAttributeTable_SetValueAsInt", 4, 4, swig_obj)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_GDALRasterAttributeTableShadow, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RasterAttributeTable_SetValueAsInt" "', argument " "1"" of type '" "GDALRasterAttributeTableShadow *""'"); 
-  }
-  arg1 = reinterpret_cast< GDALRasterAttributeTableShadow * >(argp1);
-  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "RasterAttributeTable_SetValueAsInt" "', argument " "2"" of type '" "int""'");
-  } 
-  arg2 = static_cast< int >(val2);
-  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "RasterAttributeTable_SetValueAsInt" "', argument " "3"" of type '" "int""'");
-  } 
-  arg3 = static_cast< int >(val3);
-  ecode4 = SWIG_AsVal_int(swig_obj[3], &val4);
-  if (!SWIG_IsOK(ecode4)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "RasterAttributeTable_SetValueAsInt" "', argument " "4"" of type '" "int""'");
-  } 
-  arg4 = static_cast< int >(val4);
-  {
-    const int bLocalUseExceptions = GetUseExceptions();
-    if ( bLocalUseExceptions ) {
-      pushErrorHandler();
-    }
-    {
-      SWIG_PYTHON_THREAD_BEGIN_ALLOW;
-      GDALRasterAttributeTableShadow_SetValueAsInt(arg1,arg2,arg3,arg4);
-      SWIG_PYTHON_THREAD_END_ALLOW;
-    }
-    if ( bLocalUseExceptions ) {
-      popErrorHandler();
-    }
-#ifndef SED_HACKS
-    if ( bLocalUseExceptions ) {
-      CPLErr eclass = CPLGetLastErrorType();
-      if ( eclass == CE_Failure || eclass == CE_Fatal ) {
-        SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
-      }
-    }
-#endif
-  }
-  resultobj = SWIG_Py_Void();
-  if ( ReturnSame(bLocalUseExceptionsCode) ) { CPLErr eclass = CPLGetLastErrorType(); if ( eclass == CE_Failure || eclass == CE_Fatal ) { Py_XDECREF(resultobj); SWIG_Error( SWIG_RuntimeError, CPLGetLastErrorMsg() ); return NULL; } }
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_RasterAttributeTable_SetValueAsDouble(PyObject *self, PyObject *args) {
-  PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
-  GDALRasterAttributeTableShadow *arg1 = (GDALRasterAttributeTableShadow *) 0 ;
-  int arg2 ;
-  int arg3 ;
-  double arg4 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  int val3 ;
-  int ecode3 = 0 ;
-  double val4 ;
-  int ecode4 = 0 ;
-  PyObject *swig_obj[4] ;
-  
-  if (!SWIG_Python_UnpackTuple(args, "RasterAttributeTable_SetValueAsDouble", 4, 4, swig_obj)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_GDALRasterAttributeTableShadow, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RasterAttributeTable_SetValueAsDouble" "', argument " "1"" of type '" "GDALRasterAttributeTableShadow *""'"); 
-  }
-  arg1 = reinterpret_cast< GDALRasterAttributeTableShadow * >(argp1);
-  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "RasterAttributeTable_SetValueAsDouble" "', argument " "2"" of type '" "int""'");
-  } 
-  arg2 = static_cast< int >(val2);
-  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "RasterAttributeTable_SetValueAsDouble" "', argument " "3"" of type '" "int""'");
-  } 
-  arg3 = static_cast< int >(val3);
-  ecode4 = SWIG_AsVal_double(swig_obj[3], &val4);
-  if (!SWIG_IsOK(ecode4)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "RasterAttributeTable_SetValueAsDouble" "', argument " "4"" of type '" "double""'");
-  } 
-  arg4 = static_cast< double >(val4);
-  {
-    const int bLocalUseExceptions = GetUseExceptions();
-    if ( bLocalUseExceptions ) {
-      pushErrorHandler();
-    }
-    {
-      SWIG_PYTHON_THREAD_BEGIN_ALLOW;
-      GDALRasterAttributeTableShadow_SetValueAsDouble(arg1,arg2,arg3,arg4);
-      SWIG_PYTHON_THREAD_END_ALLOW;
-    }
-    if ( bLocalUseExceptions ) {
-      popErrorHandler();
-    }
-#ifndef SED_HACKS
-    if ( bLocalUseExceptions ) {
-      CPLErr eclass = CPLGetLastErrorType();
-      if ( eclass == CE_Failure || eclass == CE_Fatal ) {
-        SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
-      }
-    }
-#endif
-  }
-  resultobj = SWIG_Py_Void();
-  if ( ReturnSame(bLocalUseExceptionsCode) ) { CPLErr eclass = CPLGetLastErrorType(); if ( eclass == CE_Failure || eclass == CE_Fatal ) { Py_XDECREF(resultobj); SWIG_Error( SWIG_RuntimeError, CPLGetLastErrorMsg() ); return NULL; } }
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_RasterAttributeTable_SetRowCount(PyObject *self, PyObject *args) {
-  PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
-  GDALRasterAttributeTableShadow *arg1 = (GDALRasterAttributeTableShadow *) 0 ;
-  int arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  PyObject *swig_obj[2] ;
-  
-  if (!SWIG_Python_UnpackTuple(args, "RasterAttributeTable_SetRowCount", 2, 2, swig_obj)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_GDALRasterAttributeTableShadow, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RasterAttributeTable_SetRowCount" "', argument " "1"" of type '" "GDALRasterAttributeTableShadow *""'"); 
-  }
-  arg1 = reinterpret_cast< GDALRasterAttributeTableShadow * >(argp1);
-  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "RasterAttributeTable_SetRowCount" "', argument " "2"" of type '" "int""'");
-  } 
-  arg2 = static_cast< int >(val2);
-  {
-    const int bLocalUseExceptions = GetUseExceptions();
-    if ( bLocalUseExceptions ) {
-      pushErrorHandler();
-    }
-    {
-      SWIG_PYTHON_THREAD_BEGIN_ALLOW;
-      GDALRasterAttributeTableShadow_SetRowCount(arg1,arg2);
-      SWIG_PYTHON_THREAD_END_ALLOW;
-    }
-    if ( bLocalUseExceptions ) {
-      popErrorHandler();
-    }
-#ifndef SED_HACKS
-    if ( bLocalUseExceptions ) {
-      CPLErr eclass = CPLGetLastErrorType();
-      if ( eclass == CE_Failure || eclass == CE_Fatal ) {
-        SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
-      }
-    }
-#endif
-  }
-  resultobj = SWIG_Py_Void();
-  if ( ReturnSame(bLocalUseExceptionsCode) ) { CPLErr eclass = CPLGetLastErrorType(); if ( eclass == CE_Failure || eclass == CE_Fatal ) { Py_XDECREF(resultobj); SWIG_Error( SWIG_RuntimeError, CPLGetLastErrorMsg() ); return NULL; } }
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_RasterAttributeTable_CreateColumn(PyObject *self, PyObject *args) {
-  PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
-  GDALRasterAttributeTableShadow *arg1 = (GDALRasterAttributeTableShadow *) 0 ;
-  char *arg2 = (char *) 0 ;
-  GDALRATFieldType arg3 ;
-  GDALRATFieldUsage arg4 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int res2 ;
-  char *buf2 = 0 ;
-  int alloc2 = 0 ;
-  int val3 ;
-  int ecode3 = 0 ;
-  int val4 ;
-  int ecode4 = 0 ;
-  PyObject *swig_obj[4] ;
-  int result;
-  
-  if (!SWIG_Python_UnpackTuple(args, "RasterAttributeTable_CreateColumn", 4, 4, swig_obj)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_GDALRasterAttributeTableShadow, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RasterAttributeTable_CreateColumn" "', argument " "1"" of type '" "GDALRasterAttributeTableShadow *""'"); 
-  }
-  arg1 = reinterpret_cast< GDALRasterAttributeTableShadow * >(argp1);
-  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, NULL, &alloc2);
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "RasterAttributeTable_CreateColumn" "', argument " "2"" of type '" "char const *""'");
-  }
-  arg2 = reinterpret_cast< char * >(buf2);
-  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "RasterAttributeTable_CreateColumn" "', argument " "3"" of type '" "GDALRATFieldType""'");
-  } 
-  arg3 = static_cast< GDALRATFieldType >(val3);
-  ecode4 = SWIG_AsVal_int(swig_obj[3], &val4);
-  if (!SWIG_IsOK(ecode4)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "RasterAttributeTable_CreateColumn" "', argument " "4"" of type '" "GDALRATFieldUsage""'");
-  } 
-  arg4 = static_cast< GDALRATFieldUsage >(val4);
-  {
-    const int bLocalUseExceptions = GetUseExceptions();
-    if ( bLocalUseExceptions ) {
-      pushErrorHandler();
-    }
-    {
-      SWIG_PYTHON_THREAD_BEGIN_ALLOW;
-      result = (int)GDALRasterAttributeTableShadow_CreateColumn(arg1,(char const *)arg2,arg3,arg4);
-      SWIG_PYTHON_THREAD_END_ALLOW;
-    }
-    if ( bLocalUseExceptions ) {
-      popErrorHandler();
-    }
-#ifndef SED_HACKS
-    if ( bLocalUseExceptions ) {
-      CPLErr eclass = CPLGetLastErrorType();
-      if ( eclass == CE_Failure || eclass == CE_Fatal ) {
-        SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
-      }
-    }
-#endif
-  }
-  resultobj = SWIG_From_int(static_cast< int >(result));
-  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
-  if ( ReturnSame(bLocalUseExceptionsCode) ) { CPLErr eclass = CPLGetLastErrorType(); if ( eclass == CE_Failure || eclass == CE_Fatal ) { Py_XDECREF(resultobj); SWIG_Error( SWIG_RuntimeError, CPLGetLastErrorMsg() ); return NULL; } }
-  return resultobj;
-fail:
-  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_RasterAttributeTable_GetLinearBinning(PyObject *self, PyObject *args) {
-  PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
-  GDALRasterAttributeTableShadow *arg1 = (GDALRasterAttributeTableShadow *) 0 ;
-  double *arg2 = (double *) 0 ;
-  double *arg3 = (double *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  double temp2 ;
-  int res2 = SWIG_TMPOBJ ;
-  double temp3 ;
-  int res3 = SWIG_TMPOBJ ;
-  PyObject *swig_obj[1] ;
-  bool result;
-  
-  arg2 = &temp2;
-  arg3 = &temp3;
-  if (!args) SWIG_fail;
-  swig_obj[0] = args;
-  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_GDALRasterAttributeTableShadow, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RasterAttributeTable_GetLinearBinning" "', argument " "1"" of type '" "GDALRasterAttributeTableShadow *""'"); 
-  }
-  arg1 = reinterpret_cast< GDALRasterAttributeTableShadow * >(argp1);
-  {
-    const int bLocalUseExceptions = GetUseExceptions();
-    if ( bLocalUseExceptions ) {
-      pushErrorHandler();
-    }
-    {
-      SWIG_PYTHON_THREAD_BEGIN_ALLOW;
-      result = (bool)GDALRasterAttributeTableShadow_GetLinearBinning(arg1,arg2,arg3);
-      SWIG_PYTHON_THREAD_END_ALLOW;
-    }
-    if ( bLocalUseExceptions ) {
-      popErrorHandler();
-    }
-#ifndef SED_HACKS
-    if ( bLocalUseExceptions ) {
-      CPLErr eclass = CPLGetLastErrorType();
-      if ( eclass == CE_Failure || eclass == CE_Fatal ) {
-        SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
-      }
-    }
-#endif
-  }
-  resultobj = SWIG_From_bool(static_cast< bool >(result));
-  if (ReturnSame(SWIG_IsTmpObj(res2))) {
-    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg2)));
-  } else {
-    int new_flags = SWIG_IsNewObj(res2) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
-    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_double, new_flags));
-  }
-  if (ReturnSame(SWIG_IsTmpObj(res3))) {
-    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg3)));
-  } else {
-    int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
-    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_double, new_flags));
-  }
-  if ( ReturnSame(bLocalUseExceptionsCode) ) { CPLErr eclass = CPLGetLastErrorType(); if ( eclass == CE_Failure || eclass == CE_Fatal ) { Py_XDECREF(resultobj); SWIG_Error( SWIG_RuntimeError, CPLGetLastErrorMsg() ); return NULL; } }
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_RasterAttributeTable_SetLinearBinning(PyObject *self, PyObject *args) {
-  PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
-  GDALRasterAttributeTableShadow *arg1 = (GDALRasterAttributeTableShadow *) 0 ;
-  double arg2 ;
-  double arg3 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  double val2 ;
-  int ecode2 = 0 ;
-  double val3 ;
-  int ecode3 = 0 ;
-  PyObject *swig_obj[3] ;
-  int result;
-  
-  if (!SWIG_Python_UnpackTuple(args, "RasterAttributeTable_SetLinearBinning", 3, 3, swig_obj)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_GDALRasterAttributeTableShadow, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RasterAttributeTable_SetLinearBinning" "', argument " "1"" of type '" "GDALRasterAttributeTableShadow *""'"); 
-  }
-  arg1 = reinterpret_cast< GDALRasterAttributeTableShadow * >(argp1);
-  ecode2 = SWIG_AsVal_double(swig_obj[1], &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "RasterAttributeTable_SetLinearBinning" "', argument " "2"" of type '" "double""'");
-  } 
-  arg2 = static_cast< double >(val2);
-  ecode3 = SWIG_AsVal_double(swig_obj[2], &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "RasterAttributeTable_SetLinearBinning" "', argument " "3"" of type '" "double""'");
-  } 
-  arg3 = static_cast< double >(val3);
-  {
-    const int bLocalUseExceptions = GetUseExceptions();
-    if ( bLocalUseExceptions ) {
-      pushErrorHandler();
-    }
-    {
-      SWIG_PYTHON_THREAD_BEGIN_ALLOW;
-      result = (int)GDALRasterAttributeTableShadow_SetLinearBinning(arg1,arg2,arg3);
-      SWIG_PYTHON_THREAD_END_ALLOW;
-    }
-    if ( bLocalUseExceptions ) {
-      popErrorHandler();
-    }
-#ifndef SED_HACKS
-    if ( bLocalUseExceptions ) {
-      CPLErr eclass = CPLGetLastErrorType();
-      if ( eclass == CE_Failure || eclass == CE_Fatal ) {
-        SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
-      }
-    }
-#endif
-  }
-  resultobj = SWIG_From_int(static_cast< int >(result));
-  if ( ReturnSame(bLocalUseExceptionsCode) ) { CPLErr eclass = CPLGetLastErrorType(); if ( eclass == CE_Failure || eclass == CE_Fatal ) { Py_XDECREF(resultobj); SWIG_Error( SWIG_RuntimeError, CPLGetLastErrorMsg() ); return NULL; } }
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_RasterAttributeTable_GetRowOfValue(PyObject *self, PyObject *args) {
-  PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
-  GDALRasterAttributeTableShadow *arg1 = (GDALRasterAttributeTableShadow *) 0 ;
-  double arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  double val2 ;
-  int ecode2 = 0 ;
-  PyObject *swig_obj[2] ;
-  int result;
-  
-  if (!SWIG_Python_UnpackTuple(args, "RasterAttributeTable_GetRowOfValue", 2, 2, swig_obj)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_GDALRasterAttributeTableShadow, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RasterAttributeTable_GetRowOfValue" "', argument " "1"" of type '" "GDALRasterAttributeTableShadow *""'"); 
-  }
-  arg1 = reinterpret_cast< GDALRasterAttributeTableShadow * >(argp1);
-  ecode2 = SWIG_AsVal_double(swig_obj[1], &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "RasterAttributeTable_GetRowOfValue" "', argument " "2"" of type '" "double""'");
-  } 
-  arg2 = static_cast< double >(val2);
-  {
-    const int bLocalUseExceptions = GetUseExceptions();
-    if ( bLocalUseExceptions ) {
-      pushErrorHandler();
-    }
-    {
-      SWIG_PYTHON_THREAD_BEGIN_ALLOW;
-      result = (int)GDALRasterAttributeTableShadow_GetRowOfValue(arg1,arg2);
-      SWIG_PYTHON_THREAD_END_ALLOW;
-    }
-    if ( bLocalUseExceptions ) {
-      popErrorHandler();
-    }
-#ifndef SED_HACKS
-    if ( bLocalUseExceptions ) {
-      CPLErr eclass = CPLGetLastErrorType();
-      if ( eclass == CE_Failure || eclass == CE_Fatal ) {
-        SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
-      }
-    }
-#endif
-  }
-  resultobj = SWIG_From_int(static_cast< int >(result));
-  if ( ReturnSame(bLocalUseExceptionsCode) ) { CPLErr eclass = CPLGetLastErrorType(); if ( eclass == CE_Failure || eclass == CE_Fatal ) { Py_XDECREF(resultobj); SWIG_Error( SWIG_RuntimeError, CPLGetLastErrorMsg() ); return NULL; } }
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_RasterAttributeTable_ChangesAreWrittenToFile(PyObject *self, PyObject *args) {
-  PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
-  GDALRasterAttributeTableShadow *arg1 = (GDALRasterAttributeTableShadow *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject *swig_obj[1] ;
-  int result;
-  
-  if (!args) SWIG_fail;
-  swig_obj[0] = args;
-  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_GDALRasterAttributeTableShadow, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RasterAttributeTable_ChangesAreWrittenToFile" "', argument " "1"" of type '" "GDALRasterAttributeTableShadow *""'"); 
-  }
-  arg1 = reinterpret_cast< GDALRasterAttributeTableShadow * >(argp1);
-  {
-    const int bLocalUseExceptions = GetUseExceptions();
-    if ( bLocalUseExceptions ) {
-      pushErrorHandler();
-    }
-    {
-      SWIG_PYTHON_THREAD_BEGIN_ALLOW;
-      result = (int)GDALRasterAttributeTableShadow_ChangesAreWrittenToFile(arg1);
-      SWIG_PYTHON_THREAD_END_ALLOW;
-    }
-    if ( bLocalUseExceptions ) {
-      popErrorHandler();
-    }
-#ifndef SED_HACKS
-    if ( bLocalUseExceptions ) {
-      CPLErr eclass = CPLGetLastErrorType();
-      if ( eclass == CE_Failure || eclass == CE_Fatal ) {
-        SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
-      }
-    }
-#endif
-  }
-  resultobj = SWIG_From_int(static_cast< int >(result));
-  if ( ReturnSame(bLocalUseExceptionsCode) ) { CPLErr eclass = CPLGetLastErrorType(); if ( eclass == CE_Failure || eclass == CE_Fatal ) { Py_XDECREF(resultobj); SWIG_Error( SWIG_RuntimeError, CPLGetLastErrorMsg() ); return NULL; } }
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_RasterAttributeTable_DumpReadable(PyObject *self, PyObject *args) {
-  PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
-  GDALRasterAttributeTableShadow *arg1 = (GDALRasterAttributeTableShadow *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject *swig_obj[1] ;
-  
-  if (!args) SWIG_fail;
-  swig_obj[0] = args;
-  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_GDALRasterAttributeTableShadow, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RasterAttributeTable_DumpReadable" "', argument " "1"" of type '" "GDALRasterAttributeTableShadow *""'"); 
-  }
-  arg1 = reinterpret_cast< GDALRasterAttributeTableShadow * >(argp1);
-  {
-    const int bLocalUseExceptions = GetUseExceptions();
-    if ( bLocalUseExceptions ) {
-      pushErrorHandler();
-    }
-    {
-      SWIG_PYTHON_THREAD_BEGIN_ALLOW;
-      GDALRasterAttributeTableShadow_DumpReadable(arg1);
-      SWIG_PYTHON_THREAD_END_ALLOW;
-    }
-    if ( bLocalUseExceptions ) {
-      popErrorHandler();
-    }
-#ifndef SED_HACKS
-    if ( bLocalUseExceptions ) {
-      CPLErr eclass = CPLGetLastErrorType();
-      if ( eclass == CE_Failure || eclass == CE_Fatal ) {
-        SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
-      }
-    }
-#endif
-  }
-  resultobj = SWIG_Py_Void();
-  if ( ReturnSame(bLocalUseExceptionsCode) ) { CPLErr eclass = CPLGetLastErrorType(); if ( eclass == CE_Failure || eclass == CE_Fatal ) { Py_XDECREF(resultobj); SWIG_Error( SWIG_RuntimeError, CPLGetLastErrorMsg() ); return NULL; } }
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_RasterAttributeTable_SetTableType(PyObject *self, PyObject *args) {
-  PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
-  GDALRasterAttributeTableShadow *arg1 = (GDALRasterAttributeTableShadow *) 0 ;
-  GDALRATTableType arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  PyObject *swig_obj[2] ;
-  
-  if (!SWIG_Python_UnpackTuple(args, "RasterAttributeTable_SetTableType", 2, 2, swig_obj)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_GDALRasterAttributeTableShadow, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RasterAttributeTable_SetTableType" "', argument " "1"" of type '" "GDALRasterAttributeTableShadow *""'"); 
-  }
-  arg1 = reinterpret_cast< GDALRasterAttributeTableShadow * >(argp1);
-  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "RasterAttributeTable_SetTableType" "', argument " "2"" of type '" "GDALRATTableType""'");
-  } 
-  arg2 = static_cast< GDALRATTableType >(val2);
-  {
-    const int bLocalUseExceptions = GetUseExceptions();
-    if ( bLocalUseExceptions ) {
-      pushErrorHandler();
-    }
-    {
-      SWIG_PYTHON_THREAD_BEGIN_ALLOW;
-      GDALRasterAttributeTableShadow_SetTableType(arg1,arg2);
-      SWIG_PYTHON_THREAD_END_ALLOW;
-    }
-    if ( bLocalUseExceptions ) {
-      popErrorHandler();
-    }
-#ifndef SED_HACKS
-    if ( bLocalUseExceptions ) {
-      CPLErr eclass = CPLGetLastErrorType();
-      if ( eclass == CE_Failure || eclass == CE_Fatal ) {
-        SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
-      }
-    }
-#endif
-  }
-  resultobj = SWIG_Py_Void();
-  if ( ReturnSame(bLocalUseExceptionsCode) ) { CPLErr eclass = CPLGetLastErrorType(); if ( eclass == CE_Failure || eclass == CE_Fatal ) { Py_XDECREF(resultobj); SWIG_Error( SWIG_RuntimeError, CPLGetLastErrorMsg() ); return NULL; } }
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_RasterAttributeTable_GetTableType(PyObject *self, PyObject *args) {
-  PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
-  GDALRasterAttributeTableShadow *arg1 = (GDALRasterAttributeTableShadow *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject *swig_obj[1] ;
-  GDALRATTableType result;
-  
-  if (!args) SWIG_fail;
-  swig_obj[0] = args;
-  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_GDALRasterAttributeTableShadow, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RasterAttributeTable_GetTableType" "', argument " "1"" of type '" "GDALRasterAttributeTableShadow *""'"); 
-  }
-  arg1 = reinterpret_cast< GDALRasterAttributeTableShadow * >(argp1);
-  {
-    const int bLocalUseExceptions = GetUseExceptions();
-    if ( bLocalUseExceptions ) {
-      pushErrorHandler();
-    }
-    {
-      SWIG_PYTHON_THREAD_BEGIN_ALLOW;
-      result = (GDALRATTableType)GDALRasterAttributeTableShadow_GetTableType(arg1);
-      SWIG_PYTHON_THREAD_END_ALLOW;
-    }
-    if ( bLocalUseExceptions ) {
-      popErrorHandler();
-    }
-#ifndef SED_HACKS
-    if ( bLocalUseExceptions ) {
-      CPLErr eclass = CPLGetLastErrorType();
-      if ( eclass == CE_Failure || eclass == CE_Fatal ) {
-        SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
-      }
-    }
-#endif
-  }
-  resultobj = SWIG_From_int(static_cast< int >(result));
-  if ( ReturnSame(bLocalUseExceptionsCode) ) { CPLErr eclass = CPLGetLastErrorType(); if ( eclass == CE_Failure || eclass == CE_Fatal ) { Py_XDECREF(resultobj); SWIG_Error( SWIG_RuntimeError, CPLGetLastErrorMsg() ); return NULL; } }
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *RasterAttributeTable_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *obj;
-  if (!SWIG_Python_UnpackTuple(args, "swigregister", 1, 1, &obj)) return NULL;
-  SWIG_TypeNewClientData(SWIGTYPE_p_GDALRasterAttributeTableShadow, SWIG_NewClientData(obj));
-  return SWIG_Py_Void();
-}
-
-SWIGINTERN PyObject *RasterAttributeTable_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  return SWIG_Python_InitShadowInstance(args);
-}
-
 SWIGINTERN PyObject *_wrap_delete_SubdatasetInfo(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
   GDALSubdatasetInfoShadow *arg1 = (GDALSubdatasetInfoShadow *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   PyObject *swig_obj[1] ;
   
@@ -45288,14 +45986,175 @@
     /* %typemap(freearg) char **dict */
     CSLDestroy( arg19 );
   }
   return NULL;
 }
 
 
+SWIGINTERN PyObject *_wrap_IsLineOfSightVisible(PyObject *self, PyObject *args, PyObject *kwargs) {
+  PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
+  GDALRasterBandShadow *arg1 = (GDALRasterBandShadow *) 0 ;
+  int arg2 ;
+  int arg3 ;
+  double arg4 ;
+  int arg5 ;
+  int arg6 ;
+  double arg7 ;
+  bool *arg8 = (bool *) 0 ;
+  int *arg9 = (int *) 0 ;
+  int *arg10 = (int *) 0 ;
+  char **arg11 = (char **) NULL ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  int val2 ;
+  int ecode2 = 0 ;
+  int val3 ;
+  int ecode3 = 0 ;
+  double val4 ;
+  int ecode4 = 0 ;
+  int val5 ;
+  int ecode5 = 0 ;
+  int val6 ;
+  int ecode6 = 0 ;
+  double val7 ;
+  int ecode7 = 0 ;
+  bool visible8 = 0 ;
+  int nxintersection8 = 0 ;
+  int nyintersection8 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  PyObject * obj2 = 0 ;
+  PyObject * obj3 = 0 ;
+  PyObject * obj4 = 0 ;
+  PyObject * obj5 = 0 ;
+  PyObject * obj6 = 0 ;
+  PyObject * obj7 = 0 ;
+  char * kwnames[] = {
+    (char *)"band",  (char *)"xA",  (char *)"yA",  (char *)"zA",  (char *)"xB",  (char *)"yB",  (char *)"zB",  (char *)"options",  NULL 
+  };
+  
+  {
+    /* %typemap(in) (bool *pbVisible, int *pnXIntersection, int *pnYIntersection) */
+    arg8 = &visible8;
+    arg9 = &nxintersection8;
+    arg10 = &nyintersection8;
+  }
+  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OOOOOOO|O:IsLineOfSightVisible", kwnames, &obj0, &obj1, &obj2, &obj3, &obj4, &obj5, &obj6, &obj7)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_GDALRasterBandShadow, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsLineOfSightVisible" "', argument " "1"" of type '" "GDALRasterBandShadow *""'"); 
+  }
+  arg1 = reinterpret_cast< GDALRasterBandShadow * >(argp1);
+  ecode2 = SWIG_AsVal_int(obj1, &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "IsLineOfSightVisible" "', argument " "2"" of type '" "int""'");
+  } 
+  arg2 = static_cast< int >(val2);
+  ecode3 = SWIG_AsVal_int(obj2, &val3);
+  if (!SWIG_IsOK(ecode3)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "IsLineOfSightVisible" "', argument " "3"" of type '" "int""'");
+  } 
+  arg3 = static_cast< int >(val3);
+  ecode4 = SWIG_AsVal_double(obj3, &val4);
+  if (!SWIG_IsOK(ecode4)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "IsLineOfSightVisible" "', argument " "4"" of type '" "double""'");
+  } 
+  arg4 = static_cast< double >(val4);
+  ecode5 = SWIG_AsVal_int(obj4, &val5);
+  if (!SWIG_IsOK(ecode5)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "IsLineOfSightVisible" "', argument " "5"" of type '" "int""'");
+  } 
+  arg5 = static_cast< int >(val5);
+  ecode6 = SWIG_AsVal_int(obj5, &val6);
+  if (!SWIG_IsOK(ecode6)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "IsLineOfSightVisible" "', argument " "6"" of type '" "int""'");
+  } 
+  arg6 = static_cast< int >(val6);
+  ecode7 = SWIG_AsVal_double(obj6, &val7);
+  if (!SWIG_IsOK(ecode7)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "IsLineOfSightVisible" "', argument " "7"" of type '" "double""'");
+  } 
+  arg7 = static_cast< double >(val7);
+  if (obj7) {
+    {
+      /* %typemap(in) char **dict */
+      arg11 = NULL;
+      if ( PySequence_Check( obj7 ) ) {
+        int bErr = FALSE;
+        arg11 = CSLFromPySequence(obj7, &bErr);
+        if ( bErr )
+        {
+          SWIG_fail;
+        }
+      }
+      else if ( PyMapping_Check( obj7 ) ) {
+        int bErr = FALSE;
+        arg11 = CSLFromPyMapping(obj7, &bErr);
+        if ( bErr )
+        {
+          SWIG_fail;
+        }
+      }
+      else {
+        PyErr_SetString(PyExc_TypeError,"Argument must be dictionary or sequence of strings");
+        SWIG_fail;
+      }
+    }
+  }
+  {
+    if (!arg1) {
+      SWIG_exception(SWIG_ValueError,"Received a NULL pointer.");
+    }
+  }
+  {
+    const int bLocalUseExceptions = GetUseExceptions();
+    if ( bLocalUseExceptions ) {
+      pushErrorHandler();
+    }
+    {
+      SWIG_PYTHON_THREAD_BEGIN_ALLOW;
+      IsLineOfSightVisible(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11);
+      SWIG_PYTHON_THREAD_END_ALLOW;
+    }
+    if ( bLocalUseExceptions ) {
+      popErrorHandler();
+    }
+#ifndef SED_HACKS
+    if ( bLocalUseExceptions ) {
+      CPLErr eclass = CPLGetLastErrorType();
+      if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+        SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+      }
+    }
+#endif
+  }
+  resultobj = SWIG_Py_Void();
+  {
+    /* %typemap(argout) (bool *pbVisible, int *pnXIntersection, int *pnYIntersection)  */
+    PyObject *r = PyTuple_New( 3 );
+    PyTuple_SetItem( r, 0, PyBool_FromLong(*arg8) );
+    PyTuple_SetItem( r, 1, PyLong_FromLong(*arg9) );
+    PyTuple_SetItem( r, 2, PyLong_FromLong(*arg10) );
+    resultobj = t_output_helper(resultobj,r);
+  }
+  {
+    /* %typemap(freearg) char **dict */
+    CSLDestroy( arg11 );
+  }
+  if ( ReturnSame(bLocalUseExceptionsCode) ) { CPLErr eclass = CPLGetLastErrorType(); if ( eclass == CE_Failure || eclass == CE_Fatal ) { Py_XDECREF(resultobj); SWIG_Error( SWIG_RuntimeError, CPLGetLastErrorMsg() ); return NULL; } }
+  return resultobj;
+fail:
+  {
+    /* %typemap(freearg) char **dict */
+    CSLDestroy( arg11 );
+  }
+  return NULL;
+}
+
+
 SWIGINTERN PyObject *_wrap_AutoCreateWarpedVRT(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
   GDALDatasetShadow *arg1 = (GDALDatasetShadow *) 0 ;
   char *arg2 = (char *) 0 ;
   char *arg3 = (char *) 0 ;
   GDALResampleAlg arg4 = (GDALResampleAlg) GRA_NearestNeighbour ;
   double arg5 = (double) 0.0 ;
@@ -52871,14 +53730,313 @@
     CPLFree(psProgressInfo);
     
   }
   return NULL;
 }
 
 
+SWIGINTERN PyObject *_wrap_new_GDALTileIndexOptions(PyObject *self, PyObject *args) {
+  PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
+  char **arg1 = (char **) 0 ;
+  PyObject *swig_obj[1] ;
+  GDALTileIndexOptions *result = 0 ;
+  
+  if (!args) SWIG_fail;
+  swig_obj[0] = args;
+  {
+    /* %typemap(in) char **dict */
+    arg1 = NULL;
+    if ( PySequence_Check( swig_obj[0] ) ) {
+      int bErr = FALSE;
+      arg1 = CSLFromPySequence(swig_obj[0], &bErr);
+      if ( bErr )
+      {
+        SWIG_fail;
+      }
+    }
+    else if ( PyMapping_Check( swig_obj[0] ) ) {
+      int bErr = FALSE;
+      arg1 = CSLFromPyMapping(swig_obj[0], &bErr);
+      if ( bErr )
+      {
+        SWIG_fail;
+      }
+    }
+    else {
+      PyErr_SetString(PyExc_TypeError,"Argument must be dictionary or sequence of strings");
+      SWIG_fail;
+    }
+  }
+  {
+    const int bLocalUseExceptions = GetUseExceptions();
+    if ( bLocalUseExceptions ) {
+      pushErrorHandler();
+    }
+    {
+      SWIG_PYTHON_THREAD_BEGIN_ALLOW;
+      result = (GDALTileIndexOptions *)new_GDALTileIndexOptions(arg1);
+      SWIG_PYTHON_THREAD_END_ALLOW;
+    }
+    if ( bLocalUseExceptions ) {
+      popErrorHandler();
+    }
+#ifndef SED_HACKS
+    if ( bLocalUseExceptions ) {
+      CPLErr eclass = CPLGetLastErrorType();
+      if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+        SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+      }
+    }
+#endif
+  }
+  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_GDALTileIndexOptions, SWIG_POINTER_NEW |  0 );
+  {
+    /* %typemap(freearg) char **dict */
+    CSLDestroy( arg1 );
+  }
+  if ( ReturnSame(bLocalUseExceptionsCode) ) { CPLErr eclass = CPLGetLastErrorType(); if ( eclass == CE_Failure || eclass == CE_Fatal ) { Py_XDECREF(resultobj); SWIG_Error( SWIG_RuntimeError, CPLGetLastErrorMsg() ); return NULL; } }
+  return resultobj;
+fail:
+  {
+    /* %typemap(freearg) char **dict */
+    CSLDestroy( arg1 );
+  }
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_delete_GDALTileIndexOptions(PyObject *self, PyObject *args) {
+  PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
+  GDALTileIndexOptions *arg1 = (GDALTileIndexOptions *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject *swig_obj[1] ;
+  
+  if (!args) SWIG_fail;
+  swig_obj[0] = args;
+  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_GDALTileIndexOptions, SWIG_POINTER_DISOWN |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_GDALTileIndexOptions" "', argument " "1"" of type '" "GDALTileIndexOptions *""'"); 
+  }
+  arg1 = reinterpret_cast< GDALTileIndexOptions * >(argp1);
+  {
+    const int bLocalUseExceptions = GetUseExceptions();
+    if ( bLocalUseExceptions ) {
+      pushErrorHandler();
+    }
+    {
+      SWIG_PYTHON_THREAD_BEGIN_ALLOW;
+      delete_GDALTileIndexOptions(arg1);
+      SWIG_PYTHON_THREAD_END_ALLOW;
+    }
+    if ( bLocalUseExceptions ) {
+      popErrorHandler();
+    }
+#ifndef SED_HACKS
+    if ( bLocalUseExceptions ) {
+      CPLErr eclass = CPLGetLastErrorType();
+      if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+        SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+      }
+    }
+#endif
+  }
+  resultobj = SWIG_Py_Void();
+  if ( ReturnSame(bLocalUseExceptionsCode) ) { CPLErr eclass = CPLGetLastErrorType(); if ( eclass == CE_Failure || eclass == CE_Fatal ) { Py_XDECREF(resultobj); SWIG_Error( SWIG_RuntimeError, CPLGetLastErrorMsg() ); return NULL; } }
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *GDALTileIndexOptions_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *obj;
+  if (!SWIG_Python_UnpackTuple(args, "swigregister", 1, 1, &obj)) return NULL;
+  SWIG_TypeNewClientData(SWIGTYPE_p_GDALTileIndexOptions, SWIG_NewClientData(obj));
+  return SWIG_Py_Void();
+}
+
+SWIGINTERN PyObject *GDALTileIndexOptions_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  return SWIG_Python_InitShadowInstance(args);
+}
+
+SWIGINTERN PyObject *_wrap_TileIndexInternalNames(PyObject *self, PyObject *args) {
+  PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
+  char *arg1 = (char *) 0 ;
+  char **arg2 = (char **) 0 ;
+  GDALTileIndexOptions *arg3 = (GDALTileIndexOptions *) 0 ;
+  GDALProgressFunc arg4 = (GDALProgressFunc) NULL ;
+  void *arg5 = (void *) NULL ;
+  int bToFree1 = 0 ;
+  void *argp3 = 0 ;
+  int res3 = 0 ;
+  PyObject *swig_obj[5] ;
+  GDALDatasetShadow *result = 0 ;
+  
+  /* %typemap(arginit) ( const char* callback_data=NULL)  */
+  PyProgressData *psProgressInfo;
+  psProgressInfo = (PyProgressData *) CPLCalloc(1,sizeof(PyProgressData));
+  psProgressInfo->nLastReported = -1;
+  psProgressInfo->psPyCallback = NULL;
+  psProgressInfo->psPyCallbackData = NULL;
+  arg5 = psProgressInfo;
+  if (!SWIG_Python_UnpackTuple(args, "TileIndexInternalNames", 3, 5, swig_obj)) SWIG_fail;
+  {
+    /* %typemap(in) (const char *utf8_path) */
+    if (PyUnicode_Check(swig_obj[0]) || PyBytes_Check(swig_obj[0]))
+    {
+      arg1 = GDALPythonObjectToCStr( swig_obj[0], &bToFree1 );
+    }
+    else
+    {
+      arg1 = GDALPythonPathToCStr(swig_obj[0], &bToFree1);
+      
+    }
+    if (arg1 == NULL)
+    {
+      PyErr_SetString( PyExc_RuntimeError, "not a string or os.PathLike" );
+      SWIG_fail;
+    }
+  }
+  {
+    /* %typemap(in) char **dict */
+    arg2 = NULL;
+    if ( PySequence_Check( swig_obj[1] ) ) {
+      int bErr = FALSE;
+      arg2 = CSLFromPySequence(swig_obj[1], &bErr);
+      if ( bErr )
+      {
+        SWIG_fail;
+      }
+    }
+    else if ( PyMapping_Check( swig_obj[1] ) ) {
+      int bErr = FALSE;
+      arg2 = CSLFromPyMapping(swig_obj[1], &bErr);
+      if ( bErr )
+      {
+        SWIG_fail;
+      }
+    }
+    else {
+      PyErr_SetString(PyExc_TypeError,"Argument must be dictionary or sequence of strings");
+      SWIG_fail;
+    }
+  }
+  res3 = SWIG_ConvertPtr(swig_obj[2], &argp3,SWIGTYPE_p_GDALTileIndexOptions, 0 |  0 );
+  if (!SWIG_IsOK(res3)) {
+    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "TileIndexInternalNames" "', argument " "3"" of type '" "GDALTileIndexOptions *""'"); 
+  }
+  arg3 = reinterpret_cast< GDALTileIndexOptions * >(argp3);
+  if (swig_obj[3]) {
+    {
+      /* %typemap(in) (GDALProgressFunc callback = NULL) */
+      /* callback_func typemap */
+      
+      /* In some cases 0 is passed instead of None. */
+      /* See https://github.com/OSGeo/gdal/pull/219 */
+      if ( PyLong_Check(swig_obj[3]) || PyInt_Check(swig_obj[3]) )
+      {
+        if( PyLong_AsLong(swig_obj[3]) == 0 )
+        {
+          swig_obj[3] = Py_None;
+        }
+      }
+      
+      if (swig_obj[3] && swig_obj[3] != Py_None ) {
+        void* cbfunction = NULL;
+        CPL_IGNORE_RET_VAL(SWIG_ConvertPtr( swig_obj[3],
+            (void**)&cbfunction,
+            SWIGTYPE_p_f_double_p_q_const__char_p_void__int,
+            SWIG_POINTER_EXCEPTION | 0 ));
+        
+        if ( cbfunction == GDALTermProgress ) {
+          arg4 = GDALTermProgress;
+        } else {
+          if (!PyCallable_Check(swig_obj[3])) {
+            PyErr_SetString( PyExc_RuntimeError,
+              "Object given is not a Python function" );
+            SWIG_fail;
+          }
+          psProgressInfo->psPyCallback = swig_obj[3];
+          arg4 = PyProgressProxy;
+        }
+        
+      }
+      
+    }
+  }
+  if (swig_obj[4]) {
+    {
+      /* %typemap(in) ( void* callback_data=NULL)  */
+      psProgressInfo->psPyCallbackData = swig_obj[4] ;
+    }
+  }
+  {
+    if (!arg1) {
+      SWIG_exception(SWIG_ValueError,"Received a NULL pointer.");
+    }
+  }
+  {
+    const int bLocalUseExceptions = GetUseExceptions();
+    if ( bLocalUseExceptions ) {
+      pushErrorHandler();
+    }
+    {
+      SWIG_PYTHON_THREAD_BEGIN_ALLOW;
+      result = (GDALDatasetShadow *)wrapper_TileIndex_names((char const *)arg1,arg2,arg3,SWIG_STD_MOVE(arg4),arg5);
+      SWIG_PYTHON_THREAD_END_ALLOW;
+    }
+    if ( bLocalUseExceptions ) {
+      popErrorHandler();
+    }
+#ifndef SED_HACKS
+    if ( bLocalUseExceptions ) {
+      CPLErr eclass = CPLGetLastErrorType();
+      if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+        SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+      }
+    }
+#endif
+  }
+  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_GDALDatasetShadow, SWIG_POINTER_OWN |  0 );
+  {
+    /* %typemap(freearg) (const char *utf8_path) */
+    GDALPythonFreeCStr(arg1, bToFree1);
+  }
+  {
+    /* %typemap(freearg) char **dict */
+    CSLDestroy( arg2 );
+  }
+  {
+    /* %typemap(freearg) ( void* callback_data=NULL)  */
+    
+    CPLFree(psProgressInfo);
+    
+  }
+  if ( ReturnSame(bLocalUseExceptionsCode) ) { CPLErr eclass = CPLGetLastErrorType(); if ( eclass == CE_Failure || eclass == CE_Fatal ) { Py_XDECREF(resultobj); SWIG_Error( SWIG_RuntimeError, CPLGetLastErrorMsg() ); return NULL; } }
+  return resultobj;
+fail:
+  {
+    /* %typemap(freearg) (const char *utf8_path) */
+    GDALPythonFreeCStr(arg1, bToFree1);
+  }
+  {
+    /* %typemap(freearg) char **dict */
+    CSLDestroy( arg2 );
+  }
+  {
+    /* %typemap(freearg) ( void* callback_data=NULL)  */
+    
+    CPLFree(psProgressInfo);
+    
+  }
+  return NULL;
+}
+
+
 SWIGINTERN PyObject *_wrap_new_GDALMultiDimTranslateOptions(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
   char **arg1 = (char **) 0 ;
   PyObject *swig_obj[1] ;
   GDALMultiDimTranslateOptions *result = 0 ;
   
   if (!args) SWIG_fail;
@@ -53233,20 +54391,145 @@
 	 { "new_DirEntry", _wrap_new_DirEntry, METH_O, "new_DirEntry(DirEntry entryIn) -> DirEntry"},
 	 { "delete_DirEntry", _wrap_delete_DirEntry, METH_O, "delete_DirEntry(DirEntry self)"},
 	 { "DirEntry_IsDirectory", _wrap_DirEntry_IsDirectory, METH_O, "DirEntry_IsDirectory(DirEntry self) -> bool"},
 	 { "DirEntry_swigregister", DirEntry_swigregister, METH_O, NULL},
 	 { "DirEntry_swiginit", DirEntry_swiginit, METH_VARARGS, NULL},
 	 { "GetNextDirEntry", _wrap_GetNextDirEntry, METH_O, "GetNextDirEntry(VSIDIR * dir) -> DirEntry"},
 	 { "CloseDir", _wrap_CloseDir, METH_O, "CloseDir(VSIDIR * dir)"},
-	 { "SetConfigOption", _wrap_SetConfigOption, METH_VARARGS, "SetConfigOption(char const * pszKey, char const * pszValue)"},
-	 { "SetThreadLocalConfigOption", _wrap_SetThreadLocalConfigOption, METH_VARARGS, "SetThreadLocalConfigOption(char const * pszKey, char const * pszValue)"},
-	 { "GetConfigOption", _wrap_GetConfigOption, METH_VARARGS, "GetConfigOption(char const * pszKey, char const * pszDefault=None) -> char const *"},
-	 { "GetGlobalConfigOption", _wrap_GetGlobalConfigOption, METH_VARARGS, "GetGlobalConfigOption(char const * pszKey, char const * pszDefault=None) -> char const *"},
-	 { "GetThreadLocalConfigOption", _wrap_GetThreadLocalConfigOption, METH_VARARGS, "GetThreadLocalConfigOption(char const * pszKey, char const * pszDefault=None) -> char const *"},
-	 { "GetConfigOptions", _wrap_GetConfigOptions, METH_NOARGS, "GetConfigOptions() -> char **"},
+	 { "SetConfigOption", _wrap_SetConfigOption, METH_VARARGS, "\n"
+		"SetConfigOption(char const * pszKey, char const * pszValue)\n"
+		"\n"
+		"\n"
+		"Set the value of a configuration option for all threads.\n"
+		"See :cpp:func:`CPLSetConfigOption`.\n"
+		"\n"
+		"Parameters\n"
+		"----------\n"
+		"pszKey : str\n"
+		"    name of the configuration option\n"
+		"pszValue : str\n"
+		"    value of the configuration option\n"
+		"\n"
+		"See Also\n"
+		"--------\n"
+		":py:func:`SetThreadLocalConfigOption`\n"
+		":py:func:`config_option`\n"
+		":py:func:`config_options`\n"
+		"\n"
+		"\n"
+		""},
+	 { "SetThreadLocalConfigOption", _wrap_SetThreadLocalConfigOption, METH_VARARGS, "\n"
+		"SetThreadLocalConfigOption(char const * pszKey, char const * pszValue)\n"
+		"\n"
+		"\n"
+		"Set the value of a configuration option for the current thread.\n"
+		"See :cpp:func:`CPLSetThreadLocalConfigOption`.\n"
+		"\n"
+		"Parameters\n"
+		"----------\n"
+		"pszKey : str\n"
+		"    name of the configuration option\n"
+		"pszValue : str\n"
+		"    value of the configuration option\n"
+		"\n"
+		"See Also\n"
+		"--------\n"
+		":py:func:`SetConfigOption`\n"
+		":py:func:`config_option`\n"
+		":py:func:`config_options`\n"
+		"\n"
+		""},
+	 { "GetConfigOption", _wrap_GetConfigOption, METH_VARARGS, "\n"
+		"GetConfigOption(char const * pszKey, char const * pszDefault=None) -> char const *\n"
+		"\n"
+		"\n"
+		"Return the value of a configuration option.\n"
+		"See :cpp:func:`CPLGetConfigOption`.\n"
+		"\n"
+		"Parameters\n"
+		"----------\n"
+		"pszKey : str\n"
+		"    name of the configuration option\n"
+		"pszDefault : str, optional\n"
+		"    default value to return if the option has not been set\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"str\n"
+		"\n"
+		"See Also\n"
+		"--------\n"
+		":py:func:`GetConfigOptions`\n"
+		":py:func:`GetThreadLocalConfigOption`\n"
+		"\n"
+		""},
+	 { "GetGlobalConfigOption", _wrap_GetGlobalConfigOption, METH_VARARGS, "\n"
+		"GetGlobalConfigOption(char const * pszKey, char const * pszDefault=None) -> char const *\n"
+		"\n"
+		"\n"
+		"Return the value of a global (not thread-local) configuration option.\n"
+		"See :cpp:func:`CPLGetGlobalConfigOption`.\n"
+		"\n"
+		"Parameters\n"
+		"----------\n"
+		"pszKey : str\n"
+		"    name of the configuration option\n"
+		"pszDefault : str, optional\n"
+		"    default value to return if the option has not been set\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"str\n"
+		"\n"
+		""},
+	 { "GetThreadLocalConfigOption", _wrap_GetThreadLocalConfigOption, METH_VARARGS, "\n"
+		"GetThreadLocalConfigOption(char const * pszKey, char const * pszDefault=None) -> char const *\n"
+		"\n"
+		"\n"
+		"Return the value of a thread-local configuration option.\n"
+		"See :cpp:func:`CPLGetThreadLocalConfigOption`.\n"
+		"\n"
+		"Parameters\n"
+		"----------\n"
+		"pszKey : str\n"
+		"    name of the configuration option\n"
+		"pszDefault : str, optional\n"
+		"    default value to return if the option has not been set\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"str\n"
+		"\n"
+		"\n"
+		""},
+	 { "GetConfigOptions", _wrap_GetConfigOptions, METH_NOARGS, "\n"
+		"GetConfigOptions() -> char **\n"
+		"\n"
+		"\n"
+		"Return a dictionary of currently set configuration options.\n"
+		"See :cpp:func:`CPLGetConfigOptions`.\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"dict\n"
+		"\n"
+		"Examples\n"
+		"--------\n"
+		">>> with gdal.config_options({'A': '3', 'B': '4'}):\n"
+		"...     gdal.SetConfigOption('C', '5')\n"
+		"...     gdal.GetConfigOptions()\n"
+		"...\n"
+		"{'C': '5', 'A': '3', 'B': '4'}\n"
+		"\n"
+		"See Also\n"
+		"--------\n"
+		":py:func:`GetConfigOption`\n"
+		":py:func:`GetGlobalConfigOptions`\n"
+		"\n"
+		""},
 	 { "SetPathSpecificOption", _wrap_SetPathSpecificOption, METH_VARARGS, "SetPathSpecificOption(char const * pszPathPrefix, char const * pszKey, char const * pszValue)"},
 	 { "SetCredential", _wrap_SetCredential, METH_VARARGS, "SetCredential(char const * pszPathPrefix, char const * pszKey, char const * pszValue)"},
 	 { "GetCredential", _wrap_GetCredential, METH_VARARGS, "GetCredential(char const * pszPathPrefix, char const * pszKey, char const * pszDefault=None) -> char const *"},
 	 { "GetPathSpecificOption", _wrap_GetPathSpecificOption, METH_VARARGS, "GetPathSpecificOption(char const * pszPathPrefix, char const * pszKey, char const * pszDefault=None) -> char const *"},
 	 { "ClearCredentials", _wrap_ClearCredentials, METH_VARARGS, "ClearCredentials(char const * pszPathPrefix=None)"},
 	 { "ClearPathSpecificOptions", _wrap_ClearPathSpecificOptions, METH_VARARGS, "ClearPathSpecificOptions(char const * pszPathPrefix=None)"},
 	 { "CPLBinaryToHex", _wrap_CPLBinaryToHex, METH_O, "CPLBinaryToHex(int nBytes) -> retStringAndCPLFree *"},
@@ -53291,39 +54574,239 @@
 	 { "VSIFGetRangeStatusL", _wrap_VSIFGetRangeStatusL, METH_VARARGS, "VSIFGetRangeStatusL(VSILFILE fp, GIntBig offset, GIntBig length) -> int"},
 	 { "VSIFWriteL", _wrap_VSIFWriteL, METH_VARARGS, "VSIFWriteL(int nLen, int size, int memb, VSILFILE fp) -> int"},
 	 { "VSICurlClearCache", _wrap_VSICurlClearCache, METH_NOARGS, "VSICurlClearCache()"},
 	 { "VSICurlPartialClearCache", _wrap_VSICurlPartialClearCache, METH_O, "VSICurlPartialClearCache(char const * utf8_path)"},
 	 { "NetworkStatsReset", _wrap_NetworkStatsReset, METH_NOARGS, "NetworkStatsReset()"},
 	 { "NetworkStatsGetAsSerializedJSON", _wrap_NetworkStatsGetAsSerializedJSON, METH_VARARGS, "NetworkStatsGetAsSerializedJSON(char ** options=None) -> retStringAndCPLFree *"},
 	 { "ParseCommandLine", _wrap_ParseCommandLine, METH_O, "ParseCommandLine(char const * utf8_path) -> char **"},
-	 { "GetNumCPUs", _wrap_GetNumCPUs, METH_NOARGS, "GetNumCPUs() -> int"},
+	 { "GetNumCPUs", _wrap_GetNumCPUs, METH_NOARGS, "\n"
+		"GetNumCPUs() -> int\n"
+		"\n"
+		"\n"
+		"Return the number of processors detected by GDAL.\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"int\n"
+		"\n"
+		""},
 	 { "GetUsablePhysicalRAM", _wrap_GetUsablePhysicalRAM, METH_NOARGS, "GetUsablePhysicalRAM() -> GIntBig"},
 	 { "MajorObject_GetDescription", _wrap_MajorObject_GetDescription, METH_O, "MajorObject_GetDescription(MajorObject self) -> char const *"},
 	 { "MajorObject_SetDescription", _wrap_MajorObject_SetDescription, METH_VARARGS, "MajorObject_SetDescription(MajorObject self, char const * pszNewDesc)"},
 	 { "MajorObject_GetMetadataDomainList", _wrap_MajorObject_GetMetadataDomainList, METH_O, "MajorObject_GetMetadataDomainList(MajorObject self) -> char **"},
 	 { "MajorObject_GetMetadata_Dict", _wrap_MajorObject_GetMetadata_Dict, METH_VARARGS, "MajorObject_GetMetadata_Dict(MajorObject self, char const * pszDomain=\"\") -> char **"},
 	 { "MajorObject_GetMetadata_List", _wrap_MajorObject_GetMetadata_List, METH_VARARGS, "MajorObject_GetMetadata_List(MajorObject self, char const * pszDomain=\"\") -> char **"},
 	 { "MajorObject_SetMetadata", _wrap_MajorObject_SetMetadata, METH_VARARGS, "\n"
 		"MajorObject_SetMetadata(MajorObject self, char ** papszMetadata, char const * pszDomain=\"\") -> CPLErr\n"
 		"MajorObject_SetMetadata(MajorObject self, char * pszMetadataString, char const * pszDomain=\"\") -> CPLErr\n"
 		""},
 	 { "MajorObject_GetMetadataItem", _wrap_MajorObject_GetMetadataItem, METH_VARARGS, "MajorObject_GetMetadataItem(MajorObject self, char const * pszName, char const * pszDomain=\"\") -> char const *"},
 	 { "MajorObject_SetMetadataItem", _wrap_MajorObject_SetMetadataItem, METH_VARARGS, "MajorObject_SetMetadataItem(MajorObject self, char const * pszName, char const * pszValue, char const * pszDomain=\"\") -> CPLErr"},
 	 { "MajorObject_swigregister", MajorObject_swigregister, METH_O, NULL},
-	 { "Driver_ShortName_get", _wrap_Driver_ShortName_get, METH_O, "Driver_ShortName_get(Driver self) -> char const *"},
-	 { "Driver_LongName_get", _wrap_Driver_LongName_get, METH_O, "Driver_LongName_get(Driver self) -> char const *"},
-	 { "Driver_HelpTopic_get", _wrap_Driver_HelpTopic_get, METH_O, "Driver_HelpTopic_get(Driver self) -> char const *"},
-	 { "Driver_Create", (PyCFunction)(void(*)(void))_wrap_Driver_Create, METH_VARARGS|METH_KEYWORDS, "Driver_Create(Driver self, char const * utf8_path, int xsize, int ysize, int bands=1, GDALDataType eType=GDT_Byte, char ** options=None) -> Dataset"},
-	 { "Driver_CreateMultiDimensional", (PyCFunction)(void(*)(void))_wrap_Driver_CreateMultiDimensional, METH_VARARGS|METH_KEYWORDS, "Driver_CreateMultiDimensional(Driver self, char const * utf8_path, char ** root_group_options=None, char ** options=None) -> Dataset"},
-	 { "Driver_CreateCopy", (PyCFunction)(void(*)(void))_wrap_Driver_CreateCopy, METH_VARARGS|METH_KEYWORDS, "Driver_CreateCopy(Driver self, char const * utf8_path, Dataset src, int strict=1, char ** options=None, GDALProgressFunc callback=0, void * callback_data=None) -> Dataset"},
-	 { "Driver_Delete", _wrap_Driver_Delete, METH_VARARGS, "Driver_Delete(Driver self, char const * utf8_path) -> CPLErr"},
-	 { "Driver_Rename", _wrap_Driver_Rename, METH_VARARGS, "Driver_Rename(Driver self, char const * newName, char const * oldName) -> CPLErr"},
-	 { "Driver_CopyFiles", _wrap_Driver_CopyFiles, METH_VARARGS, "Driver_CopyFiles(Driver self, char const * newName, char const * oldName) -> CPLErr"},
-	 { "Driver_Register", _wrap_Driver_Register, METH_O, "Driver_Register(Driver self) -> int"},
-	 { "Driver_Deregister", _wrap_Driver_Deregister, METH_O, "Driver_Deregister(Driver self)"},
+	 { "Driver_ShortName_get", _wrap_Driver_ShortName_get, METH_O, "\n"
+		"Driver_ShortName_get(Driver self) -> char const *\n"
+		"\n"
+		"The short name of a :py:class:`Driver` that can be passed to\n"
+		":py:func:`GetDriverByName`.\n"
+		"See :cpp:func:`GDALGetDriverShortName`.\n"
+		"\n"
+		""},
+	 { "Driver_LongName_get", _wrap_Driver_LongName_get, METH_O, "\n"
+		"Driver_LongName_get(Driver self) -> char const *\n"
+		"\n"
+		"The long name of the driver.\n"
+		"See :cpp:func:`GDALGetDriverLongName`.\n"
+		"\n"
+		""},
+	 { "Driver_HelpTopic_get", _wrap_Driver_HelpTopic_get, METH_O, "\n"
+		"Driver_HelpTopic_get(Driver self) -> char const *\n"
+		"\n"
+		"The URL for driver documentation, relative to the GDAL documentation directory.\n"
+		"See :cpp:func:`GDALGetDriverHelpTopic`.\n"
+		"\n"
+		""},
+	 { "Driver_Create", (PyCFunction)(void(*)(void))_wrap_Driver_Create, METH_VARARGS|METH_KEYWORDS, "\n"
+		"Driver_Create(Driver self, char const * utf8_path, int xsize, int ysize, int bands=1, GDALDataType eType=GDT_Byte, char ** options=None) -> Dataset\n"
+		"\n"
+		"\n"
+		"Create a new :py:class:`Dataset` with this driver.\n"
+		"See :cpp:func:`GDALDriver::Create`.\n"
+		"\n"
+		"Parameters\n"
+		"----------\n"
+		"utf8_path : str\n"
+		"   Path of the dataset to create.\n"
+		"xsize : int\n"
+		"   Width of created raster in pixels. Set to zero for vector datasets.\n"
+		"ysize : int\n"
+		"   Height of created raster in pixels. Set to zero for vector datasets.\n"
+		"bands : int, default = 1\n"
+		"    Number of bands. Set to zero for vector datasets.\n"
+		"eType : int, default = :py:const:`GDT_Byte`\n"
+		"    Raster data type. Set to :py:const:`GDT_Unknown` for vector datasets.\n"
+		"options : list/dict\n"
+		"    List of driver-specific options\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"Dataset\n"
+		"\n"
+		"Examples\n"
+		"--------\n"
+		">>> with gdal.GetDriverByName('GTiff').Create('test.tif', 12, 4, 2, gdal.GDT_Float32, {'COMPRESS': 'DEFLATE'}) as ds:\n"
+		"...     print(gdal.Info(ds))\n"
+		"...\n"
+		"Driver: GTiff/GeoTIFF\n"
+		"Files: test.tif\n"
+		"Size is 12, 4\n"
+		"Image Structure Metadata:\n"
+		"  INTERLEAVE=PIXEL\n"
+		"Corner Coordinates:\n"
+		"Upper Left  (    0.0,    0.0)\n"
+		"Lower Left  (    0.0,    4.0)\n"
+		"Upper Right (   12.0,    0.0)\n"
+		"Lower Right (   12.0,    4.0)\n"
+		"Center      (    6.0,    2.0)\n"
+		"Band 1 Block=12x4 Type=Float32, ColorInterp=Gray\n"
+		"Band 2 Block=12x4 Type=Float32, ColorInterp=Undefined\n"
+		"\n"
+		">>> with gdal.GetDriverByName('ESRI Shapefile').Create('test.shp', 0, 0, 0, gdal.GDT_Unknown) as ds:\n"
+		"...     print(gdal.VectorInfo(ds))\n"
+		"...\n"
+		"INFO: Open of `test.shp'\n"
+		"      using driver `ESRI Shapefile' successful.\n"
+		"\n"
+		""},
+	 { "Driver_CreateMultiDimensional", (PyCFunction)(void(*)(void))_wrap_Driver_CreateMultiDimensional, METH_VARARGS|METH_KEYWORDS, "\n"
+		"Driver_CreateMultiDimensional(Driver self, char const * utf8_path, char ** root_group_options=None, char ** options=None) -> Dataset\n"
+		"\n"
+		"\n"
+		"Create a new multidimensional dataset.\n"
+		"See :cpp:func:`GDALDriver::CreateMultiDimensional`.\n"
+		"\n"
+		"Parameters\n"
+		"----------\n"
+		"utf8_path : str\n"
+		"   Path of the dataset to create.\n"
+		"root_group_options : dict/list\n"
+		"   Driver-specific options regarding the creation of the\n"
+		"   root group.\n"
+		"options : list/dict\n"
+		"   List of driver-specific options regarding the creation\n"
+		"   of the Dataset.\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"Dataset\n"
+		"\n"
+		"Examples\n"
+		"--------\n"
+		">>> with gdal.GetDriverByName('netCDF').CreateMultiDimensional('test.nc') as ds:\n"
+		"...     gdal.MultiDimInfo(ds)\n"
+		"...\n"
+		"{'type': 'group', 'driver': 'netCDF', 'name': '/', 'attributes': {'Conventions': 'CF-1.6'}, 'structural_info': {'NC_FORMAT': 'NETCDF4'}}\n"
+		"\n"
+		"\n"
+		""},
+	 { "Driver_CreateCopy", (PyCFunction)(void(*)(void))_wrap_Driver_CreateCopy, METH_VARARGS|METH_KEYWORDS, "\n"
+		"Driver_CreateCopy(Driver self, char const * utf8_path, Dataset src, int strict=1, char ** options=None, GDALProgressFunc callback=0, void * callback_data=None) -> Dataset\n"
+		"\n"
+		"\n"
+		"Create a copy of a :py:class:`Dataset`.\n"
+		"See :cpp:func:`GDALDriver::CreateCopy`.\n"
+		"\n"
+		"Parameters\n"
+		"----------\n"
+		"utf8_path : str\n"
+		"   Path of the dataset to create.\n"
+		"src : Dataset\n"
+		"   The Dataset being duplicated.\n"
+		"strict : bool, default=1\n"
+		"   Indicates whether the copy must be strictly equivalent or if\n"
+		"   it may be adapted as needed for the output format.\n"
+		"options : list/dict\n"
+		"   List of driver-specific options\n"
+		"callback : function, optional\n"
+		"   A progress callback function\n"
+		"callback_data: optional\n"
+		"   Optional data to be passed to callback function\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"Dataset\n"
+		"\n"
+		""},
+	 { "Driver_Delete", _wrap_Driver_Delete, METH_VARARGS, "\n"
+		"Driver_Delete(Driver self, char const * utf8_path) -> CPLErr\n"
+		"\n"
+		"Delete a :py:class:`Dataset`.\n"
+		"See :cpp:func:`GDALDriver::Delete`.\n"
+		"\n"
+		"Parameters\n"
+		"----------\n"
+		"utf8_path : str\n"
+		"   Path of the dataset to delete.\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"int:\n"
+		"   :py:const:`CE_None` on success or :py:const:`CE_Failure` on failure.\n"
+		"\n"
+		""},
+	 { "Driver_Rename", _wrap_Driver_Rename, METH_VARARGS, "\n"
+		"Driver_Rename(Driver self, char const * newName, char const * oldName) -> CPLErr\n"
+		"\n"
+		"Rename a :py:class:`Dataset`.\n"
+		"See :cpp:func:`GDALDriver::Rename`.\n"
+		"\n"
+		"Parameters\n"
+		"----------\n"
+		"newName : str\n"
+		"    new path for the dataset\n"
+		"oldName : str\n"
+		"    old path for the dataset\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"int:\n"
+		"   :py:const:`CE_None` on success or :py:const:`CE_Failure` on failure.\n"
+		"\n"
+		""},
+	 { "Driver_CopyFiles", _wrap_Driver_CopyFiles, METH_VARARGS, "\n"
+		"Driver_CopyFiles(Driver self, char const * newName, char const * oldName) -> CPLErr\n"
+		"\n"
+		"Copy all the files associated with a :py:class:`Dataset`.\n"
+		"\n"
+		"Parameters\n"
+		"----------\n"
+		"newName : str\n"
+		"    new path for the dataset\n"
+		"oldName : str\n"
+		"    old path for the dataset\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"int:\n"
+		"   :py:const:`CE_None` on success or :py:const:`CE_Failure` on failure.\n"
+		"\n"
+		""},
+	 { "Driver_Register", _wrap_Driver_Register, METH_O, "\n"
+		"Driver_Register(Driver self) -> int\n"
+		"\n"
+		"Register the driver for use.\n"
+		"See :cpp:func:`GDALDriverManager::RegisterDriver`.\n"
+		"\n"
+		""},
+	 { "Driver_Deregister", _wrap_Driver_Deregister, METH_O, "\n"
+		"Driver_Deregister(Driver self)\n"
+		"\n"
+		"Deregister the driver.\n"
+		"See :cpp:func:`GDALDriverManager::DeregisterDriver`.\n"
+		"\n"
+		""},
 	 { "Driver_swigregister", Driver_swigregister, METH_O, NULL},
 	 { "ColorEntry_c1_set", _wrap_ColorEntry_c1_set, METH_VARARGS, "ColorEntry_c1_set(ColorEntry self, short c1)"},
 	 { "ColorEntry_c1_get", _wrap_ColorEntry_c1_get, METH_O, "ColorEntry_c1_get(ColorEntry self) -> short"},
 	 { "ColorEntry_c2_set", _wrap_ColorEntry_c2_set, METH_VARARGS, "ColorEntry_c2_set(ColorEntry self, short c2)"},
 	 { "ColorEntry_c2_get", _wrap_ColorEntry_c2_get, METH_O, "ColorEntry_c2_get(ColorEntry self) -> short"},
 	 { "ColorEntry_c3_set", _wrap_ColorEntry_c3_set, METH_VARARGS, "ColorEntry_c3_set(ColorEntry self, short c3)"},
 	 { "ColorEntry_c3_get", _wrap_ColorEntry_c3_get, METH_O, "ColorEntry_c3_get(ColorEntry self) -> short"},
@@ -53369,87 +54852,854 @@
 	 { "VirtualMem_swigregister", VirtualMem_swigregister, METH_O, NULL},
 	 { "delete_AsyncReader", _wrap_delete_AsyncReader, METH_O, "delete_AsyncReader(AsyncReader self)"},
 	 { "AsyncReader_GetNextUpdatedRegion", _wrap_AsyncReader_GetNextUpdatedRegion, METH_VARARGS, "AsyncReader_GetNextUpdatedRegion(AsyncReader self, double timeout) -> GDALAsyncStatusType"},
 	 { "AsyncReader_GetBuffer", _wrap_AsyncReader_GetBuffer, METH_O, "AsyncReader_GetBuffer(AsyncReader self)"},
 	 { "AsyncReader_LockBuffer", _wrap_AsyncReader_LockBuffer, METH_VARARGS, "AsyncReader_LockBuffer(AsyncReader self, double timeout) -> int"},
 	 { "AsyncReader_UnlockBuffer", _wrap_AsyncReader_UnlockBuffer, METH_O, "AsyncReader_UnlockBuffer(AsyncReader self)"},
 	 { "AsyncReader_swigregister", AsyncReader_swigregister, METH_O, NULL},
-	 { "Dataset_RasterXSize_get", _wrap_Dataset_RasterXSize_get, METH_O, "Dataset_RasterXSize_get(Dataset self) -> int"},
-	 { "Dataset_RasterYSize_get", _wrap_Dataset_RasterYSize_get, METH_O, "Dataset_RasterYSize_get(Dataset self) -> int"},
-	 { "Dataset_RasterCount_get", _wrap_Dataset_RasterCount_get, METH_O, "Dataset_RasterCount_get(Dataset self) -> int"},
+	 { "Dataset_RasterXSize_get", _wrap_Dataset_RasterXSize_get, METH_O, "\n"
+		"Dataset_RasterXSize_get(Dataset self) -> int\n"
+		"\n"
+		"\n"
+		"Raster width in pixels. See :cpp:func:`GDALGetRasterXSize`.\n"
+		"\n"
+		"\n"
+		""},
+	 { "Dataset_RasterYSize_get", _wrap_Dataset_RasterYSize_get, METH_O, "\n"
+		"Dataset_RasterYSize_get(Dataset self) -> int\n"
+		"\n"
+		"\n"
+		"Raster height in pixels. See :cpp:func:`GDALGetRasterYSize`.\n"
+		"\n"
+		"\n"
+		""},
+	 { "Dataset_RasterCount_get", _wrap_Dataset_RasterCount_get, METH_O, "\n"
+		"Dataset_RasterCount_get(Dataset self) -> int\n"
+		"\n"
+		"\n"
+		"The number of bands in this dataset.\n"
+		"\n"
+		"\n"
+		""},
 	 { "delete_Dataset", _wrap_delete_Dataset, METH_O, "delete_Dataset(Dataset self)"},
 	 { "Dataset_Close", _wrap_Dataset_Close, METH_O, "\n"
 		"Dataset_Close(Dataset self) -> CPLErr\n"
 		"\n"
 		"Closes opened dataset and releases allocated resources.\n"
 		"\n"
 		"This method can be used to force the dataset to close\n"
 		"when one more references to the dataset are still\n"
-		"reachable. If Close is never called, the dataset will\n"
+		"reachable. If :py:meth:`Close` is never called, the dataset will\n"
 		"be closed automatically during garbage collection.\n"
 		"\n"
+		"In most cases, it is preferable to open or create a dataset\n"
+		"using a context manager instead of calling :py:meth:`Close`\n"
+		"directly.\n"
+		"\n"
+		"\n"
+		""},
+	 { "Dataset_GetDriver", _wrap_Dataset_GetDriver, METH_O, "\n"
+		"Dataset_GetDriver(Dataset self) -> Driver\n"
+		"\n"
+		"\n"
+		"Fetch the driver used to open or create this :py:class:`Dataset`.\n"
+		"\n"
+		"\n"
+		""},
+	 { "Dataset_GetRasterBand", _wrap_Dataset_GetRasterBand, METH_VARARGS, "\n"
+		"Dataset_GetRasterBand(Dataset self, int nBand) -> Band\n"
+		"\n"
+		"\n"
+		"Fetch a :py:class:`Band` band from a :py:class:`Dataset`. See :cpp:func:`GDALGetRasterBand`.\n"
+		"\n"
+		"Parameters\n"
+		"-----------\n"
+		"nBand : int\n"
+		"    the index of the band to fetch, from 1 to :py:attr:`RasterCount`\n"
+		"\n"
+		"Returns\n"
+		"--------\n"
+		"Band:\n"
+		"    the :py:class:`Band`, or ``None`` on error.\n"
+		"\n"
+		"\n"
+		""},
+	 { "Dataset_GetRootGroup", _wrap_Dataset_GetRootGroup, METH_O, "\n"
+		"Dataset_GetRootGroup(Dataset self) -> Group\n"
+		"\n"
+		"\n"
+		"Return the root :py:class:`Group` of this dataset.\n"
+		"Only value for multidimensional datasets.\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"Group\n"
+		"\n"
+		"\n"
+		""},
+	 { "Dataset_GetProjection", _wrap_Dataset_GetProjection, METH_O, "\n"
+		"Dataset_GetProjection(Dataset self) -> char const *\n"
+		"\n"
+		"\n"
+		"Return a WKT representation of the dataset spatial reference.\n"
+		"Equivalent to :py:meth:`GetProjectionRef`.\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"str\n"
+		"\n"
+		"\n"
+		""},
+	 { "Dataset_GetProjectionRef", _wrap_Dataset_GetProjectionRef, METH_O, "\n"
+		"Dataset_GetProjectionRef(Dataset self) -> char const *\n"
+		"\n"
+		"\n"
+		"Return a WKT representation of the dataset spatial reference.\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"str\n"
+		"\n"
+		"\n"
+		""},
+	 { "Dataset_GetSpatialRef", _wrap_Dataset_GetSpatialRef, METH_O, "\n"
+		"Dataset_GetSpatialRef(Dataset self) -> SpatialReference\n"
+		"\n"
+		"\n"
+		"Fetch the spatial reference for this dataset.\n"
+		"\n"
+		"Returns\n"
+		"--------\n"
+		"osr.SpatialReference\n"
+		"\n"
+		"\n"
+		""},
+	 { "Dataset_SetProjection", _wrap_Dataset_SetProjection, METH_VARARGS, "\n"
+		"Dataset_SetProjection(Dataset self, char const * prj) -> CPLErr\n"
+		"\n"
+		"\n"
+		"Set the spatial reference system for this dataset.\n"
+		"\n"
+		"See :cpp:func:`GDALDataset::SetProjection`.\n"
+		"\n"
+		"Parameters\n"
+		"----------\n"
+		"prj:\n"
+		"   The projection string in OGC WKT or PROJ.4 format\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		":py:const:`CE_Failure` if an error occurs, otherwise :py:const:`CE_None`.\n"
+		"\n"
+		"\n"
+		""},
+	 { "Dataset_SetSpatialRef", _wrap_Dataset_SetSpatialRef, METH_VARARGS, "\n"
+		"Dataset_SetSpatialRef(Dataset self, SpatialReference srs) -> CPLErr\n"
+		"\n"
+		"\n"
+		"Set the spatial reference system for this dataset.\n"
+		"\n"
+		"Parameters\n"
+		"----------\n"
+		"srs : SpatialReference\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		":py:const:`CE_Failure` if an error occurs, otherwise :py:const:`CE_None`.\n"
+		"\n"
+		"\n"
+		""},
+	 { "Dataset_GetGeoTransform", (PyCFunction)(void(*)(void))_wrap_Dataset_GetGeoTransform, METH_VARARGS|METH_KEYWORDS, "\n"
+		"Dataset_GetGeoTransform(Dataset self, int * can_return_null=None)\n"
+		"\n"
+		"\n"
+		"Fetch the affine transformation coefficients.\n"
+		"\n"
+		"See :cpp:func:`GDALGetGeoTransform`.\n"
+		"\n"
+		"Parameters\n"
+		"-----------\n"
+		"can_return_null : bool, default=False\n"
+		"    if ``True``, return ``None`` instead of the default transformation\n"
+		"    if the transformation for this :py:class:`Dataset` has not been defined.\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"tuple:\n"
+		"    a 6-member tuple representing the transformation coefficients\n"
+		"\n"
+		"\n"
+		"\n"
+		""},
+	 { "Dataset_SetGeoTransform", _wrap_Dataset_SetGeoTransform, METH_VARARGS, "\n"
+		"Dataset_SetGeoTransform(Dataset self, double [6] argin) -> CPLErr\n"
+		"\n"
+		"\n"
+		"Set the affine transformation coefficients.\n"
+		"\n"
+		"See :py:meth:`GetGeoTransform` for details on the meaning of the coefficients.\n"
+		"\n"
+		"Parameters\n"
+		"----------\n"
+		"argin : tuple\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		":py:const:`CE_Failure` if an error occurs, otherwise :py:const:`CE_None`.\n"
+		"\n"
+		"\n"
+		""},
+	 { "Dataset_BuildOverviews", (PyCFunction)(void(*)(void))_wrap_Dataset_BuildOverviews, METH_VARARGS|METH_KEYWORDS, "\n"
+		"Dataset_BuildOverviews(Dataset self, char const * resampling=\"NEAREST\", int overviewlist=0, GDALProgressFunc callback=0, void * callback_data=None, char ** options=None) -> int\n"
+		"\n"
+		"\n"
+		"Build raster overview(s) for all bands.\n"
+		"\n"
+		"See :cpp:func:`GDALDataset::BuildOverviews`\n"
+		"\n"
+		"Parameters\n"
+		"----------\n"
+		"resampling : str, optional\n"
+		"             The resampling method to use. See :cpp:func:`GDALDataset::BuildOveriews`.\n"
+		"overviewlist : list\n"
+		"             A list of overview levels (decimation factors) to build, or an\n"
+		"             empty list to clear existing overviews.\n"
+		"callback : function, optional\n"
+		"             A progress callback function\n"
+		"callback_data: optional\n"
+		"             Optional data to be passed to callback function\n"
+		"options : dict/list, optional\n"
+		"             A dict or list of key=value options\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		":py:const:`CE_Failure` if an error occurs, otherwise :py:const:`CE_None`.\n"
+		"\n"
+		"Examples\n"
+		"--------\n"
+		">>> import numpy as np\n"
+		">>> ds = gdal.GetDriverByName('GTiff').Create('test.tif', 12, 12)\n"
+		">>> ds.GetRasterBand(1).WriteArray(np.arange(12*12).reshape((12, 12)))\n"
+		"0\n"
+		">>> ds.BuildOverviews('AVERAGE', [2, 4])\n"
+		"0\n"
+		">>> ds.GetRasterBand(1).GetOverviewCount()\n"
+		"2\n"
+		">>> ds.BuildOverviews(overviewlist=[])\n"
+		"0\n"
+		">>> ds.GetRasterBand(1).GetOverviewCount()\n"
+		"0\n"
+		"\n"
+		""},
+	 { "Dataset_GetGCPCount", _wrap_Dataset_GetGCPCount, METH_O, "\n"
+		"Dataset_GetGCPCount(Dataset self) -> int\n"
+		"\n"
+		"\n"
+		"Get number of GCPs. See :cpp:func:`GDALGetGCPCount`.\n"
+		"\n"
+		"Returns\n"
+		"--------\n"
+		"int\n"
+		"\n"
+		"\n"
+		""},
+	 { "Dataset_GetGCPProjection", _wrap_Dataset_GetGCPProjection, METH_O, "\n"
+		"Dataset_GetGCPProjection(Dataset self) -> char const *\n"
+		"\n"
+		"\n"
+		"Return a WKT representation of the GCP spatial reference.\n"
+		"\n"
+		"Returns\n"
+		"--------\n"
+		"string\n"
+		"\n"
+		"\n"
+		""},
+	 { "Dataset_GetGCPSpatialRef", _wrap_Dataset_GetGCPSpatialRef, METH_O, "\n"
+		"Dataset_GetGCPSpatialRef(Dataset self) -> SpatialReference\n"
+		"\n"
+		"\n"
+		"Get output spatial reference system for GCPs.\n"
+		"\n"
+		"See :cpp:func:`GDALGetGCPSpatialRef`\n"
+		"\n"
+		"\n"
+		""},
+	 { "Dataset_GetGCPs", _wrap_Dataset_GetGCPs, METH_O, "\n"
+		"Dataset_GetGCPs(Dataset self)\n"
+		"\n"
+		"\n"
+		"Get the GCPs. See :cpp:func:`GDALGetGCPs`.\n"
+		"\n"
+		"Returns\n"
+		"--------\n"
+		"tuple\n"
+		"    a tuple of :py:class:`GCP` objects.\n"
+		"\n"
+		"\n"
+		""},
+	 { "Dataset__SetGCPs", _wrap_Dataset__SetGCPs, METH_VARARGS, "\n"
+		"Dataset__SetGCPs(Dataset self, int nGCPs, char const * pszGCPProjection) -> CPLErr\n"
+		"\n"
+		"\n"
 		""},
-	 { "Dataset_GetDriver", _wrap_Dataset_GetDriver, METH_O, "Dataset_GetDriver(Dataset self) -> Driver"},
-	 { "Dataset_GetRasterBand", _wrap_Dataset_GetRasterBand, METH_VARARGS, "Dataset_GetRasterBand(Dataset self, int nBand) -> Band"},
-	 { "Dataset_GetRootGroup", _wrap_Dataset_GetRootGroup, METH_O, "Dataset_GetRootGroup(Dataset self) -> Group"},
-	 { "Dataset_GetProjection", _wrap_Dataset_GetProjection, METH_O, "Dataset_GetProjection(Dataset self) -> char const *"},
-	 { "Dataset_GetProjectionRef", _wrap_Dataset_GetProjectionRef, METH_O, "Dataset_GetProjectionRef(Dataset self) -> char const *"},
-	 { "Dataset_GetSpatialRef", _wrap_Dataset_GetSpatialRef, METH_O, "Dataset_GetSpatialRef(Dataset self) -> SpatialReference"},
-	 { "Dataset_SetProjection", _wrap_Dataset_SetProjection, METH_VARARGS, "Dataset_SetProjection(Dataset self, char const * prj) -> CPLErr"},
-	 { "Dataset_SetSpatialRef", _wrap_Dataset_SetSpatialRef, METH_VARARGS, "Dataset_SetSpatialRef(Dataset self, SpatialReference srs) -> CPLErr"},
-	 { "Dataset_GetGeoTransform", (PyCFunction)(void(*)(void))_wrap_Dataset_GetGeoTransform, METH_VARARGS|METH_KEYWORDS, "Dataset_GetGeoTransform(Dataset self, int * can_return_null=None)"},
-	 { "Dataset_SetGeoTransform", _wrap_Dataset_SetGeoTransform, METH_VARARGS, "Dataset_SetGeoTransform(Dataset self, double [6] argin) -> CPLErr"},
-	 { "Dataset_BuildOverviews", (PyCFunction)(void(*)(void))_wrap_Dataset_BuildOverviews, METH_VARARGS|METH_KEYWORDS, "Dataset_BuildOverviews(Dataset self, char const * resampling=\"NEAREST\", int overviewlist=0, GDALProgressFunc callback=0, void * callback_data=None, char ** options=None) -> int"},
-	 { "Dataset_GetGCPCount", _wrap_Dataset_GetGCPCount, METH_O, "Dataset_GetGCPCount(Dataset self) -> int"},
-	 { "Dataset_GetGCPProjection", _wrap_Dataset_GetGCPProjection, METH_O, "Dataset_GetGCPProjection(Dataset self) -> char const *"},
-	 { "Dataset_GetGCPSpatialRef", _wrap_Dataset_GetGCPSpatialRef, METH_O, "Dataset_GetGCPSpatialRef(Dataset self) -> SpatialReference"},
-	 { "Dataset_GetGCPs", _wrap_Dataset_GetGCPs, METH_O, "Dataset_GetGCPs(Dataset self)"},
-	 { "Dataset__SetGCPs", _wrap_Dataset__SetGCPs, METH_VARARGS, "Dataset__SetGCPs(Dataset self, int nGCPs, char const * pszGCPProjection) -> CPLErr"},
 	 { "Dataset__SetGCPs2", _wrap_Dataset__SetGCPs2, METH_VARARGS, "Dataset__SetGCPs2(Dataset self, int nGCPs, SpatialReference hSRS) -> CPLErr"},
-	 { "Dataset_FlushCache", _wrap_Dataset_FlushCache, METH_O, "Dataset_FlushCache(Dataset self) -> CPLErr"},
-	 { "Dataset_AddBand", (PyCFunction)(void(*)(void))_wrap_Dataset_AddBand, METH_VARARGS|METH_KEYWORDS, "Dataset_AddBand(Dataset self, GDALDataType datatype=GDT_Byte, char ** options=None) -> CPLErr"},
-	 { "Dataset_CreateMaskBand", _wrap_Dataset_CreateMaskBand, METH_VARARGS, "Dataset_CreateMaskBand(Dataset self, int nFlags) -> CPLErr"},
-	 { "Dataset_GetFileList", _wrap_Dataset_GetFileList, METH_O, "Dataset_GetFileList(Dataset self) -> char **"},
+	 { "Dataset_FlushCache", _wrap_Dataset_FlushCache, METH_O, "\n"
+		"Dataset_FlushCache(Dataset self) -> CPLErr\n"
+		"\n"
+		"\n"
+		"Flush all write-cached data to disk.\n"
+		"\n"
+		"See :cpp:func:`GDALDataset::FlushCache`.\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"int\n"
+		"    `gdal.CE_None` in case of success\n"
+		"\n"
+		""},
+	 { "Dataset_AddBand", (PyCFunction)(void(*)(void))_wrap_Dataset_AddBand, METH_VARARGS|METH_KEYWORDS, "\n"
+		"Dataset_AddBand(Dataset self, GDALDataType datatype=GDT_Byte, char ** options=None) -> CPLErr\n"
+		"\n"
+		"\n"
+		"Adds a band to a :py:class:`Dataset`.\n"
+		"\n"
+		"Not supported by all drivers.\n"
+		"\n"
+		"Parameters\n"
+		"-----------\n"
+		"datatype: int\n"
+		"    the data type of the pixels in the new band\n"
+		"options: dict/list\n"
+		"    an optional dict or list of format-specific ``NAME=VALUE`` option strings.\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"int:\n"
+		"   :py:const:`CE_None` on success or :py:const:`CE_Failure` on failure.\n"
+		"\n"
+		"Examples\n"
+		"--------\n"
+		">>> ds=gdal.GetDriverByName('MEM').Create('', 10, 10)\n"
+		">>> ds.RasterCount\n"
+		"1\n"
+		">>> ds.AddBand(gdal.GDT_Float32)\n"
+		"0\n"
+		">>> ds.RasterCount\n"
+		"2\n"
+		"\n"
+		""},
+	 { "Dataset_CreateMaskBand", _wrap_Dataset_CreateMaskBand, METH_VARARGS, "\n"
+		"Dataset_CreateMaskBand(Dataset self, int nFlags) -> CPLErr\n"
+		"\n"
+		"\n"
+		"Adds a mask band to the dataset.\n"
+		"\n"
+		"See :cpp:func:`GDALDataset::CreateMaskBand`.\n"
+		"\n"
+		"Parameters\n"
+		"----------\n"
+		"flags : int\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"int\n"
+		"    :py:const:`CE_Failure` if an error occurs, otherwise :py:const:`CE_None`.\n"
+		"\n"
+		"\n"
+		""},
+	 { "Dataset_GetFileList", _wrap_Dataset_GetFileList, METH_O, "\n"
+		"Dataset_GetFileList(Dataset self) -> char **\n"
+		"\n"
+		"\n"
+		"Returns a list of files believed to be part of this dataset.\n"
+		"See :cpp:func:`GDALGetFileList`.\n"
+		"\n"
+		"\n"
+		""},
 	 { "Dataset_WriteRaster", (PyCFunction)(void(*)(void))_wrap_Dataset_WriteRaster, METH_VARARGS|METH_KEYWORDS, "Dataset_WriteRaster(Dataset self, int xoff, int yoff, int xsize, int ysize, GIntBig buf_len, int * buf_xsize=None, int * buf_ysize=None, GDALDataType * buf_type=None, int band_list=0, GIntBig * buf_pixel_space=None, GIntBig * buf_line_space=None, GIntBig * buf_band_space=None) -> CPLErr"},
-	 { "Dataset_AdviseRead", _wrap_Dataset_AdviseRead, METH_VARARGS, "Dataset_AdviseRead(Dataset self, int xoff, int yoff, int xsize, int ysize, int * buf_xsize=None, int * buf_ysize=None, GDALDataType * buf_type=None, int band_list=0, char ** options=None) -> CPLErr"},
+	 { "Dataset_AdviseRead", _wrap_Dataset_AdviseRead, METH_VARARGS, "\n"
+		"Dataset_AdviseRead(Dataset self, int xoff, int yoff, int xsize, int ysize, int * buf_xsize=None, int * buf_ysize=None, GDALDataType * buf_type=None, int band_list=0, char ** options=None) -> CPLErr\n"
+		"\n"
+		"\n"
+		"Advise driver of upcoming read requests.\n"
+		"\n"
+		"See :cpp:func:`GDALDataset::AdviseRead`.\n"
+		"\n"
+		"\n"
+		""},
 	 { "Dataset_BeginAsyncReader", (PyCFunction)(void(*)(void))_wrap_Dataset_BeginAsyncReader, METH_VARARGS|METH_KEYWORDS, "Dataset_BeginAsyncReader(Dataset self, int xOff, int yOff, int xSize, int ySize, size_t buf_len, int buf_xsize, int buf_ysize, GDALDataType bufType=(GDALDataType) 0, int band_list=0, int nPixelSpace=0, int nLineSpace=0, int nBandSpace=0, char ** options=None) -> AsyncReader"},
 	 { "Dataset_EndAsyncReader", _wrap_Dataset_EndAsyncReader, METH_VARARGS, "Dataset_EndAsyncReader(Dataset self, AsyncReader ario)"},
 	 { "Dataset_GetVirtualMem", (PyCFunction)(void(*)(void))_wrap_Dataset_GetVirtualMem, METH_VARARGS|METH_KEYWORDS, "Dataset_GetVirtualMem(Dataset self, GDALRWFlag eRWFlag, int nXOff, int nYOff, int nXSize, int nYSize, int nBufXSize, int nBufYSize, GDALDataType eBufType, int band_list, int bIsBandSequential, size_t nCacheSize, size_t nPageSizeHint, char ** options=None) -> VirtualMem"},
 	 { "Dataset_GetTiledVirtualMem", (PyCFunction)(void(*)(void))_wrap_Dataset_GetTiledVirtualMem, METH_VARARGS|METH_KEYWORDS, "Dataset_GetTiledVirtualMem(Dataset self, GDALRWFlag eRWFlag, int nXOff, int nYOff, int nXSize, int nYSize, int nTileXSize, int nTileYSize, GDALDataType eBufType, int band_list, GDALTileOrganization eTileOrganization, size_t nCacheSize, char ** options=None) -> VirtualMem"},
-	 { "Dataset_CreateLayer", (PyCFunction)(void(*)(void))_wrap_Dataset_CreateLayer, METH_VARARGS|METH_KEYWORDS, "Dataset_CreateLayer(Dataset self, char const * name, SpatialReference srs=None, OGRwkbGeometryType geom_type=wkbUnknown, char ** options=None) -> Layer"},
-	 { "Dataset_CopyLayer", (PyCFunction)(void(*)(void))_wrap_Dataset_CopyLayer, METH_VARARGS|METH_KEYWORDS, "Dataset_CopyLayer(Dataset self, Layer src_layer, char const * new_name, char ** options=None) -> Layer"},
+	 { "Dataset_CreateLayer", (PyCFunction)(void(*)(void))_wrap_Dataset_CreateLayer, METH_VARARGS|METH_KEYWORDS, "\n"
+		"Dataset_CreateLayer(Dataset self, char const * name, SpatialReference srs=None, OGRwkbGeometryType geom_type=wkbUnknown, char ** options=None) -> Layer\n"
+		"\n"
+		"\n"
+		"Create a new layer in a vector Dataset.\n"
+		"\n"
+		"Parameters\n"
+		"----------\n"
+		"name : string\n"
+		"       the name for the new layer.  This should ideally not\n"
+		"       match any existing layer on the datasource.\n"
+		"srs : osr.SpatialReference, default=None\n"
+		"      the coordinate system to use for the new layer, or ``None`` if\n"
+		"      no coordinate system is available.\n"
+		"geom_type : int, default = :py:const:`ogr.wkbUnknown`\n"
+		"      geometry type for the layer.  Use :py:const:`ogr.wkbUnknown` if there\n"
+		"      are no constraints on the types geometry to be written.\n"
+		"options : dict/list, optional\n"
+		"      Driver-specific dict or list of name=value options\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"ogr.Layer or ``None`` on failure.\n"
+		"\n"
+		"\n"
+		"Examples\n"
+		"--------\n"
+		">>> ds = gdal.GetDriverByName('GPKG').Create('test.gpkg', 0, 0)\n"
+		">>> ds.GetLayerCount()\n"
+		"0\n"
+		">>> lyr = ds.CreateLayer('poly', geom_type=ogr.wkbPolygon)\n"
+		">>> ds.GetLayerCount()\n"
+		"1\n"
+		"\n"
+		"\n"
+		""},
+	 { "Dataset_CreateLayerFromGeomFieldDefn", _wrap_Dataset_CreateLayerFromGeomFieldDefn, METH_VARARGS, "Dataset_CreateLayerFromGeomFieldDefn(Dataset self, char const * name, GeomFieldDefn geom_field, char ** options=None) -> Layer"},
+	 { "Dataset_CopyLayer", (PyCFunction)(void(*)(void))_wrap_Dataset_CopyLayer, METH_VARARGS|METH_KEYWORDS, "\n"
+		"Dataset_CopyLayer(Dataset self, Layer src_layer, char const * new_name, char ** options=None) -> Layer\n"
+		"\n"
+		"\n"
+		"Duplicate an existing :py:class:`ogr.Layer`.\n"
+		"\n"
+		"See :cpp:func:`GDALDAtaset::CopyLayer`.\n"
+		"\n"
+		"Parameters\n"
+		"----------\n"
+		"src_layer : ogr.Layer\n"
+		"            source layer\n"
+		"new_name : str\n"
+		"           name of the layer to create\n"
+		"options : dict/list\n"
+		"          a dict or list of name=value driver-specific creation options\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"ogr.Layer, or ``None`` if an error occurs\n"
+		"\n"
+		""},
 	 { "Dataset_DeleteLayer", _wrap_Dataset_DeleteLayer, METH_VARARGS, "Dataset_DeleteLayer(Dataset self, int index) -> OGRErr"},
-	 { "Dataset_GetLayerCount", _wrap_Dataset_GetLayerCount, METH_O, "Dataset_GetLayerCount(Dataset self) -> int"},
-	 { "Dataset_IsLayerPrivate", _wrap_Dataset_IsLayerPrivate, METH_VARARGS, "Dataset_IsLayerPrivate(Dataset self, int index) -> bool"},
-	 { "Dataset_GetLayerByIndex", _wrap_Dataset_GetLayerByIndex, METH_VARARGS, "Dataset_GetLayerByIndex(Dataset self, int index=0) -> Layer"},
-	 { "Dataset_GetLayerByName", _wrap_Dataset_GetLayerByName, METH_VARARGS, "Dataset_GetLayerByName(Dataset self, char const * layer_name) -> Layer"},
-	 { "Dataset_ResetReading", _wrap_Dataset_ResetReading, METH_O, "Dataset_ResetReading(Dataset self)"},
-	 { "Dataset_GetNextFeature", (PyCFunction)(void(*)(void))_wrap_Dataset_GetNextFeature, METH_VARARGS|METH_KEYWORDS, "Dataset_GetNextFeature(Dataset self, bool include_layer=True, bool include_pct=False, GDALProgressFunc callback=0, void * callback_data=None) -> Feature"},
-	 { "Dataset_TestCapability", _wrap_Dataset_TestCapability, METH_VARARGS, "Dataset_TestCapability(Dataset self, char const * cap) -> bool"},
+	 { "Dataset_IsLayerPrivate", _wrap_Dataset_IsLayerPrivate, METH_VARARGS, "\n"
+		"Dataset_IsLayerPrivate(Dataset self, int index) -> bool\n"
+		"\n"
+		"\n"
+		"Parameters\n"
+		"----------\n"
+		"index : int\n"
+		"        Index o layer to check\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"bool\n"
+		"     ``True`` if the layer is a private or system table, ``False`` otherwise\n"
+		"\n"
+		"\n"
+		"\n"
+		""},
+	 { "Dataset_GetNextFeature", (PyCFunction)(void(*)(void))_wrap_Dataset_GetNextFeature, METH_VARARGS|METH_KEYWORDS, "\n"
+		"Dataset_GetNextFeature(Dataset self, bool include_layer=True, bool include_pct=False, GDALProgressFunc callback=0, void * callback_data=None) -> Feature\n"
+		"\n"
+		"\n"
+		"Fetch the next available feature from this dataset.\n"
+		"\n"
+		"This method is intended for the few drivers where\n"
+		":py:meth:`OGRLayer.GetNextFeature` is not efficient, but in general\n"
+		":py:meth:`OGRLayer.GetNextFeature` is a more natural API.\n"
+		"\n"
+		"See :cpp:func:`GDALDataset::GetNextFeature`.\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"ogr.Feature\n"
+		"\n"
+		"\n"
+		""},
+	 { "Dataset_TestCapability", _wrap_Dataset_TestCapability, METH_VARARGS, "\n"
+		"Dataset_TestCapability(Dataset self, char const * cap) -> bool\n"
+		"\n"
+		"\n"
+		"Test if a capability is available.\n"
+		"\n"
+		"Parameters\n"
+		"----------\n"
+		"cap : str\n"
+		"   Name of the capability (e.g., :py:const:`ogr.ODsCTransactions`)\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"bool\n"
+		"    ``True`` if the capability is available, ``False`` if invalid or unavailable\n"
+		"\n"
+		"Examples\n"
+		"--------\n"
+		">>> ds = gdal.GetDriverByName('ESRI Shapefile').Create('test.shp', 0, 0, 0, gdal.GDT_Unknown)\n"
+		">>> ds.TestCapability(ogr.ODsCTransactions)\n"
+		"False\n"
+		">>> ds.TestCapability(ogr.ODsCMeasuredGeometries)\n"
+		"True\n"
+		">>> ds.TestCapability(gdal.GDsCAddRelationship)\n"
+		"False\n"
+		"\n"
+		"\n"
+		""},
 	 { "Dataset_ExecuteSQL", (PyCFunction)(void(*)(void))_wrap_Dataset_ExecuteSQL, METH_VARARGS|METH_KEYWORDS, "Dataset_ExecuteSQL(Dataset self, char const * statement, Geometry spatialFilter=None, char const * dialect=\"\") -> Layer"},
 	 { "Dataset_ReleaseResultSet", _wrap_Dataset_ReleaseResultSet, METH_VARARGS, "Dataset_ReleaseResultSet(Dataset self, Layer layer)"},
-	 { "Dataset_GetStyleTable", _wrap_Dataset_GetStyleTable, METH_O, "Dataset_GetStyleTable(Dataset self) -> StyleTable"},
-	 { "Dataset_SetStyleTable", _wrap_Dataset_SetStyleTable, METH_VARARGS, "Dataset_SetStyleTable(Dataset self, StyleTable table)"},
-	 { "Dataset_AbortSQL", _wrap_Dataset_AbortSQL, METH_O, "Dataset_AbortSQL(Dataset self) -> OGRErr"},
-	 { "Dataset_StartTransaction", (PyCFunction)(void(*)(void))_wrap_Dataset_StartTransaction, METH_VARARGS|METH_KEYWORDS, "Dataset_StartTransaction(Dataset self, int force=FALSE) -> OGRErr"},
-	 { "Dataset_CommitTransaction", _wrap_Dataset_CommitTransaction, METH_O, "Dataset_CommitTransaction(Dataset self) -> OGRErr"},
-	 { "Dataset_RollbackTransaction", _wrap_Dataset_RollbackTransaction, METH_O, "Dataset_RollbackTransaction(Dataset self) -> OGRErr"},
-	 { "Dataset_ClearStatistics", _wrap_Dataset_ClearStatistics, METH_O, "Dataset_ClearStatistics(Dataset self)"},
-	 { "Dataset_GetFieldDomainNames", _wrap_Dataset_GetFieldDomainNames, METH_VARARGS, "Dataset_GetFieldDomainNames(Dataset self, char ** options=None) -> char **"},
-	 { "Dataset_GetFieldDomain", _wrap_Dataset_GetFieldDomain, METH_VARARGS, "Dataset_GetFieldDomain(Dataset self, char const * name) -> FieldDomain"},
-	 { "Dataset_AddFieldDomain", _wrap_Dataset_AddFieldDomain, METH_VARARGS, "Dataset_AddFieldDomain(Dataset self, FieldDomain fieldDomain) -> bool"},
-	 { "Dataset_DeleteFieldDomain", _wrap_Dataset_DeleteFieldDomain, METH_VARARGS, "Dataset_DeleteFieldDomain(Dataset self, char const * name) -> bool"},
-	 { "Dataset_UpdateFieldDomain", _wrap_Dataset_UpdateFieldDomain, METH_VARARGS, "Dataset_UpdateFieldDomain(Dataset self, FieldDomain fieldDomain) -> bool"},
-	 { "Dataset_GetRelationshipNames", _wrap_Dataset_GetRelationshipNames, METH_VARARGS, "Dataset_GetRelationshipNames(Dataset self, char ** options=None) -> char **"},
-	 { "Dataset_GetRelationship", _wrap_Dataset_GetRelationship, METH_VARARGS, "Dataset_GetRelationship(Dataset self, char const * name) -> Relationship"},
-	 { "Dataset_AddRelationship", _wrap_Dataset_AddRelationship, METH_VARARGS, "Dataset_AddRelationship(Dataset self, Relationship relationship) -> bool"},
-	 { "Dataset_DeleteRelationship", _wrap_Dataset_DeleteRelationship, METH_VARARGS, "Dataset_DeleteRelationship(Dataset self, char const * name) -> bool"},
-	 { "Dataset_UpdateRelationship", _wrap_Dataset_UpdateRelationship, METH_VARARGS, "Dataset_UpdateRelationship(Dataset self, Relationship relationship) -> bool"},
+	 { "Dataset_GetStyleTable", _wrap_Dataset_GetStyleTable, METH_O, "\n"
+		"Dataset_GetStyleTable(Dataset self) -> StyleTable\n"
+		"\n"
+		"\n"
+		"Returns dataset style table.\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"ogr.StyleTable\n"
+		"\n"
+		"\n"
+		""},
+	 { "Dataset_SetStyleTable", _wrap_Dataset_SetStyleTable, METH_VARARGS, "\n"
+		"Dataset_SetStyleTable(Dataset self, StyleTable table)\n"
+		"\n"
+		"\n"
+		"Set dataset style table\n"
+		"\n"
+		"Parameters\n"
+		"----------\n"
+		"table : ogr.StyleTable\n"
+		"\n"
+		""},
+	 { "Dataset_GetLayerByIndex", _wrap_Dataset_GetLayerByIndex, METH_VARARGS, "\n"
+		"Dataset_GetLayerByIndex(Dataset self, int index=0) -> Layer\n"
+		"\n"
+		"\n"
+		"Fetch a layer by index.\n"
+		"\n"
+		"Parameters\n"
+		"----------\n"
+		"index : int\n"
+		"    A layer number between 0 and ``GetLayerCount() - 1``\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"ogr.Layer\n"
+		"\n"
+		"\n"
+		""},
+	 { "Dataset_GetLayerByName", _wrap_Dataset_GetLayerByName, METH_VARARGS, "Dataset_GetLayerByName(Dataset self, char const * layer_name) -> Layer"},
+	 { "Dataset_ResetReading", _wrap_Dataset_ResetReading, METH_O, "\n"
+		"Dataset_ResetReading(Dataset self)\n"
+		"\n"
+		"\n"
+		"Reset feature reading to start on the first feature.\n"
+		"\n"
+		"This affects :py:meth:`GetNextFeature`.\n"
+		"\n"
+		"Depending on drivers, this may also have the side effect of calling\n"
+		":py:meth:`OGRLayer.ResetReading` on the layers of this dataset.\n"
+		"\n"
+		"\n"
+		""},
+	 { "Dataset_GetLayerCount", _wrap_Dataset_GetLayerCount, METH_O, "\n"
+		"Dataset_GetLayerCount(Dataset self) -> int\n"
+		"\n"
+		"\n"
+		"Get the number of layers in this dataset.\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"int\n"
+		"\n"
+		"\n"
+		""},
+	 { "Dataset_AbortSQL", _wrap_Dataset_AbortSQL, METH_O, "\n"
+		"Dataset_AbortSQL(Dataset self) -> OGRErr\n"
+		"\n"
+		"\n"
+		"Abort any SQL statement running in the data store.\n"
+		"\n"
+		"Not implemented by all drivers. See :cpp:func:`GDALDataset::AbortSQL`.\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		":py:const:`ogr.OGRERR_NONE` on success or :py:const:`ogr.OGRERR_UNSUPPORTED_OPERATION` if AbortSQL is not supported for this dataset.\n"
+		"\n"
+		""},
+	 { "Dataset_StartTransaction", (PyCFunction)(void(*)(void))_wrap_Dataset_StartTransaction, METH_VARARGS|METH_KEYWORDS, "\n"
+		"Dataset_StartTransaction(Dataset self, int force=FALSE) -> OGRErr\n"
+		"\n"
+		"\n"
+		"Creates a transaction. See :cpp:func:`GDALDataset::StartTransaction`.\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"int\n"
+		"    If starting the transaction fails, will return\n"
+		"    :py:const:`ogr.OGRERR_FAILURE`. Datasources which do not support transactions will\n"
+		"    always return :py:const:`OGRERR_UNSUPPORTED_OPERATION`.\n"
+		"\n"
+		"\n"
+		""},
+	 { "Dataset_CommitTransaction", _wrap_Dataset_CommitTransaction, METH_O, "\n"
+		"Dataset_CommitTransaction(Dataset self) -> OGRErr\n"
+		"\n"
+		"Commits a transaction, for `Datasets` that support transactions.\n"
+		"\n"
+		"See :cpp:func:`GDALDataset::CommitTransaction`.\n"
+		"\n"
+		""},
+	 { "Dataset_RollbackTransaction", _wrap_Dataset_RollbackTransaction, METH_O, "\n"
+		"Dataset_RollbackTransaction(Dataset self) -> OGRErr\n"
+		"\n"
+		"\n"
+		"Roll back a Dataset to its state before the start of the current transaction.\n"
+		"\n"
+		"For datasets that support transactions.\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"int\n"
+		"    If no transaction is active, or the rollback fails, will return\n"
+		"    :py:const:`OGRERR_FAILURE`. Datasources which do not support transactions will\n"
+		"    always return :py:const:`OGRERR_UNSUPPORTED_OPERATION`.\n"
+		"\n"
+		"\n"
+		""},
+	 { "Dataset_ClearStatistics", _wrap_Dataset_ClearStatistics, METH_O, "\n"
+		"Dataset_ClearStatistics(Dataset self)\n"
+		"\n"
+		"\n"
+		"Clear statistics\n"
+		"\n"
+		"See :cpp:func:`GDALDatset::ClearStatistics`.\n"
+		"\n"
+		"\n"
+		""},
+	 { "Dataset_GetFieldDomainNames", _wrap_Dataset_GetFieldDomainNames, METH_VARARGS, "\n"
+		"Dataset_GetFieldDomainNames(Dataset self, char ** options=None) -> char **\n"
+		"\n"
+		"\n"
+		"Get a list of the names of all field domains stored in the dataset.\n"
+		"\n"
+		"Parameters\n"
+		"----------\n"
+		"options: dict/list, optional\n"
+		"         Driver-specific options determining how attributes should\n"
+		"         be retrieved.\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"list, or ``None`` if no field domains are stored in the dataset.\n"
+		"\n"
+		""},
+	 { "Dataset_GetFieldDomain", _wrap_Dataset_GetFieldDomain, METH_VARARGS, "\n"
+		"Dataset_GetFieldDomain(Dataset self, char const * name) -> FieldDomain\n"
+		"\n"
+		"\n"
+		"Get a field domain from its name.\n"
+		"\n"
+		"Parameters\n"
+		"----------\n"
+		"name: str\n"
+		"      The name of the field domain\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"ogr.FieldDomain, or ``None`` if it is not found.\n"
+		"\n"
+		""},
+	 { "Dataset_AddFieldDomain", _wrap_Dataset_AddFieldDomain, METH_VARARGS, "\n"
+		"Dataset_AddFieldDomain(Dataset self, FieldDomain fieldDomain) -> bool\n"
+		"\n"
+		"\n"
+		"Add a :py:class:`ogr.FieldDomain` to the dataset.\n"
+		"\n"
+		"Only a few drivers support this operation. See :cpp:func:`GDALDataset::AddFieldDomain`.\n"
+		"\n"
+		"Parameters\n"
+		"----------\n"
+		"fieldDomain : ogr.FieldDomain\n"
+		"              The field domain to add\n"
+		"\n"
+		"Returns\n"
+		"--------\n"
+		"bool:\n"
+		"    ``True`` if the field domain was added, ``False`` in case of error.\n"
+		"\n"
+		"\n"
+		"\n"
+		""},
+	 { "Dataset_DeleteFieldDomain", _wrap_Dataset_DeleteFieldDomain, METH_VARARGS, "\n"
+		"Dataset_DeleteFieldDomain(Dataset self, char const * name) -> bool\n"
+		"\n"
+		"\n"
+		"Removes a field domain from the Dataset.\n"
+		"\n"
+		"Parameters\n"
+		"----------\n"
+		"name : str\n"
+		"       Name of the field domain to delete\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"bool\n"
+		"     ``True`` if the field domain was removed, otherwise ``False``.\n"
+		"\n"
+		"\n"
+		""},
+	 { "Dataset_UpdateFieldDomain", _wrap_Dataset_UpdateFieldDomain, METH_VARARGS, "\n"
+		"Dataset_UpdateFieldDomain(Dataset self, FieldDomain fieldDomain) -> bool\n"
+		"\n"
+		"\n"
+		"Update an existing field domain by replacing its definition.\n"
+		"\n"
+		"The existing field domain with matching name will be replaced.\n"
+		"\n"
+		"Requires the :py:const:`ogr.ODsCUpdateFieldDomain` datasset capability.\n"
+		"\n"
+		"Parameters\n"
+		"----------\n"
+		"fieldDomain : ogr.FieldDomain\n"
+		"    Updated field domain.\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"bool\n"
+		"    ``True`` in case of success\n"
+		"\n"
+		"\n"
+		""},
+	 { "Dataset_GetRelationshipNames", _wrap_Dataset_GetRelationshipNames, METH_VARARGS, "\n"
+		"Dataset_GetRelationshipNames(Dataset self, char ** options=None) -> char **\n"
+		"\n"
+		"\n"
+		"Get a list of the names of all relationships stored in the dataset.\n"
+		"\n"
+		"Parameters\n"
+		"----------\n"
+		"options : dict/list, optional\n"
+		"    driver-specific options determining how the relationships should be retrieved\n"
+		"\n"
+		"\n"
+		""},
+	 { "Dataset_GetRelationship", _wrap_Dataset_GetRelationship, METH_VARARGS, "\n"
+		"Dataset_GetRelationship(Dataset self, char const * name) -> Relationship\n"
+		"\n"
+		"\n"
+		"Get a relationship from its name.\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"Relationship, or ``None`` if not found.\n"
+		"\n"
+		""},
+	 { "Dataset_AddRelationship", _wrap_Dataset_AddRelationship, METH_VARARGS, "\n"
+		"Dataset_AddRelationship(Dataset self, Relationship relationship) -> bool\n"
+		"\n"
+		"\n"
+		"Add a :py:class:`Relationship` to the dataset.\n"
+		"\n"
+		"See :cpp:func:`GDALDataset::AddRelationship`.\n"
+		"\n"
+		"Parameters\n"
+		"----------\n"
+		"relationship : Relationship\n"
+		"               The relationship to add\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"bool:\n"
+		"    ``True`` if the field domain was added, ``False`` in case of error.\n"
+		"\n"
+		"\n"
+		""},
+	 { "Dataset_DeleteRelationship", _wrap_Dataset_DeleteRelationship, METH_VARARGS, "\n"
+		"Dataset_DeleteRelationship(Dataset self, char const * name) -> bool\n"
+		"\n"
+		"\n"
+		"Removes a relationship from the Dataset.\n"
+		"\n"
+		"Parameters\n"
+		"----------\n"
+		"name : str\n"
+		"       Name of the relationship to remove.\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"bool\n"
+		"     ``True`` if the relationship  was removed, otherwise ``False``.\n"
+		"\n"
+		"\n"
+		"\n"
+		""},
+	 { "Dataset_UpdateRelationship", _wrap_Dataset_UpdateRelationship, METH_VARARGS, "\n"
+		"Dataset_UpdateRelationship(Dataset self, Relationship relationship) -> bool\n"
+		"\n"
+		"\n"
+		"Update an existing relationship by replacing its definition.\n"
+		"\n"
+		"The existing relationship with matching name will be replaced.\n"
+		"\n"
+		"Requires the :py:const:`gdal.GDsCUpdateFieldDomain` dataset capability.\n"
+		"\n"
+		"Parameters\n"
+		"----------\n"
+		"relationship : Relationship\n"
+		"    Updated relationship\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"bool\n"
+		"    ``True`` in case of success\n"
+		"\n"
+		"\n"
+		""},
 	 { "Dataset_ReadRaster1", (PyCFunction)(void(*)(void))_wrap_Dataset_ReadRaster1, METH_VARARGS|METH_KEYWORDS, "Dataset_ReadRaster1(Dataset self, double xoff, double yoff, double xsize, double ysize, int * buf_xsize=None, int * buf_ysize=None, GDALDataType * buf_type=None, int band_list=0, GIntBig * buf_pixel_space=None, GIntBig * buf_line_space=None, GIntBig * buf_band_space=None, GDALRIOResampleAlg resample_alg=GRIORA_NearestNeighbour, GDALProgressFunc callback=0, void * callback_data=None, void * inputOutputBuf=None) -> CPLErr"},
 	 { "Dataset_swigregister", Dataset_swigregister, METH_O, NULL},
+	 { "new_RasterAttributeTable", _wrap_new_RasterAttributeTable, METH_NOARGS, "new_RasterAttributeTable() -> RasterAttributeTable"},
+	 { "delete_RasterAttributeTable", _wrap_delete_RasterAttributeTable, METH_O, "delete_RasterAttributeTable(RasterAttributeTable self)"},
+	 { "RasterAttributeTable_Clone", _wrap_RasterAttributeTable_Clone, METH_O, "RasterAttributeTable_Clone(RasterAttributeTable self) -> RasterAttributeTable"},
+	 { "RasterAttributeTable_GetColumnCount", _wrap_RasterAttributeTable_GetColumnCount, METH_O, "RasterAttributeTable_GetColumnCount(RasterAttributeTable self) -> int"},
+	 { "RasterAttributeTable_GetNameOfCol", _wrap_RasterAttributeTable_GetNameOfCol, METH_VARARGS, "RasterAttributeTable_GetNameOfCol(RasterAttributeTable self, int iCol) -> char const *"},
+	 { "RasterAttributeTable_GetUsageOfCol", _wrap_RasterAttributeTable_GetUsageOfCol, METH_VARARGS, "RasterAttributeTable_GetUsageOfCol(RasterAttributeTable self, int iCol) -> GDALRATFieldUsage"},
+	 { "RasterAttributeTable_GetTypeOfCol", _wrap_RasterAttributeTable_GetTypeOfCol, METH_VARARGS, "RasterAttributeTable_GetTypeOfCol(RasterAttributeTable self, int iCol) -> GDALRATFieldType"},
+	 { "RasterAttributeTable_GetColOfUsage", _wrap_RasterAttributeTable_GetColOfUsage, METH_VARARGS, "RasterAttributeTable_GetColOfUsage(RasterAttributeTable self, GDALRATFieldUsage eUsage) -> int"},
+	 { "RasterAttributeTable_GetRowCount", _wrap_RasterAttributeTable_GetRowCount, METH_O, "RasterAttributeTable_GetRowCount(RasterAttributeTable self) -> int"},
+	 { "RasterAttributeTable_GetValueAsString", _wrap_RasterAttributeTable_GetValueAsString, METH_VARARGS, "RasterAttributeTable_GetValueAsString(RasterAttributeTable self, int iRow, int iCol) -> char const *"},
+	 { "RasterAttributeTable_GetValueAsInt", _wrap_RasterAttributeTable_GetValueAsInt, METH_VARARGS, "RasterAttributeTable_GetValueAsInt(RasterAttributeTable self, int iRow, int iCol) -> int"},
+	 { "RasterAttributeTable_GetValueAsDouble", _wrap_RasterAttributeTable_GetValueAsDouble, METH_VARARGS, "RasterAttributeTable_GetValueAsDouble(RasterAttributeTable self, int iRow, int iCol) -> double"},
+	 { "RasterAttributeTable_ReadValuesIOAsString", _wrap_RasterAttributeTable_ReadValuesIOAsString, METH_VARARGS, "RasterAttributeTable_ReadValuesIOAsString(RasterAttributeTable self, int iField, int iStartRow, int iLength) -> CPLErr"},
+	 { "RasterAttributeTable_ReadValuesIOAsInteger", _wrap_RasterAttributeTable_ReadValuesIOAsInteger, METH_VARARGS, "RasterAttributeTable_ReadValuesIOAsInteger(RasterAttributeTable self, int iField, int iStartRow, int iLength) -> CPLErr"},
+	 { "RasterAttributeTable_ReadValuesIOAsDouble", _wrap_RasterAttributeTable_ReadValuesIOAsDouble, METH_VARARGS, "RasterAttributeTable_ReadValuesIOAsDouble(RasterAttributeTable self, int iField, int iStartRow, int iLength) -> CPLErr"},
+	 { "RasterAttributeTable_SetValueAsString", _wrap_RasterAttributeTable_SetValueAsString, METH_VARARGS, "RasterAttributeTable_SetValueAsString(RasterAttributeTable self, int iRow, int iCol, char const * pszValue)"},
+	 { "RasterAttributeTable_SetValueAsInt", _wrap_RasterAttributeTable_SetValueAsInt, METH_VARARGS, "RasterAttributeTable_SetValueAsInt(RasterAttributeTable self, int iRow, int iCol, int nValue)"},
+	 { "RasterAttributeTable_SetValueAsDouble", _wrap_RasterAttributeTable_SetValueAsDouble, METH_VARARGS, "RasterAttributeTable_SetValueAsDouble(RasterAttributeTable self, int iRow, int iCol, double dfValue)"},
+	 { "RasterAttributeTable_SetRowCount", _wrap_RasterAttributeTable_SetRowCount, METH_VARARGS, "RasterAttributeTable_SetRowCount(RasterAttributeTable self, int nCount)"},
+	 { "RasterAttributeTable_CreateColumn", _wrap_RasterAttributeTable_CreateColumn, METH_VARARGS, "RasterAttributeTable_CreateColumn(RasterAttributeTable self, char const * pszName, GDALRATFieldType eType, GDALRATFieldUsage eUsage) -> int"},
+	 { "RasterAttributeTable_GetLinearBinning", _wrap_RasterAttributeTable_GetLinearBinning, METH_O, "RasterAttributeTable_GetLinearBinning(RasterAttributeTable self) -> bool"},
+	 { "RasterAttributeTable_SetLinearBinning", _wrap_RasterAttributeTable_SetLinearBinning, METH_VARARGS, "RasterAttributeTable_SetLinearBinning(RasterAttributeTable self, double dfRow0Min, double dfBinSize) -> int"},
+	 { "RasterAttributeTable_GetRowOfValue", _wrap_RasterAttributeTable_GetRowOfValue, METH_VARARGS, "RasterAttributeTable_GetRowOfValue(RasterAttributeTable self, double dfValue) -> int"},
+	 { "RasterAttributeTable_ChangesAreWrittenToFile", _wrap_RasterAttributeTable_ChangesAreWrittenToFile, METH_O, "RasterAttributeTable_ChangesAreWrittenToFile(RasterAttributeTable self) -> int"},
+	 { "RasterAttributeTable_DumpReadable", _wrap_RasterAttributeTable_DumpReadable, METH_O, "RasterAttributeTable_DumpReadable(RasterAttributeTable self)"},
+	 { "RasterAttributeTable_SetTableType", _wrap_RasterAttributeTable_SetTableType, METH_VARARGS, "RasterAttributeTable_SetTableType(RasterAttributeTable self, GDALRATTableType eTableType)"},
+	 { "RasterAttributeTable_GetTableType", _wrap_RasterAttributeTable_GetTableType, METH_O, "RasterAttributeTable_GetTableType(RasterAttributeTable self) -> GDALRATTableType"},
+	 { "RasterAttributeTable_RemoveStatistics", _wrap_RasterAttributeTable_RemoveStatistics, METH_O, "RasterAttributeTable_RemoveStatistics(RasterAttributeTable self)"},
+	 { "RasterAttributeTable_swigregister", RasterAttributeTable_swigregister, METH_O, NULL},
+	 { "RasterAttributeTable_swiginit", RasterAttributeTable_swiginit, METH_VARARGS, NULL},
 	 { "delete_Group", _wrap_delete_Group, METH_O, "delete_Group(Group self)"},
 	 { "Group_GetName", _wrap_Group_GetName, METH_O, "Group_GetName(Group self) -> char const *"},
 	 { "Group_GetFullName", _wrap_Group_GetFullName, METH_O, "Group_GetFullName(Group self) -> char const *"},
 	 { "Group_GetMDArrayNames", _wrap_Group_GetMDArrayNames, METH_VARARGS, "Group_GetMDArrayNames(Group self, char ** options=None) -> char **"},
 	 { "Group_OpenMDArray", _wrap_Group_OpenMDArray, METH_VARARGS, "Group_OpenMDArray(Group self, char const * name, char ** options=None) -> MDArray"},
 	 { "Group_OpenMDArrayFromFullname", _wrap_Group_OpenMDArrayFromFullname, METH_VARARGS, "Group_OpenMDArrayFromFullname(Group self, char const * name, char ** options=None) -> MDArray"},
 	 { "Group_ResolveMDArray", _wrap_Group_ResolveMDArray, METH_VARARGS, "Group_ResolveMDArray(Group self, char const * name, char const * starting_point, char ** options=None) -> MDArray"},
@@ -53582,73 +55832,814 @@
 	 { "ExtendedDataType_swigregister", ExtendedDataType_swigregister, METH_O, NULL},
 	 { "delete_EDTComponent", _wrap_delete_EDTComponent, METH_O, "delete_EDTComponent(EDTComponent self)"},
 	 { "EDTComponent_Create", _wrap_EDTComponent_Create, METH_VARARGS, "EDTComponent_Create(char const * name, size_t offset, ExtendedDataType type) -> EDTComponent"},
 	 { "EDTComponent_GetName", _wrap_EDTComponent_GetName, METH_O, "EDTComponent_GetName(EDTComponent self) -> char const *"},
 	 { "EDTComponent_GetOffset", _wrap_EDTComponent_GetOffset, METH_O, "EDTComponent_GetOffset(EDTComponent self) -> size_t"},
 	 { "EDTComponent_GetType", _wrap_EDTComponent_GetType, METH_O, "EDTComponent_GetType(EDTComponent self) -> ExtendedDataType"},
 	 { "EDTComponent_swigregister", EDTComponent_swigregister, METH_O, NULL},
+	 { "CreateRasterAttributeTableFromMDArrays", _wrap_CreateRasterAttributeTableFromMDArrays, METH_VARARGS, "CreateRasterAttributeTableFromMDArrays(GDALRATTableType eTableType, int nArrays, int nUsages=0) -> RasterAttributeTable"},
 	 { "Band_XSize_get", _wrap_Band_XSize_get, METH_O, "Band_XSize_get(Band self) -> int"},
 	 { "Band_YSize_get", _wrap_Band_YSize_get, METH_O, "Band_YSize_get(Band self) -> int"},
 	 { "Band_DataType_get", _wrap_Band_DataType_get, METH_O, "Band_DataType_get(Band self) -> GDALDataType"},
-	 { "Band_GetDataset", _wrap_Band_GetDataset, METH_O, "Band_GetDataset(Band self) -> Dataset"},
-	 { "Band_GetBand", _wrap_Band_GetBand, METH_O, "Band_GetBand(Band self) -> int"},
-	 { "Band_GetBlockSize", _wrap_Band_GetBlockSize, METH_O, "Band_GetBlockSize(Band self)"},
-	 { "Band_GetActualBlockSize", _wrap_Band_GetActualBlockSize, METH_VARARGS, "Band_GetActualBlockSize(Band self, int nXBlockOff, int nYBlockOff)"},
-	 { "Band_GetColorInterpretation", _wrap_Band_GetColorInterpretation, METH_O, "Band_GetColorInterpretation(Band self) -> GDALColorInterp"},
-	 { "Band_GetRasterColorInterpretation", _wrap_Band_GetRasterColorInterpretation, METH_O, "Band_GetRasterColorInterpretation(Band self) -> GDALColorInterp"},
-	 { "Band_SetColorInterpretation", _wrap_Band_SetColorInterpretation, METH_VARARGS, "Band_SetColorInterpretation(Band self, GDALColorInterp val) -> CPLErr"},
-	 { "Band_SetRasterColorInterpretation", _wrap_Band_SetRasterColorInterpretation, METH_VARARGS, "Band_SetRasterColorInterpretation(Band self, GDALColorInterp val) -> CPLErr"},
+	 { "Band_GetDataset", _wrap_Band_GetDataset, METH_O, "\n"
+		"Band_GetDataset(Band self) -> Dataset\n"
+		"\n"
+		"\n"
+		"Fetch the :py:class:`Dataset` associated with this Band.\n"
+		"See :cpp:func:`GDALRasterBand::GetDataset`.\n"
+		"\n"
+		""},
+	 { "Band_GetBand", _wrap_Band_GetBand, METH_O, "\n"
+		"Band_GetBand(Band self) -> int\n"
+		"\n"
+		"\n"
+		"Return the index of this band.\n"
+		"See :cpp:func:`GDALRasterBand::GetBand`.\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"int\n"
+		"    the (1-based) index of this band\n"
+		"\n"
+		""},
+	 { "Band_GetBlockSize", _wrap_Band_GetBlockSize, METH_O, "\n"
+		"Band_GetBlockSize(Band self)\n"
+		"\n"
+		"\n"
+		"Fetch the natural block size of this band.\n"
+		"See :cpp:func:`GDALRasterBand::GetBlockSize`.\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"list\n"
+		"    list with the x and y dimensions of a block\n"
+		"\n"
+		""},
+	 { "Band_GetActualBlockSize", _wrap_Band_GetActualBlockSize, METH_VARARGS, "\n"
+		"Band_GetActualBlockSize(Band self, int nXBlockOff, int nYBlockOff)\n"
+		"\n"
+		"\n"
+		"Fetch the actual block size for a given block offset.\n"
+		"See :cpp:func:`GDALRasterBand::GetActualBlockSize`.\n"
+		"\n"
+		"Parameters\n"
+		"----------\n"
+		"nXBlockOff : int\n"
+		"    the horizontal block offset for which to calculate the\n"
+		"    number of valid pixels, with zero indicating the left most block, 1 the next\n"
+		"    block and so forth.\n"
+		"nYBlockOff : int\n"
+		"    the vertical block offset, with zero indicating\n"
+		"    the top most block, 1 the next block and so forth.\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"tuple\n"
+		"    tuple with the x and y dimensions of the block\n"
+		"\n"
+		""},
+	 { "Band_GetColorInterpretation", _wrap_Band_GetColorInterpretation, METH_O, "\n"
+		"Band_GetColorInterpretation(Band self) -> GDALColorInterp\n"
+		"\n"
+		"\n"
+		"Get the :cpp:enum:`GDALColorInterp` value for this band.\n"
+		"See :cpp:func:`GDALRasterBand::GetColorInterpretation`.\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"int\n"
+		"\n"
+		""},
+	 { "Band_GetRasterColorInterpretation", _wrap_Band_GetRasterColorInterpretation, METH_O, "\n"
+		"Band_GetRasterColorInterpretation(Band self) -> GDALColorInterp\n"
+		"\n"
+		"\n"
+		"Return the color interpretation code for this band.\n"
+		"See :cpp:func:`GDALRasterBand::GetColorInterpretation`.\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"int\n"
+		"    The color interpretation code (default :py:const:`gdal.GCI_Undefined`)\n"
+		"\n"
+		"\n"
+		""},
+	 { "Band_SetColorInterpretation", _wrap_Band_SetColorInterpretation, METH_VARARGS, "\n"
+		"Band_SetColorInterpretation(Band self, GDALColorInterp val) -> CPLErr\n"
+		"\n"
+		"\n"
+		"Set color interpretation of the band\n"
+		"See :cpp:func:`GDALRasterBand::SetColorInterpretation`.\n"
+		"\n"
+		"Parameters\n"
+		"----------\n"
+		"val : int\n"
+		"    A color interpretation code such as :py:const:`gdal.GCI_RedBand`\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"int:\n"
+		"   :py:const:`CE_None` on success or :py:const:`CE_Failure` on failure.\n"
+		"\n"
+		""},
+	 { "Band_SetRasterColorInterpretation", _wrap_Band_SetRasterColorInterpretation, METH_VARARGS, "\n"
+		"Band_SetRasterColorInterpretation(Band self, GDALColorInterp val) -> CPLErr\n"
+		"\n"
+		"Deprecated.  Alternate name for :py:meth:`SetColorInterpretation`.\n"
+		"\n"
+		""},
 	 { "Band_GetNoDataValue", _wrap_Band_GetNoDataValue, METH_O, "Band_GetNoDataValue(Band self)"},
-	 { "Band_GetNoDataValueAsInt64", _wrap_Band_GetNoDataValueAsInt64, METH_O, "Band_GetNoDataValueAsInt64(Band self)"},
-	 { "Band_GetNoDataValueAsUInt64", _wrap_Band_GetNoDataValueAsUInt64, METH_O, "Band_GetNoDataValueAsUInt64(Band self)"},
+	 { "Band_GetNoDataValueAsInt64", _wrap_Band_GetNoDataValueAsInt64, METH_O, "\n"
+		"Band_GetNoDataValueAsInt64(Band self)\n"
+		"\n"
+		"\n"
+		"Fetch the nodata value for this band.\n"
+		"See :cpp:func:`GDALRasterBand::GetNoDataValueAsInt64`.\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"int\n"
+		"    The nodata value, or ``None`` if it has not been set or\n"
+		"    the data type of this band is not :py:const:`gdal.GDT_Int64`.\n"
+		"\n"
+		"\n"
+		""},
+	 { "Band_GetNoDataValueAsUInt64", _wrap_Band_GetNoDataValueAsUInt64, METH_O, "\n"
+		"Band_GetNoDataValueAsUInt64(Band self)\n"
+		"\n"
+		"\n"
+		"Fetch the nodata value for this band.\n"
+		"See :cpp:func:`GDALRasterBand::GetNoDataValueAsUInt64`.\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"int\n"
+		"    The nodata value, or ``None`` if it has not been set or\n"
+		"    the data type of this band is not :py:const:`gdal.GDT_UInt64`.\n"
+		"\n"
+		"\n"
+		""},
 	 { "Band_SetNoDataValue", _wrap_Band_SetNoDataValue, METH_VARARGS, "Band_SetNoDataValue(Band self, double d) -> CPLErr"},
 	 { "Band_SetNoDataValueAsInt64", _wrap_Band_SetNoDataValueAsInt64, METH_VARARGS, "Band_SetNoDataValueAsInt64(Band self, GIntBig v) -> CPLErr"},
 	 { "Band_SetNoDataValueAsUInt64", _wrap_Band_SetNoDataValueAsUInt64, METH_VARARGS, "Band_SetNoDataValueAsUInt64(Band self, GUIntBig v) -> CPLErr"},
-	 { "Band_DeleteNoDataValue", _wrap_Band_DeleteNoDataValue, METH_O, "Band_DeleteNoDataValue(Band self) -> CPLErr"},
-	 { "Band_GetUnitType", _wrap_Band_GetUnitType, METH_O, "Band_GetUnitType(Band self) -> char const *"},
-	 { "Band_SetUnitType", _wrap_Band_SetUnitType, METH_VARARGS, "Band_SetUnitType(Band self, char const * val) -> CPLErr"},
-	 { "Band_GetRasterCategoryNames", _wrap_Band_GetRasterCategoryNames, METH_O, "Band_GetRasterCategoryNames(Band self) -> char **"},
-	 { "Band_SetRasterCategoryNames", _wrap_Band_SetRasterCategoryNames, METH_VARARGS, "Band_SetRasterCategoryNames(Band self, char ** names) -> CPLErr"},
-	 { "Band_GetMinimum", _wrap_Band_GetMinimum, METH_O, "Band_GetMinimum(Band self)"},
-	 { "Band_GetMaximum", _wrap_Band_GetMaximum, METH_O, "Band_GetMaximum(Band self)"},
-	 { "Band_GetOffset", _wrap_Band_GetOffset, METH_O, "Band_GetOffset(Band self)"},
-	 { "Band_GetScale", _wrap_Band_GetScale, METH_O, "Band_GetScale(Band self)"},
-	 { "Band_SetOffset", _wrap_Band_SetOffset, METH_VARARGS, "Band_SetOffset(Band self, double val) -> CPLErr"},
-	 { "Band_SetScale", _wrap_Band_SetScale, METH_VARARGS, "Band_SetScale(Band self, double val) -> CPLErr"},
-	 { "Band_GetStatistics", _wrap_Band_GetStatistics, METH_VARARGS, "Band_GetStatistics(Band self, int approx_ok, int force) -> CPLErr"},
+	 { "Band_DeleteNoDataValue", _wrap_Band_DeleteNoDataValue, METH_O, "\n"
+		"Band_DeleteNoDataValue(Band self) -> CPLErr\n"
+		"\n"
+		"\n"
+		"Remove the nodata value for this band.\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"int:\n"
+		"   :py:const:`CE_None` on success or :py:const:`CE_Failure` on failure.\n"
+		"\n"
+		"\n"
+		""},
+	 { "Band_GetUnitType", _wrap_Band_GetUnitType, METH_O, "\n"
+		"Band_GetUnitType(Band self) -> char const *\n"
+		"\n"
+		"\n"
+		"Return a name for the units of this raster's values.\n"
+		"See :cpp:func:`GDALRasterBand::GetUnitType`.\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"str\n"
+		"\n"
+		"Examples\n"
+		"--------\n"
+		">>> ds = gdal.GetDriverByName('MEM').Create('', 10, 10)\n"
+		">>> ds.GetRasterBand(1).SetUnitType('ft')\n"
+		"0\n"
+		">>> ds.GetRasterBand(1).GetUnitType()\n"
+		"'ft'\n"
+		"\n"
+		""},
+	 { "Band_SetUnitType", _wrap_Band_SetUnitType, METH_VARARGS, "\n"
+		"Band_SetUnitType(Band self, char const * val) -> CPLErr\n"
+		"\n"
+		"\n"
+		"Set unit type.\n"
+		"See :cpp:func:`GDALRasterBand::SetUnitType`.\n"
+		"\n"
+		"Parameters\n"
+		"----------\n"
+		"val : str\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"int:\n"
+		"   :py:const:`CE_None` on success or :py:const:`CE_Failure` on failure.\n"
+		"\n"
+		""},
+	 { "Band_GetRasterCategoryNames", _wrap_Band_GetRasterCategoryNames, METH_O, "\n"
+		"Band_GetRasterCategoryNames(Band self) -> char **\n"
+		"\n"
+		"\n"
+		"Fetch the list of category names for this band.\n"
+		"See :cpp:func:`GDALRasterBand::GetCategoryNames`.\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"list\n"
+		"    The list of names, or ``None`` if no names exist.\n"
+		"\n"
+		"\n"
+		""},
+	 { "Band_SetRasterCategoryNames", _wrap_Band_SetRasterCategoryNames, METH_VARARGS, "\n"
+		"Band_SetRasterCategoryNames(Band self, char ** names) -> CPLErr\n"
+		"\n"
+		"Deprecated.  Alternate name for :py:meth:`SetCategoryNames`.\n"
+		"\n"
+		""},
+	 { "Band_GetMinimum", _wrap_Band_GetMinimum, METH_O, "\n"
+		"Band_GetMinimum(Band self)\n"
+		"\n"
+		"\n"
+		"Fetch a previously stored maximum value for this band.\n"
+		"See :cpp:func:`GDALRasterBand::GetMinimum`.\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"float\n"
+		"    The stored minimum value, or ``None`` if no value\n"
+		"    has been stored.\n"
+		"\n"
+		"\n"
+		""},
+	 { "Band_GetMaximum", _wrap_Band_GetMaximum, METH_O, "\n"
+		"Band_GetMaximum(Band self)\n"
+		"\n"
+		"\n"
+		"Fetch a previously stored maximum value for this band.\n"
+		"See :cpp:func:`GDALRasterBand::GetMaximum`.\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"float\n"
+		"    The stored maximum value, or ``None`` if no value\n"
+		"    has been stored.\n"
+		"\n"
+		"\n"
+		""},
+	 { "Band_GetOffset", _wrap_Band_GetOffset, METH_O, "\n"
+		"Band_GetOffset(Band self)\n"
+		"\n"
+		"\n"
+		"Fetch the raster value offset.\n"
+		"See :cpp:func:`GDALRasterBand::GetOffset`.\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"double\n"
+		"    The offset value, or ``0.0``.\n"
+		"\n"
+		"\n"
+		""},
+	 { "Band_GetScale", _wrap_Band_GetScale, METH_O, "\n"
+		"Band_GetScale(Band self)\n"
+		"\n"
+		"\n"
+		"Fetch the band scale value.\n"
+		"See :cpp:func:`GDALRasterBand::GetScale`.\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"double\n"
+		"    The scale value, or ``1.0``.\n"
+		"\n"
+		""},
+	 { "Band_SetOffset", _wrap_Band_SetOffset, METH_VARARGS, "\n"
+		"Band_SetOffset(Band self, double val) -> CPLErr\n"
+		"\n"
+		"\n"
+		"Set scaling offset.\n"
+		"See :cpp:func:`GDALRasterBand::SetOffset`.\n"
+		"\n"
+		"Parameters\n"
+		"----------\n"
+		"val : float\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"int:\n"
+		"   :py:const:`CE_None` on success or :py:const:`CE_Failure` on failure.\n"
+		"\n"
+		"See Also\n"
+		"--------\n"
+		":py:meth:`SetScale`\n"
+		"\n"
+		""},
+	 { "Band_SetScale", _wrap_Band_SetScale, METH_VARARGS, "\n"
+		"Band_SetScale(Band self, double val) -> CPLErr\n"
+		"\n"
+		"Set scaling ratio.\n"
+		"See :cpp:func:`GDALRasterBand::SetScale`.\n"
+		"\n"
+		"Parameters\n"
+		"----------\n"
+		"val : float\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"int:\n"
+		"   :py:const:`CE_None` on success or :py:const:`CE_Failure` on failure.\n"
+		"\n"
+		"See Also\n"
+		"--------\n"
+		":py:meth:`SetOffset`\n"
+		"\n"
+		""},
+	 { "Band_GetStatistics", _wrap_Band_GetStatistics, METH_VARARGS, "\n"
+		"Band_GetStatistics(Band self, int approx_ok, int force) -> CPLErr\n"
+		"\n"
+		"\n"
+		"Return the minimum, maximum, mean, and standard deviation of all pixel values\n"
+		"in this band.\n"
+		"See :cpp:func:`GDALRasterBand::GetStatistics`\n"
+		"\n"
+		"Parameters\n"
+		"----------\n"
+		"approx_ok : bool\n"
+		"    If ``True``, allow overviews or a subset of image tiles to be used in\n"
+		"    computing the statistics.\n"
+		"force : bool\n"
+		"    If ``False``, only return a result if it can be obtained without scanning\n"
+		"    the image, i.e. from pre-existing metadata.\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"list\n"
+		"   a list with the min, max, mean, and standard deviation of values\n"
+		"   in the Band.\n"
+		"\n"
+		"See Also\n"
+		"--------\n"
+		":py:meth:`ComputeBandStats`\n"
+		":py:meth:`ComputeRasterMinMax`\n"
+		":py:meth:`GetMaximum`\n"
+		":py:meth:`GetMinimum`\n"
+		":py:meth:`GetStatistics`\n"
+		"\n"
+		""},
 	 { "Band_ComputeStatistics", (PyCFunction)(void(*)(void))_wrap_Band_ComputeStatistics, METH_VARARGS|METH_KEYWORDS, "Band_ComputeStatistics(Band self, bool approx_ok, GDALProgressFunc callback=0, void * callback_data=None) -> CPLErr"},
-	 { "Band_SetStatistics", _wrap_Band_SetStatistics, METH_VARARGS, "Band_SetStatistics(Band self, double min, double max, double mean, double stddev) -> CPLErr"},
-	 { "Band_GetOverviewCount", _wrap_Band_GetOverviewCount, METH_O, "Band_GetOverviewCount(Band self) -> int"},
-	 { "Band_GetOverview", _wrap_Band_GetOverview, METH_VARARGS, "Band_GetOverview(Band self, int i) -> Band"},
-	 { "Band_Checksum", (PyCFunction)(void(*)(void))_wrap_Band_Checksum, METH_VARARGS|METH_KEYWORDS, "Band_Checksum(Band self, int xoff=0, int yoff=0, int * xsize=None, int * ysize=None) -> int"},
+	 { "Band_SetStatistics", _wrap_Band_SetStatistics, METH_VARARGS, "\n"
+		"Band_SetStatistics(Band self, double min, double max, double mean, double stddev) -> CPLErr\n"
+		"\n"
+		"\n"
+		"Set statistics on band.\n"
+		"See :cpp:func:`GDALRasterBand::SetStatistics`.\n"
+		"\n"
+		"Parameters\n"
+		"----------\n"
+		"min : float\n"
+		"max : float\n"
+		"mean : float\n"
+		"stdev : float\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"int:\n"
+		"   :py:const:`CE_None` on apparent success or :py:const:`CE_Failure` on\n"
+		"   failure.  This method cannot detect whether metadata will be properly saved and\n"
+		"   so may return :py:const:`gdal.`CE_None` even if the statistics will never be\n"
+		"   saved.\n"
+		"\n"
+		"See Also\n"
+		"--------\n"
+		":py:meth:`ComputeBandStats`\n"
+		":py:meth:`ComputeRasterMinMax`\n"
+		":py:meth:`ComputeStatistics`\n"
+		":py:meth:`GetMaximum`\n"
+		":py:meth:`GetMinimum`\n"
+		":py:meth:`GetStatistics`\n"
+		"\n"
+		""},
+	 { "Band_GetOverviewCount", _wrap_Band_GetOverviewCount, METH_O, "\n"
+		"Band_GetOverviewCount(Band self) -> int\n"
+		"\n"
+		"\n"
+		"Return the number of overview layers available.\n"
+		"See :cpp:func:`GDALRasterBand::GetOverviewCount`.\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"int\n"
+		"\n"
+		"\n"
+		""},
+	 { "Band_GetOverview", _wrap_Band_GetOverview, METH_VARARGS, "\n"
+		"Band_GetOverview(Band self, int i) -> Band\n"
+		"\n"
+		"\n"
+		"Fetch a raster overview.\n"
+		"See :cpp:func:`GDALRasterBand::GetOverview`.\n"
+		"\n"
+		"Parameters\n"
+		"----------\n"
+		"i : int\n"
+		"    Overview index between 0 and ``GetOverviewCount() - 1``.\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"Band\n"
+		"\n"
+		"\n"
+		""},
+	 { "Band_Checksum", (PyCFunction)(void(*)(void))_wrap_Band_Checksum, METH_VARARGS|METH_KEYWORDS, "\n"
+		"Band_Checksum(Band self, int xoff=0, int yoff=0, int * xsize=None, int * ysize=None) -> int\n"
+		"\n"
+		"\n"
+		"Computes a checksum from a region of a RasterBand.\n"
+		"See :cpp:func:`GDALChecksumImage`.\n"
+		"\n"
+		"Parameters\n"
+		"----------\n"
+		"xoff : int, default=0\n"
+		"   The pixel offset to left side of the region of the band to\n"
+		"   be read. This would be zero to start from the left side.\n"
+		"yoff : int, default=0\n"
+		"   The line offset to top side of the region of the band to\n"
+		"   be read. This would be zero to start from the top side.\n"
+		"xsize : int, optional\n"
+		"     The number of pixels to read in the x direction. By default,\n"
+		"     equal to the number of columns in the raster.\n"
+		"ysize : int, optional\n"
+		"     The number of rows to read in the y direction. By default,\n"
+		"     equal to the number of bands in the raster.\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"int\n"
+		"    checksum value, or -1 in case of error\n"
+		"\n"
+		"\n"
+		""},
 	 { "Band_ComputeRasterMinMax", (PyCFunction)(void(*)(void))_wrap_Band_ComputeRasterMinMax, METH_VARARGS|METH_KEYWORDS, "Band_ComputeRasterMinMax(Band self, bool approx_ok=False, bool can_return_none=False)"},
-	 { "Band_ComputeBandStats", _wrap_Band_ComputeBandStats, METH_VARARGS, "Band_ComputeBandStats(Band self, int samplestep=1)"},
-	 { "Band_Fill", _wrap_Band_Fill, METH_VARARGS, "Band_Fill(Band self, double real_fill, double imag_fill=0.0) -> CPLErr"},
+	 { "Band_ComputeBandStats", _wrap_Band_ComputeBandStats, METH_VARARGS, "\n"
+		"Band_ComputeBandStats(Band self, int samplestep=1)\n"
+		"\n"
+		"\n"
+		"Computes the mean and standard deviation of values in this Band.\n"
+		"See :cpp:func:`GDALComputeBandStats`.\n"
+		"\n"
+		"Parameters\n"
+		"----------\n"
+		"samplestep : int, default=1\n"
+		"    Step between scanlines used to compute statistics.\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"tuple\n"
+		"    tuple of length 2 with value of mean and standard deviation\n"
+		"\n"
+		"See Also\n"
+		"--------\n"
+		":py:meth:`ComputeRasterMinMax`\n"
+		":py:meth:`ComputeStatistics`\n"
+		":py:meth:`GetMaximum`\n"
+		":py:meth:`GetMinimum`\n"
+		":py:meth:`GetStatistics`\n"
+		":py:meth:`SetStatistics`\n"
+		"\n"
+		""},
+	 { "Band_Fill", _wrap_Band_Fill, METH_VARARGS, "\n"
+		"Band_Fill(Band self, double real_fill, double imag_fill=0.0) -> CPLErr\n"
+		"\n"
+		"\n"
+		"Fill this band with a constant value.\n"
+		"See :cpp:func:`GDALRasterBand::Fill`.\n"
+		"\n"
+		"Parameters\n"
+		"----------\n"
+		"real_fill : float\n"
+		"    real component of the fill value\n"
+		"imag_fill : float, default = 0.0\n"
+		"    imaginary component of the fill value\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"int:\n"
+		"   :py:const:`CE_None` on success or :py:const:`CE_Failure` on failure.\n"
+		"\n"
+		"\n"
+		""},
 	 { "Band_WriteRaster", (PyCFunction)(void(*)(void))_wrap_Band_WriteRaster, METH_VARARGS|METH_KEYWORDS, "Band_WriteRaster(Band self, int xoff, int yoff, int xsize, int ysize, GIntBig buf_len, int * buf_xsize=None, int * buf_ysize=None, GDALDataType * buf_type=None, GIntBig * buf_pixel_space=None, GIntBig * buf_line_space=None) -> CPLErr"},
-	 { "Band_FlushCache", _wrap_Band_FlushCache, METH_O, "Band_FlushCache(Band self)"},
-	 { "Band_GetRasterColorTable", _wrap_Band_GetRasterColorTable, METH_O, "Band_GetRasterColorTable(Band self) -> ColorTable"},
-	 { "Band_GetColorTable", _wrap_Band_GetColorTable, METH_O, "Band_GetColorTable(Band self) -> ColorTable"},
-	 { "Band_SetRasterColorTable", _wrap_Band_SetRasterColorTable, METH_VARARGS, "Band_SetRasterColorTable(Band self, ColorTable arg) -> int"},
-	 { "Band_SetColorTable", _wrap_Band_SetColorTable, METH_VARARGS, "Band_SetColorTable(Band self, ColorTable arg) -> int"},
+	 { "Band_FlushCache", _wrap_Band_FlushCache, METH_O, "\n"
+		"Band_FlushCache(Band self)\n"
+		"\n"
+		"\n"
+		"Flush raster data cache.\n"
+		"See :cpp:func:`GDALRasterBand::FlushCache`.\n"
+		"\n"
+		""},
+	 { "Band_GetRasterColorTable", _wrap_Band_GetRasterColorTable, METH_O, "\n"
+		"Band_GetRasterColorTable(Band self) -> ColorTable\n"
+		"\n"
+		"\n"
+		"Fetch the color table associated with this band.\n"
+		"See :cpp:func:`GDALRasterBand::GetColorTable`.\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"ColorTable\n"
+		"    The :py:class:`ColorTable`, or ``None`` if it has not been defined.\n"
+		"\n"
+		""},
+	 { "Band_GetColorTable", _wrap_Band_GetColorTable, METH_O, "\n"
+		"Band_GetColorTable(Band self) -> ColorTable\n"
+		"\n"
+		"\n"
+		"Get the color table associated with this band.\n"
+		"See :cpp:func:`GDALRasterBand::GetColorTable`.\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"ColorTable or ``None``\n"
+		"\n"
+		""},
+	 { "Band_SetRasterColorTable", _wrap_Band_SetRasterColorTable, METH_VARARGS, "\n"
+		"Band_SetRasterColorTable(Band self, ColorTable arg) -> int\n"
+		"\n"
+		"Deprecated. Alternate name for :py:meth:`SetColorTable`.\n"
+		"\n"
+		""},
+	 { "Band_SetColorTable", _wrap_Band_SetColorTable, METH_VARARGS, "\n"
+		"Band_SetColorTable(Band self, ColorTable arg) -> int\n"
+		"\n"
+		"\n"
+		"Set the raster color table.\n"
+		"See :cpp:func:`GDALRasterBand::SetColorTable`.\n"
+		"\n"
+		"Parameters\n"
+		"----------\n"
+		"arg : ColorTable\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"int:\n"
+		"   :py:const:`CE_None` on success or :py:const:`CE_Failure` on failure.\n"
+		"\n"
+		""},
 	 { "Band_GetDefaultRAT", _wrap_Band_GetDefaultRAT, METH_O, "Band_GetDefaultRAT(Band self) -> RasterAttributeTable"},
 	 { "Band_SetDefaultRAT", _wrap_Band_SetDefaultRAT, METH_VARARGS, "Band_SetDefaultRAT(Band self, RasterAttributeTable table) -> int"},
-	 { "Band_GetMaskBand", _wrap_Band_GetMaskBand, METH_O, "Band_GetMaskBand(Band self) -> Band"},
-	 { "Band_GetMaskFlags", _wrap_Band_GetMaskFlags, METH_O, "Band_GetMaskFlags(Band self) -> int"},
-	 { "Band_CreateMaskBand", _wrap_Band_CreateMaskBand, METH_VARARGS, "Band_CreateMaskBand(Band self, int nFlags) -> CPLErr"},
-	 { "Band_IsMaskBand", _wrap_Band_IsMaskBand, METH_O, "Band_IsMaskBand(Band self) -> bool"},
-	 { "Band_GetHistogram", (PyCFunction)(void(*)(void))_wrap_Band_GetHistogram, METH_VARARGS|METH_KEYWORDS, "Band_GetHistogram(Band self, double min=-0.5, double max=255.5, int buckets=256, int include_out_of_range=0, int approx_ok=1, GDALProgressFunc callback=0, void * callback_data=None) -> CPLErr"},
-	 { "Band_GetDefaultHistogram", (PyCFunction)(void(*)(void))_wrap_Band_GetDefaultHistogram, METH_VARARGS|METH_KEYWORDS, "Band_GetDefaultHistogram(Band self, double * min_ret=None, double * max_ret=None, int * buckets_ret=None, GUIntBig ** ppanHistogram=None, int force=1, GDALProgressFunc callback=0, void * callback_data=None) -> CPLErr"},
-	 { "Band_SetDefaultHistogram", _wrap_Band_SetDefaultHistogram, METH_VARARGS, "Band_SetDefaultHistogram(Band self, double min, double max, int buckets_in) -> CPLErr"},
-	 { "Band_HasArbitraryOverviews", _wrap_Band_HasArbitraryOverviews, METH_O, "Band_HasArbitraryOverviews(Band self) -> bool"},
-	 { "Band_GetCategoryNames", _wrap_Band_GetCategoryNames, METH_O, "Band_GetCategoryNames(Band self) -> char **"},
-	 { "Band_SetCategoryNames", _wrap_Band_SetCategoryNames, METH_VARARGS, "Band_SetCategoryNames(Band self, char ** papszCategoryNames) -> CPLErr"},
+	 { "Band_GetMaskBand", _wrap_Band_GetMaskBand, METH_O, "\n"
+		"Band_GetMaskBand(Band self) -> Band\n"
+		"\n"
+		"\n"
+		"Return the mask band associated with this band.\n"
+		"See :cpp:func:`GDALRasterBand::GetMaskBand`.\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"Band\n"
+		"\n"
+		"\n"
+		""},
+	 { "Band_GetMaskFlags", _wrap_Band_GetMaskFlags, METH_O, "\n"
+		"Band_GetMaskFlags(Band self) -> int\n"
+		"\n"
+		"\n"
+		"Return the status flags of the mask band.\n"
+		"See :cpp:func:`GDALRasterBand::GetMaskFlags`.\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"int\n"
+		"\n"
+		"Examples\n"
+		"--------\n"
+		">>> import numpy as np\n"
+		">>> ds = gdal.GetDriverByName('MEM').Create('', 10, 10)\n"
+		">>> band = ds.GetRasterBand(1)\n"
+		">>> band.GetMaskFlags() == gdal.GMF_ALL_VALID\n"
+		"True\n"
+		">>> band.SetNoDataValue(22)\n"
+		"0\n"
+		">>> band.WriteArray(np.array([[22]]))\n"
+		"0\n"
+		">>> band.GetMaskBand().ReadAsArray(win_xsize=2,win_ysize=2)\n"
+		"array([[  0, 255],\n"
+		"       [255, 255]], dtype=uint8)\n"
+		">>> band.GetMaskFlags() == gdal.GMF_NODATA\n"
+		"True\n"
+		"\n"
+		"\n"
+		""},
+	 { "Band_CreateMaskBand", _wrap_Band_CreateMaskBand, METH_VARARGS, "\n"
+		"Band_CreateMaskBand(Band self, int nFlags) -> CPLErr\n"
+		"\n"
+		"\n"
+		"Add a mask band to the current band.\n"
+		"See :cpp:func:`GDALRasterBand::CreateMaskBand`.\n"
+		"\n"
+		"Parameters\n"
+		"----------\n"
+		"nFlags : int\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"int:\n"
+		"   :py:const:`CE_None` on success or :py:const:`CE_Failure` on failure.\n"
+		"\n"
+		"\n"
+		""},
+	 { "Band_IsMaskBand", _wrap_Band_IsMaskBand, METH_O, "\n"
+		"Band_IsMaskBand(Band self) -> bool\n"
+		"\n"
+		"\n"
+		"Returns whether the band is a mask band.\n"
+		"See :cpp:func:`GDALRasterBand::IsMaskBand`.\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"bool\n"
+		"\n"
+		""},
+	 { "Band_GetHistogram", (PyCFunction)(void(*)(void))_wrap_Band_GetHistogram, METH_VARARGS|METH_KEYWORDS, "\n"
+		"Band_GetHistogram(Band self, double min=-0.5, double max=255.5, int buckets=256, int include_out_of_range=0, int approx_ok=1, GDALProgressFunc callback=0, void * callback_data=None) -> CPLErr\n"
+		"\n"
+		"\n"
+		"Compute raster histogram.\n"
+		"See :cpp:func:`GDALRasterBand::GetHistogram`.\n"
+		"\n"
+		"Parameters\n"
+		"----------\n"
+		"min : float, default=-0.05\n"
+		"    the lower bound of the histogram\n"
+		"max : float, default=255.5\n"
+		"    the upper bound of the histogram\n"
+		"buckets : int, default=256\n"
+		"    the number of buckets int he histogram\n"
+		"include_out_of_range : bool, default=False\n"
+		"    if ``True``, add out-of-range values into the first and last buckets\n"
+		"approx_ok : bool, default=True\n"
+		"    if ``True``, compute an approximate histogram by using subsampling or overviews\n"
+		"callback : function, optional\n"
+		"             A progress callback function\n"
+		"callback_data: optional\n"
+		"             Optional data to be passed to callback function\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"list\n"
+		"    list with length equal to ``buckets``. If ``approx_ok`` is ``False``, each\n"
+		"    the value of each list item will equal the number of pixels in that bucket.\n"
+		"\n"
+		"Examples\n"
+		"--------\n"
+		">>> import numpy as np\n"
+		">>> ds = gdal.GetDriverByName('MEM').Create('', 10, 10, eType=gdal.GDT_Float32)\n"
+		">>> ds.WriteArray(np.random.normal(size=100).reshape(10, 10))\n"
+		"0\n"
+		">>> ds.GetRasterBand(1).GetHistogram(min=-3.5, max=3.5, buckets=13, approx_ok=False)\n"
+		"[0, 0, 3, 9, 13, 12, 25, 22, 9, 6, 0, 1, 0]  # random\n"
+		"\n"
+		""},
+	 { "Band_GetDefaultHistogram", (PyCFunction)(void(*)(void))_wrap_Band_GetDefaultHistogram, METH_VARARGS|METH_KEYWORDS, "\n"
+		"Band_GetDefaultHistogram(Band self, double * min_ret=None, double * max_ret=None, int * buckets_ret=None, GUIntBig ** ppanHistogram=None, int force=1, GDALProgressFunc callback=0, void * callback_data=None) -> CPLErr\n"
+		"\n"
+		"\n"
+		"Fetch the default histogram for this band.\n"
+		"See :cpp:func:`GDALRasterBand::GetDefaultHistogram`.\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"list\n"
+		"    List with the following four elements:\n"
+		"    - lower bound of histogram\n"
+		"    - upper bound of histogram\n"
+		"    - number of buckets in histogram\n"
+		"    - tuple with counts for each bucket\n"
+		"\n"
+		""},
+	 { "Band_SetDefaultHistogram", _wrap_Band_SetDefaultHistogram, METH_VARARGS, "\n"
+		"Band_SetDefaultHistogram(Band self, double min, double max, int buckets_in) -> CPLErr\n"
+		"\n"
+		"\n"
+		"Set default histogram.\n"
+		"See :cpp:func:`GDALRasterBand::SetDefaultHistogram`.\n"
+		"\n"
+		"Parameters\n"
+		"----------\n"
+		"min : float\n"
+		"    minimum value\n"
+		"max : float\n"
+		"    maximum value\n"
+		"buckets_in : list\n"
+		"    list of pixel counts for each bucket\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"int:\n"
+		"   :py:const:`CE_None` on success or :py:const:`CE_Failure` on failure.\n"
+		"\n"
+		"See Also\n"
+		"--------\n"
+		":py:meth:`SetHistogram`\n"
+		"\n"
+		""},
+	 { "Band_HasArbitraryOverviews", _wrap_Band_HasArbitraryOverviews, METH_O, "\n"
+		"Band_HasArbitraryOverviews(Band self) -> bool\n"
+		"\n"
+		"\n"
+		"Check for arbitrary overviews.\n"
+		"See :cpp:func:`GDALRasterBand::HasArbitraryOverviews`.\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"bool\n"
+		"\n"
+		""},
+	 { "Band_GetCategoryNames", _wrap_Band_GetCategoryNames, METH_O, "\n"
+		"Band_GetCategoryNames(Band self) -> char **\n"
+		"\n"
+		"\n"
+		"Fetch the list of category names for this raster.\n"
+		"See :cpp:func:`GDALRasterBand::GetCategoryNames`.\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"list\n"
+		"    A list of category names, or ``None``\n"
+		"\n"
+		""},
+	 { "Band_SetCategoryNames", _wrap_Band_SetCategoryNames, METH_VARARGS, "\n"
+		"Band_SetCategoryNames(Band self, char ** papszCategoryNames) -> CPLErr\n"
+		"\n"
+		"\n"
+		"Set the category names for this band.\n"
+		"See :cpp:func:`GDALRasterBand::SetCategoryNames`.\n"
+		"\n"
+		"Parameters\n"
+		"----------\n"
+		"papszCategoryNames : list\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"int:\n"
+		"   :py:const:`CE_None` on success or :py:const:`CE_Failure` on failure.\n"
+		"\n"
+		""},
 	 { "Band_GetVirtualMem", (PyCFunction)(void(*)(void))_wrap_Band_GetVirtualMem, METH_VARARGS|METH_KEYWORDS, "Band_GetVirtualMem(Band self, GDALRWFlag eRWFlag, int nXOff, int nYOff, int nXSize, int nYSize, int nBufXSize, int nBufYSize, GDALDataType eBufType, size_t nCacheSize, size_t nPageSizeHint, char ** options=None) -> VirtualMem"},
 	 { "Band_GetVirtualMemAuto", (PyCFunction)(void(*)(void))_wrap_Band_GetVirtualMemAuto, METH_VARARGS|METH_KEYWORDS, "Band_GetVirtualMemAuto(Band self, GDALRWFlag eRWFlag, char ** options=None) -> VirtualMem"},
 	 { "Band_GetTiledVirtualMem", (PyCFunction)(void(*)(void))_wrap_Band_GetTiledVirtualMem, METH_VARARGS|METH_KEYWORDS, "Band_GetTiledVirtualMem(Band self, GDALRWFlag eRWFlag, int nXOff, int nYOff, int nXSize, int nYSize, int nTileXSize, int nTileYSize, GDALDataType eBufType, size_t nCacheSize, char ** options=None) -> VirtualMem"},
-	 { "Band_GetDataCoverageStatus", _wrap_Band_GetDataCoverageStatus, METH_VARARGS, "Band_GetDataCoverageStatus(Band self, int nXOff, int nYOff, int nXSize, int nYSize, int nMaskFlagStop=0) -> int"},
+	 { "Band_GetDataCoverageStatus", _wrap_Band_GetDataCoverageStatus, METH_VARARGS, "\n"
+		"Band_GetDataCoverageStatus(Band self, int nXOff, int nYOff, int nXSize, int nYSize, int nMaskFlagStop=0) -> int\n"
+		"\n"
+		"\n"
+		"Determine whether a sub-window of the Band contains only data, only empty blocks, or a mix of both.\n"
+		"See :cpp:func:`GDALRasterBand::GetDataCoverageStatus`.\n"
+		"\n"
+		"Parameters\n"
+		"----------\n"
+		"nXOff : int\n"
+		"nYOff : int\n"
+		"nXSize : int\n"
+		"nYSize : int\n"
+		"nMaskFlagStop : int, default=0\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"list\n"
+		"    First value represents a bitwise-or value of the following constants\n"
+		"    - :py:const:`gdalconst.GDAL_DATA_COVERAGE_STATUS_DATA`\n"
+		"    - :py:const:`gdalconst.GDAL_DATA_COVERAGE_STATUS_EMPTY`\n"
+		"    - :py:const:`gdalconst.GDAL_DATA_COVERAGE_STATUS_UNIMPLEMENTED`\n"
+		"    Second value represents the approximate percentage in [0, 100] of pixels in the window that have valid values\n"
+		"\n"
+		"Examples\n"
+		"--------\n"
+		">>> import numpy as np\n"
+		">>> # Create a raster with four blocks\n"
+		">>> ds = gdal.GetDriverByName('GTiff').Create('test.tif', 64, 64, options = {'SPARSE_OK':True, 'TILED':True, 'BLOCKXSIZE':32, 'BLOCKYSIZE':32})\n"
+		">>> band = ds.GetRasterBand(1)\n"
+		">>> # Write some data to upper-left block\n"
+		">>> band.WriteArray(np.array([[1, 2], [3, 4]]))\n"
+		"0\n"
+		">>> # Check status of upper-left block\n"
+		">>> flags, pct = band.GetDataCoverageStatus(0, 0, 32, 32)\n"
+		">>> flags == gdal.GDAL_DATA_COVERAGE_STATUS_DATA\n"
+		"True\n"
+		">>> pct\n"
+		"100.0\n"
+		">>> # Check status of upper-right block\n"
+		">>> flags, pct = band.GetDataCoverageStatus(32, 0, 32, 32)\n"
+		">>> flags == gdal.GDAL_DATA_COVERAGE_STATUS_EMPTY\n"
+		"True\n"
+		">>> pct\n"
+		"0.0\n"
+		">>> # Check status of window touching all four blocks\n"
+		">>> flags, pct = band.GetDataCoverageStatus(16, 16, 32, 32)\n"
+		">>> flags == gdal.GDAL_DATA_COVERAGE_STATUS_DATA | gdal.GDAL_DATA_COVERAGE_STATUS_EMPTY\n"
+		"True\n"
+		">>> pct\n"
+		"25.0\n"
+		"\n"
+		""},
 	 { "Band_AdviseRead", _wrap_Band_AdviseRead, METH_VARARGS, "Band_AdviseRead(Band self, int xoff, int yoff, int xsize, int ysize, int * buf_xsize=None, int * buf_ysize=None, GDALDataType * buf_type=None, char ** options=None) -> CPLErr"},
 	 { "Band_AsMDArray", _wrap_Band_AsMDArray, METH_O, "Band_AsMDArray(Band self) -> MDArray"},
 	 { "Band__EnablePixelTypeSignedByteWarning", _wrap_Band__EnablePixelTypeSignedByteWarning, METH_VARARGS, "Band__EnablePixelTypeSignedByteWarning(Band self, bool b)"},
 	 { "Band_ReadRaster1", (PyCFunction)(void(*)(void))_wrap_Band_ReadRaster1, METH_VARARGS|METH_KEYWORDS, "Band_ReadRaster1(Band self, double xoff, double yoff, double xsize, double ysize, int * buf_xsize=None, int * buf_ysize=None, GDALDataType * buf_type=None, GIntBig * buf_pixel_space=None, GIntBig * buf_line_space=None, GDALRIOResampleAlg resample_alg=GRIORA_NearestNeighbour, GDALProgressFunc callback=0, void * callback_data=None, void * inputOutputBuf=None) -> CPLErr"},
 	 { "Band_ReadBlock", (PyCFunction)(void(*)(void))_wrap_Band_ReadBlock, METH_VARARGS|METH_KEYWORDS, "Band_ReadBlock(Band self, int xoff, int yoff, void * buf_obj=None) -> CPLErr"},
 	 { "Band_swigregister", Band_swigregister, METH_O, NULL},
 	 { "new_ColorTable", (PyCFunction)(void(*)(void))_wrap_new_ColorTable, METH_VARARGS|METH_KEYWORDS, "new_ColorTable(GDALPaletteInterp palette=GPI_RGB) -> ColorTable"},
@@ -53658,40 +56649,14 @@
 	 { "ColorTable_GetCount", _wrap_ColorTable_GetCount, METH_O, "ColorTable_GetCount(ColorTable self) -> int"},
 	 { "ColorTable_GetColorEntry", _wrap_ColorTable_GetColorEntry, METH_VARARGS, "ColorTable_GetColorEntry(ColorTable self, int entry) -> ColorEntry"},
 	 { "ColorTable_GetColorEntryAsRGB", _wrap_ColorTable_GetColorEntryAsRGB, METH_VARARGS, "ColorTable_GetColorEntryAsRGB(ColorTable self, int entry, ColorEntry centry) -> int"},
 	 { "ColorTable_SetColorEntry", _wrap_ColorTable_SetColorEntry, METH_VARARGS, "ColorTable_SetColorEntry(ColorTable self, int entry, ColorEntry centry)"},
 	 { "ColorTable_CreateColorRamp", _wrap_ColorTable_CreateColorRamp, METH_VARARGS, "ColorTable_CreateColorRamp(ColorTable self, int nStartIndex, ColorEntry startcolor, int nEndIndex, ColorEntry endcolor)"},
 	 { "ColorTable_swigregister", ColorTable_swigregister, METH_O, NULL},
 	 { "ColorTable_swiginit", ColorTable_swiginit, METH_VARARGS, NULL},
-	 { "new_RasterAttributeTable", _wrap_new_RasterAttributeTable, METH_NOARGS, "new_RasterAttributeTable() -> RasterAttributeTable"},
-	 { "delete_RasterAttributeTable", _wrap_delete_RasterAttributeTable, METH_O, "delete_RasterAttributeTable(RasterAttributeTable self)"},
-	 { "RasterAttributeTable_Clone", _wrap_RasterAttributeTable_Clone, METH_O, "RasterAttributeTable_Clone(RasterAttributeTable self) -> RasterAttributeTable"},
-	 { "RasterAttributeTable_GetColumnCount", _wrap_RasterAttributeTable_GetColumnCount, METH_O, "RasterAttributeTable_GetColumnCount(RasterAttributeTable self) -> int"},
-	 { "RasterAttributeTable_GetNameOfCol", _wrap_RasterAttributeTable_GetNameOfCol, METH_VARARGS, "RasterAttributeTable_GetNameOfCol(RasterAttributeTable self, int iCol) -> char const *"},
-	 { "RasterAttributeTable_GetUsageOfCol", _wrap_RasterAttributeTable_GetUsageOfCol, METH_VARARGS, "RasterAttributeTable_GetUsageOfCol(RasterAttributeTable self, int iCol) -> GDALRATFieldUsage"},
-	 { "RasterAttributeTable_GetTypeOfCol", _wrap_RasterAttributeTable_GetTypeOfCol, METH_VARARGS, "RasterAttributeTable_GetTypeOfCol(RasterAttributeTable self, int iCol) -> GDALRATFieldType"},
-	 { "RasterAttributeTable_GetColOfUsage", _wrap_RasterAttributeTable_GetColOfUsage, METH_VARARGS, "RasterAttributeTable_GetColOfUsage(RasterAttributeTable self, GDALRATFieldUsage eUsage) -> int"},
-	 { "RasterAttributeTable_GetRowCount", _wrap_RasterAttributeTable_GetRowCount, METH_O, "RasterAttributeTable_GetRowCount(RasterAttributeTable self) -> int"},
-	 { "RasterAttributeTable_GetValueAsString", _wrap_RasterAttributeTable_GetValueAsString, METH_VARARGS, "RasterAttributeTable_GetValueAsString(RasterAttributeTable self, int iRow, int iCol) -> char const *"},
-	 { "RasterAttributeTable_GetValueAsInt", _wrap_RasterAttributeTable_GetValueAsInt, METH_VARARGS, "RasterAttributeTable_GetValueAsInt(RasterAttributeTable self, int iRow, int iCol) -> int"},
-	 { "RasterAttributeTable_GetValueAsDouble", _wrap_RasterAttributeTable_GetValueAsDouble, METH_VARARGS, "RasterAttributeTable_GetValueAsDouble(RasterAttributeTable self, int iRow, int iCol) -> double"},
-	 { "RasterAttributeTable_SetValueAsString", _wrap_RasterAttributeTable_SetValueAsString, METH_VARARGS, "RasterAttributeTable_SetValueAsString(RasterAttributeTable self, int iRow, int iCol, char const * pszValue)"},
-	 { "RasterAttributeTable_SetValueAsInt", _wrap_RasterAttributeTable_SetValueAsInt, METH_VARARGS, "RasterAttributeTable_SetValueAsInt(RasterAttributeTable self, int iRow, int iCol, int nValue)"},
-	 { "RasterAttributeTable_SetValueAsDouble", _wrap_RasterAttributeTable_SetValueAsDouble, METH_VARARGS, "RasterAttributeTable_SetValueAsDouble(RasterAttributeTable self, int iRow, int iCol, double dfValue)"},
-	 { "RasterAttributeTable_SetRowCount", _wrap_RasterAttributeTable_SetRowCount, METH_VARARGS, "RasterAttributeTable_SetRowCount(RasterAttributeTable self, int nCount)"},
-	 { "RasterAttributeTable_CreateColumn", _wrap_RasterAttributeTable_CreateColumn, METH_VARARGS, "RasterAttributeTable_CreateColumn(RasterAttributeTable self, char const * pszName, GDALRATFieldType eType, GDALRATFieldUsage eUsage) -> int"},
-	 { "RasterAttributeTable_GetLinearBinning", _wrap_RasterAttributeTable_GetLinearBinning, METH_O, "RasterAttributeTable_GetLinearBinning(RasterAttributeTable self) -> bool"},
-	 { "RasterAttributeTable_SetLinearBinning", _wrap_RasterAttributeTable_SetLinearBinning, METH_VARARGS, "RasterAttributeTable_SetLinearBinning(RasterAttributeTable self, double dfRow0Min, double dfBinSize) -> int"},
-	 { "RasterAttributeTable_GetRowOfValue", _wrap_RasterAttributeTable_GetRowOfValue, METH_VARARGS, "RasterAttributeTable_GetRowOfValue(RasterAttributeTable self, double dfValue) -> int"},
-	 { "RasterAttributeTable_ChangesAreWrittenToFile", _wrap_RasterAttributeTable_ChangesAreWrittenToFile, METH_O, "RasterAttributeTable_ChangesAreWrittenToFile(RasterAttributeTable self) -> int"},
-	 { "RasterAttributeTable_DumpReadable", _wrap_RasterAttributeTable_DumpReadable, METH_O, "RasterAttributeTable_DumpReadable(RasterAttributeTable self)"},
-	 { "RasterAttributeTable_SetTableType", _wrap_RasterAttributeTable_SetTableType, METH_VARARGS, "RasterAttributeTable_SetTableType(RasterAttributeTable self, GDALRATTableType eTableType)"},
-	 { "RasterAttributeTable_GetTableType", _wrap_RasterAttributeTable_GetTableType, METH_O, "RasterAttributeTable_GetTableType(RasterAttributeTable self) -> GDALRATTableType"},
-	 { "RasterAttributeTable_swigregister", RasterAttributeTable_swigregister, METH_O, NULL},
-	 { "RasterAttributeTable_swiginit", RasterAttributeTable_swiginit, METH_VARARGS, NULL},
 	 { "delete_SubdatasetInfo", _wrap_delete_SubdatasetInfo, METH_O, "delete_SubdatasetInfo(SubdatasetInfo self)"},
 	 { "SubdatasetInfo_GetPathComponent", _wrap_SubdatasetInfo_GetPathComponent, METH_O, "SubdatasetInfo_GetPathComponent(SubdatasetInfo self) -> retStringAndCPLFree *"},
 	 { "SubdatasetInfo_GetSubdatasetComponent", _wrap_SubdatasetInfo_GetSubdatasetComponent, METH_O, "SubdatasetInfo_GetSubdatasetComponent(SubdatasetInfo self) -> retStringAndCPLFree *"},
 	 { "SubdatasetInfo_ModifyPathComponent", _wrap_SubdatasetInfo_ModifyPathComponent, METH_VARARGS, "SubdatasetInfo_ModifyPathComponent(SubdatasetInfo self, char const * pszNewFileName) -> retStringAndCPLFree *"},
 	 { "SubdatasetInfo_swigregister", SubdatasetInfo_swigregister, METH_O, NULL},
 	 { "GetSubdatasetInfo", _wrap_GetSubdatasetInfo, METH_O, "GetSubdatasetInfo(char const * pszFileName) -> GDALSubdatasetInfoShadow *"},
 	 { "new_Relationship", _wrap_new_Relationship, METH_VARARGS, "new_Relationship(char const * name, char const * leftTableName, char const * rightTableName, GDALRelationshipCardinality cardinality) -> Relationship"},
@@ -53731,14 +56696,52 @@
 	 { "FillNodata", (PyCFunction)(void(*)(void))_wrap_FillNodata, METH_VARARGS|METH_KEYWORDS, "FillNodata(Band targetBand, Band maskBand, double maxSearchDist, int smoothingIterations, char ** options=None, GDALProgressFunc callback=0, void * callback_data=None) -> int"},
 	 { "SieveFilter", (PyCFunction)(void(*)(void))_wrap_SieveFilter, METH_VARARGS|METH_KEYWORDS, "SieveFilter(Band srcBand, Band maskBand, Band dstBand, int threshold, int connectedness=4, char ** options=None, GDALProgressFunc callback=0, void * callback_data=None) -> int"},
 	 { "RegenerateOverviews", (PyCFunction)(void(*)(void))_wrap_RegenerateOverviews, METH_VARARGS|METH_KEYWORDS, "RegenerateOverviews(Band srcBand, int overviewBandCount, char const * resampling=\"average\", GDALProgressFunc callback=0, void * callback_data=None) -> int"},
 	 { "RegenerateOverview", (PyCFunction)(void(*)(void))_wrap_RegenerateOverview, METH_VARARGS|METH_KEYWORDS, "RegenerateOverview(Band srcBand, Band overviewBand, char const * resampling=\"average\", GDALProgressFunc callback=0, void * callback_data=None) -> int"},
 	 { "ContourGenerate", (PyCFunction)(void(*)(void))_wrap_ContourGenerate, METH_VARARGS|METH_KEYWORDS, "ContourGenerate(Band srcBand, double contourInterval, double contourBase, int fixedLevelCount, int useNoData, double noDataValue, Layer dstLayer, int idField, int elevField, GDALProgressFunc callback=0, void * callback_data=None) -> int"},
 	 { "ContourGenerateEx", (PyCFunction)(void(*)(void))_wrap_ContourGenerateEx, METH_VARARGS|METH_KEYWORDS, "ContourGenerateEx(Band srcBand, Layer dstLayer, char ** options=None, GDALProgressFunc callback=0, void * callback_data=None) -> int"},
 	 { "ViewshedGenerate", (PyCFunction)(void(*)(void))_wrap_ViewshedGenerate, METH_VARARGS|METH_KEYWORDS, "ViewshedGenerate(Band srcBand, char const * driverName, char const * targetRasterName, char ** creationOptions, double observerX, double observerY, double observerHeight, double targetHeight, double visibleVal, double invisibleVal, double outOfRangeVal, double noDataVal, double dfCurvCoeff, GDALViewshedMode mode, double maxDistance, GDALProgressFunc callback=0, void * callback_data=None, GDALViewshedOutputType heightMode=GVOT_NORMAL, char ** options=None) -> Dataset"},
+	 { "IsLineOfSightVisible", (PyCFunction)(void(*)(void))_wrap_IsLineOfSightVisible, METH_VARARGS|METH_KEYWORDS, "\n"
+		"IsLineOfSightVisible(Band band, int xA, int yA, double zA, int xB, int yB, double zB, char ** options=None)\n"
+		"\n"
+		"\n"
+		"Check Line of Sight between two points.\n"
+		"Both input coordinates must be within the raster coordinate bounds.\n"
+		"\n"
+		" See :cpp:func:`GDALIsLineOfSightVisible`.\n"
+		"\n"
+		".. versionadded:: 3.9\n"
+		"\n"
+		"Parameters\n"
+		"----------\n"
+		"band : gdal.RasterBand\n"
+		"    The band to read the DEM data from. This must NOT be null.\n"
+		"xA : int\n"
+		"    The X location (raster column) of the first point to check on the raster.\n"
+		"yA : int\n"
+		"    The Y location (raster row) of the first point to check on the raster.\n"
+		"zA : float\n"
+		"    The Z location (height) of the first point to check.\n"
+		"xB : int\n"
+		"    The X location (raster column) of the second point to check on the raster.\n"
+		"yB : int\n"
+		"    The Y location (raster row) of the second point to check on the raster.\n"
+		"zB : float\n"
+		"    The Z location (height) of the second point to check.\n"
+		"options : dict/list, optional\n"
+		"    A dict or list of name=value of options for the line of sight algorithm (currently ignored).\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"collections.namedtuple(is_visible: bool, col_intersection: int, row_intersection: int)\n"
+		"    is_visible is True if the two points are within Line of Sight.\n"
+		"    col_intersection is the raster column index where the LOS line intersects with terrain (will be set in the future, currently set to -1).\n"
+		"    row_intersection is the raster row index where the LOS line intersects with terrain (will be set in the future, currently set to -1).\n"
+		"\n"
+		""},
 	 { "AutoCreateWarpedVRT", _wrap_AutoCreateWarpedVRT, METH_VARARGS, "AutoCreateWarpedVRT(Dataset src_ds, char const * src_wkt=None, char const * dst_wkt=None, GDALResampleAlg eResampleAlg=GRA_NearestNeighbour, double maxerror=0.0) -> Dataset"},
 	 { "CreatePansharpenedVRT", _wrap_CreatePansharpenedVRT, METH_VARARGS, "CreatePansharpenedVRT(char const * pszXML, Band panchroBand, int nInputSpectralBands) -> Dataset"},
 	 { "delete_GDALTransformerInfoShadow", _wrap_delete_GDALTransformerInfoShadow, METH_O, "delete_GDALTransformerInfoShadow(GDALTransformerInfoShadow self)"},
 	 { "GDALTransformerInfoShadow_TransformPoint", _wrap_GDALTransformerInfoShadow_TransformPoint, METH_VARARGS, "\n"
 		"GDALTransformerInfoShadow_TransformPoint(GDALTransformerInfoShadow self, int bDstToSrc, double [3] inout) -> int\n"
 		"GDALTransformerInfoShadow_TransformPoint(GDALTransformerInfoShadow self, int bDstToSrc, double x, double y, double z=0.0) -> int\n"
 		""},
@@ -53757,40 +56760,255 @@
 	 { "SuggestedWarpOutputRes_swigregister", SuggestedWarpOutputRes_swigregister, METH_O, NULL},
 	 { "SuggestedWarpOutputFromTransformer", _wrap_SuggestedWarpOutputFromTransformer, METH_VARARGS, "SuggestedWarpOutputFromTransformer(Dataset src, GDALTransformerInfoShadow transformer) -> SuggestedWarpOutputRes"},
 	 { "SuggestedWarpOutputFromOptions", _wrap_SuggestedWarpOutputFromOptions, METH_VARARGS, "SuggestedWarpOutputFromOptions(Dataset src, char ** options) -> SuggestedWarpOutputRes"},
 	 { "_ApplyVerticalShiftGrid", (PyCFunction)(void(*)(void))_wrap__ApplyVerticalShiftGrid, METH_VARARGS|METH_KEYWORDS, "_ApplyVerticalShiftGrid(Dataset src_ds, Dataset grid_ds, bool inverse=False, double srcUnitToMeter=1.0, double dstUnitToMeter=1.0, char ** options=None) -> Dataset"},
 	 { "ApplyGeoTransform", _wrap_ApplyGeoTransform, METH_VARARGS, "ApplyGeoTransform(double [6] padfGeoTransform, double dfPixel, double dfLine)"},
 	 { "InvGeoTransform", _wrap_InvGeoTransform, METH_O, "InvGeoTransform(double [6] gt_in) -> RETURN_NONE"},
 	 { "VersionInfo", _wrap_VersionInfo, METH_VARARGS, "VersionInfo(char const * request=\"VERSION_NUM\") -> char const *"},
-	 { "AllRegister", _wrap_AllRegister, METH_NOARGS, "AllRegister()"},
+	 { "AllRegister", _wrap_AllRegister, METH_NOARGS, "\n"
+		"AllRegister()\n"
+		"\n"
+		"\n"
+		"Register all known configured GDAL drivers.\n"
+		"Automatically called when the :py:mod:`gdal` module is loaded.\n"
+		"Does not need to be called in user code unless a driver was\n"
+		"deregistered and needs to be re-registered.\n"
+		"See :cpp:func:`GDALAllRegister`.\n"
+		"\n"
+		"See Also\n"
+		"--------\n"
+		":py:func:`Driver.Register`\n"
+		"\n"
+		""},
 	 { "GDALDestroyDriverManager", _wrap_GDALDestroyDriverManager, METH_NOARGS, "GDALDestroyDriverManager()"},
-	 { "GetCacheMax", _wrap_GetCacheMax, METH_NOARGS, "GetCacheMax() -> GIntBig"},
-	 { "GetCacheUsed", _wrap_GetCacheUsed, METH_NOARGS, "GetCacheUsed() -> GIntBig"},
-	 { "SetCacheMax", _wrap_SetCacheMax, METH_O, "SetCacheMax(GIntBig nBytes)"},
-	 { "GetDataTypeSize", _wrap_GetDataTypeSize, METH_O, "GetDataTypeSize(GDALDataType eDataType) -> int"},
+	 { "GetCacheMax", _wrap_GetCacheMax, METH_NOARGS, "\n"
+		"GetCacheMax() -> GIntBig\n"
+		"\n"
+		"\n"
+		"Get the maximum size of the block cache.\n"
+		"See :cpp:func:`GDALGetCacheMax`.\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"int\n"
+		"    maximum cache size in bytes\n"
+		"\n"
+		""},
+	 { "GetCacheUsed", _wrap_GetCacheUsed, METH_NOARGS, "\n"
+		"GetCacheUsed() -> GIntBig\n"
+		"\n"
+		"\n"
+		"Get the number of bytes in used by the block cache.\n"
+		"See :cpp:func:`GDALGetCacheUsed`.\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"int\n"
+		"    cache size in bytes\n"
+		"\n"
+		""},
+	 { "SetCacheMax", _wrap_SetCacheMax, METH_O, "\n"
+		"SetCacheMax(GIntBig nBytes)\n"
+		"\n"
+		"\n"
+		"Set the maximum size of the block cache.\n"
+		"See :cpp:func:`GDALSetCacheMax`.\n"
+		"\n"
+		"Parameters\n"
+		"----------\n"
+		"nBytes: int\n"
+		"    Cache size in bytes\n"
+		"\n"
+		"See Also\n"
+		"--------\n"
+		":config:`GDAL_CACHEMAX`\n"
+		"\n"
+		""},
+	 { "GetDataTypeSize", _wrap_GetDataTypeSize, METH_O, "\n"
+		"GetDataTypeSize(GDALDataType eDataType) -> int\n"
+		"\n"
+		"\n"
+		"Return the size of the data type in bits.\n"
+		"\n"
+		"Parameters\n"
+		"----------\n"
+		"eDataType : int\n"
+		"    data type code\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"int\n"
+		"\n"
+		"Examples\n"
+		"--------\n"
+		">>> gdal.GetDataTypeSize(gdal.GDT_Byte)\n"
+		"8\n"
+		">>> gdal.GetDataTypeSize(gdal.GDT_Int32)\n"
+		"32\n"
+		"\n"
+		""},
 	 { "DataTypeIsComplex", _wrap_DataTypeIsComplex, METH_O, "DataTypeIsComplex(GDALDataType eDataType) -> int"},
-	 { "GetDataTypeName", _wrap_GetDataTypeName, METH_O, "GetDataTypeName(GDALDataType eDataType) -> char const *"},
-	 { "GetDataTypeByName", _wrap_GetDataTypeByName, METH_O, "GetDataTypeByName(char const * pszDataTypeName) -> GDALDataType"},
+	 { "GetDataTypeName", _wrap_GetDataTypeName, METH_O, "\n"
+		"GetDataTypeName(GDALDataType eDataType) -> char const *\n"
+		"\n"
+		"\n"
+		"Return the name of the data type.\n"
+		"\n"
+		"Parameters\n"
+		"----------\n"
+		"eDataType : int\n"
+		"    data type code\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"str\n"
+		"\n"
+		"Examples\n"
+		"--------\n"
+		">>> gdal.GetDataTypeName(gdal.GDT_Int16)\n"
+		"'Int16'\n"
+		">>> gdal.GetDataTypeName(gdal.GDT_Float64)\n"
+		"'Float64'\n"
+		"\n"
+		""},
+	 { "GetDataTypeByName", _wrap_GetDataTypeByName, METH_O, "\n"
+		"GetDataTypeByName(char const * pszDataTypeName) -> GDALDataType\n"
+		"\n"
+		"\n"
+		"Return the data type for a given name.\n"
+		"\n"
+		"Parameters\n"
+		"----------\n"
+		"pszDataTypeName : str\n"
+		"    data type name\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"int\n"
+		"    data type code\n"
+		"\n"
+		"Examples\n"
+		"--------\n"
+		">>> gdal.GetDataTypeByName('Int16') == gdal.GDT_Int16\n"
+		"True\n"
+		"\n"
+		"\n"
+		""},
 	 { "DataTypeUnion", _wrap_DataTypeUnion, METH_VARARGS, "DataTypeUnion(GDALDataType a, GDALDataType b) -> GDALDataType"},
 	 { "GetColorInterpretationName", _wrap_GetColorInterpretationName, METH_O, "GetColorInterpretationName(GDALColorInterp eColorInterp) -> char const *"},
 	 { "GetPaletteInterpretationName", _wrap_GetPaletteInterpretationName, METH_O, "GetPaletteInterpretationName(GDALPaletteInterp ePaletteInterp) -> char const *"},
 	 { "DecToDMS", _wrap_DecToDMS, METH_VARARGS, "DecToDMS(double arg1, char const * arg2, int arg3=2) -> char const *"},
 	 { "PackedDMSToDec", _wrap_PackedDMSToDec, METH_O, "PackedDMSToDec(double dfPacked) -> double"},
 	 { "DecToPackedDMS", _wrap_DecToPackedDMS, METH_O, "DecToPackedDMS(double dfDec) -> double"},
 	 { "ParseXMLString", _wrap_ParseXMLString, METH_O, "ParseXMLString(char * pszXMLString) -> CPLXMLNode *"},
 	 { "SerializeXMLTree", _wrap_SerializeXMLTree, METH_O, "SerializeXMLTree(CPLXMLNode * xmlnode) -> retStringAndCPLFree *"},
 	 { "GetJPEG2000Structure", _wrap_GetJPEG2000Structure, METH_VARARGS, "GetJPEG2000Structure(char const * pszFilename, char ** options=None) -> CPLXMLNode *"},
 	 { "GetJPEG2000StructureAsString", _wrap_GetJPEG2000StructureAsString, METH_VARARGS, "GetJPEG2000StructureAsString(char const * pszFilename, char ** options=None) -> retStringAndCPLFree *"},
 	 { "HasTriangulation", _wrap_HasTriangulation, METH_NOARGS, "HasTriangulation() -> int"},
-	 { "GetDriverCount", _wrap_GetDriverCount, METH_NOARGS, "GetDriverCount() -> int"},
+	 { "GetDriverCount", _wrap_GetDriverCount, METH_NOARGS, "\n"
+		"GetDriverCount() -> int\n"
+		"\n"
+		"\n"
+		"Return the number of registered drivers.\n"
+		"See :cpp:func:`GDALGetDriverCount`.\n"
+		"\n"
+		"Examples\n"
+		"--------\n"
+		">>> gdal.GetDriverCount()\n"
+		"227\n"
+		">>> gdal.GetDriverByName('ESRI Shapefile').Deregister()\n"
+		">>> gdal.GetDriverCount()\n"
+		"226\n"
+		"\n"
+		"\n"
+		""},
 	 { "GetDriverByName", _wrap_GetDriverByName, METH_O, "GetDriverByName(char const * name) -> Driver"},
 	 { "GetDriver", _wrap_GetDriver, METH_O, "GetDriver(int i) -> Driver"},
-	 { "Open", _wrap_Open, METH_VARARGS, "Open(char const * utf8_path, GDALAccess eAccess=GA_ReadOnly) -> Dataset"},
-	 { "OpenEx", (PyCFunction)(void(*)(void))_wrap_OpenEx, METH_VARARGS|METH_KEYWORDS, "OpenEx(char const * utf8_path, unsigned int nOpenFlags=0, char ** allowed_drivers=None, char ** open_options=None, char ** sibling_files=None) -> Dataset"},
-	 { "OpenShared", _wrap_OpenShared, METH_VARARGS, "OpenShared(char const * utf8_path, GDALAccess eAccess=GA_ReadOnly) -> Dataset"},
+	 { "Open", _wrap_Open, METH_VARARGS, "\n"
+		"Open(char const * utf8_path, GDALAccess eAccess=GA_ReadOnly) -> Dataset\n"
+		"\n"
+		"\n"
+		"Opens a raster file as a :py:class:`Dataset` using default options.\n"
+		"See :cpp:func:`GDALOpen`.\n"
+		"For more control over how the file is opened, use :py:func:`OpenEx`.\n"
+		"\n"
+		"Parameters\n"
+		"----------\n"
+		"utf8_path : str\n"
+		"    name of the file to open\n"
+		"eAccess : int, default = :py:const:`gdal.GA_ReadOnly`\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"Dataset, or ``None`` on failure\n"
+		"\n"
+		"See Also\n"
+		"--------\n"
+		":py:func:`OpenEx`\n"
+		":py:func:`OpenShared`\n"
+		"\n"
+		"\n"
+		""},
+	 { "OpenEx", (PyCFunction)(void(*)(void))_wrap_OpenEx, METH_VARARGS|METH_KEYWORDS, "\n"
+		"OpenEx(char const * utf8_path, unsigned int nOpenFlags=0, char ** allowed_drivers=None, char ** open_options=None, char ** sibling_files=None) -> Dataset\n"
+		"\n"
+		"\n"
+		"Open a raster or vector file as a :py:class:`Dataset`.\n"
+		"See :cpp:func:`GDALOpenEx`.\n"
+		"\n"
+		"Parameters\n"
+		"----------\n"
+		"utf8_path : str\n"
+		"    name of the file to open\n"
+		"flags : int\n"
+		"        Flags controlling how the Dataset is opened. Multiple ``gdal.OF_XXX`` flags\n"
+		"        may be combined using the ``|`` operator. See :cpp:func:`GDALOpenEx`.\n"
+		"allowed_drivers : list, optional\n"
+		"        A list of the names of drivers that may attempt to open the dataset.\n"
+		"open_options : dict/list, optional\n"
+		"        A dict or list of name=value driver-specific opening options.\n"
+		"sibling_files: list, optional\n"
+		"        A list of filenames that are auxiliary to the main filename\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"Dataset, or ``None`` on failure.\n"
+		"\n"
+		"See Also\n"
+		"--------\n"
+		":py:func:`Open`\n"
+		":py:func:`OpenShared`\n"
+		"\n"
+		"\n"
+		""},
+	 { "OpenShared", _wrap_OpenShared, METH_VARARGS, "\n"
+		"OpenShared(char const * utf8_path, GDALAccess eAccess=GA_ReadOnly) -> Dataset\n"
+		"\n"
+		"\n"
+		"Open a raster file as a :py:class:`Dataset`. If the file has already been\n"
+		"opened in the current thread, return a reference to the already-opened\n"
+		":py:class:`Dataset`.  See :cpp:func:`GDALOpenShared`.\n"
+		"\n"
+		"Parameters\n"
+		"----------\n"
+		"utf8_path : str\n"
+		"    name of the file to open\n"
+		"eAccess : int, default = :py:const:`gdal.GA_ReadOnly`\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"Dataset, or ``None`` on failure\n"
+		"\n"
+		"See Also\n"
+		"--------\n"
+		":py:func:`Open`\n"
+		":py:func:`OpenEx`\n"
+		"\n"
+		"\n"
+		""},
 	 { "IdentifyDriver", _wrap_IdentifyDriver, METH_VARARGS, "IdentifyDriver(char const * utf8_path, char ** papszSiblings=None) -> Driver"},
 	 { "IdentifyDriverEx", (PyCFunction)(void(*)(void))_wrap_IdentifyDriverEx, METH_VARARGS|METH_KEYWORDS, "IdentifyDriverEx(char const * utf8_path, unsigned int nIdentifyFlags=0, char ** allowed_drivers=None, char ** sibling_files=None) -> Driver"},
 	 { "GeneralCmdLineProcessor", _wrap_GeneralCmdLineProcessor, METH_VARARGS, "GeneralCmdLineProcessor(char ** papszArgv, int nOptions=0) -> char **"},
 	 { "new_GDALInfoOptions", _wrap_new_GDALInfoOptions, METH_O, "new_GDALInfoOptions(char ** options) -> GDALInfoOptions"},
 	 { "delete_GDALInfoOptions", _wrap_delete_GDALInfoOptions, METH_O, "delete_GDALInfoOptions(GDALInfoOptions self)"},
 	 { "GDALInfoOptions_swigregister", GDALInfoOptions_swigregister, METH_O, NULL},
 	 { "GDALInfoOptions_swiginit", GDALInfoOptions_swiginit, METH_VARARGS, NULL},
@@ -53852,14 +57070,19 @@
 	 { "wrapper_GDALFootprintDestName", _wrap_wrapper_GDALFootprintDestName, METH_VARARGS, "wrapper_GDALFootprintDestName(char const * dest, Dataset srcDS, GDALFootprintOptions options, GDALProgressFunc callback=0, void * callback_data=None) -> Dataset"},
 	 { "new_GDALBuildVRTOptions", _wrap_new_GDALBuildVRTOptions, METH_O, "new_GDALBuildVRTOptions(char ** options) -> GDALBuildVRTOptions"},
 	 { "delete_GDALBuildVRTOptions", _wrap_delete_GDALBuildVRTOptions, METH_O, "delete_GDALBuildVRTOptions(GDALBuildVRTOptions self)"},
 	 { "GDALBuildVRTOptions_swigregister", GDALBuildVRTOptions_swigregister, METH_O, NULL},
 	 { "GDALBuildVRTOptions_swiginit", GDALBuildVRTOptions_swiginit, METH_VARARGS, NULL},
 	 { "BuildVRTInternalObjects", _wrap_BuildVRTInternalObjects, METH_VARARGS, "BuildVRTInternalObjects(char const * dest, int object_list_count, GDALBuildVRTOptions options, GDALProgressFunc callback=0, void * callback_data=None) -> Dataset"},
 	 { "BuildVRTInternalNames", _wrap_BuildVRTInternalNames, METH_VARARGS, "BuildVRTInternalNames(char const * dest, char ** source_filenames, GDALBuildVRTOptions options, GDALProgressFunc callback=0, void * callback_data=None) -> Dataset"},
+	 { "new_GDALTileIndexOptions", _wrap_new_GDALTileIndexOptions, METH_O, "new_GDALTileIndexOptions(char ** options) -> GDALTileIndexOptions"},
+	 { "delete_GDALTileIndexOptions", _wrap_delete_GDALTileIndexOptions, METH_O, "delete_GDALTileIndexOptions(GDALTileIndexOptions self)"},
+	 { "GDALTileIndexOptions_swigregister", GDALTileIndexOptions_swigregister, METH_O, NULL},
+	 { "GDALTileIndexOptions_swiginit", GDALTileIndexOptions_swiginit, METH_VARARGS, NULL},
+	 { "TileIndexInternalNames", _wrap_TileIndexInternalNames, METH_VARARGS, "TileIndexInternalNames(char const * dest, char ** source_filenames, GDALTileIndexOptions options, GDALProgressFunc callback=0, void * callback_data=None) -> Dataset"},
 	 { "new_GDALMultiDimTranslateOptions", _wrap_new_GDALMultiDimTranslateOptions, METH_O, "new_GDALMultiDimTranslateOptions(char ** options) -> GDALMultiDimTranslateOptions"},
 	 { "delete_GDALMultiDimTranslateOptions", _wrap_delete_GDALMultiDimTranslateOptions, METH_O, "delete_GDALMultiDimTranslateOptions(GDALMultiDimTranslateOptions self)"},
 	 { "GDALMultiDimTranslateOptions_swigregister", GDALMultiDimTranslateOptions_swigregister, METH_O, NULL},
 	 { "GDALMultiDimTranslateOptions_swiginit", GDALMultiDimTranslateOptions_swiginit, METH_VARARGS, NULL},
 	 { "wrapper_GDALMultiDimTranslateDestName", _wrap_wrapper_GDALMultiDimTranslateDestName, METH_VARARGS, "wrapper_GDALMultiDimTranslateDestName(char const * dest, int object_list_count, GDALMultiDimTranslateOptions multiDimTranslateOptions, GDALProgressFunc callback=0, void * callback_data=None) -> Dataset"},
 	 { NULL, NULL, 0, NULL }
 };
@@ -53908,43 +57131,47 @@
 static swig_type_info _swigt__p_GDALNearblackOptions = {"_p_GDALNearblackOptions", "GDALNearblackOptions *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_GDALProgressFunc = {"_p_GDALProgressFunc", "GDALProgressFunc *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_GDALRasterAttributeTableShadow = {"_p_GDALRasterAttributeTableShadow", "GDALRasterAttributeTableShadow *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_GDALRasterBandShadow = {"_p_GDALRasterBandShadow", "GDALRasterBandShadow *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_GDALRasterizeOptions = {"_p_GDALRasterizeOptions", "GDALRasterizeOptions *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_GDALRelationshipShadow = {"_p_GDALRelationshipShadow", "GDALRelationshipShadow *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_GDALSubdatasetInfo = {"_p_GDALSubdatasetInfo", "GDALSubdatasetInfoShadow *|GDALSubdatasetInfo *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_GDALTileIndexOptions = {"_p_GDALTileIndexOptions", "GDALTileIndexOptions *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_GDALTransformerInfoShadow = {"_p_GDALTransformerInfoShadow", "GDALTransformerInfoShadow *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_GDALTranslateOptions = {"_p_GDALTranslateOptions", "GDALTranslateOptions *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_GDALVectorInfoOptions = {"_p_GDALVectorInfoOptions", "GDALVectorInfoOptions *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_GDALVectorTranslateOptions = {"_p_GDALVectorTranslateOptions", "GDALVectorTranslateOptions *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_GDALViewshedMode = {"_p_GDALViewshedMode", "GDALViewshedMode *|enum GDALViewshedMode *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_GDALViewshedOutputType = {"_p_GDALViewshedOutputType", "GDALViewshedOutputType *|enum GDALViewshedOutputType *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_GDALWarpAppOptions = {"_p_GDALWarpAppOptions", "GDALWarpAppOptions *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_GDAL_GCP = {"_p_GDAL_GCP", "GDAL_GCP *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_GIntBig = {"_p_GIntBig", "GIntBig *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_GUIntBig = {"_p_GUIntBig", "GUIntBig *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_OGRFeatureShadow = {"_p_OGRFeatureShadow", "OGRFeatureShadow *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_OGRFieldDomainShadow = {"_p_OGRFieldDomainShadow", "OGRFieldDomainShadow *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_OGRGeomFieldDefnShadow = {"_p_OGRGeomFieldDefnShadow", "OGRGeomFieldDefnShadow *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_OGRGeometryShadow = {"_p_OGRGeometryShadow", "OGRGeometryShadow *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_OGRLayerShadow = {"_p_OGRLayerShadow", "OGRLayerShadow *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_OGRStyleTableShadow = {"_p_OGRStyleTableShadow", "OGRStyleTableShadow *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_OSRSpatialReferenceShadow = {"_p_OSRSpatialReferenceShadow", "OSRSpatialReferenceShadow *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_StatBuf = {"_p_StatBuf", "StatBuf *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_Statistics = {"_p_Statistics", "Statistics *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_SuggestedWarpOutputRes = {"_p_SuggestedWarpOutputRes", "SuggestedWarpOutputRes *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_VSIDIR = {"_p_VSIDIR", "VSIDIR *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_VSILFILE = {"_p_VSILFILE", "VSILFILE *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_bool = {"_p_bool", "bool *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_char = {"_p_char", "retStringAndCPLFree *|char *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_double = {"_p_double", "double *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_f_double_p_q_const__char_p_void__int = {"_p_f_double_p_q_const__char_p_void__int", "int (*)(double,char const *,void *)", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_int = {"_p_int", "CPLErr *|GDALAccess *|GDALAsyncStatusType *|GDALColorInterp *|GDALDataType *|GDALPaletteInterp *|GDALRATFieldType *|GDALRATFieldUsage *|GDALRATTableType *|GDALRIOResampleAlg *|GDALRWFlag *|GDALRelationshipCardinality *|GDALRelationshipType *|GDALResampleAlg *|GDALTileOrganization *|OGRAxisOrientation *|OGRErr *|OGRFieldDomainMergePolicy *|OGRFieldDomainSplitPolicy *|OGRFieldDomainType *|OGRFieldSubType *|OGRFieldType *|OGRJustification *|OGRwkbByteOrder *|OGRwkbGeometryType *|OSRAxisMappingStrategy *|RETURN_NONE *|int *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_p_GByte = {"_p_p_GByte", "GByte **", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_p_GDALDatasetShadow = {"_p_p_GDALDatasetShadow", "GDALDatasetShadow **", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_p_GDALDimensionHS = {"_p_p_GDALDimensionHS", "GDALDimensionHS **", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_p_GDALEDTComponentHS = {"_p_p_GDALEDTComponentHS", "GDALEDTComponentHS **", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_p_GDALMDArrayHS = {"_p_p_GDALMDArrayHS", "GDALMDArrayHS **", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_p_GDALRasterBandShadow = {"_p_p_GDALRasterBandShadow", "GDALRasterBandShadow **", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_p_GDAL_GCP = {"_p_p_GDAL_GCP", "GDAL_GCP **", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_p_GUIntBig = {"_p_p_GUIntBig", "GUIntBig **", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_p_OGRLayerShadow = {"_p_p_OGRLayerShadow", "OGRLayerShadow **", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_p_OSRSpatialReferenceShadow = {"_p_p_OSRSpatialReferenceShadow", "OSRSpatialReferenceShadow **", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_p_char = {"_p_p_char", "char **", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_p_double = {"_p_p_double", "double **", 0, 0, (void*)0, 0};
@@ -53987,43 +57214,47 @@
   &_swigt__p_GDALNearblackOptions,
   &_swigt__p_GDALProgressFunc,
   &_swigt__p_GDALRasterAttributeTableShadow,
   &_swigt__p_GDALRasterBandShadow,
   &_swigt__p_GDALRasterizeOptions,
   &_swigt__p_GDALRelationshipShadow,
   &_swigt__p_GDALSubdatasetInfo,
+  &_swigt__p_GDALTileIndexOptions,
   &_swigt__p_GDALTransformerInfoShadow,
   &_swigt__p_GDALTranslateOptions,
   &_swigt__p_GDALVectorInfoOptions,
   &_swigt__p_GDALVectorTranslateOptions,
   &_swigt__p_GDALViewshedMode,
   &_swigt__p_GDALViewshedOutputType,
   &_swigt__p_GDALWarpAppOptions,
   &_swigt__p_GDAL_GCP,
   &_swigt__p_GIntBig,
   &_swigt__p_GUIntBig,
   &_swigt__p_OGRFeatureShadow,
   &_swigt__p_OGRFieldDomainShadow,
+  &_swigt__p_OGRGeomFieldDefnShadow,
   &_swigt__p_OGRGeometryShadow,
   &_swigt__p_OGRLayerShadow,
   &_swigt__p_OGRStyleTableShadow,
   &_swigt__p_OSRSpatialReferenceShadow,
   &_swigt__p_StatBuf,
   &_swigt__p_Statistics,
   &_swigt__p_SuggestedWarpOutputRes,
   &_swigt__p_VSIDIR,
   &_swigt__p_VSILFILE,
+  &_swigt__p_bool,
   &_swigt__p_char,
   &_swigt__p_double,
   &_swigt__p_f_double_p_q_const__char_p_void__int,
   &_swigt__p_int,
   &_swigt__p_p_GByte,
   &_swigt__p_p_GDALDatasetShadow,
   &_swigt__p_p_GDALDimensionHS,
   &_swigt__p_p_GDALEDTComponentHS,
+  &_swigt__p_p_GDALMDArrayHS,
   &_swigt__p_p_GDALRasterBandShadow,
   &_swigt__p_p_GDAL_GCP,
   &_swigt__p_p_GUIntBig,
   &_swigt__p_p_OGRLayerShadow,
   &_swigt__p_p_OSRSpatialReferenceShadow,
   &_swigt__p_p_char,
   &_swigt__p_p_double,
@@ -54066,43 +57297,47 @@
 static swig_cast_info _swigc__p_GDALNearblackOptions[] = {  {&_swigt__p_GDALNearblackOptions, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_GDALProgressFunc[] = {  {&_swigt__p_GDALProgressFunc, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_GDALRasterAttributeTableShadow[] = {  {&_swigt__p_GDALRasterAttributeTableShadow, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_GDALRasterBandShadow[] = {  {&_swigt__p_GDALRasterBandShadow, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_GDALRasterizeOptions[] = {  {&_swigt__p_GDALRasterizeOptions, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_GDALRelationshipShadow[] = {  {&_swigt__p_GDALRelationshipShadow, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_GDALSubdatasetInfo[] = {  {&_swigt__p_GDALSubdatasetInfo, 0, 0, 0},{0, 0, 0, 0}};
+static swig_cast_info _swigc__p_GDALTileIndexOptions[] = {  {&_swigt__p_GDALTileIndexOptions, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_GDALTransformerInfoShadow[] = {  {&_swigt__p_GDALTransformerInfoShadow, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_GDALTranslateOptions[] = {  {&_swigt__p_GDALTranslateOptions, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_GDALVectorInfoOptions[] = {  {&_swigt__p_GDALVectorInfoOptions, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_GDALVectorTranslateOptions[] = {  {&_swigt__p_GDALVectorTranslateOptions, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_GDALViewshedMode[] = {  {&_swigt__p_GDALViewshedMode, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_GDALViewshedOutputType[] = {  {&_swigt__p_GDALViewshedOutputType, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_GDALWarpAppOptions[] = {  {&_swigt__p_GDALWarpAppOptions, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_GDAL_GCP[] = {  {&_swigt__p_GDAL_GCP, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_GIntBig[] = {  {&_swigt__p_GIntBig, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_GUIntBig[] = {  {&_swigt__p_GUIntBig, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_OGRFeatureShadow[] = {  {&_swigt__p_OGRFeatureShadow, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_OGRFieldDomainShadow[] = {  {&_swigt__p_OGRFieldDomainShadow, 0, 0, 0},{0, 0, 0, 0}};
+static swig_cast_info _swigc__p_OGRGeomFieldDefnShadow[] = {  {&_swigt__p_OGRGeomFieldDefnShadow, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_OGRGeometryShadow[] = {  {&_swigt__p_OGRGeometryShadow, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_OGRLayerShadow[] = {  {&_swigt__p_OGRLayerShadow, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_OGRStyleTableShadow[] = {  {&_swigt__p_OGRStyleTableShadow, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_OSRSpatialReferenceShadow[] = {  {&_swigt__p_OSRSpatialReferenceShadow, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_StatBuf[] = {  {&_swigt__p_StatBuf, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_Statistics[] = {  {&_swigt__p_Statistics, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_SuggestedWarpOutputRes[] = {  {&_swigt__p_SuggestedWarpOutputRes, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_VSIDIR[] = {  {&_swigt__p_VSIDIR, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_VSILFILE[] = {  {&_swigt__p_VSILFILE, 0, 0, 0},{0, 0, 0, 0}};
+static swig_cast_info _swigc__p_bool[] = {  {&_swigt__p_bool, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_char[] = {  {&_swigt__p_char, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_double[] = {  {&_swigt__p_double, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_f_double_p_q_const__char_p_void__int[] = {  {&_swigt__p_f_double_p_q_const__char_p_void__int, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_int[] = {  {&_swigt__p_int, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_p_GByte[] = {  {&_swigt__p_p_GByte, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_p_GDALDatasetShadow[] = {  {&_swigt__p_p_GDALDatasetShadow, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_p_GDALDimensionHS[] = {  {&_swigt__p_p_GDALDimensionHS, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_p_GDALEDTComponentHS[] = {  {&_swigt__p_p_GDALEDTComponentHS, 0, 0, 0},{0, 0, 0, 0}};
+static swig_cast_info _swigc__p_p_GDALMDArrayHS[] = {  {&_swigt__p_p_GDALMDArrayHS, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_p_GDALRasterBandShadow[] = {  {&_swigt__p_p_GDALRasterBandShadow, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_p_GDAL_GCP[] = {  {&_swigt__p_p_GDAL_GCP, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_p_GUIntBig[] = {  {&_swigt__p_p_GUIntBig, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_p_OGRLayerShadow[] = {  {&_swigt__p_p_OGRLayerShadow, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_p_OSRSpatialReferenceShadow[] = {  {&_swigt__p_p_OSRSpatialReferenceShadow, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_p_char[] = {  {&_swigt__p_p_char, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_p_double[] = {  {&_swigt__p_p_double, 0, 0, 0},{0, 0, 0, 0}};
@@ -54145,43 +57380,47 @@
   _swigc__p_GDALNearblackOptions,
   _swigc__p_GDALProgressFunc,
   _swigc__p_GDALRasterAttributeTableShadow,
   _swigc__p_GDALRasterBandShadow,
   _swigc__p_GDALRasterizeOptions,
   _swigc__p_GDALRelationshipShadow,
   _swigc__p_GDALSubdatasetInfo,
+  _swigc__p_GDALTileIndexOptions,
   _swigc__p_GDALTransformerInfoShadow,
   _swigc__p_GDALTranslateOptions,
   _swigc__p_GDALVectorInfoOptions,
   _swigc__p_GDALVectorTranslateOptions,
   _swigc__p_GDALViewshedMode,
   _swigc__p_GDALViewshedOutputType,
   _swigc__p_GDALWarpAppOptions,
   _swigc__p_GDAL_GCP,
   _swigc__p_GIntBig,
   _swigc__p_GUIntBig,
   _swigc__p_OGRFeatureShadow,
   _swigc__p_OGRFieldDomainShadow,
+  _swigc__p_OGRGeomFieldDefnShadow,
   _swigc__p_OGRGeometryShadow,
   _swigc__p_OGRLayerShadow,
   _swigc__p_OGRStyleTableShadow,
   _swigc__p_OSRSpatialReferenceShadow,
   _swigc__p_StatBuf,
   _swigc__p_Statistics,
   _swigc__p_SuggestedWarpOutputRes,
   _swigc__p_VSIDIR,
   _swigc__p_VSILFILE,
+  _swigc__p_bool,
   _swigc__p_char,
   _swigc__p_double,
   _swigc__p_f_double_p_q_const__char_p_void__int,
   _swigc__p_int,
   _swigc__p_p_GByte,
   _swigc__p_p_GDALDatasetShadow,
   _swigc__p_p_GDALDimensionHS,
   _swigc__p_p_GDALEDTComponentHS,
+  _swigc__p_p_GDALMDArrayHS,
   _swigc__p_p_GDALRasterBandShadow,
   _swigc__p_p_GDAL_GCP,
   _swigc__p_p_GUIntBig,
   _swigc__p_p_OGRLayerShadow,
   _swigc__p_p_OSRSpatialReferenceShadow,
   _swigc__p_p_char,
   _swigc__p_p_double,
```

### Comparing `GDAL-3.8.5/extensions/gdalconst_wrap.c` & `GDAL-3.9.0/extensions/gdalconst_wrap.c`

 * *Files identical despite different names*

### Comparing `GDAL-3.8.5/extensions/gnm_wrap.cpp` & `GDAL-3.9.0/extensions/gnm_wrap.cpp`

 * *Files identical despite different names*

### Comparing `GDAL-3.8.5/extensions/ogr_wrap.cpp` & `GDAL-3.9.0/extensions/ogr_wrap.cpp`

 * *Files 2% similar despite different names*

```diff
@@ -2983,47 +2983,49 @@
 
 
 /* -------- TYPES TABLE (BEGIN) -------- */
 
 #define SWIGTYPE_p_ArrowArray swig_types[0]
 #define SWIGTYPE_p_ArrowArrayStream swig_types[1]
 #define SWIGTYPE_p_ArrowSchema swig_types[2]
-#define SWIGTYPE_p_GDALMajorObjectShadow swig_types[3]
-#define SWIGTYPE_p_GDALProgressFunc swig_types[4]
-#define SWIGTYPE_p_GIntBig swig_types[5]
-#define SWIGTYPE_p_OGRCodedValue swig_types[6]
-#define SWIGTYPE_p_OGRDataSourceShadow swig_types[7]
-#define SWIGTYPE_p_OGRDriverShadow swig_types[8]
-#define SWIGTYPE_p_OGRFeatureDefnShadow swig_types[9]
-#define SWIGTYPE_p_OGRFeatureShadow swig_types[10]
-#define SWIGTYPE_p_OGRFieldDefnShadow swig_types[11]
-#define SWIGTYPE_p_OGRFieldDomainShadow swig_types[12]
-#define SWIGTYPE_p_OGRGeomFieldDefnShadow swig_types[13]
-#define SWIGTYPE_p_OGRGeomTransformerShadow swig_types[14]
-#define SWIGTYPE_p_OGRGeometryShadow swig_types[15]
-#define SWIGTYPE_p_OGRLayerShadow swig_types[16]
-#define SWIGTYPE_p_OGRPreparedGeometryShadow swig_types[17]
-#define SWIGTYPE_p_OGRStyleTableShadow swig_types[18]
-#define SWIGTYPE_p_OSRCoordinateTransformationShadow swig_types[19]
-#define SWIGTYPE_p_OSRSpatialReferenceShadow swig_types[20]
-#define SWIGTYPE_p_bool swig_types[21]
-#define SWIGTYPE_p_char swig_types[22]
-#define SWIGTYPE_p_double swig_types[23]
-#define SWIGTYPE_p_f_double_p_q_const__char_p_void__int swig_types[24]
-#define SWIGTYPE_p_float swig_types[25]
-#define SWIGTYPE_p_int swig_types[26]
-#define SWIGTYPE_p_p_GIntBig swig_types[27]
-#define SWIGTYPE_p_p_OGRGeometryTypeCounter swig_types[28]
-#define SWIGTYPE_p_p_OGRSpatialReferenceH swig_types[29]
-#define SWIGTYPE_p_p_char swig_types[30]
-#define SWIGTYPE_p_p_double swig_types[31]
-#define SWIGTYPE_p_p_int swig_types[32]
-#define SWIGTYPE_p_size_t swig_types[33]
-static swig_type_info *swig_types[35];
-static swig_module_info swig_module = {swig_types, 34, 0, 0, 0, 0};
+#define SWIGTYPE_p_GDALDatasetShadow swig_types[3]
+#define SWIGTYPE_p_GDALMajorObjectShadow swig_types[4]
+#define SWIGTYPE_p_GDALProgressFunc swig_types[5]
+#define SWIGTYPE_p_GIntBig swig_types[6]
+#define SWIGTYPE_p_OGRCodedValue swig_types[7]
+#define SWIGTYPE_p_OGRDataSourceShadow swig_types[8]
+#define SWIGTYPE_p_OGRDriverShadow swig_types[9]
+#define SWIGTYPE_p_OGRFeatureDefnShadow swig_types[10]
+#define SWIGTYPE_p_OGRFeatureShadow swig_types[11]
+#define SWIGTYPE_p_OGRFieldDefnShadow swig_types[12]
+#define SWIGTYPE_p_OGRFieldDomainShadow swig_types[13]
+#define SWIGTYPE_p_OGRGeomCoordinatePrecisionShadow swig_types[14]
+#define SWIGTYPE_p_OGRGeomFieldDefnShadow swig_types[15]
+#define SWIGTYPE_p_OGRGeomTransformerShadow swig_types[16]
+#define SWIGTYPE_p_OGRGeometryShadow swig_types[17]
+#define SWIGTYPE_p_OGRLayerShadow swig_types[18]
+#define SWIGTYPE_p_OGRPreparedGeometryShadow swig_types[19]
+#define SWIGTYPE_p_OGRStyleTableShadow swig_types[20]
+#define SWIGTYPE_p_OSRCoordinateTransformationShadow swig_types[21]
+#define SWIGTYPE_p_OSRSpatialReferenceShadow swig_types[22]
+#define SWIGTYPE_p_bool swig_types[23]
+#define SWIGTYPE_p_char swig_types[24]
+#define SWIGTYPE_p_double swig_types[25]
+#define SWIGTYPE_p_f_double_p_q_const__char_p_void__int swig_types[26]
+#define SWIGTYPE_p_float swig_types[27]
+#define SWIGTYPE_p_int swig_types[28]
+#define SWIGTYPE_p_p_GIntBig swig_types[29]
+#define SWIGTYPE_p_p_OGRGeometryTypeCounter swig_types[30]
+#define SWIGTYPE_p_p_OGRSpatialReferenceH swig_types[31]
+#define SWIGTYPE_p_p_char swig_types[32]
+#define SWIGTYPE_p_p_double swig_types[33]
+#define SWIGTYPE_p_p_int swig_types[34]
+#define SWIGTYPE_p_size_t swig_types[35]
+static swig_type_info *swig_types[37];
+static swig_module_info swig_module = {swig_types, 36, 0, 0, 0, 0};
 #define SWIG_TypeQuery(name) SWIG_TypeQueryModule(&swig_module, &swig_module, name)
 #define SWIG_MangledTypeQuery(name) SWIG_MangledTypeQueryModule(&swig_module, &swig_module, name)
 
 /* -------- TYPES TABLE (END) -------- */
 
 #ifdef SWIG_TypeQuery
 # undef SWIG_TypeQuery
@@ -3187,14 +3189,15 @@
 #include "ogr_recordbatch.h"
 #include "ogr_p.h"
 
 #define FIELD_INDEX_ERROR_TMPL "Invalid field index: '%i'"
 #define FIELD_NAME_ERROR_TMPL "Invalid field name: '%s'"
 
 typedef void GDALMajorObjectShadow;
+typedef void GDALDatasetShadow;
 
 #ifdef DEBUG
 typedef struct OGRSpatialReferenceHS OSRSpatialReferenceShadow;
 typedef struct OGRDriverHS OGRDriverShadow;
 typedef struct OGRDataSourceHS OGRDataSourceShadow;
 typedef struct OGRLayerHS OGRLayerShadow;
 typedef struct OGRFeatureHS OGRFeatureShadow;
@@ -3215,14 +3218,15 @@
 #endif
 
 typedef struct OGRStyleTableHS OGRStyleTableShadow;
 typedef struct OGRGeomFieldDefnHS OGRGeomFieldDefnShadow;
 typedef struct OGRGeomTransformer OGRGeomTransformerShadow;
 typedef struct _OGRPreparedGeometry OGRPreparedGeometryShadow;
 typedef struct OGRFieldDomainHS OGRFieldDomainShadow;
+typedef struct OGRGeomCoordinatePrecision OGRGeomCoordinatePrecisionShadow;
 
 
 SWIGINTERNINLINE PyObject*
   SWIG_From_int  (int value)
 {
   return PyInt_FromLong((long) value);
 }
@@ -4410,14 +4414,94 @@
       }
       else
       {
           free(array);
           return NULL;
       }
   }
+
+static void ReleaseArrowArrayStreamPyCapsule(PyObject* capsule) {
+    struct ArrowArrayStream* stream =
+        (struct ArrowArrayStream*)PyCapsule_GetPointer(capsule, "arrow_array_stream");
+    if (stream->release != NULL) {
+        stream->release(stream);
+    }
+    CPLFree(stream);
+}
+
+static char** ParseArrowMetadata(const char *pabyMetadata)
+{
+    char** ret = NULL;
+    int32_t nKVP;
+    memcpy(&nKVP, pabyMetadata, sizeof(int32_t));
+    pabyMetadata += sizeof(int32_t);
+    for (int i = 0; i < nKVP; ++i)
+    {
+        int32_t nSizeKey;
+        memcpy(&nSizeKey, pabyMetadata, sizeof(int32_t));
+        pabyMetadata += sizeof(int32_t);
+        std::string osKey;
+        osKey.assign(pabyMetadata, nSizeKey);
+        pabyMetadata += nSizeKey;
+
+        int32_t nSizeValue;
+        memcpy(&nSizeValue, pabyMetadata, sizeof(int32_t));
+        pabyMetadata += sizeof(int32_t);
+        std::string osValue;
+        osValue.assign(pabyMetadata, nSizeValue);
+        pabyMetadata += nSizeValue;
+
+        ret = CSLSetNameValue(ret, osKey.c_str(), osValue.c_str());
+    }
+
+    return ret;
+}
+
+// Create output fields using CreateFieldFromArrowSchema()
+static bool CreateFieldsFromArrowSchema(OGRLayerH hDstLayer,
+                                        const struct ArrowSchema* schemaSrc,
+                                        char** options)
+{
+    for (int i = 0; i < schemaSrc->n_children; ++i)
+    {
+        const char *metadata =
+            schemaSrc->children[i]->metadata;
+        if( metadata )
+        {
+            char** keyValues = ParseArrowMetadata(metadata);
+            const char *ARROW_EXTENSION_NAME_KEY = "ARROW:extension:name";
+            const char *EXTENSION_NAME_OGC_WKB = "ogc.wkb";
+            const char *EXTENSION_NAME_GEOARROW_WKB = "geoarrow.wkb";
+            const char* value = CSLFetchNameValue(keyValues, ARROW_EXTENSION_NAME_KEY);
+            const bool bSkip = ( value && (EQUAL(value, EXTENSION_NAME_OGC_WKB) || EQUAL(value, EXTENSION_NAME_GEOARROW_WKB)) );
+            CSLDestroy(keyValues);
+            if( bSkip )
+                continue;
+        }
+
+        const char *pszFieldName =
+            schemaSrc->children[i]->name;
+        if (!EQUAL(pszFieldName, "OGC_FID") &&
+            !EQUAL(pszFieldName, "wkb_geometry") &&
+            !OGR_L_CreateFieldFromArrowSchema(
+                hDstLayer, schemaSrc->children[i], options))
+        {
+            CPLError(CE_Failure, CPLE_AppDefined,
+                     "Cannot create field %s",
+                     pszFieldName);
+            return false;
+        }
+    }
+    return true;
+}
+
+
+SWIGINTERN GDALDatasetShadow *OGRLayerShadow_GetDataset(OGRLayerShadow *self){
+      return OGR_L_GetDataset(self);
+  }
 SWIGINTERN OGRErr OGRLayerShadow_Rename(OGRLayerShadow *self,char const *new_name){
     return OGR_L_Rename( self, new_name);
   }
 SWIGINTERN int OGRLayerShadow_GetRefCount(OGRLayerShadow *self){
     return OGR_L_GetRefCount(self);
   }
 SWIGINTERN void OGRLayerShadow_SetSpatialFilter__SWIG_0(OGRLayerShadow *self,OGRGeometryShadow *filter){
@@ -4553,14 +4637,22 @@
     OGRErr eErr = OGR_L_GetExtentEx(self, geom_field, (OGREnvelope*)argout, force);
     if (can_return_null)
         *isvalid = (eErr == 0);
     else
         *isvalid = TRUE;
     return;
   }
+SWIGINTERN void OGRLayerShadow_GetExtent3D(OGRLayerShadow *self,double argout[6],int *isvalid=NULL,int force=1,int can_return_null=0,int geom_field=0){
+    OGRErr eErr = OGR_L_GetExtent3D(self, geom_field, (OGREnvelope3D*)argout, force);
+    if (can_return_null)
+        *isvalid = (eErr == 0);
+    else
+        *isvalid = TRUE;
+    return;
+  }
 SWIGINTERN bool OGRLayerShadow_TestCapability(OGRLayerShadow *self,char const *cap){
     return (OGR_L_TestCapability(self, cap) > 0);
   }
 SWIGINTERN OGRErr OGRLayerShadow_CreateField(OGRLayerShadow *self,OGRFieldDefnShadow *field_def,int approx_ok=1){
     return OGR_L_CreateField(self, field_def, approx_ok);
   }
 SWIGINTERN OGRErr OGRLayerShadow_DeleteField(OGRLayerShadow *self,int iField){
@@ -4636,14 +4728,37 @@
 SWIGINTERN OGRStyleTableShadow *OGRLayerShadow_GetStyleTable(OGRLayerShadow *self){
     return (OGRStyleTableShadow*) OGR_L_GetStyleTable(self);
   }
 SWIGINTERN void OGRLayerShadow_SetStyleTable(OGRLayerShadow *self,OGRStyleTableShadow *table){
     if( table != NULL )
         OGR_L_SetStyleTable(self, (OGRStyleTableH) table);
   }
+SWIGINTERN PyObject *OGRLayerShadow_ExportArrowArrayStreamPyCapsule(OGRLayerShadow *self,char **options=NULL){
+        struct ArrowArrayStream* stream =
+            (struct ArrowArrayStream*)CPLMalloc(sizeof(struct ArrowArrayStream));
+
+        const int success = OGR_L_GetArrowStream(self, stream, options);
+
+        PyObject* ret;
+        SWIG_PYTHON_THREAD_BEGIN_BLOCK;
+        if( success )
+        {
+            ret = PyCapsule_New(stream, "arrow_array_stream", ReleaseArrowArrayStreamPyCapsule);
+        }
+        else
+        {
+            CPLFree(stream);
+            Py_INCREF(Py_None);
+            ret = Py_None;
+        }
+
+        SWIG_PYTHON_THREAD_END_BLOCK;
+
+        return ret;
+    }
 SWIGINTERN ArrowArrayStream *OGRLayerShadow_GetArrowStream(OGRLayerShadow *self,char **options=NULL){
       struct ArrowArrayStream* stream = (struct ArrowArrayStream* )malloc(sizeof(struct ArrowArrayStream));
       if( OGR_L_GetArrowStream(self, stream, options) )
           return stream;
       else
       {
           free(stream);
@@ -4655,14 +4770,124 @@
     }
 SWIGINTERN OGRErr OGRLayerShadow_CreateFieldFromArrowSchema(OGRLayerShadow *self,ArrowSchema const *schema,char **options=NULL){
         return OGR_L_CreateFieldFromArrowSchema(self, schema, options) ? 0 : 6;
     }
 SWIGINTERN OGRErr OGRLayerShadow_WriteArrowBatch(OGRLayerShadow *self,ArrowSchema const *schema,ArrowArray *array,char **options=NULL){
         return OGR_L_WriteArrowBatch(self, schema, array, options) ? 0 : 6;
     }
+SWIGINTERN OGRErr OGRLayerShadow_WriteArrowStreamCapsule(OGRLayerShadow *self,PyObject *capsule,int createFieldsFromSchema,char **options=NULL){
+        ArrowArrayStream* stream = (ArrowArrayStream*)PyCapsule_GetPointer(capsule, "arrow_array_stream");
+        if( !stream )
+        {
+            CPLError(CE_Failure, CPLE_AppDefined, "PyCapsule_GetPointer(capsule, \"arrow_array_stream\") failed");
+            return 6;
+        }
+        if( stream->release == NULL )
+        {
+            CPLError(CE_Failure, CPLE_AppDefined, "stream->release == NULL");
+            return 6;
+        }
+
+        ArrowSchema schema;
+        if( stream->get_schema(stream, &schema) != 0 )
+        {
+            stream->release(stream);
+            return 6;
+        }
+
+        if( createFieldsFromSchema == TRUE ||
+            (createFieldsFromSchema == -1 && OGR_FD_GetFieldCount(OGR_L_GetLayerDefn(self)) == 0) )
+        {
+            if( !CreateFieldsFromArrowSchema(self, &schema, options) )
+            {
+                schema.release(&schema);
+                stream->release(stream);
+                return 6;
+            }
+        }
+
+        while( true )
+        {
+            ArrowArray array;
+            if( stream->get_next(stream, &array) == 0 )
+            {
+                if( array.release == NULL )
+                    break;
+                if( !OGR_L_WriteArrowBatch(self, &schema, &array, options) )
+                {
+                    if( array.release )
+                        array.release(&array);
+                    schema.release(&schema);
+                    stream->release(stream);
+                    return 6;
+                }
+                if( array.release )
+                    array.release(&array);
+            }
+            else
+            {
+                CPLError(CE_Failure, CPLE_AppDefined, "stream->get_next(stream, &array) failed");
+                schema.release(&schema);
+                stream->release(stream);
+                return 6;
+            }
+        }
+        schema.release(&schema);
+        stream->release(stream);
+        return 0;
+    }
+SWIGINTERN OGRErr OGRLayerShadow_WriteArrowSchemaAndArrowArrayCapsule(OGRLayerShadow *self,PyObject *schemaCapsule,PyObject *arrayCapsule,int createFieldsFromSchema,char **options=NULL){
+        ArrowSchema* schema = (ArrowSchema*)PyCapsule_GetPointer(schemaCapsule, "arrow_schema");
+        if( !schema )
+        {
+            CPLError(CE_Failure, CPLE_AppDefined, "PyCapsule_GetPointer(schemaCapsule, \"arrow_schema\") failed");
+            return 6;
+        }
+        if( schema->release == NULL )
+        {
+            CPLError(CE_Failure, CPLE_AppDefined, "schema->release == NULL");
+            return 6;
+        }
+
+        if( createFieldsFromSchema == TRUE ||
+            (createFieldsFromSchema == -1 && OGR_FD_GetFieldCount(OGR_L_GetLayerDefn(self)) == 0) )
+        {
+            if( !CreateFieldsFromArrowSchema(self, schema, options) )
+            {
+                schema->release(schema);
+                return 6;
+            }
+        }
+
+        ArrowArray* array = (ArrowArray*)PyCapsule_GetPointer(arrayCapsule, "arrow_array");
+        if( !array )
+        {
+            CPLError(CE_Failure, CPLE_AppDefined, "PyCapsule_GetPointer(arrayCapsule, \"arrow_array\") failed");
+            schema->release(schema);
+            return 6;
+        }
+        if( array->release == NULL )
+        {
+            CPLError(CE_Failure, CPLE_AppDefined, "array->release == NULL");
+            schema->release(schema);
+            return 6;
+        }
+
+        OGRErr eErr = 0;
+        if( !OGR_L_WriteArrowBatch(self, schema, array, options) )
+        {
+            eErr = 6;
+        }
+
+        if( schema->release )
+            schema->release(schema);
+        if( array->release )
+            array->release(array);
+        return eErr;
+    }
 SWIGINTERN void OGRLayerShadow_GetGeometryTypes(OGRLayerShadow *self,OGRGeometryTypeCounter **ppRet,int *pnEntryCount,int geom_field=0,int flags=0,GDALProgressFunc callback=NULL,void *callback_data=NULL){
         *ppRet = OGR_L_GetGeometryTypes(self, geom_field, flags, pnEntryCount, callback, callback_data);
     }
 SWIGINTERN void OGRLayerShadow_GetSupportedSRSList(OGRLayerShadow *self,OGRSpatialReferenceH **ppRet,int *pnEntryCount,int geom_field=0){
         *ppRet = OGR_L_GetSupportedSRSList(self, geom_field, pnEntryCount);
     }
 SWIGINTERN OGRErr OGRLayerShadow_SetActiveSRS(OGRLayerShadow *self,int geom_field,OSRSpatialReferenceShadow *srs){
@@ -5616,14 +5841,20 @@
   }
 SWIGINTERN int OGRGeomFieldDefnShadow_IsNullable(OGRGeomFieldDefnShadow *self){
     return OGR_GFld_IsNullable( self );
   }
 SWIGINTERN void OGRGeomFieldDefnShadow_SetNullable(OGRGeomFieldDefnShadow *self,int bNullable){
     return OGR_GFld_SetNullable( self, bNullable );
   }
+SWIGINTERN OGRGeomCoordinatePrecisionShadow *OGRGeomFieldDefnShadow_GetCoordinatePrecision(OGRGeomFieldDefnShadow *self){
+    return OGR_GFld_GetCoordinatePrecision(self);
+  }
+SWIGINTERN void OGRGeomFieldDefnShadow_SetCoordinatePrecision(OGRGeomFieldDefnShadow *self,OGRGeomCoordinatePrecisionShadow *coordPrec){
+    OGR_GFld_SetCoordinatePrecision(self, coordPrec);
+  }
 
   OGRGeometryShadow* CreateGeometryFromWkb( size_t len, char *bin_string,
                                             OSRSpatialReferenceShadow *reference=NULL ) {
     OGRGeometryH geom = NULL;
     OGRErr err = OGR_G_CreateFromWkbEx( (unsigned char *) bin_string,
                                         reference,
                                         &geom,
@@ -5993,14 +6224,17 @@
   }
 SWIGINTERN double OGRGeometryShadow_Length(OGRGeometryShadow *self){
     return OGR_G_Length(self);
   }
 SWIGINTERN double OGRGeometryShadow_Area(OGRGeometryShadow *self){
     return OGR_G_Area(self);
   }
+SWIGINTERN double OGRGeometryShadow_GeodesicArea(OGRGeometryShadow *self){
+    return OGR_G_GeodesicArea(self);
+  }
 SWIGINTERN bool OGRGeometryShadow_IsClockwise(OGRGeometryShadow *self){
     return OGR_G_IsClockwise(self);
   }
 SWIGINTERN double OGRGeometryShadow_GetArea(OGRGeometryShadow *self){
     return OGR_G_Area(self);
   }
 SWIGINTERN int OGRGeometryShadow_GetPointCount(OGRGeometryShadow *self){
@@ -6109,14 +6343,17 @@
   }
 SWIGINTERN OGRGeometryShadow *OGRGeometryShadow_ConcaveHull(OGRGeometryShadow *self,double ratio,bool allowHoles){
     return (OGRGeometryShadow*) OGR_G_ConcaveHull(self, ratio, allowHoles);
   }
 SWIGINTERN OGRGeometryShadow *OGRGeometryShadow_MakeValid(OGRGeometryShadow *self,char **options=NULL){
     return (OGRGeometryShadow*) OGR_G_MakeValidEx(self, options);
   }
+SWIGINTERN OGRGeometryShadow *OGRGeometryShadow_SetPrecision(OGRGeometryShadow *self,double gridSize,int flags=0){
+    return (OGRGeometryShadow*) OGR_G_SetPrecision(self, gridSize, flags);
+  }
 SWIGINTERN OGRGeometryShadow *OGRGeometryShadow_Normalize(OGRGeometryShadow *self){
     return (OGRGeometryShadow*) OGR_G_Normalize(self);
   }
 SWIGINTERN OGRGeometryShadow *OGRGeometryShadow_RemoveLowerDimensionSubGeoms(OGRGeometryShadow *self){
     return (OGRGeometryShadow*) OGR_G_RemoveLowerDimensionSubGeoms(self);
   }
 SWIGINTERN OGRGeometryShadow *OGRGeometryShadow_Buffer(OGRGeometryShadow *self,double distance,int quadsecs=30){
@@ -6127,14 +6364,17 @@
   }
 SWIGINTERN OGRGeometryShadow *OGRGeometryShadow_Union(OGRGeometryShadow *self,OGRGeometryShadow *other){
     return (OGRGeometryShadow*) OGR_G_Union( self, other );
   }
 SWIGINTERN OGRGeometryShadow *OGRGeometryShadow_UnionCascaded(OGRGeometryShadow *self){
     return (OGRGeometryShadow*) OGR_G_UnionCascaded( self );
   }
+SWIGINTERN OGRGeometryShadow *OGRGeometryShadow_UnaryUnion(OGRGeometryShadow *self){
+    return (OGRGeometryShadow*) OGR_G_UnaryUnion( self );
+  }
 SWIGINTERN OGRGeometryShadow *OGRGeometryShadow_Difference(OGRGeometryShadow *self,OGRGeometryShadow *other){
     return (OGRGeometryShadow*) OGR_G_Difference( self, other );
   }
 SWIGINTERN OGRGeometryShadow *OGRGeometryShadow_SymDifference(OGRGeometryShadow *self,OGRGeometryShadow *other){
     return (OGRGeometryShadow*) OGR_G_SymDifference( self, other );
   }
 SWIGINTERN OGRGeometryShadow *OGRGeometryShadow_SymmetricDifference(OGRGeometryShadow *self,OGRGeometryShadow *other){
@@ -6539,14 +6779,47 @@
   return (OGRFieldDomainShadow*) OGR_GlobFldDomain_Create( name,
                                                            description,
                                                            type,
                                                            subtype,
                                                            glob );
 }
 
+SWIGINTERN void delete_OGRGeomCoordinatePrecisionShadow(OGRGeomCoordinatePrecisionShadow *self){
+    OGRGeomCoordinatePrecisionDestroy(self);
+  }
+SWIGINTERN void OGRGeomCoordinatePrecisionShadow_Set(OGRGeomCoordinatePrecisionShadow *self,double xyResolution,double zResolution,double mResolution){
+      OGRGeomCoordinatePrecisionSet(self, xyResolution, zResolution, mResolution);
+  }
+SWIGINTERN void OGRGeomCoordinatePrecisionShadow_SetFromMeter(OGRGeomCoordinatePrecisionShadow *self,OSRSpatialReferenceShadow *srs,double xyMeterResolution,double zMeterResolution,double mResolution){
+      OGRGeomCoordinatePrecisionSetFromMeter(self, srs, xyMeterResolution, zMeterResolution, mResolution);
+  }
+SWIGINTERN double OGRGeomCoordinatePrecisionShadow_GetXYResolution(OGRGeomCoordinatePrecisionShadow *self){
+    return OGRGeomCoordinatePrecisionGetXYResolution(self);
+  }
+SWIGINTERN double OGRGeomCoordinatePrecisionShadow_GetZResolution(OGRGeomCoordinatePrecisionShadow *self){
+    return OGRGeomCoordinatePrecisionGetZResolution(self);
+  }
+SWIGINTERN double OGRGeomCoordinatePrecisionShadow_GetMResolution(OGRGeomCoordinatePrecisionShadow *self){
+    return OGRGeomCoordinatePrecisionGetMResolution(self);
+  }
+SWIGINTERN char **OGRGeomCoordinatePrecisionShadow_GetFormats(OGRGeomCoordinatePrecisionShadow *self){
+    return OGRGeomCoordinatePrecisionGetFormats(self);
+  }
+SWIGINTERN char **OGRGeomCoordinatePrecisionShadow_GetFormatSpecificOptions(OGRGeomCoordinatePrecisionShadow *self,char const *formatName){
+    return OGRGeomCoordinatePrecisionGetFormatSpecificOptions(self, formatName);
+  }
+SWIGINTERN void OGRGeomCoordinatePrecisionShadow_SetFormatSpecificOptions(OGRGeomCoordinatePrecisionShadow *self,char const *formatName,char **formatSpecificOptions){
+    OGRGeomCoordinatePrecisionSetFormatSpecificOptions(self, formatName, formatSpecificOptions);
+  }
+
+static
+OGRGeomCoordinatePrecisionShadow* CreateGeomCoordinatePrecision() {
+  return OGRGeomCoordinatePrecisionCreate();
+}
+
 
 char const *OGRDriverShadow_get_name( OGRDriverShadow *h ) {
   return OGR_Dr_GetName( h );
 }
 
 char const *OGRDataSourceShadow_get_name( OGRDataSourceShadow *h ) {
   return OGR_DS_GetName( h );
@@ -10766,14 +11039,59 @@
 SWIGINTERN PyObject *ArrowArrayStream_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
   PyObject *obj;
   if (!SWIG_Python_UnpackTuple(args, "swigregister", 1, 1, &obj)) return NULL;
   SWIG_TypeNewClientData(SWIGTYPE_p_ArrowArrayStream, SWIG_NewClientData(obj));
   return SWIG_Py_Void();
 }
 
+SWIGINTERN PyObject *_wrap_Layer_GetDataset(PyObject *self, PyObject *args) {
+  PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
+  OGRLayerShadow *arg1 = (OGRLayerShadow *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject *swig_obj[1] ;
+  GDALDatasetShadow *result = 0 ;
+  
+  if (!args) SWIG_fail;
+  swig_obj[0] = args;
+  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_OGRLayerShadow, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Layer_GetDataset" "', argument " "1"" of type '" "OGRLayerShadow *""'"); 
+  }
+  arg1 = reinterpret_cast< OGRLayerShadow * >(argp1);
+  {
+    const int bLocalUseExceptions = GetUseExceptions();
+    if ( bLocalUseExceptions ) {
+      pushErrorHandler();
+    }
+    {
+      SWIG_PYTHON_THREAD_BEGIN_ALLOW;
+      result = (GDALDatasetShadow *)OGRLayerShadow_GetDataset(arg1);
+      SWIG_PYTHON_THREAD_END_ALLOW;
+    }
+    if ( bLocalUseExceptions ) {
+      popErrorHandler();
+    }
+#ifndef SED_HACKS
+    if ( bLocalUseExceptions ) {
+      CPLErr eclass = CPLGetLastErrorType();
+      if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+        SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+      }
+    }
+#endif
+  }
+  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_GDALDatasetShadow, 0 |  0 );
+  if ( ReturnSame(bLocalUseExceptionsCode) ) { CPLErr eclass = CPLGetLastErrorType(); if ( eclass == CE_Failure || eclass == CE_Fatal ) { Py_XDECREF(resultobj); SWIG_Error( SWIG_RuntimeError, CPLGetLastErrorMsg() ); return NULL; } }
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
 SWIGINTERN PyObject *_wrap_Layer_Rename(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
   OGRLayerShadow *arg1 = (OGRLayerShadow *) 0 ;
   char *arg2 = (char *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   int res2 ;
@@ -12454,14 +12772,114 @@
   if ( ReturnSame(bLocalUseExceptionsCode) ) { CPLErr eclass = CPLGetLastErrorType(); if ( eclass == CE_Failure || eclass == CE_Fatal ) { Py_XDECREF(resultobj); SWIG_Error( SWIG_RuntimeError, CPLGetLastErrorMsg() ); return NULL; } }
   return resultobj;
 fail:
   return NULL;
 }
 
 
+SWIGINTERN PyObject *_wrap_Layer_GetExtent3D(PyObject *self, PyObject *args, PyObject *kwargs) {
+  PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
+  OGRLayerShadow *arg1 = (OGRLayerShadow *) 0 ;
+  double *arg2 ;
+  int *arg3 = (int *) NULL ;
+  int arg4 = (int) 1 ;
+  int arg5 = (int) 0 ;
+  int arg6 = (int) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  double argout2[6] ;
+  int isvalid2 ;
+  int val4 ;
+  int ecode4 = 0 ;
+  int val5 ;
+  int ecode5 = 0 ;
+  int val6 ;
+  int ecode6 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  PyObject * obj2 = 0 ;
+  PyObject * obj3 = 0 ;
+  char * kwnames[] = {
+    (char *)"self",  (char *)"force",  (char *)"can_return_null",  (char *)"geom_field",  NULL 
+  };
+  
+  {
+    /* %typemap(in,numinputs=0) (double argout2[6], int* isvalid2) */
+    arg2 = argout2;
+    arg3 = &isvalid2;
+  }
+  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O|OOO:Layer_GetExtent3D", kwnames, &obj0, &obj1, &obj2, &obj3)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_OGRLayerShadow, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Layer_GetExtent3D" "', argument " "1"" of type '" "OGRLayerShadow *""'"); 
+  }
+  arg1 = reinterpret_cast< OGRLayerShadow * >(argp1);
+  if (obj1) {
+    ecode4 = SWIG_AsVal_int(obj1, &val4);
+    if (!SWIG_IsOK(ecode4)) {
+      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Layer_GetExtent3D" "', argument " "4"" of type '" "int""'");
+    } 
+    arg4 = static_cast< int >(val4);
+  }
+  if (obj2) {
+    ecode5 = SWIG_AsVal_int(obj2, &val5);
+    if (!SWIG_IsOK(ecode5)) {
+      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "Layer_GetExtent3D" "', argument " "5"" of type '" "int""'");
+    } 
+    arg5 = static_cast< int >(val5);
+  }
+  if (obj3) {
+    ecode6 = SWIG_AsVal_int(obj3, &val6);
+    if (!SWIG_IsOK(ecode6)) {
+      SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "Layer_GetExtent3D" "', argument " "6"" of type '" "int""'");
+    } 
+    arg6 = static_cast< int >(val6);
+  }
+  {
+    const int bLocalUseExceptions = GetUseExceptions();
+    if ( bLocalUseExceptions ) {
+      pushErrorHandler();
+    }
+    {
+      SWIG_PYTHON_THREAD_BEGIN_ALLOW;
+      OGRLayerShadow_GetExtent3D(arg1,arg2,arg3,arg4,arg5,arg6);
+      SWIG_PYTHON_THREAD_END_ALLOW;
+    }
+    if ( bLocalUseExceptions ) {
+      popErrorHandler();
+    }
+#ifndef SED_HACKS
+    if ( bLocalUseExceptions ) {
+      CPLErr eclass = CPLGetLastErrorType();
+      if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+        SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+      }
+    }
+#endif
+  }
+  resultobj = SWIG_Py_Void();
+  {
+    /* %typemap(argout) (double argout[6], int* isvalid)  */
+    PyObject *r;
+    if ( !*arg3 ) {
+      Py_INCREF(Py_None);
+      r = Py_None;
+    }
+    else {
+      r = CreateTupleFromDoubleArray(arg2, 6);
+    }
+    resultobj = t_output_helper(resultobj,r);
+  }
+  if ( ReturnSame(bLocalUseExceptionsCode) ) { CPLErr eclass = CPLGetLastErrorType(); if ( eclass == CE_Failure || eclass == CE_Fatal ) { Py_XDECREF(resultobj); SWIG_Error( SWIG_RuntimeError, CPLGetLastErrorMsg() ); return NULL; } }
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
 SWIGINTERN PyObject *_wrap_Layer_TestCapability(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
   OGRLayerShadow *arg1 = (OGRLayerShadow *) 0 ;
   char *arg2 = (char *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   int res2 ;
@@ -14904,14 +15322,93 @@
   if ( ReturnSame(bLocalUseExceptionsCode) ) { CPLErr eclass = CPLGetLastErrorType(); if ( eclass == CE_Failure || eclass == CE_Fatal ) { Py_XDECREF(resultobj); SWIG_Error( SWIG_RuntimeError, CPLGetLastErrorMsg() ); return NULL; } }
   return resultobj;
 fail:
   return NULL;
 }
 
 
+SWIGINTERN PyObject *_wrap_Layer_ExportArrowArrayStreamPyCapsule(PyObject *self, PyObject *args) {
+  PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
+  OGRLayerShadow *arg1 = (OGRLayerShadow *) 0 ;
+  char **arg2 = (char **) NULL ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject *swig_obj[2] ;
+  PyObject *result = 0 ;
+  
+  if (!SWIG_Python_UnpackTuple(args, "Layer_ExportArrowArrayStreamPyCapsule", 1, 2, swig_obj)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_OGRLayerShadow, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Layer_ExportArrowArrayStreamPyCapsule" "', argument " "1"" of type '" "OGRLayerShadow *""'"); 
+  }
+  arg1 = reinterpret_cast< OGRLayerShadow * >(argp1);
+  if (swig_obj[1]) {
+    {
+      /* %typemap(in) char **dict */
+      arg2 = NULL;
+      if ( PySequence_Check( swig_obj[1] ) ) {
+        int bErr = FALSE;
+        arg2 = CSLFromPySequence(swig_obj[1], &bErr);
+        if ( bErr )
+        {
+          SWIG_fail;
+        }
+      }
+      else if ( PyMapping_Check( swig_obj[1] ) ) {
+        int bErr = FALSE;
+        arg2 = CSLFromPyMapping(swig_obj[1], &bErr);
+        if ( bErr )
+        {
+          SWIG_fail;
+        }
+      }
+      else {
+        PyErr_SetString(PyExc_TypeError,"Argument must be dictionary or sequence of strings");
+        SWIG_fail;
+      }
+    }
+  }
+  {
+    const int bLocalUseExceptions = GetUseExceptions();
+    if ( bLocalUseExceptions ) {
+      pushErrorHandler();
+    }
+    {
+      SWIG_PYTHON_THREAD_BEGIN_ALLOW;
+      result = (PyObject *)OGRLayerShadow_ExportArrowArrayStreamPyCapsule(arg1,arg2);
+      SWIG_PYTHON_THREAD_END_ALLOW;
+    }
+    if ( bLocalUseExceptions ) {
+      popErrorHandler();
+    }
+#ifndef SED_HACKS
+    if ( bLocalUseExceptions ) {
+      CPLErr eclass = CPLGetLastErrorType();
+      if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+        SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+      }
+    }
+#endif
+  }
+  resultobj = result;
+  {
+    /* %typemap(freearg) char **dict */
+    CSLDestroy( arg2 );
+  }
+  if ( ReturnSame(bLocalUseExceptionsCode) ) { CPLErr eclass = CPLGetLastErrorType(); if ( eclass == CE_Failure || eclass == CE_Fatal ) { Py_XDECREF(resultobj); SWIG_Error( SWIG_RuntimeError, CPLGetLastErrorMsg() ); return NULL; } }
+  return resultobj;
+fail:
+  {
+    /* %typemap(freearg) char **dict */
+    CSLDestroy( arg2 );
+  }
+  return NULL;
+}
+
+
 SWIGINTERN PyObject *_wrap_Layer_GetArrowStream(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
   OGRLayerShadow *arg1 = (OGRLayerShadow *) 0 ;
   char **arg2 = (char **) NULL ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   PyObject *swig_obj[2] ;
@@ -15308,14 +15805,226 @@
     /* %typemap(freearg) char **dict */
     CSLDestroy( arg4 );
   }
   return NULL;
 }
 
 
+SWIGINTERN PyObject *_wrap_Layer_WriteArrowStreamCapsule(PyObject *self, PyObject *args) {
+  PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
+  OGRLayerShadow *arg1 = (OGRLayerShadow *) 0 ;
+  PyObject *arg2 = (PyObject *) 0 ;
+  int arg3 ;
+  char **arg4 = (char **) NULL ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  int val3 ;
+  int ecode3 = 0 ;
+  PyObject *swig_obj[4] ;
+  OGRErr result;
+  
+  if (!SWIG_Python_UnpackTuple(args, "Layer_WriteArrowStreamCapsule", 3, 4, swig_obj)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_OGRLayerShadow, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Layer_WriteArrowStreamCapsule" "', argument " "1"" of type '" "OGRLayerShadow *""'"); 
+  }
+  arg1 = reinterpret_cast< OGRLayerShadow * >(argp1);
+  arg2 = swig_obj[1];
+  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
+  if (!SWIG_IsOK(ecode3)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Layer_WriteArrowStreamCapsule" "', argument " "3"" of type '" "int""'");
+  } 
+  arg3 = static_cast< int >(val3);
+  if (swig_obj[3]) {
+    {
+      /* %typemap(in) char **dict */
+      arg4 = NULL;
+      if ( PySequence_Check( swig_obj[3] ) ) {
+        int bErr = FALSE;
+        arg4 = CSLFromPySequence(swig_obj[3], &bErr);
+        if ( bErr )
+        {
+          SWIG_fail;
+        }
+      }
+      else if ( PyMapping_Check( swig_obj[3] ) ) {
+        int bErr = FALSE;
+        arg4 = CSLFromPyMapping(swig_obj[3], &bErr);
+        if ( bErr )
+        {
+          SWIG_fail;
+        }
+      }
+      else {
+        PyErr_SetString(PyExc_TypeError,"Argument must be dictionary or sequence of strings");
+        SWIG_fail;
+      }
+    }
+  }
+  {
+    const int bLocalUseExceptions = GetUseExceptions();
+    if ( bLocalUseExceptions ) {
+      pushErrorHandler();
+    }
+    {
+      SWIG_PYTHON_THREAD_BEGIN_ALLOW;
+      result = (OGRErr)OGRLayerShadow_WriteArrowStreamCapsule(arg1,arg2,arg3,arg4);
+      SWIG_PYTHON_THREAD_END_ALLOW;
+    }
+    if ( bLocalUseExceptions ) {
+      popErrorHandler();
+    }
+#ifndef SED_HACKS
+    if ( bLocalUseExceptions ) {
+      CPLErr eclass = CPLGetLastErrorType();
+      if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+        SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+      }
+    }
+#endif
+  }
+  {
+    /* %typemap(out) OGRErr */
+    if ( result != 0 && GetUseExceptions()) {
+      const char* pszMessage = CPLGetLastErrorMsg();
+      if( pszMessage[0] != '\0' )
+      PyErr_SetString( PyExc_RuntimeError, pszMessage );
+      else
+      PyErr_SetString( PyExc_RuntimeError, OGRErrMessages(result) );
+      SWIG_fail;
+    }
+  }
+  {
+    /* %typemap(freearg) char **dict */
+    CSLDestroy( arg4 );
+  }
+  {
+    /* %typemap(ret) OGRErr */
+    if ( ReturnSame(resultobj == Py_None || resultobj == 0) ) {
+      resultobj = PyInt_FromLong( result );
+    }
+  }
+  if ( ReturnSame(bLocalUseExceptionsCode) ) { CPLErr eclass = CPLGetLastErrorType(); if ( eclass == CE_Failure || eclass == CE_Fatal ) { Py_XDECREF(resultobj); SWIG_Error( SWIG_RuntimeError, CPLGetLastErrorMsg() ); return NULL; } }
+  return resultobj;
+fail:
+  {
+    /* %typemap(freearg) char **dict */
+    CSLDestroy( arg4 );
+  }
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_Layer_WriteArrowSchemaAndArrowArrayCapsule(PyObject *self, PyObject *args) {
+  PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
+  OGRLayerShadow *arg1 = (OGRLayerShadow *) 0 ;
+  PyObject *arg2 = (PyObject *) 0 ;
+  PyObject *arg3 = (PyObject *) 0 ;
+  int arg4 ;
+  char **arg5 = (char **) NULL ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  int val4 ;
+  int ecode4 = 0 ;
+  PyObject *swig_obj[5] ;
+  OGRErr result;
+  
+  if (!SWIG_Python_UnpackTuple(args, "Layer_WriteArrowSchemaAndArrowArrayCapsule", 4, 5, swig_obj)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_OGRLayerShadow, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Layer_WriteArrowSchemaAndArrowArrayCapsule" "', argument " "1"" of type '" "OGRLayerShadow *""'"); 
+  }
+  arg1 = reinterpret_cast< OGRLayerShadow * >(argp1);
+  arg2 = swig_obj[1];
+  arg3 = swig_obj[2];
+  ecode4 = SWIG_AsVal_int(swig_obj[3], &val4);
+  if (!SWIG_IsOK(ecode4)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Layer_WriteArrowSchemaAndArrowArrayCapsule" "', argument " "4"" of type '" "int""'");
+  } 
+  arg4 = static_cast< int >(val4);
+  if (swig_obj[4]) {
+    {
+      /* %typemap(in) char **dict */
+      arg5 = NULL;
+      if ( PySequence_Check( swig_obj[4] ) ) {
+        int bErr = FALSE;
+        arg5 = CSLFromPySequence(swig_obj[4], &bErr);
+        if ( bErr )
+        {
+          SWIG_fail;
+        }
+      }
+      else if ( PyMapping_Check( swig_obj[4] ) ) {
+        int bErr = FALSE;
+        arg5 = CSLFromPyMapping(swig_obj[4], &bErr);
+        if ( bErr )
+        {
+          SWIG_fail;
+        }
+      }
+      else {
+        PyErr_SetString(PyExc_TypeError,"Argument must be dictionary or sequence of strings");
+        SWIG_fail;
+      }
+    }
+  }
+  {
+    const int bLocalUseExceptions = GetUseExceptions();
+    if ( bLocalUseExceptions ) {
+      pushErrorHandler();
+    }
+    {
+      SWIG_PYTHON_THREAD_BEGIN_ALLOW;
+      result = (OGRErr)OGRLayerShadow_WriteArrowSchemaAndArrowArrayCapsule(arg1,arg2,arg3,arg4,arg5);
+      SWIG_PYTHON_THREAD_END_ALLOW;
+    }
+    if ( bLocalUseExceptions ) {
+      popErrorHandler();
+    }
+#ifndef SED_HACKS
+    if ( bLocalUseExceptions ) {
+      CPLErr eclass = CPLGetLastErrorType();
+      if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+        SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+      }
+    }
+#endif
+  }
+  {
+    /* %typemap(out) OGRErr */
+    if ( result != 0 && GetUseExceptions()) {
+      const char* pszMessage = CPLGetLastErrorMsg();
+      if( pszMessage[0] != '\0' )
+      PyErr_SetString( PyExc_RuntimeError, pszMessage );
+      else
+      PyErr_SetString( PyExc_RuntimeError, OGRErrMessages(result) );
+      SWIG_fail;
+    }
+  }
+  {
+    /* %typemap(freearg) char **dict */
+    CSLDestroy( arg5 );
+  }
+  {
+    /* %typemap(ret) OGRErr */
+    if ( ReturnSame(resultobj == Py_None || resultobj == 0) ) {
+      resultobj = PyInt_FromLong( result );
+    }
+  }
+  if ( ReturnSame(bLocalUseExceptionsCode) ) { CPLErr eclass = CPLGetLastErrorType(); if ( eclass == CE_Failure || eclass == CE_Fatal ) { Py_XDECREF(resultobj); SWIG_Error( SWIG_RuntimeError, CPLGetLastErrorMsg() ); return NULL; } }
+  return resultobj;
+fail:
+  {
+    /* %typemap(freearg) char **dict */
+    CSLDestroy( arg5 );
+  }
+  return NULL;
+}
+
+
 SWIGINTERN PyObject *_wrap_Layer_GetGeometryTypes(PyObject *self, PyObject *args, PyObject *kwargs) {
   PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
   OGRLayerShadow *arg1 = (OGRLayerShadow *) 0 ;
   OGRGeometryTypeCounter **arg2 = (OGRGeometryTypeCounter **) 0 ;
   int *arg3 = (int *) 0 ;
   int arg4 = (int) 0 ;
   int arg5 = (int) 0 ;
@@ -26051,14 +26760,110 @@
   if ( ReturnSame(bLocalUseExceptionsCode) ) { CPLErr eclass = CPLGetLastErrorType(); if ( eclass == CE_Failure || eclass == CE_Fatal ) { Py_XDECREF(resultobj); SWIG_Error( SWIG_RuntimeError, CPLGetLastErrorMsg() ); return NULL; } }
   return resultobj;
 fail:
   return NULL;
 }
 
 
+SWIGINTERN PyObject *_wrap_GeomFieldDefn_GetCoordinatePrecision(PyObject *self, PyObject *args) {
+  PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
+  OGRGeomFieldDefnShadow *arg1 = (OGRGeomFieldDefnShadow *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject *swig_obj[1] ;
+  OGRGeomCoordinatePrecisionShadow *result = 0 ;
+  
+  if (!args) SWIG_fail;
+  swig_obj[0] = args;
+  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_OGRGeomFieldDefnShadow, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GeomFieldDefn_GetCoordinatePrecision" "', argument " "1"" of type '" "OGRGeomFieldDefnShadow *""'"); 
+  }
+  arg1 = reinterpret_cast< OGRGeomFieldDefnShadow * >(argp1);
+  {
+    const int bLocalUseExceptions = GetUseExceptions();
+    if ( bLocalUseExceptions ) {
+      pushErrorHandler();
+    }
+    {
+      SWIG_PYTHON_THREAD_BEGIN_ALLOW;
+      result = (OGRGeomCoordinatePrecisionShadow *)OGRGeomFieldDefnShadow_GetCoordinatePrecision(arg1);
+      SWIG_PYTHON_THREAD_END_ALLOW;
+    }
+    if ( bLocalUseExceptions ) {
+      popErrorHandler();
+    }
+#ifndef SED_HACKS
+    if ( bLocalUseExceptions ) {
+      CPLErr eclass = CPLGetLastErrorType();
+      if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+        SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+      }
+    }
+#endif
+  }
+  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OGRGeomCoordinatePrecisionShadow, 0 |  0 );
+  if ( ReturnSame(bLocalUseExceptionsCode) ) { CPLErr eclass = CPLGetLastErrorType(); if ( eclass == CE_Failure || eclass == CE_Fatal ) { Py_XDECREF(resultobj); SWIG_Error( SWIG_RuntimeError, CPLGetLastErrorMsg() ); return NULL; } }
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_GeomFieldDefn_SetCoordinatePrecision(PyObject *self, PyObject *args) {
+  PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
+  OGRGeomFieldDefnShadow *arg1 = (OGRGeomFieldDefnShadow *) 0 ;
+  OGRGeomCoordinatePrecisionShadow *arg2 = (OGRGeomCoordinatePrecisionShadow *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  void *argp2 = 0 ;
+  int res2 = 0 ;
+  PyObject *swig_obj[2] ;
+  
+  if (!SWIG_Python_UnpackTuple(args, "GeomFieldDefn_SetCoordinatePrecision", 2, 2, swig_obj)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_OGRGeomFieldDefnShadow, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GeomFieldDefn_SetCoordinatePrecision" "', argument " "1"" of type '" "OGRGeomFieldDefnShadow *""'"); 
+  }
+  arg1 = reinterpret_cast< OGRGeomFieldDefnShadow * >(argp1);
+  res2 = SWIG_ConvertPtr(swig_obj[1], &argp2,SWIGTYPE_p_OGRGeomCoordinatePrecisionShadow, 0 |  0 );
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GeomFieldDefn_SetCoordinatePrecision" "', argument " "2"" of type '" "OGRGeomCoordinatePrecisionShadow *""'"); 
+  }
+  arg2 = reinterpret_cast< OGRGeomCoordinatePrecisionShadow * >(argp2);
+  {
+    const int bLocalUseExceptions = GetUseExceptions();
+    if ( bLocalUseExceptions ) {
+      pushErrorHandler();
+    }
+    {
+      SWIG_PYTHON_THREAD_BEGIN_ALLOW;
+      OGRGeomFieldDefnShadow_SetCoordinatePrecision(arg1,arg2);
+      SWIG_PYTHON_THREAD_END_ALLOW;
+    }
+    if ( bLocalUseExceptions ) {
+      popErrorHandler();
+    }
+#ifndef SED_HACKS
+    if ( bLocalUseExceptions ) {
+      CPLErr eclass = CPLGetLastErrorType();
+      if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+        SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+      }
+    }
+#endif
+  }
+  resultobj = SWIG_Py_Void();
+  if ( ReturnSame(bLocalUseExceptionsCode) ) { CPLErr eclass = CPLGetLastErrorType(); if ( eclass == CE_Failure || eclass == CE_Fatal ) { Py_XDECREF(resultobj); SWIG_Error( SWIG_RuntimeError, CPLGetLastErrorMsg() ); return NULL; } }
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
 SWIGINTERN PyObject *GeomFieldDefn_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
   PyObject *obj;
   if (!SWIG_Python_UnpackTuple(args, "swigregister", 1, 1, &obj)) return NULL;
   SWIG_TypeNewClientData(SWIGTYPE_p_OGRGeomFieldDefnShadow, SWIG_NewClientData(obj));
   return SWIG_Py_Void();
 }
 
@@ -28383,14 +29188,59 @@
   if ( ReturnSame(bLocalUseExceptionsCode) ) { CPLErr eclass = CPLGetLastErrorType(); if ( eclass == CE_Failure || eclass == CE_Fatal ) { Py_XDECREF(resultobj); SWIG_Error( SWIG_RuntimeError, CPLGetLastErrorMsg() ); return NULL; } }
   return resultobj;
 fail:
   return NULL;
 }
 
 
+SWIGINTERN PyObject *_wrap_Geometry_GeodesicArea(PyObject *self, PyObject *args) {
+  PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
+  OGRGeometryShadow *arg1 = (OGRGeometryShadow *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject *swig_obj[1] ;
+  double result;
+  
+  if (!args) SWIG_fail;
+  swig_obj[0] = args;
+  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_OGRGeometryShadow, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Geometry_GeodesicArea" "', argument " "1"" of type '" "OGRGeometryShadow *""'"); 
+  }
+  arg1 = reinterpret_cast< OGRGeometryShadow * >(argp1);
+  {
+    const int bLocalUseExceptions = GetUseExceptions();
+    if ( bLocalUseExceptions ) {
+      pushErrorHandler();
+    }
+    {
+      SWIG_PYTHON_THREAD_BEGIN_ALLOW;
+      result = (double)OGRGeometryShadow_GeodesicArea(arg1);
+      SWIG_PYTHON_THREAD_END_ALLOW;
+    }
+    if ( bLocalUseExceptions ) {
+      popErrorHandler();
+    }
+#ifndef SED_HACKS
+    if ( bLocalUseExceptions ) {
+      CPLErr eclass = CPLGetLastErrorType();
+      if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+        SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+      }
+    }
+#endif
+  }
+  resultobj = SWIG_From_double(static_cast< double >(result));
+  if ( ReturnSame(bLocalUseExceptionsCode) ) { CPLErr eclass = CPLGetLastErrorType(); if ( eclass == CE_Failure || eclass == CE_Fatal ) { Py_XDECREF(resultobj); SWIG_Error( SWIG_RuntimeError, CPLGetLastErrorMsg() ); return NULL; } }
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
 SWIGINTERN PyObject *_wrap_Geometry_IsClockwise(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
   OGRGeometryShadow *arg1 = (OGRGeometryShadow *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   PyObject *swig_obj[1] ;
   bool result;
@@ -30014,14 +30864,76 @@
     /* %typemap(freearg) char **dict */
     CSLDestroy( arg2 );
   }
   return NULL;
 }
 
 
+SWIGINTERN PyObject *_wrap_Geometry_SetPrecision(PyObject *self, PyObject *args) {
+  PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
+  OGRGeometryShadow *arg1 = (OGRGeometryShadow *) 0 ;
+  double arg2 ;
+  int arg3 = (int) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  double val2 ;
+  int ecode2 = 0 ;
+  int val3 ;
+  int ecode3 = 0 ;
+  PyObject *swig_obj[3] ;
+  OGRGeometryShadow *result = 0 ;
+  
+  if (!SWIG_Python_UnpackTuple(args, "Geometry_SetPrecision", 2, 3, swig_obj)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_OGRGeometryShadow, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Geometry_SetPrecision" "', argument " "1"" of type '" "OGRGeometryShadow *""'"); 
+  }
+  arg1 = reinterpret_cast< OGRGeometryShadow * >(argp1);
+  ecode2 = SWIG_AsVal_double(swig_obj[1], &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Geometry_SetPrecision" "', argument " "2"" of type '" "double""'");
+  } 
+  arg2 = static_cast< double >(val2);
+  if (swig_obj[2]) {
+    ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
+    if (!SWIG_IsOK(ecode3)) {
+      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Geometry_SetPrecision" "', argument " "3"" of type '" "int""'");
+    } 
+    arg3 = static_cast< int >(val3);
+  }
+  {
+    const int bLocalUseExceptions = GetUseExceptions();
+    if ( bLocalUseExceptions ) {
+      pushErrorHandler();
+    }
+    {
+      SWIG_PYTHON_THREAD_BEGIN_ALLOW;
+      result = (OGRGeometryShadow *)OGRGeometryShadow_SetPrecision(arg1,arg2,arg3);
+      SWIG_PYTHON_THREAD_END_ALLOW;
+    }
+    if ( bLocalUseExceptions ) {
+      popErrorHandler();
+    }
+#ifndef SED_HACKS
+    if ( bLocalUseExceptions ) {
+      CPLErr eclass = CPLGetLastErrorType();
+      if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+        SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+      }
+    }
+#endif
+  }
+  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OGRGeometryShadow, SWIG_POINTER_OWN |  0 );
+  if ( ReturnSame(bLocalUseExceptionsCode) ) { CPLErr eclass = CPLGetLastErrorType(); if ( eclass == CE_Failure || eclass == CE_Fatal ) { Py_XDECREF(resultobj); SWIG_Error( SWIG_RuntimeError, CPLGetLastErrorMsg() ); return NULL; } }
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
 SWIGINTERN PyObject *_wrap_Geometry_Normalize(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
   OGRGeometryShadow *arg1 = (OGRGeometryShadow *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   PyObject *swig_obj[1] ;
   OGRGeometryShadow *result = 0 ;
@@ -30330,14 +31242,59 @@
   if ( ReturnSame(bLocalUseExceptionsCode) ) { CPLErr eclass = CPLGetLastErrorType(); if ( eclass == CE_Failure || eclass == CE_Fatal ) { Py_XDECREF(resultobj); SWIG_Error( SWIG_RuntimeError, CPLGetLastErrorMsg() ); return NULL; } }
   return resultobj;
 fail:
   return NULL;
 }
 
 
+SWIGINTERN PyObject *_wrap_Geometry_UnaryUnion(PyObject *self, PyObject *args) {
+  PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
+  OGRGeometryShadow *arg1 = (OGRGeometryShadow *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject *swig_obj[1] ;
+  OGRGeometryShadow *result = 0 ;
+  
+  if (!args) SWIG_fail;
+  swig_obj[0] = args;
+  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_OGRGeometryShadow, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Geometry_UnaryUnion" "', argument " "1"" of type '" "OGRGeometryShadow *""'"); 
+  }
+  arg1 = reinterpret_cast< OGRGeometryShadow * >(argp1);
+  {
+    const int bLocalUseExceptions = GetUseExceptions();
+    if ( bLocalUseExceptions ) {
+      pushErrorHandler();
+    }
+    {
+      SWIG_PYTHON_THREAD_BEGIN_ALLOW;
+      result = (OGRGeometryShadow *)OGRGeometryShadow_UnaryUnion(arg1);
+      SWIG_PYTHON_THREAD_END_ALLOW;
+    }
+    if ( bLocalUseExceptions ) {
+      popErrorHandler();
+    }
+#ifndef SED_HACKS
+    if ( bLocalUseExceptions ) {
+      CPLErr eclass = CPLGetLastErrorType();
+      if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+        SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+      }
+    }
+#endif
+  }
+  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OGRGeometryShadow, SWIG_POINTER_OWN |  0 );
+  if ( ReturnSame(bLocalUseExceptionsCode) ) { CPLErr eclass = CPLGetLastErrorType(); if ( eclass == CE_Failure || eclass == CE_Fatal ) { Py_XDECREF(resultobj); SWIG_Error( SWIG_RuntimeError, CPLGetLastErrorMsg() ); return NULL; } }
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
 SWIGINTERN PyObject *_wrap_Geometry_Difference(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
   OGRGeometryShadow *arg1 = (OGRGeometryShadow *) 0 ;
   OGRGeometryShadow *arg2 = (OGRGeometryShadow *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   void *argp2 = 0 ;
@@ -34556,14 +35513,590 @@
   if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
   if (alloc5 == SWIG_NEWOBJ) delete[] buf5;
   return NULL;
 }
 
 
+SWIGINTERN PyObject *_wrap_delete_GeomCoordinatePrecision(PyObject *self, PyObject *args) {
+  PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
+  OGRGeomCoordinatePrecisionShadow *arg1 = (OGRGeomCoordinatePrecisionShadow *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject *swig_obj[1] ;
+  
+  if (!args) SWIG_fail;
+  swig_obj[0] = args;
+  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_OGRGeomCoordinatePrecisionShadow, SWIG_POINTER_DISOWN |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_GeomCoordinatePrecision" "', argument " "1"" of type '" "OGRGeomCoordinatePrecisionShadow *""'"); 
+  }
+  arg1 = reinterpret_cast< OGRGeomCoordinatePrecisionShadow * >(argp1);
+  {
+    const int bLocalUseExceptions = GetUseExceptions();
+    if ( bLocalUseExceptions ) {
+      pushErrorHandler();
+    }
+    {
+      SWIG_PYTHON_THREAD_BEGIN_ALLOW;
+      delete_OGRGeomCoordinatePrecisionShadow(arg1);
+      SWIG_PYTHON_THREAD_END_ALLOW;
+    }
+    if ( bLocalUseExceptions ) {
+      popErrorHandler();
+    }
+#ifndef SED_HACKS
+    if ( bLocalUseExceptions ) {
+      CPLErr eclass = CPLGetLastErrorType();
+      if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+        SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+      }
+    }
+#endif
+  }
+  resultobj = SWIG_Py_Void();
+  if ( ReturnSame(bLocalUseExceptionsCode) ) { CPLErr eclass = CPLGetLastErrorType(); if ( eclass == CE_Failure || eclass == CE_Fatal ) { Py_XDECREF(resultobj); SWIG_Error( SWIG_RuntimeError, CPLGetLastErrorMsg() ); return NULL; } }
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_GeomCoordinatePrecision_Set(PyObject *self, PyObject *args) {
+  PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
+  OGRGeomCoordinatePrecisionShadow *arg1 = (OGRGeomCoordinatePrecisionShadow *) 0 ;
+  double arg2 ;
+  double arg3 ;
+  double arg4 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  double val2 ;
+  int ecode2 = 0 ;
+  double val3 ;
+  int ecode3 = 0 ;
+  double val4 ;
+  int ecode4 = 0 ;
+  PyObject *swig_obj[4] ;
+  
+  if (!SWIG_Python_UnpackTuple(args, "GeomCoordinatePrecision_Set", 4, 4, swig_obj)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_OGRGeomCoordinatePrecisionShadow, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GeomCoordinatePrecision_Set" "', argument " "1"" of type '" "OGRGeomCoordinatePrecisionShadow *""'"); 
+  }
+  arg1 = reinterpret_cast< OGRGeomCoordinatePrecisionShadow * >(argp1);
+  ecode2 = SWIG_AsVal_double(swig_obj[1], &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GeomCoordinatePrecision_Set" "', argument " "2"" of type '" "double""'");
+  } 
+  arg2 = static_cast< double >(val2);
+  ecode3 = SWIG_AsVal_double(swig_obj[2], &val3);
+  if (!SWIG_IsOK(ecode3)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "GeomCoordinatePrecision_Set" "', argument " "3"" of type '" "double""'");
+  } 
+  arg3 = static_cast< double >(val3);
+  ecode4 = SWIG_AsVal_double(swig_obj[3], &val4);
+  if (!SWIG_IsOK(ecode4)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "GeomCoordinatePrecision_Set" "', argument " "4"" of type '" "double""'");
+  } 
+  arg4 = static_cast< double >(val4);
+  {
+    const int bLocalUseExceptions = GetUseExceptions();
+    if ( bLocalUseExceptions ) {
+      pushErrorHandler();
+    }
+    {
+      SWIG_PYTHON_THREAD_BEGIN_ALLOW;
+      OGRGeomCoordinatePrecisionShadow_Set(arg1,arg2,arg3,arg4);
+      SWIG_PYTHON_THREAD_END_ALLOW;
+    }
+    if ( bLocalUseExceptions ) {
+      popErrorHandler();
+    }
+#ifndef SED_HACKS
+    if ( bLocalUseExceptions ) {
+      CPLErr eclass = CPLGetLastErrorType();
+      if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+        SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+      }
+    }
+#endif
+  }
+  resultobj = SWIG_Py_Void();
+  if ( ReturnSame(bLocalUseExceptionsCode) ) { CPLErr eclass = CPLGetLastErrorType(); if ( eclass == CE_Failure || eclass == CE_Fatal ) { Py_XDECREF(resultobj); SWIG_Error( SWIG_RuntimeError, CPLGetLastErrorMsg() ); return NULL; } }
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_GeomCoordinatePrecision_SetFromMeter(PyObject *self, PyObject *args) {
+  PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
+  OGRGeomCoordinatePrecisionShadow *arg1 = (OGRGeomCoordinatePrecisionShadow *) 0 ;
+  OSRSpatialReferenceShadow *arg2 = (OSRSpatialReferenceShadow *) 0 ;
+  double arg3 ;
+  double arg4 ;
+  double arg5 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  void *argp2 = 0 ;
+  int res2 = 0 ;
+  double val3 ;
+  int ecode3 = 0 ;
+  double val4 ;
+  int ecode4 = 0 ;
+  double val5 ;
+  int ecode5 = 0 ;
+  PyObject *swig_obj[5] ;
+  
+  if (!SWIG_Python_UnpackTuple(args, "GeomCoordinatePrecision_SetFromMeter", 5, 5, swig_obj)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_OGRGeomCoordinatePrecisionShadow, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GeomCoordinatePrecision_SetFromMeter" "', argument " "1"" of type '" "OGRGeomCoordinatePrecisionShadow *""'"); 
+  }
+  arg1 = reinterpret_cast< OGRGeomCoordinatePrecisionShadow * >(argp1);
+  res2 = SWIG_ConvertPtr(swig_obj[1], &argp2,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GeomCoordinatePrecision_SetFromMeter" "', argument " "2"" of type '" "OSRSpatialReferenceShadow *""'"); 
+  }
+  arg2 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp2);
+  ecode3 = SWIG_AsVal_double(swig_obj[2], &val3);
+  if (!SWIG_IsOK(ecode3)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "GeomCoordinatePrecision_SetFromMeter" "', argument " "3"" of type '" "double""'");
+  } 
+  arg3 = static_cast< double >(val3);
+  ecode4 = SWIG_AsVal_double(swig_obj[3], &val4);
+  if (!SWIG_IsOK(ecode4)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "GeomCoordinatePrecision_SetFromMeter" "', argument " "4"" of type '" "double""'");
+  } 
+  arg4 = static_cast< double >(val4);
+  ecode5 = SWIG_AsVal_double(swig_obj[4], &val5);
+  if (!SWIG_IsOK(ecode5)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "GeomCoordinatePrecision_SetFromMeter" "', argument " "5"" of type '" "double""'");
+  } 
+  arg5 = static_cast< double >(val5);
+  {
+    if (!arg2) {
+      SWIG_exception(SWIG_ValueError,"Received a NULL pointer.");
+    }
+  }
+  {
+    const int bLocalUseExceptions = GetUseExceptions();
+    if ( bLocalUseExceptions ) {
+      pushErrorHandler();
+    }
+    {
+      SWIG_PYTHON_THREAD_BEGIN_ALLOW;
+      OGRGeomCoordinatePrecisionShadow_SetFromMeter(arg1,arg2,arg3,arg4,arg5);
+      SWIG_PYTHON_THREAD_END_ALLOW;
+    }
+    if ( bLocalUseExceptions ) {
+      popErrorHandler();
+    }
+#ifndef SED_HACKS
+    if ( bLocalUseExceptions ) {
+      CPLErr eclass = CPLGetLastErrorType();
+      if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+        SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+      }
+    }
+#endif
+  }
+  resultobj = SWIG_Py_Void();
+  if ( ReturnSame(bLocalUseExceptionsCode) ) { CPLErr eclass = CPLGetLastErrorType(); if ( eclass == CE_Failure || eclass == CE_Fatal ) { Py_XDECREF(resultobj); SWIG_Error( SWIG_RuntimeError, CPLGetLastErrorMsg() ); return NULL; } }
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_GeomCoordinatePrecision_GetXYResolution(PyObject *self, PyObject *args) {
+  PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
+  OGRGeomCoordinatePrecisionShadow *arg1 = (OGRGeomCoordinatePrecisionShadow *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject *swig_obj[1] ;
+  double result;
+  
+  if (!args) SWIG_fail;
+  swig_obj[0] = args;
+  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_OGRGeomCoordinatePrecisionShadow, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GeomCoordinatePrecision_GetXYResolution" "', argument " "1"" of type '" "OGRGeomCoordinatePrecisionShadow *""'"); 
+  }
+  arg1 = reinterpret_cast< OGRGeomCoordinatePrecisionShadow * >(argp1);
+  {
+    const int bLocalUseExceptions = GetUseExceptions();
+    if ( bLocalUseExceptions ) {
+      pushErrorHandler();
+    }
+    {
+      SWIG_PYTHON_THREAD_BEGIN_ALLOW;
+      result = (double)OGRGeomCoordinatePrecisionShadow_GetXYResolution(arg1);
+      SWIG_PYTHON_THREAD_END_ALLOW;
+    }
+    if ( bLocalUseExceptions ) {
+      popErrorHandler();
+    }
+#ifndef SED_HACKS
+    if ( bLocalUseExceptions ) {
+      CPLErr eclass = CPLGetLastErrorType();
+      if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+        SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+      }
+    }
+#endif
+  }
+  resultobj = SWIG_From_double(static_cast< double >(result));
+  if ( ReturnSame(bLocalUseExceptionsCode) ) { CPLErr eclass = CPLGetLastErrorType(); if ( eclass == CE_Failure || eclass == CE_Fatal ) { Py_XDECREF(resultobj); SWIG_Error( SWIG_RuntimeError, CPLGetLastErrorMsg() ); return NULL; } }
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_GeomCoordinatePrecision_GetZResolution(PyObject *self, PyObject *args) {
+  PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
+  OGRGeomCoordinatePrecisionShadow *arg1 = (OGRGeomCoordinatePrecisionShadow *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject *swig_obj[1] ;
+  double result;
+  
+  if (!args) SWIG_fail;
+  swig_obj[0] = args;
+  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_OGRGeomCoordinatePrecisionShadow, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GeomCoordinatePrecision_GetZResolution" "', argument " "1"" of type '" "OGRGeomCoordinatePrecisionShadow *""'"); 
+  }
+  arg1 = reinterpret_cast< OGRGeomCoordinatePrecisionShadow * >(argp1);
+  {
+    const int bLocalUseExceptions = GetUseExceptions();
+    if ( bLocalUseExceptions ) {
+      pushErrorHandler();
+    }
+    {
+      SWIG_PYTHON_THREAD_BEGIN_ALLOW;
+      result = (double)OGRGeomCoordinatePrecisionShadow_GetZResolution(arg1);
+      SWIG_PYTHON_THREAD_END_ALLOW;
+    }
+    if ( bLocalUseExceptions ) {
+      popErrorHandler();
+    }
+#ifndef SED_HACKS
+    if ( bLocalUseExceptions ) {
+      CPLErr eclass = CPLGetLastErrorType();
+      if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+        SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+      }
+    }
+#endif
+  }
+  resultobj = SWIG_From_double(static_cast< double >(result));
+  if ( ReturnSame(bLocalUseExceptionsCode) ) { CPLErr eclass = CPLGetLastErrorType(); if ( eclass == CE_Failure || eclass == CE_Fatal ) { Py_XDECREF(resultobj); SWIG_Error( SWIG_RuntimeError, CPLGetLastErrorMsg() ); return NULL; } }
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_GeomCoordinatePrecision_GetMResolution(PyObject *self, PyObject *args) {
+  PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
+  OGRGeomCoordinatePrecisionShadow *arg1 = (OGRGeomCoordinatePrecisionShadow *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject *swig_obj[1] ;
+  double result;
+  
+  if (!args) SWIG_fail;
+  swig_obj[0] = args;
+  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_OGRGeomCoordinatePrecisionShadow, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GeomCoordinatePrecision_GetMResolution" "', argument " "1"" of type '" "OGRGeomCoordinatePrecisionShadow *""'"); 
+  }
+  arg1 = reinterpret_cast< OGRGeomCoordinatePrecisionShadow * >(argp1);
+  {
+    const int bLocalUseExceptions = GetUseExceptions();
+    if ( bLocalUseExceptions ) {
+      pushErrorHandler();
+    }
+    {
+      SWIG_PYTHON_THREAD_BEGIN_ALLOW;
+      result = (double)OGRGeomCoordinatePrecisionShadow_GetMResolution(arg1);
+      SWIG_PYTHON_THREAD_END_ALLOW;
+    }
+    if ( bLocalUseExceptions ) {
+      popErrorHandler();
+    }
+#ifndef SED_HACKS
+    if ( bLocalUseExceptions ) {
+      CPLErr eclass = CPLGetLastErrorType();
+      if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+        SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+      }
+    }
+#endif
+  }
+  resultobj = SWIG_From_double(static_cast< double >(result));
+  if ( ReturnSame(bLocalUseExceptionsCode) ) { CPLErr eclass = CPLGetLastErrorType(); if ( eclass == CE_Failure || eclass == CE_Fatal ) { Py_XDECREF(resultobj); SWIG_Error( SWIG_RuntimeError, CPLGetLastErrorMsg() ); return NULL; } }
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_GeomCoordinatePrecision_GetFormats(PyObject *self, PyObject *args) {
+  PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
+  OGRGeomCoordinatePrecisionShadow *arg1 = (OGRGeomCoordinatePrecisionShadow *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject *swig_obj[1] ;
+  char **result = 0 ;
+  
+  if (!args) SWIG_fail;
+  swig_obj[0] = args;
+  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_OGRGeomCoordinatePrecisionShadow, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GeomCoordinatePrecision_GetFormats" "', argument " "1"" of type '" "OGRGeomCoordinatePrecisionShadow *""'"); 
+  }
+  arg1 = reinterpret_cast< OGRGeomCoordinatePrecisionShadow * >(argp1);
+  {
+    const int bLocalUseExceptions = GetUseExceptions();
+    if ( bLocalUseExceptions ) {
+      pushErrorHandler();
+    }
+    {
+      SWIG_PYTHON_THREAD_BEGIN_ALLOW;
+      result = (char **)OGRGeomCoordinatePrecisionShadow_GetFormats(arg1);
+      SWIG_PYTHON_THREAD_END_ALLOW;
+    }
+    if ( bLocalUseExceptions ) {
+      popErrorHandler();
+    }
+#ifndef SED_HACKS
+    if ( bLocalUseExceptions ) {
+      CPLErr eclass = CPLGetLastErrorType();
+      if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+        SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+      }
+    }
+#endif
+  }
+  {
+    /* %typemap(out) char **CSL -> ( string ) */
+    bool bErr = false;
+    resultobj = CSLToList(result, &bErr);
+    CSLDestroy(result);
+    if( bErr ) {
+      SWIG_fail;
+    }
+  }
+  if ( ReturnSame(bLocalUseExceptionsCode) ) { CPLErr eclass = CPLGetLastErrorType(); if ( eclass == CE_Failure || eclass == CE_Fatal ) { Py_XDECREF(resultobj); SWIG_Error( SWIG_RuntimeError, CPLGetLastErrorMsg() ); return NULL; } }
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_GeomCoordinatePrecision_GetFormatSpecificOptions(PyObject *self, PyObject *args) {
+  PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
+  OGRGeomCoordinatePrecisionShadow *arg1 = (OGRGeomCoordinatePrecisionShadow *) 0 ;
+  char *arg2 = (char *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  int res2 ;
+  char *buf2 = 0 ;
+  int alloc2 = 0 ;
+  PyObject *swig_obj[2] ;
+  char **result = 0 ;
+  
+  if (!SWIG_Python_UnpackTuple(args, "GeomCoordinatePrecision_GetFormatSpecificOptions", 2, 2, swig_obj)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_OGRGeomCoordinatePrecisionShadow, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GeomCoordinatePrecision_GetFormatSpecificOptions" "', argument " "1"" of type '" "OGRGeomCoordinatePrecisionShadow *""'"); 
+  }
+  arg1 = reinterpret_cast< OGRGeomCoordinatePrecisionShadow * >(argp1);
+  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, NULL, &alloc2);
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GeomCoordinatePrecision_GetFormatSpecificOptions" "', argument " "2"" of type '" "char const *""'");
+  }
+  arg2 = reinterpret_cast< char * >(buf2);
+  {
+    if (!arg2) {
+      SWIG_exception(SWIG_ValueError,"Received a NULL pointer.");
+    }
+  }
+  {
+    const int bLocalUseExceptions = GetUseExceptions();
+    if ( bLocalUseExceptions ) {
+      pushErrorHandler();
+    }
+    {
+      SWIG_PYTHON_THREAD_BEGIN_ALLOW;
+      result = (char **)OGRGeomCoordinatePrecisionShadow_GetFormatSpecificOptions(arg1,(char const *)arg2);
+      SWIG_PYTHON_THREAD_END_ALLOW;
+    }
+    if ( bLocalUseExceptions ) {
+      popErrorHandler();
+    }
+#ifndef SED_HACKS
+    if ( bLocalUseExceptions ) {
+      CPLErr eclass = CPLGetLastErrorType();
+      if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+        SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+      }
+    }
+#endif
+  }
+  {
+    /* %typemap(out) char **dict */
+    resultobj = GetCSLStringAsPyDict(result, false);
+  }
+  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+  if ( ReturnSame(bLocalUseExceptionsCode) ) { CPLErr eclass = CPLGetLastErrorType(); if ( eclass == CE_Failure || eclass == CE_Fatal ) { Py_XDECREF(resultobj); SWIG_Error( SWIG_RuntimeError, CPLGetLastErrorMsg() ); return NULL; } }
+  return resultobj;
+fail:
+  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_GeomCoordinatePrecision_SetFormatSpecificOptions(PyObject *self, PyObject *args) {
+  PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
+  OGRGeomCoordinatePrecisionShadow *arg1 = (OGRGeomCoordinatePrecisionShadow *) 0 ;
+  char *arg2 = (char *) 0 ;
+  char **arg3 = (char **) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  int res2 ;
+  char *buf2 = 0 ;
+  int alloc2 = 0 ;
+  PyObject *swig_obj[3] ;
+  
+  if (!SWIG_Python_UnpackTuple(args, "GeomCoordinatePrecision_SetFormatSpecificOptions", 3, 3, swig_obj)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_OGRGeomCoordinatePrecisionShadow, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GeomCoordinatePrecision_SetFormatSpecificOptions" "', argument " "1"" of type '" "OGRGeomCoordinatePrecisionShadow *""'"); 
+  }
+  arg1 = reinterpret_cast< OGRGeomCoordinatePrecisionShadow * >(argp1);
+  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, NULL, &alloc2);
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GeomCoordinatePrecision_SetFormatSpecificOptions" "', argument " "2"" of type '" "char const *""'");
+  }
+  arg2 = reinterpret_cast< char * >(buf2);
+  {
+    /* %typemap(in) char **dict */
+    arg3 = NULL;
+    if ( PySequence_Check( swig_obj[2] ) ) {
+      int bErr = FALSE;
+      arg3 = CSLFromPySequence(swig_obj[2], &bErr);
+      if ( bErr )
+      {
+        SWIG_fail;
+      }
+    }
+    else if ( PyMapping_Check( swig_obj[2] ) ) {
+      int bErr = FALSE;
+      arg3 = CSLFromPyMapping(swig_obj[2], &bErr);
+      if ( bErr )
+      {
+        SWIG_fail;
+      }
+    }
+    else {
+      PyErr_SetString(PyExc_TypeError,"Argument must be dictionary or sequence of strings");
+      SWIG_fail;
+    }
+  }
+  {
+    if (!arg2) {
+      SWIG_exception(SWIG_ValueError,"Received a NULL pointer.");
+    }
+  }
+  {
+    const int bLocalUseExceptions = GetUseExceptions();
+    if ( bLocalUseExceptions ) {
+      pushErrorHandler();
+    }
+    {
+      SWIG_PYTHON_THREAD_BEGIN_ALLOW;
+      OGRGeomCoordinatePrecisionShadow_SetFormatSpecificOptions(arg1,(char const *)arg2,arg3);
+      SWIG_PYTHON_THREAD_END_ALLOW;
+    }
+    if ( bLocalUseExceptions ) {
+      popErrorHandler();
+    }
+#ifndef SED_HACKS
+    if ( bLocalUseExceptions ) {
+      CPLErr eclass = CPLGetLastErrorType();
+      if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+        SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+      }
+    }
+#endif
+  }
+  resultobj = SWIG_Py_Void();
+  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+  {
+    /* %typemap(freearg) char **dict */
+    CSLDestroy( arg3 );
+  }
+  if ( ReturnSame(bLocalUseExceptionsCode) ) { CPLErr eclass = CPLGetLastErrorType(); if ( eclass == CE_Failure || eclass == CE_Fatal ) { Py_XDECREF(resultobj); SWIG_Error( SWIG_RuntimeError, CPLGetLastErrorMsg() ); return NULL; } }
+  return resultobj;
+fail:
+  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+  {
+    /* %typemap(freearg) char **dict */
+    CSLDestroy( arg3 );
+  }
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *GeomCoordinatePrecision_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *obj;
+  if (!SWIG_Python_UnpackTuple(args, "swigregister", 1, 1, &obj)) return NULL;
+  SWIG_TypeNewClientData(SWIGTYPE_p_OGRGeomCoordinatePrecisionShadow, SWIG_NewClientData(obj));
+  return SWIG_Py_Void();
+}
+
+SWIGINTERN PyObject *_wrap_CreateGeomCoordinatePrecision(PyObject *self, PyObject *args) {
+  PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
+  OGRGeomCoordinatePrecisionShadow *result = 0 ;
+  
+  if (!SWIG_Python_UnpackTuple(args, "CreateGeomCoordinatePrecision", 0, 0, 0)) SWIG_fail;
+  {
+    const int bLocalUseExceptions = GetUseExceptions();
+    if ( bLocalUseExceptions ) {
+      pushErrorHandler();
+    }
+    {
+      SWIG_PYTHON_THREAD_BEGIN_ALLOW;
+      result = (OGRGeomCoordinatePrecisionShadow *)CreateGeomCoordinatePrecision();
+      SWIG_PYTHON_THREAD_END_ALLOW;
+    }
+    if ( bLocalUseExceptions ) {
+      popErrorHandler();
+    }
+#ifndef SED_HACKS
+    if ( bLocalUseExceptions ) {
+      CPLErr eclass = CPLGetLastErrorType();
+      if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+        SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+      }
+    }
+#endif
+  }
+  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OGRGeomCoordinatePrecisionShadow, SWIG_POINTER_OWN |  0 );
+  if ( ReturnSame(bLocalUseExceptionsCode) ) { CPLErr eclass = CPLGetLastErrorType(); if ( eclass == CE_Failure || eclass == CE_Fatal ) { Py_XDECREF(resultobj); SWIG_Error( SWIG_RuntimeError, CPLGetLastErrorMsg() ); return NULL; } }
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
 SWIGINTERN PyObject *_wrap_GetDriverCount(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
   int result;
   
   if (!SWIG_Python_UnpackTuple(args, "GetDriverCount", 0, 0, 0)) SWIG_fail;
   {
     const int bLocalUseExceptions = GetUseExceptions();
@@ -36321,14 +37854,27 @@
 	 { "ArrowSchema_GetChild", _wrap_ArrowSchema_GetChild, METH_VARARGS, "ArrowSchema_GetChild(ArrowSchema self, int iChild) -> ArrowSchema"},
 	 { "ArrowSchema_swigregister", ArrowSchema_swigregister, METH_O, NULL},
 	 { "ArrowSchema_swiginit", ArrowSchema_swiginit, METH_VARARGS, NULL},
 	 { "delete_ArrowArrayStream", _wrap_delete_ArrowArrayStream, METH_O, "delete_ArrowArrayStream(ArrowArrayStream self)"},
 	 { "ArrowArrayStream_GetSchema", _wrap_ArrowArrayStream_GetSchema, METH_O, "ArrowArrayStream_GetSchema(ArrowArrayStream self) -> ArrowSchema"},
 	 { "ArrowArrayStream_GetNextRecordBatch", _wrap_ArrowArrayStream_GetNextRecordBatch, METH_VARARGS, "ArrowArrayStream_GetNextRecordBatch(ArrowArrayStream self, char ** options=None) -> ArrowArray"},
 	 { "ArrowArrayStream_swigregister", ArrowArrayStream_swigregister, METH_O, NULL},
+	 { "Layer_GetDataset", _wrap_Layer_GetDataset, METH_O, "\n"
+		"Layer_GetDataset(Layer self) -> GDALDatasetShadow *\n"
+		"\n"
+		"Return the dataset associated with this layer.\n"
+		"\n"
+		"For more details: :cpp:func:`OGR_L_GetDataset`\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"Dataset:\n"
+		"    Dataset or None\n"
+		"\n"
+		""},
 	 { "Layer_Rename", _wrap_Layer_Rename, METH_VARARGS, "Layer_Rename(Layer self, char const * new_name) -> OGRErr"},
 	 { "Layer_GetRefCount", _wrap_Layer_GetRefCount, METH_O, "\n"
 		"Layer_GetRefCount(Layer self) -> int\n"
 		"\n"
 		"For more details: :cpp:func:`OGR_L_GetRefCount`\n"
 		"\n"
 		""},
@@ -36688,14 +38234,15 @@
 		"--------\n"
 		"minx: float\n"
 		"maxx: float\n"
 		"miny: float\n"
 		"maxy: float\n"
 		"\n"
 		""},
+	 { "Layer_GetExtent3D", (PyCFunction)(void(*)(void))_wrap_Layer_GetExtent3D, METH_VARARGS|METH_KEYWORDS, "Layer_GetExtent3D(Layer self, int force=1, int can_return_null=0, int geom_field=0)"},
 	 { "Layer_TestCapability", _wrap_Layer_TestCapability, METH_VARARGS, "\n"
 		"Layer_TestCapability(Layer self, char const * cap) -> bool\n"
 		"\n"
 		"Test if this layer supported the named capability.\n"
 		"\n"
 		"For more details: :cpp:func:`OGR_L_TestCapability`\n"
 		"\n"
@@ -37155,18 +38702,21 @@
 		"Layer_SetStyleTable(Layer self, StyleTable table)\n"
 		"\n"
 		"Set style table.\n"
 		"\n"
 		"For more details: :cpp:func:`OGR_L_SetStyleTable`\n"
 		"\n"
 		""},
+	 { "Layer_ExportArrowArrayStreamPyCapsule", _wrap_Layer_ExportArrowArrayStreamPyCapsule, METH_VARARGS, "Layer_ExportArrowArrayStreamPyCapsule(Layer self, char ** options=None) -> PyObject *"},
 	 { "Layer_GetArrowStream", _wrap_Layer_GetArrowStream, METH_VARARGS, "Layer_GetArrowStream(Layer self, char ** options=None) -> ArrowArrayStream"},
 	 { "Layer_IsArrowSchemaSupported", _wrap_Layer_IsArrowSchemaSupported, METH_VARARGS, "Layer_IsArrowSchemaSupported(Layer self, ArrowSchema schema, char ** options=None)"},
 	 { "Layer_CreateFieldFromArrowSchema", _wrap_Layer_CreateFieldFromArrowSchema, METH_VARARGS, "Layer_CreateFieldFromArrowSchema(Layer self, ArrowSchema schema, char ** options=None) -> OGRErr"},
 	 { "Layer_WriteArrowBatch", _wrap_Layer_WriteArrowBatch, METH_VARARGS, "Layer_WriteArrowBatch(Layer self, ArrowSchema schema, ArrowArray array, char ** options=None) -> OGRErr"},
+	 { "Layer_WriteArrowStreamCapsule", _wrap_Layer_WriteArrowStreamCapsule, METH_VARARGS, "Layer_WriteArrowStreamCapsule(Layer self, PyObject * capsule, int createFieldsFromSchema, char ** options=None) -> OGRErr"},
+	 { "Layer_WriteArrowSchemaAndArrowArrayCapsule", _wrap_Layer_WriteArrowSchemaAndArrowArrayCapsule, METH_VARARGS, "Layer_WriteArrowSchemaAndArrowArrayCapsule(Layer self, PyObject * schemaCapsule, PyObject * arrayCapsule, int createFieldsFromSchema, char ** options=None) -> OGRErr"},
 	 { "Layer_GetGeometryTypes", (PyCFunction)(void(*)(void))_wrap_Layer_GetGeometryTypes, METH_VARARGS|METH_KEYWORDS, "\n"
 		"Layer_GetGeometryTypes(Layer self, int geom_field=0, int flags=0, GDALProgressFunc callback=0, void * callback_data=None)\n"
 		"\n"
 		"Get actual geometry types found in features.\n"
 		"\n"
 		"For more details: :cpp:func:`OGR_L_GetGeometryTypes`\n"
 		"\n"
@@ -37191,2357 +38741,1912 @@
 		"    values the corresponding number of geometries of that type in the layer.\n"
 		"\n"
 		""},
 	 { "Layer_GetSupportedSRSList", (PyCFunction)(void(*)(void))_wrap_Layer_GetSupportedSRSList, METH_VARARGS|METH_KEYWORDS, "Layer_GetSupportedSRSList(Layer self, int geom_field=0)"},
 	 { "Layer_SetActiveSRS", _wrap_Layer_SetActiveSRS, METH_VARARGS, "Layer_SetActiveSRS(Layer self, int geom_field, SpatialReference srs) -> OGRErr"},
 	 { "Layer_swigregister", Layer_swigregister, METH_O, NULL},
 	 { "delete_Feature", _wrap_delete_Feature, METH_O, "delete_Feature(Feature self)"},
-	 { "new_Feature", (PyCFunction)(void(*)(void))_wrap_new_Feature, METH_VARARGS|METH_KEYWORDS, "new_Feature(FeatureDefn feature_def) -> Feature"},
-	 { "Feature_GetDefnRef", _wrap_Feature_GetDefnRef, METH_O, "\n"
-		"Feature_GetDefnRef(Feature self) -> FeatureDefn\n"
-		"\n"
-		"OGRFeatureDefnH OGR_F_GetDefnRef(OGRFeatureH hFeat)\n"
+	 { "new_Feature", (PyCFunction)(void(*)(void))_wrap_new_Feature, METH_VARARGS|METH_KEYWORDS, "\n"
+		"new_Feature(FeatureDefn feature_def) -> Feature\n"
 		"\n"
-		"Fetch feature definition.\n"
-		"\n"
-		"This function is the same as the C++ method OGRFeature::GetDefnRef().\n"
 		"\n"
 		"Parameters\n"
 		"-----------\n"
-		"hFeat:\n"
-		"    handle to the feature to get the feature definition from.\n"
-		"\n"
-		"Returns\n"
-		"--------\n"
-		"OGRFeatureDefnH:\n"
-		"    a handle to the feature definition object on which feature depends.\n"
+		"feature_def:\n"
+		"    :py:class:`FeatureDefn` to which the feature will adhere.\n"
 		"\n"
 		""},
-	 { "Feature_SetGeometry", _wrap_Feature_SetGeometry, METH_VARARGS, "\n"
-		"Feature_SetGeometry(Feature self, Geometry geom) -> OGRErr\n"
-		"\n"
-		"OGRErr OGR_F_SetGeometry(OGRFeatureH hFeat, OGRGeometryH hGeom)\n"
-		"\n"
-		"Set feature geometry.\n"
+	 { "Feature_GetDefnRef", _wrap_Feature_GetDefnRef, METH_O, "\n"
+		"Feature_GetDefnRef(Feature self) -> FeatureDefn\n"
 		"\n"
-		"This function updates the features geometry, and operate exactly as\n"
-		"SetGeometryDirectly(), except that this function does not assume\n"
-		"ownership of the passed geometry, but instead makes a copy of it.\n"
 		"\n"
-		"This function is the same as the C++ OGRFeature::SetGeometry().\n"
+		"Fetch the :py:class:`FeatureDefn` associated with this Feature.\n"
 		"\n"
-		"This method has only an effect on the in-memory feature object. If\n"
-		"this object comes from a layer and the modifications must be\n"
-		"serialized back to the datasource, OGR_L_SetFeature() must be used\n"
-		"afterwards. Or if this is a new feature, OGR_L_CreateFeature() must be\n"
-		"used afterwards.\n"
-		"\n"
-		"Parameters\n"
-		"-----------\n"
-		"hFeat:\n"
-		"    handle to the feature on which new geometry is applied to.\n"
-		"hGeom:\n"
-		"    handle to the new geometry to apply to feature.\n"
+		"See :cpp:func:`OGRFeature::GetDefnRef()`.\n"
 		"\n"
 		"Returns\n"
 		"--------\n"
-		"OGRErr:\n"
-		"    OGRERR_NONE if successful, or OGR_UNSUPPORTED_GEOMETRY_TYPE if the\n"
-		"    geometry type is illegal for the OGRFeatureDefn (checking not yet\n"
-		"    implemented).\n"
+		"FeatureDefn\n"
 		"\n"
 		""},
-	 { "Feature_SetGeometryDirectly", _wrap_Feature_SetGeometryDirectly, METH_VARARGS, "\n"
-		"Feature_SetGeometryDirectly(Feature self, Geometry geom) -> OGRErr\n"
+	 { "Feature_SetGeometry", _wrap_Feature_SetGeometry, METH_VARARGS, "\n"
+		"Feature_SetGeometry(Feature self, Geometry geom) -> OGRErr\n"
 		"\n"
-		"OGRErr OGR_F_SetGeometryDirectly(OGRFeatureH hFeat, OGRGeometryH hGeom)\n"
 		"\n"
 		"Set feature geometry.\n"
 		"\n"
-		"This function updates the features geometry, and operate exactly as\n"
-		"SetGeometry(), except that this function assumes ownership of the\n"
-		"passed geometry (even in case of failure of that function).\n"
+		"This function updates the features geometry, and operates exactly as\n"
+		":py:meth:`SetGeometryDirectly`, except that this function does not assume\n"
+		"ownership of the passed geometry, but instead makes a copy of it.\n"
 		"\n"
-		"This function is the same as the C++ method\n"
-		"OGRFeature::SetGeometryDirectly.\n"
+		"See :cpp:func:`OGRFeature::SetGeometry`.\n"
 		"\n"
 		"This method has only an effect on the in-memory feature object. If\n"
 		"this object comes from a layer and the modifications must be\n"
-		"serialized back to the datasource, OGR_L_SetFeature() must be used\n"
-		"afterwards. Or if this is a new feature, OGR_L_CreateFeature() must be\n"
+		"serialized back to the datasource, :py:meth:`Layer.SetFeature` must be used\n"
+		"afterwards. Or if this is a new feature, :py:meth:`Layer.CreateFeature` must be\n"
 		"used afterwards.\n"
 		"\n"
 		"Parameters\n"
 		"-----------\n"
-		"hFeat:\n"
-		"    handle to the feature on which to apply the geometry.\n"
-		"hGeom:\n"
-		"    handle to the new geometry to apply to feature.\n"
-		"\n"
+		"geom : Geometry\n"
+		"    new geometry to apply to feature.\n"
 		"\n"
 		"Returns\n"
 		"--------\n"
-		"OGRErr:\n"
-		"    OGRERR_NONE if successful, or OGR_UNSUPPORTED_GEOMETRY_TYPE if the\n"
-		"    geometry type is illegal for the OGRFeatureDefn (checking not yet\n"
-		"    implemented).\n"
+		"int:\n"
+		"    :py:const:`OGRERR_NONE` if successful, or\n"
+		"    :py:const:`OGR_UNSUPPORTED_GEOMETRY_TYPE` if the geometry type is illegal for\n"
+		"    the :py:class:`FeatureDefn` (checking not yet implemented).\n"
 		"\n"
 		""},
+	 { "Feature_SetGeometryDirectly", _wrap_Feature_SetGeometryDirectly, METH_VARARGS, "Feature_SetGeometryDirectly(Feature self, Geometry geom) -> OGRErr"},
 	 { "Feature_GetGeometryRef", _wrap_Feature_GetGeometryRef, METH_O, "\n"
 		"Feature_GetGeometryRef(Feature self) -> Geometry\n"
 		"\n"
 		"Return the feature geometry\n"
 		"\n"
 		"The lifetime of the returned geometry is bound to the one of its belonging\n"
 		"feature.\n"
 		"\n"
-		"For more details: :cpp:func:`OGR_F_GetGeometryRef`\n"
+		"See :cpp:func:`OGRFeature::GetGeometryRef`\n"
 		"\n"
-		"The geometry() method is also available as an alias of GetGeometryRef()\n"
+		"The :py:func:`Feature.geometry` method is also available as an alias of :py:func:`Feature.GetGeometryRef`.\n"
 		"\n"
 		"Returns\n"
 		"--------\n"
 		"Geometry:\n"
 		"    the geometry, or None.\n"
 		"\n"
 		""},
 	 { "Feature_SetGeomField", _wrap_Feature_SetGeomField, METH_VARARGS, "\n"
 		"Feature_SetGeomField(Feature self, int iField, Geometry geom) -> OGRErr\n"
 		"Feature_SetGeomField(Feature self, char const * field_name, Geometry geom) -> OGRErr\n"
-		"OGRErr\n"
-		"OGR_F_SetGeomField(OGRFeatureH hFeat, int iField, OGRGeometryH hGeom)\n"
+		"\n"
 		"\n"
 		"Set feature geometry of a specified geometry field.\n"
 		"\n"
-		"This function updates the features geometry, and operate exactly as\n"
-		"SetGeometryDirectly(), except that this function does not assume\n"
+		"This function updates the features geometry, and operates exactly as\n"
+		":py:meth:`SetGeomFieldDirectly`, except that this function does not assume\n"
 		"ownership of the passed geometry, but instead makes a copy of it.\n"
 		"\n"
-		"This function is the same as the C++ OGRFeature::SetGeomField().\n"
+		"See :cpp:func:`OGRFeature::SetGeomField`.\n"
 		"\n"
 		"Parameters\n"
 		"-----------\n"
-		"hFeat:\n"
-		"    handle to the feature on which new geometry is applied to.\n"
-		"iField:\n"
-		"    geometry field to set.\n"
-		"hGeom:\n"
+		"fld_index : int / str\n"
+		"    Geometry field name or 0-based numeric index. For repeated\n"
+		"    access, use of the numeric index avoids a lookup\n"
+		"    step.\n"
+		"geom : Geometry\n"
 		"    handle to the new geometry to apply to feature.\n"
 		"\n"
 		"Returns\n"
 		"--------\n"
-		"OGRErr:\n"
-		"    OGRERR_NONE if successful, or OGR_UNSUPPORTED_GEOMETRY_TYPE if the\n"
-		"    geometry type is illegal for the OGRFeatureDefn (checking not yet\n"
-		"    implemented).\n"
+		"int:\n"
+		"    :py:const:`OGRERR_NONE` if successful, or\n"
+		"    :py:const:`OGR_UNSUPPORTED_GEOMETRY_TYPE` if the geometry type is illegal for\n"
+		"    the :py:class:`FeatureDefn` (checking not yet implemented).\n"
 		"\n"
 		""},
 	 { "Feature_SetGeomFieldDirectly", _wrap_Feature_SetGeomFieldDirectly, METH_VARARGS, "\n"
 		"Feature_SetGeomFieldDirectly(Feature self, int iField, Geometry geom) -> OGRErr\n"
 		"Feature_SetGeomFieldDirectly(Feature self, char const * field_name, Geometry geom) -> OGRErr\n"
-		"\n"
-		"OGRErr OGR_F_SetGeomFieldDirectly(OGRFeatureH hFeat, int iField, OGRGeometryH hGeom)\n"
-		"\n"
-		"Set feature geometry of a specified geometry field.\n"
-		"\n"
-		"This function updates the features geometry, and operate exactly as\n"
-		"SetGeomField(), except that this function assumes ownership of the\n"
-		"passed geometry (even in case of failure of that function).\n"
-		"\n"
-		"This function is the same as the C++ method\n"
-		"OGRFeature::SetGeomFieldDirectly.\n"
-		"\n"
-		".. versionadded:: 1.11\n"
-		"\n"
-		"Parameters\n"
-		"-----------\n"
-		"hFeat:\n"
-		"    handle to the feature on which to apply the geometry.\n"
-		"iField:\n"
-		"    geometry field to set.\n"
-		"hGeom:\n"
-		"    handle to the new geometry to apply to feature.\n"
-		"\n"
-		"Returns\n"
-		"--------\n"
-		"OGRErr:\n"
-		"    OGRERR_NONE if successful, or OGRERR_FAILURE if the index is invalid,\n"
-		"    or OGR_UNSUPPORTED_GEOMETRY_TYPE if the geometry type is illegal for\n"
-		"    the OGRFeatureDefn (checking not yet implemented).\n"
-		"\n"
 		""},
 	 { "Feature_GetGeomFieldRef", _wrap_Feature_GetGeomFieldRef, METH_VARARGS, "\n"
 		"Feature_GetGeomFieldRef(Feature self, int iField) -> Geometry\n"
 		"Feature_GetGeomFieldRef(Feature self, char const * field_name) -> Geometry\n"
-		"OGRGeometryH\n"
-		"OGR_F_GetGeomFieldRef(OGRFeatureH hFeat, int iField)\n"
 		"\n"
-		"Fetch a handle to feature geometry.\n"
 		"\n"
-		"This function is the same as the C++ method\n"
-		"OGRFeature::GetGeomFieldRef().\n"
+		"Fetch a feature :py:class:`Geometry`.\n"
+		"\n"
+		"See :cpp:func:`OGRFeature::GetGeomFieldRef`.\n"
 		"\n"
 		"Parameters\n"
 		"-----------\n"
-		"hFeat:\n"
-		"    handle to the feature to get geometry from.\n"
-		"iField:\n"
-		"    geometry field to get.\n"
+		"fld_index : int / str\n"
+		"    Field name or 0-based numeric index. For repeated\n"
+		"    access, use of the numeric index avoids a lookup\n"
+		"    step.\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"Geometry\n"
 		"\n"
-		"a handle to internal feature geometry. This object should not be\n"
-		"modified.\n"
 		"\n"
-		"GDAL 1.11 \n"
 		""},
 	 { "Feature_Clone", _wrap_Feature_Clone, METH_O, "\n"
 		"Feature_Clone(Feature self) -> Feature\n"
 		"\n"
-		"OGRFeatureH OGR_F_Clone(OGRFeatureH hFeat)\n"
-		"\n"
-		"Duplicate feature.\n"
-		"\n"
-		"The newly created feature is owned by the caller, and will have its\n"
-		"own reference to the OGRFeatureDefn.\n"
-		"\n"
-		"This function is the same as the C++ method OGRFeature::Clone().\n"
-		"\n"
-		"Parameters\n"
-		"-----------\n"
-		"hFeat:\n"
-		"    handle to the feature to clone.\n"
+		"Duplicate a Feature.\n"
+		"See :cpp:func:`OGRFeature::Clone`.\n"
 		"\n"
 		"Returns\n"
 		"--------\n"
-		"OGRFeatureH:\n"
-		"    a handle to the new feature, exactly matching this feature.\n"
+		"Feature\n"
 		"\n"
 		""},
 	 { "Feature_Equal", _wrap_Feature_Equal, METH_VARARGS, "\n"
 		"Feature_Equal(Feature self, Feature feature) -> bool\n"
-		"int OGR_F_Equal(OGRFeatureH hFeat,\n"
-		"OGRFeatureH hOtherFeat)\n"
+		"\n"
 		"\n"
 		"Test if two features are the same.\n"
 		"\n"
-		"Two features are considered equal if the share them (handle equality)\n"
-		"same OGRFeatureDefn, have the same field values, and the same geometry\n"
-		"(as tested by OGR_G_Equal()) as well as the same feature id.\n"
+		"Two features are considered equal if they reference the\n"
+		"same :py:class:`FeatureDefn`, have the same field values, and the same geometry\n"
+		"(as tested by :py:func:`Geometry.Equal`) as well as the same feature id.\n"
 		"\n"
-		"This function is the same as the C++ method OGRFeature::Equal().\n"
+		"See :cpp:func:`OGRFeature::Equal`.\n"
 		"\n"
 		"Parameters\n"
 		"-----------\n"
-		"hFeat:\n"
-		"    handle to one of the feature.\n"
-		"hOtherFeat:\n"
-		"    handle to the other feature to test this one against.\n"
+		"feature : Feature\n"
+		"    feature to test this one against\n"
 		"\n"
 		"Returns\n"
 		"--------\n"
-		"int:\n"
-		"    TRUE if they are equal, otherwise FALSE.\n"
+		"bool\n"
 		"\n"
 		""},
 	 { "Feature_GetFieldCount", _wrap_Feature_GetFieldCount, METH_O, "\n"
 		"Feature_GetFieldCount(Feature self) -> int\n"
 		"\n"
-		"int OGR_F_GetFieldCount(OGRFeatureH hFeat)\n"
 		"\n"
 		"Fetch number of fields on this feature This will always be the same as\n"
-		"the field count for the OGRFeatureDefn.\n"
+		"the field count for the :py:class:`FeatureDefn`.\n"
 		"\n"
-		"This function is the same as the C++ method\n"
-		"OGRFeature::GetFieldCount().\n"
-		"\n"
-		"Parameters\n"
-		"-----------\n"
-		"hFeat:\n"
-		"    handle to the feature to get the fields count from.\n"
+		"See :cpp:func:`OGRFeature::GetFieldCount`.\n"
 		"\n"
 		"Returns\n"
 		"--------\n"
 		"int:\n"
 		"    count of fields.\n"
 		"\n"
 		""},
 	 { "Feature_GetFieldDefnRef", _wrap_Feature_GetFieldDefnRef, METH_VARARGS, "\n"
 		"Feature_GetFieldDefnRef(Feature self, int id) -> FieldDefn\n"
 		"Feature_GetFieldDefnRef(Feature self, char const * field_name) -> FieldDefn\n"
 		"\n"
-		"OGRFieldDefnH OGR_F_GetFieldDefnRef(OGRFeatureH hFeat, int i)\n"
 		"\n"
 		"Fetch definition for this field.\n"
 		"\n"
-		"This function is the same as the C++ method\n"
-		"OGRFeature::GetFieldDefnRef().\n"
+		"See :cpp:func:`OGRFeature::GetFieldDefnRef`.\n"
 		"\n"
 		"Parameters\n"
 		"-----------\n"
-		"hFeat:\n"
-		"    handle to the feature on which the field is found.\n"
-		"i:\n"
-		"    the field to fetch, from 0 to GetFieldCount()-1.\n"
+		"fld_index : int / str\n"
+		"    Field name or 0-based numeric index. For repeated\n"
+		"    access, use of the numeric index avoids a lookup\n"
+		"    step.\n"
 		"\n"
 		"Returns\n"
 		"--------\n"
-		"OGRFieldDefnH:\n"
-		"    a handle to the field definition (from the OGRFeatureDefn). This is an\n"
-		"    internal reference, and should not be deleted or modified.\n"
+		"FieldDefn\n"
+		"    a reference to the field definition. This reference should\n"
+		"    not be modified.\n"
 		"\n"
 		""},
 	 { "Feature_GetGeomFieldCount", _wrap_Feature_GetGeomFieldCount, METH_O, "\n"
 		"Feature_GetGeomFieldCount(Feature self) -> int\n"
 		"\n"
-		"int OGR_F_GetGeomFieldCount(OGRFeatureH hFeat)\n"
 		"\n"
 		"Fetch number of geometry fields on this feature This will always be\n"
-		"the same as the geometry field count for the OGRFeatureDefn.\n"
-		"\n"
-		"This function is the same as the C++ method\n"
-		"OGRFeature::GetGeomFieldCount().\n"
-		"\n"
-		".. versionadded:: 1.11\n"
-		"\n"
-		"Parameters\n"
-		"-----------\n"
-		"hFeat:\n"
-		"    handle to the feature to get the geometry fields count from.\n"
+		"the same as the geometry field count for the :py:class:`FeatureDefn`.\n"
 		"\n"
+		"See :cpp:func:`OGRFeature::GetGeomFieldCount`.\n"
 		"\n"
 		"Returns\n"
 		"--------\n"
 		"int:\n"
 		"    count of geometry fields.\n"
 		"\n"
 		""},
 	 { "Feature_GetGeomFieldDefnRef", _wrap_Feature_GetGeomFieldDefnRef, METH_VARARGS, "\n"
 		"Feature_GetGeomFieldDefnRef(Feature self, int id) -> GeomFieldDefn\n"
 		"Feature_GetGeomFieldDefnRef(Feature self, char const * field_name) -> GeomFieldDefn\n"
 		"\n"
-		"OGRGeomFieldDefnH OGR_F_GetGeomFieldDefnRef(OGRFeatureH hFeat, int i)\n"
 		"\n"
 		"Fetch definition for this geometry field.\n"
 		"\n"
-		"This function is the same as the C++ method\n"
-		"OGRFeature::GetGeomFieldDefnRef().\n"
-		"\n"
-		".. versionadded:: 1.11\n"
+		"See :cpp:func:`OGRFeature::GetGeomFieldDefnRef`.\n"
 		"\n"
 		"Parameters\n"
 		"-----------\n"
-		"hFeat:\n"
-		"    handle to the feature on which the field is found.\n"
-		"i:\n"
-		"    the field to fetch, from 0 to GetGeomFieldCount()-1.\n"
-		"\n"
+		"fld_index : int / str\n"
+		"    Field name or 0-based numeric index. For repeated\n"
+		"    access, use of the numeric index avoids a lookup\n"
+		"    step.\n"
 		"\n"
 		"Returns\n"
 		"--------\n"
-		"OGRGeomFieldDefnH:\n"
-		"    a handle to the field definition (from the OGRFeatureDefn). This is an\n"
-		"    internal reference, and should not be deleted or modified.\n"
+		"GeomFieldDefn:\n"
+		"    a reference to the field definition.\n"
+		"    Should not be deleted or modified.\n"
 		"\n"
 		""},
 	 { "Feature_GetFieldAsString", _wrap_Feature_GetFieldAsString, METH_VARARGS, "\n"
 		"Feature_GetFieldAsString(Feature self, int id) -> char const\n"
 		"Feature_GetFieldAsString(Feature self, char const * field_name) -> char const *\n"
 		"\n"
-		"const char\\* OGR_F_GetFieldAsString(OGRFeatureH hFeat, int iField)\n"
-		"\n"
-		"Fetch field value as a string.\n"
 		"\n"
-		"OFTReal and OFTInteger fields will be translated to string using\n"
+		":py:const:`OFTReal` and :py:const:`OFTInteger` fields will be translated to string using\n"
 		"sprintf(), but not necessarily using the established formatting rules.\n"
 		"Other field types, or errors will result in a return value of zero.\n"
 		"\n"
-		"This function is the same as the C++ method\n"
-		"OGRFeature::GetFieldAsString().\n"
+		"See :cpp:func:`OGRFeature::GetFieldAsString`.\n"
 		"\n"
 		"Parameters\n"
 		"-----------\n"
-		"hFeat:\n"
-		"    handle to the feature that owned the field.\n"
-		"iField:\n"
-		"    the field to fetch, from 0 to GetFieldCount()-1.\n"
+		"fld_index : int / str\n"
+		"    Field name or 0-based numeric index. For repeated\n"
+		"    access, use of the numeric index avoids a lookup\n"
+		"    step.\n"
 		"\n"
 		"Returns\n"
 		"--------\n"
 		"str:\n"
-		"    the field value. This string is internal, and should not be modified,\n"
-		"    or freed. Its lifetime may be very brief.\n"
+		"    the field value.\n"
 		"\n"
 		""},
 	 { "Feature_GetFieldAsISO8601DateTime", _wrap_Feature_GetFieldAsISO8601DateTime, METH_VARARGS, "\n"
 		"Feature_GetFieldAsISO8601DateTime(Feature self, int id, char ** options=None) -> char const\n"
 		"Feature_GetFieldAsISO8601DateTime(Feature self, char const * field_name, char ** options=None) -> char const *\n"
+		"\n"
+		"\n"
+		"Fetch :py:const:`OFTDateTime` field value as a ISO8601 representation.\n"
+		"\n"
+		"Return a string like 'YYYY-MM-DDTHH:MM:SS(.sss)?(Z|([+|-]HH:MM))?'\n"
+		"Milliseconds are omitted if equal to zero.\n"
+		"Other field types, or errors will result in a return of an empty string.\n"
+		"\n"
+		"See :cpp:func:`OGRFeature::GetFieldAsISO8601DateTime`.\n"
+		"\n"
+		".. versionadded:: 3.7\n"
+		"\n"
+		"Parameters\n"
+		"-----------\n"
+		"fld_index : int / str\n"
+		"    Field name or 0-based numeric index. For repeated\n"
+		"    access, use of the numeric index avoids a lookup\n"
+		"    step.\n"
+		"options : dict / str\n"
+		"    Not currently used.\n"
+		"\n"
 		""},
 	 { "Feature_GetFieldAsInteger", _wrap_Feature_GetFieldAsInteger, METH_VARARGS, "\n"
 		"Feature_GetFieldAsInteger(Feature self, int id) -> int\n"
 		"Feature_GetFieldAsInteger(Feature self, char const * field_name) -> int\n"
 		"\n"
-		"int OGR_F_GetFieldAsInteger(OGRFeatureH hFeat, int iField)\n"
 		"\n"
-		"Fetch field value as integer.\n"
+		"Fetch field value as a 32-bit integer.\n"
 		"\n"
-		"OFTString features will be translated using atoi(). OFTReal fields\n"
-		"will be cast to integer. Other field types, or errors will result in a\n"
-		"return value of zero.\n"
+		":py:const:`OFTString` features will be translated using atoi().\n"
+		":py:const:`OFTReal` fields will be cast to integer. Other field types, or\n"
+		"errors will result in a return value of zero.\n"
 		"\n"
-		"This function is the same as the C++ method\n"
-		"OGRFeature::GetFieldAsInteger().\n"
+		"See :cpp:func:`GetFieldAsInteger`.\n"
 		"\n"
 		"Parameters\n"
 		"-----------\n"
-		"hFeat:\n"
-		"    handle to the feature that owned the field.\n"
-		"iField:\n"
-		"    the field to fetch, from 0 to GetFieldCount()-1.\n"
+		"fld_index : int / str\n"
+		"    Field name or 0-based numeric index. For repeated\n"
+		"    access, use of the numeric index avoids a lookup\n"
+		"    step.\n"
 		"\n"
 		"Returns\n"
 		"--------\n"
 		"int:\n"
 		"    the field value.\n"
 		"\n"
+		"Examples\n"
+		"--------\n"
+		">>> defn = ogr.FeatureDefn()\n"
+		">>> defn.AddFieldDefn(ogr.FieldDefn('my_int', ogr.OFTInteger64))\n"
+		">>> feature = ogr.Feature(defn)\n"
+		">>> feature['my_int'] = 2**32 + 1\n"
+		">>> feature.GetFieldAsInteger('my_int')\n"
+		"Warning 1: Integer overflow occurred when trying to return 64bit integer. Use GetFieldAsInteger64() instead\n"
+		"2147483647\n"
+		">>> feature.GetFieldAsInteger64('my_int')\n"
+		"4294967297\n"
+		">>> feature.GetField('my_int')\n"
+		"4294967297\n"
+		"\n"
 		""},
 	 { "Feature_GetFieldAsInteger64", _wrap_Feature_GetFieldAsInteger64, METH_VARARGS, "\n"
 		"Feature_GetFieldAsInteger64(Feature self, int id) -> GIntBig\n"
 		"Feature_GetFieldAsInteger64(Feature self, char const * field_name) -> GIntBig\n"
 		"\n"
-		"GIntBig OGR_F_GetFieldAsInteger64(OGRFeatureH hFeat, int iField)\n"
 		"\n"
 		"Fetch field value as integer 64 bit.\n"
 		"\n"
-		"OFTInteger are promoted to 64 bit. OFTString features will be\n"
-		"translated using CPLAtoGIntBig(). OFTReal fields will be cast to\n"
-		"integer. Other field types, or errors will result in a return value of\n"
-		"zero.\n"
+		":py:const:`OFTInteger` are promoted to 64 bit. :py:const:`OFTString` features\n"
+		"will be translated using :cpp:func:`CPLAtoGIntBig`. :py:const:`OFTReal` fields\n"
+		"will be cast to integer. Other field types, or errors will result in a return\n"
+		"value of zero.\n"
 		"\n"
-		"This function is the same as the C++ method\n"
-		"OGRFeature::GetFieldAsInteger64().\n"
-		"\n"
-		".. versionadded:: 2.0\n"
+		"See :cpp:func:`OGRFeature::GetFieldAsInteger64`.\n"
 		"\n"
 		"Parameters\n"
 		"-----------\n"
-		"hFeat:\n"
-		"    handle to the feature that owned the field.\n"
-		"iField:\n"
-		"    the field to fetch, from 0 to GetFieldCount()-1.\n"
+		"fld_index : int / str\n"
+		"    Field name or 0-based numeric index. For repeated\n"
+		"    access, use of the numeric index avoids a lookup\n"
+		"    step.\n"
 		"\n"
 		"Returns\n"
 		"--------\n"
 		"int:\n"
 		"    the field value.\n"
 		"\n"
 		""},
 	 { "Feature_GetFieldAsDouble", _wrap_Feature_GetFieldAsDouble, METH_VARARGS, "\n"
 		"Feature_GetFieldAsDouble(Feature self, int id) -> double\n"
 		"Feature_GetFieldAsDouble(Feature self, char const * field_name) -> double\n"
 		"\n"
-		"double OGR_F_GetFieldAsDouble(OGRFeatureH hFeat, int iField)\n"
-		"\n"
 		"Fetch field value as a double.\n"
 		"\n"
-		"OFTString features will be translated using CPLAtof(). OFTInteger\n"
+		":py:const:`OFTString` features will be translated using :cpp:func:`CPLAtof`. :py:const:`OFTInteger`\n"
 		"fields will be cast to double. Other field types, or errors will\n"
 		"result in a return value of zero.\n"
 		"\n"
-		"This function is the same as the C++ method\n"
-		"OGRFeature::GetFieldAsDouble().\n"
+		"See :cpp:func:`OGRFeature::GetFieldAsDouble`.\n"
 		"\n"
 		"Parameters\n"
 		"-----------\n"
-		"hFeat:\n"
-		"    handle to the feature that owned the field.\n"
-		"iField:\n"
-		"    the field to fetch, from 0 to GetFieldCount()-1.\n"
+		"fld_index : int / str\n"
+		"    Field name or 0-based numeric index. For repeated\n"
+		"    access, use of the numeric index avoids a lookup\n"
+		"    step.\n"
 		"\n"
 		"Returns\n"
 		"--------\n"
 		"float:\n"
 		"    the field value.\n"
 		"\n"
 		""},
 	 { "Feature_GetFieldAsDateTime", _wrap_Feature_GetFieldAsDateTime, METH_VARARGS, "\n"
 		"Feature_GetFieldAsDateTime(Feature self, int id)\n"
 		"Feature_GetFieldAsDateTime(Feature self, char const * field_name)\n"
-		"int\n"
-		"OGR_F_GetFieldAsDateTime(OGRFeatureH hFeat, int iField, int \\*pnYear,\n"
-		"int \\*pnMonth, int \\*pnDay, int \\*pnHour, int \\*pnMinute, int \\*pnSecond,\n"
-		"int \\*pnTZFlag)\n"
+		"\n"
 		"\n"
 		"Fetch field value as date and time.\n"
 		"\n"
-		"Currently this method only works for OFTDate, OFTTime and OFTDateTime\n"
-		"fields.\n"
+		"Currently this method only works for :py:const:`OFTDate`, :py:const:`OFTTime`\n"
+		"and :py:const:`OFTDateTime` fields.\n"
 		"\n"
-		"This function is the same as the C++ method\n"
-		"OGRFeature::GetFieldAsDateTime().\n"
-		"\n"
-		".. note:: Use OGR_F_GetFieldAsDateTimeEx() for second with millisecond accuracy.\n"
+		"See :cpp:func:`OGRFeature::GetFieldAsDateTime`.\n"
 		"\n"
 		"Parameters\n"
 		"-----------\n"
-		"hFeat:\n"
-		"    handle to the feature that owned the field.\n"
-		"iField:\n"
-		"    the field to fetch, from 0 to GetFieldCount()-1.\n"
-		"pnYear:\n"
-		"    (including century)\n"
-		"pnMonth:\n"
-		"    (1-12)\n"
-		"pnDay:\n"
-		"    (1-31)\n"
-		"pnHour:\n"
-		"    (0-23)\n"
-		"pnMinute:\n"
-		"    (0-59)\n"
-		"pnSecond:\n"
-		"    (0-59)\n"
-		"pnTZFlag:\n"
-		"    (0=unknown, 1=localtime, 100=GMT, see data model for\n"
-		"details)\n"
+		"fld_index : int / str\n"
+		"    Field name or 0-based numeric index. For repeated\n"
+		"    access, use of the numeric index avoids a lookup\n"
+		"    step.\n"
 		"\n"
 		"Returns\n"
 		"--------\n"
-		"int:\n"
-		"    TRUE on success or FALSE on failure.\n"
+		"list\n"
+		"    list containing [ year, month, day, hour, minute, second, timezone flag ]\n"
+		"\n"
+		"Examples\n"
+		"--------\n"
+		">>> from datetime import datetime\n"
+		">>> from zoneinfo import ZoneInfo\n"
+		">>> defn = ogr.FeatureDefn()\n"
+		">>> defn.AddFieldDefn(ogr.FieldDefn('unknown', ogr.OFTDateTime))\n"
+		">>> defn.AddFieldDefn(ogr.FieldDefn('local', ogr.OFTDateTime))\n"
+		">>> defn.AddFieldDefn(ogr.FieldDefn('utc', ogr.OFTDateTime))\n"
+		">>> feature = ogr.Feature(defn)\n"
+		">>> feature['unknown'] = datetime.now()\n"
+		">>> feature['local'] = datetime.now(ZoneInfo('Canada/Eastern'))\n"
+		">>> feature['utc'] = datetime.now(ZoneInfo('UTC'))\n"
+		">>> feature.GetFieldAsDateTime('unknown')\n"
+		"[2024, 3, 15, 20, 34, 52.594173431396484, 0]\n"
+		">>> feature.GetFieldAsDateTime('local')\n"
+		"[2024, 3, 15, 20, 34, 52.59502410888672, 84]\n"
+		">>> feature.GetFieldAsDateTime('utc')\n"
+		"[2024, 3, 16, 0, 34, 52.59580993652344, 100]\n"
+		"\n"
+		"See Also\n"
+		"--------\n"
+		":py:func:`Feature.GetFieldAsISO8601DateTime`\n"
 		"\n"
 		""},
 	 { "Feature_GetFieldAsIntegerList", _wrap_Feature_GetFieldAsIntegerList, METH_VARARGS, "\n"
 		"Feature_GetFieldAsIntegerList(Feature self, int id)\n"
 		"Feature_GetFieldAsIntegerList(Feature self, char const * field_name)\n"
 		"\n"
-		"const int\\* OGR_F_GetFieldAsIntegerList(OGRFeatureH hFeat, int iField, int\n"
-		"\\*pnCount)\n"
 		"\n"
 		"Fetch field value as a list of integers.\n"
 		"\n"
-		"Currently this function only works for OFTIntegerList fields.\n"
+		"Currently this function only works for :py:const:`OFTIntegerList` fields.\n"
 		"\n"
 		"This function is the same as the C++ method\n"
-		"OGRFeature::GetFieldAsIntegerList().\n"
+		":cpp:func:`OGRFeature::GetFieldAsIntegerList`.\n"
 		"\n"
 		"Parameters\n"
 		"-----------\n"
-		"hFeat:\n"
-		"    handle to the feature that owned the field.\n"
-		"iField:\n"
-		"    the field to fetch, from 0 to GetFieldCount()-1.\n"
-		"pnCount:\n"
-		"    an integer to put the list count (number of integers) into.\n"
+		"fld_index : int / str\n"
+		"    Field name or 0-based numeric index. For repeated\n"
+		"    access, use of the numeric index avoids a lookup\n"
+		"    step.\n"
 		"\n"
 		"Returns\n"
 		"--------\n"
-		"list[int]:\n"
-		"    the field value. This list is internal, and should not be modified, or\n"
-		"    freed. Its lifetime may be very brief. If \\*pnCount is zero on return\n"
-		"    the returned pointer may be NULL or non-NULL.\n"
+		"list:\n"
+		"    the field value.\n"
 		"\n"
 		""},
 	 { "Feature_GetFieldAsInteger64List", _wrap_Feature_GetFieldAsInteger64List, METH_VARARGS, "\n"
 		"Feature_GetFieldAsInteger64List(Feature self, int id)\n"
-		"const GIntBig\\*\n"
-		"OGR_F_GetFieldAsInteger64List(OGRFeatureH hFeat, int iField, int\n"
-		"\\*pnCount)\n"
 		"\n"
 		"Fetch field value as a list of 64 bit integers.\n"
 		"\n"
-		"Currently this function only works for OFTInteger64List fields.\n"
+		"Currently this function only works for :py:const:`OFTInteger64List` fields.\n"
 		"\n"
-		"This function is the same as the C++ method\n"
-		"OGRFeature::GetFieldAsInteger64List().\n"
-		"\n"
-		".. versionadded:: 2.0\n"
+		"See :cpp:func:`OGRFeature::GetFieldAsInteger64List`.\n"
 		"\n"
 		"Parameters\n"
 		"-----------\n"
-		"hFeat:\n"
-		"    handle to the feature that owned the field.\n"
-		"iField:\n"
-		"    the field to fetch, from 0 to GetFieldCount()-1.\n"
-		"pnCount:\n"
-		"    an integer to put the list count (number of integers) into.\n"
+		"fld_index : int / str\n"
+		"    Field name or 0-based numeric index. For repeated\n"
+		"    access, use of the numeric index avoids a lookup\n"
+		"    step.\n"
 		"\n"
 		"Returns\n"
 		"--------\n"
-		"list[int]:\n"
-		"    the field value. This list is internal, and should not be modified, or\n"
-		"    freed. Its lifetime may be very brief. If \\*pnCount is zero on return\n"
-		"    the returned pointer may be NULL or non-NULL.\n"
+		"list:\n"
+		"    the field value.\n"
 		"\n"
 		""},
 	 { "Feature_GetFieldAsDoubleList", _wrap_Feature_GetFieldAsDoubleList, METH_VARARGS, "\n"
 		"Feature_GetFieldAsDoubleList(Feature self, int id)\n"
 		"Feature_GetFieldAsDoubleList(Feature self, char const * field_name)\n"
-		"const double\\*\n"
-		"OGR_F_GetFieldAsDoubleList(OGRFeatureH hFeat, int iField, int\n"
-		"\\*pnCount)\n"
+		"\n"
 		"\n"
 		"Fetch field value as a list of doubles.\n"
 		"\n"
-		"Currently this function only works for OFTRealList fields.\n"
+		"Currently this function only works for :py:const:`OFTRealList` fields.\n"
 		"\n"
-		"This function is the same as the C++ method\n"
-		"OGRFeature::GetFieldAsDoubleList().\n"
+		"See :cpp:func:`OGRFeature::GetFieldAsDoubleList`.\n"
 		"\n"
 		"Parameters\n"
 		"-----------\n"
-		"hFeat:\n"
-		"    handle to the feature that owned the field.\n"
-		"iField:\n"
-		"    the field to fetch, from 0 to GetFieldCount()-1.\n"
-		"pnCount:\n"
-		"    an integer to put the list count (number of doubles) into.\n"
+		"fld_index : int / str\n"
+		"    Field name or 0-based numeric index. For repeated\n"
+		"    access, use of the numeric index avoids a lookup\n"
+		"    step.\n"
 		"\n"
 		"Returns\n"
+		"-------\n"
+		"list\n"
+		"\n"
+		"Examples\n"
 		"--------\n"
-		"list[float]:\n"
-		"    the field value. This list is internal, and should not be modified, or\n"
-		"    freed. Its lifetime may be very brief. If \\*pnCount is zero on return\n"
-		"    the returned pointer may be NULL or non-NULL.\n"
+		">>> defn = ogr.FeatureDefn()\n"
+		">>> defn.AddFieldDefn(ogr.FieldDefn('list', ogr.OFTRealList))\n"
+		">>> feature = ogr.Feature(defn)\n"
+		">>> feature['list'] = [1.1, 2.2, 3.3]\n"
+		">>> feature.GetFieldAsDoubleList('list')\n"
+		"[1.1, 2.2, 3.3]\n"
 		"\n"
 		""},
 	 { "Feature_GetFieldAsStringList", _wrap_Feature_GetFieldAsStringList, METH_VARARGS, "\n"
 		"Feature_GetFieldAsStringList(Feature self, int id) -> char **\n"
-		"char\\*\\*\n"
-		"OGR_F_GetFieldAsStringList(OGRFeatureH hFeat, int iField)\n"
 		"\n"
-		"Fetch field value as a list of strings.\n"
 		"\n"
-		"Currently this method only works for OFTStringList fields.\n"
+		"Fetch field value as a list of strings.\n"
 		"\n"
-		"The returned list is terminated by a NULL pointer. The number of\n"
-		"elements can also be calculated using CSLCount().\n"
+		"Currently this method only works for :py:const:`OFTStringList` fields.\n"
 		"\n"
-		"This function is the same as the C++ method\n"
-		"OGRFeature::GetFieldAsStringList().\n"
+		"See :cpp:func:`OGRFeature::GetFieldAsStringList`.\n"
 		"\n"
 		"Parameters\n"
 		"-----------\n"
-		"hFeat:\n"
-		"    handle to the feature that owned the field.\n"
-		"iField:\n"
-		"    the field to fetch, from 0 to GetFieldCount()-1.\n"
+		"fld_index : int / str\n"
+		"    Field name or 0-based numeric index. For repeated\n"
+		"    access, use of the numeric index avoids a lookup\n"
+		"    step.\n"
 		"\n"
 		"Returns\n"
 		"--------\n"
-		"list[str]:\n"
-		"    the field value. This list is internal, and should not be modified, or\n"
-		"    freed. Its lifetime may be very brief.\n"
+		"list:\n"
+		"    the field value.\n"
 		"\n"
 		""},
 	 { "Feature_GetFieldAsBinary", _wrap_Feature_GetFieldAsBinary, METH_VARARGS, "\n"
 		"Feature_GetFieldAsBinary(Feature self, int id) -> OGRErr\n"
 		"Feature_GetFieldAsBinary(Feature self, char const * field_name) -> OGRErr\n"
-		"GByte\\*\n"
-		"OGR_F_GetFieldAsBinary(OGRFeatureH hFeat, int iField, int \\*pnBytes)\n"
+		"\n"
 		"\n"
 		"Fetch field value as binary.\n"
 		"\n"
-		"This method only works for OFTBinary and OFTString fields.\n"
+		"This method only works for :py:const:`OFTBinary` and :py:const:`OFTString` fields.\n"
 		"\n"
-		"This function is the same as the C++ method\n"
-		"OGRFeature::GetFieldAsBinary().\n"
+		"See :cpp:func:`OGRFeature::GetFieldAsBinary`.\n"
 		"\n"
 		"Parameters\n"
 		"-----------\n"
-		"hFeat:\n"
-		"    handle to the feature that owned the field.\n"
-		"iField:\n"
-		"    the field to fetch, from 0 to GetFieldCount()-1.\n"
-		"pnBytes:\n"
-		"    location to place count of bytes returned.\n"
-		"\n"
+		"fld_index : int / str\n"
+		"    Field name or 0-based numeric index. For repeated\n"
+		"    access, use of the numeric index avoids a lookup\n"
+		"    step.\n"
 		"\n"
 		"Returns\n"
 		"--------\n"
-		"list:\n"
-		"    the field value. This list is internal, and should not be modified, or\n"
-		"    freed. Its lifetime may be very brief.\n"
+		"bytearray\n"
 		"\n"
 		""},
 	 { "Feature_IsFieldSet", _wrap_Feature_IsFieldSet, METH_VARARGS, "\n"
 		"Feature_IsFieldSet(Feature self, int id) -> bool\n"
 		"Feature_IsFieldSet(Feature self, char const * field_name) -> bool\n"
 		"\n"
-		"int OGR_F_IsFieldSet(OGRFeatureH hFeat, int iField)\n"
 		"\n"
 		"Test if a field has ever been assigned a value or not.\n"
 		"\n"
-		"This function is the same as the C++ method OGRFeature::IsFieldSet().\n"
+		"See :cpp:func:`OGRFeature::IsFieldSet`.\n"
 		"\n"
 		"Parameters\n"
 		"-----------\n"
-		"hFeat:\n"
-		"    handle to the feature on which the field is.\n"
-		"iField:\n"
-		"    the field to test.\n"
+		"fld_index : int / str\n"
+		"    Field name or 0-based numeric index. For repeated\n"
+		"    access, use of the numeric index avoids a lookup\n"
+		"    step.\n"
 		"\n"
 		"Returns\n"
 		"--------\n"
-		"int:\n"
-		"    TRUE if the field has been set, otherwise false.\n"
+		"bool:\n"
+		"    ``True`` if the field has been set, otherwise ``False``.\n"
 		"\n"
 		""},
 	 { "Feature_IsFieldNull", _wrap_Feature_IsFieldNull, METH_VARARGS, "\n"
 		"Feature_IsFieldNull(Feature self, int id) -> bool\n"
 		"Feature_IsFieldNull(Feature self, char const * field_name) -> bool\n"
 		"\n"
-		"int OGR_F_IsFieldNull(OGRFeatureH hFeat, int iField)\n"
 		"\n"
 		"Test if a field is null.\n"
 		"\n"
-		"This function is the same as the C++ method OGRFeature::IsFieldNull().\n"
-		"\n"
-		".. versionadded:: 2.2\n"
+		"See :cpp:func:OGRFeature::`IsFieldNull`.\n"
 		"\n"
 		"Parameters\n"
 		"-----------\n"
-		"hFeat:\n"
-		"    handle to the feature on which the field is.\n"
-		"iField:\n"
-		"    the field to test.\n"
+		"fld_index : int / str\n"
+		"    Field name or 0-based numeric index. For repeated\n"
+		"    access, use of the numeric index avoids a lookup\n"
+		"    step.\n"
 		"\n"
 		"Returns\n"
 		"--------\n"
-		"int:\n"
-		"    TRUE if the field is null, otherwise false.\n"
+		"bool:\n"
+		"    ``True`` if the field is null, otherwise ``False``\n"
 		"\n"
 		""},
 	 { "Feature_IsFieldSetAndNotNull", _wrap_Feature_IsFieldSetAndNotNull, METH_VARARGS, "\n"
 		"Feature_IsFieldSetAndNotNull(Feature self, int id) -> bool\n"
 		"Feature_IsFieldSetAndNotNull(Feature self, char const * field_name) -> bool\n"
 		"\n"
-		"int OGR_F_IsFieldSetAndNotNull(OGRFeatureH hFeat, int iField)\n"
 		"\n"
 		"Test if a field is set and not null.\n"
 		"\n"
-		"This function is the same as the C++ method\n"
-		"OGRFeature::IsFieldSetAndNotNull().\n"
-		"\n"
-		".. versionadded:: 2.2\n"
+		"See :cpp:func:`OGRFeature::IsFieldSetAndNotNull`.\n"
 		"\n"
 		"Parameters\n"
 		"-----------\n"
-		"hFeat:\n"
-		"    handle to the feature on which the field is.\n"
-		"iField:\n"
-		"    the field to test.\n"
+		"fld_index : int / str\n"
+		"    Field name or 0-based numeric index. For repeated\n"
+		"    access, use of the numeric index avoids a lookup\n"
+		"    step.\n"
 		"\n"
 		"Returns\n"
 		"--------\n"
-		"int:\n"
-		"    TRUE if the field is set and not null, otherwise false.\n"
+		"bool:\n"
+		"    ``True`` if the field is set and not null, otherwise ``False``.\n"
 		"\n"
 		""},
 	 { "Feature_GetFieldIndex", _wrap_Feature_GetFieldIndex, METH_VARARGS, "\n"
 		"Feature_GetFieldIndex(Feature self, char const * field_name) -> int\n"
 		"\n"
-		"int OGR_F_GetFieldIndex(OGRFeatureH hFeat, const char \\*pszName)\n"
 		"\n"
 		"Fetch the field index given field name.\n"
 		"\n"
-		"This is a cover for the OGRFeatureDefn::GetFieldIndex() method.\n"
-		"\n"
-		"This function is the same as the C++ method\n"
-		"OGRFeature::GetFieldIndex().\n"
+		"See :cpp:func:`OGRFeature::GetFieldIndex`.\n"
 		"\n"
 		"Parameters\n"
 		"-----------\n"
-		"hFeat:\n"
-		"    handle to the feature on which the field is found.\n"
-		"pszName:\n"
+		"field_name:\n"
 		"    the name of the field to search for.\n"
 		"\n"
 		"Returns\n"
 		"--------\n"
 		"int:\n"
 		"    the field index, or -1 if no matching field is found.\n"
 		"\n"
 		""},
 	 { "Feature_GetGeomFieldIndex", _wrap_Feature_GetGeomFieldIndex, METH_VARARGS, "\n"
 		"Feature_GetGeomFieldIndex(Feature self, char const * field_name) -> int\n"
 		"\n"
-		"int OGR_F_GetGeomFieldIndex(OGRFeatureH hFeat, const char \\*pszName)\n"
 		"\n"
 		"Fetch the geometry field index given geometry field name.\n"
 		"\n"
-		"This is a cover for the OGRFeatureDefn::GetGeomFieldIndex() method.\n"
-		"\n"
-		"This function is the same as the C++ method\n"
-		"OGRFeature::GetGeomFieldIndex().\n"
-		"\n"
-		".. versionadded:: 1.11\n"
+		"See :cpp:func:`OGRFeature::GetGeomFieldIndex`.\n"
 		"\n"
 		"Parameters\n"
 		"-----------\n"
-		"hFeat:\n"
-		"    handle to the feature on which the geometry field is found.\n"
-		"pszName:\n"
+		"field_name:\n"
 		"    the name of the geometry field to search for.\n"
 		"\n"
-		"\n"
 		"Returns\n"
 		"--------\n"
 		"int:\n"
 		"    the geometry field index, or -1 if no matching geometry field is found.\n"
 		"\n"
 		""},
 	 { "Feature_GetFID", _wrap_Feature_GetFID, METH_O, "\n"
 		"Feature_GetFID(Feature self) -> GIntBig\n"
-		"GIntBig OGR_F_GetFID(OGRFeatureH\n"
-		"hFeat)\n"
-		"\n"
-		"Get feature identifier.\n"
 		"\n"
-		"This function is the same as the C++ method OGRFeature::GetFID().\n"
-		"Note: since GDAL 2.0, this method returns a GIntBig (previously a\n"
-		"long)\n"
 		"\n"
-		"Parameters\n"
-		"-----------\n"
-		"hFeat:\n"
-		"    handle to the feature from which to get the feature\n"
-		"identifier.\n"
+		"Get feature identifier.\n"
+		"See :cpp:func:`OGRFeature::GetFID`\n"
 		"\n"
 		"Returns\n"
 		"-------\n"
 		"int:\n"
-		"    feature id or OGRNullFID if none has been assigned.\n"
+		"    feature id or :py:const:`NullFID` if none has been assigned.\n"
 		"\n"
 		""},
 	 { "Feature_SetFID", _wrap_Feature_SetFID, METH_VARARGS, "\n"
 		"Feature_SetFID(Feature self, GIntBig fid) -> OGRErr\n"
-		"OGRErr OGR_F_SetFID(OGRFeatureH hFeat,\n"
-		"GIntBig nFID)\n"
+		"\n"
 		"\n"
 		"Set the feature identifier.\n"
 		"\n"
 		"For specific types of features this operation may fail on illegal\n"
 		"features ids. Generally it always succeeds. Feature ids should be\n"
-		"greater than or equal to zero, with the exception of OGRNullFID (-1)\n"
+		"greater than or equal to zero, with the exception of :py:const:NullFID` (-1)\n"
 		"indicating that the feature id is unknown.\n"
 		"\n"
-		"This function is the same as the C++ method OGRFeature::SetFID().\n"
+		"See :cpp:func:`OGRFeature::SetFID`.\n"
 		"\n"
 		"Parameters\n"
 		"-----------\n"
-		"hFeat:\n"
-		"    handle to the feature to set the feature id to.\n"
-		"nFID:\n"
+		"fid:\n"
 		"    the new feature identifier value to assign.\n"
 		"\n"
 		"Returns\n"
 		"--------\n"
-		"OGRErr:\n"
-		"    On success OGRERR_NONE, or on failure some other value.\n"
+		"int:\n"
+		"    :py:const:`OGRERR_NONE` on success, or some other value on failure.\n"
 		"\n"
 		""},
 	 { "Feature_DumpReadable", _wrap_Feature_DumpReadable, METH_O, "\n"
 		"Feature_DumpReadable(Feature self)\n"
-		"void\n"
-		"OGR_F_DumpReadable(OGRFeatureH hFeat, FILE \\*fpOut)\n"
 		"\n"
-		"Dump this feature in a human readable form.\n"
 		"\n"
-		"This dumps the attributes, and geometry; however, it doesn't\n"
-		"definition information (other than field types and names), nor does it\n"
+		"Print this feature in a human readable form.\n"
+		"\n"
+		"This dumps the attributes and geometry. It doesn't include\n"
+		"definition information other than field types and names nor does it\n"
 		"report the geometry spatial reference system.\n"
 		"\n"
-		"This function is the same as the C++ method\n"
-		"OGRFeature::DumpReadable().\n"
+		"See :cpp:func:`OGRFeature::DumpReadable`.\n"
 		"\n"
-		"Parameters\n"
-		"-----------\n"
-		"hFeat:\n"
-		"    handle to the feature to dump.\n"
-		"fpOut:\n"
-		"    the stream to write to, such as strout.\n"
+		"Examples\n"
+		"--------\n"
+		">>> with gdal.OpenEx('data/poly.shp') as ds:\n"
+		"...     lyr = ds.GetLayer(0)\n"
+		"...     feature = lyr.GetNextFeature()\n"
+		"...     feature.DumpReadable()\n"
+		"...\n"
+		"OGRFeature(poly):0\n"
+		"  AREA (Real) = 215229.266\n"
+		"  EAS_ID (Integer64) = 168\n"
+		"  PRFEDEA (String) = 35043411\n"
+		"  POLYGON ((479819.84375 4765180.5,479690.1875 4765259.5,479647.0 4765369.5,479730.375 4765400.5,480039.03125 4765539.5,480035.34375 4765558.5,480159.78125 4765610.5,480202.28125 4765482.0,480365.0 4765015.5,480389.6875 4764950.0,480133.96875 4764856.5,480080.28125 4764979.5,480082.96875 4765049.5,480088.8125 4765139.5,480059.90625 4765239.5,480019.71875 4765319.5,479980.21875 4765409.5,479909.875 4765370.0,479859.875 4765270.0,479819.84375 4765180.5))\n"
+		"\n"
+		""},
+	 { "Feature_DumpReadableAsString", _wrap_Feature_DumpReadableAsString, METH_VARARGS, "\n"
+		"Feature_DumpReadableAsString(Feature self, char ** options=None) -> retStringAndCPLFree *\n"
+		"\n"
+		"\n"
+		"Return feature information in a human-readable form.\n"
+		"Returns the text printed by :py:func:`Feature.DumpReadable`.\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"str\n"
 		"\n"
 		""},
-	 { "Feature_DumpReadableAsString", _wrap_Feature_DumpReadableAsString, METH_VARARGS, "Feature_DumpReadableAsString(Feature self, char ** options=None) -> retStringAndCPLFree *"},
 	 { "Feature_UnsetField", _wrap_Feature_UnsetField, METH_VARARGS, "\n"
 		"Feature_UnsetField(Feature self, int id)\n"
 		"Feature_UnsetField(Feature self, char const * field_name)\n"
 		"\n"
-		"void OGR_F_UnsetField(OGRFeatureH hFeat, int iField)\n"
 		"\n"
 		"Clear a field, marking it as unset.\n"
 		"\n"
-		"This function is the same as the C++ method OGRFeature::UnsetField().\n"
+		"See :cpp:func:`OGRFeature::UnsetField`.\n"
 		"\n"
 		"Parameters\n"
 		"-----------\n"
-		"hFeat:\n"
-		"    handle to the feature on which the field is.\n"
-		"iField:\n"
-		"    the field to unset.\n"
+		"fld_index : int / str\n"
+		"    Field name or 0-based numeric index. For repeated\n"
+		"    access, use of the numeric index avoids a lookup\n"
+		"    step.\n"
 		"\n"
 		""},
 	 { "Feature_SetFieldNull", _wrap_Feature_SetFieldNull, METH_VARARGS, "\n"
 		"Feature_SetFieldNull(Feature self, int id)\n"
 		"Feature_SetFieldNull(Feature self, char const * field_name)\n"
 		"\n"
-		"void OGR_F_SetFieldNull(OGRFeatureH hFeat, int iField)\n"
 		"\n"
 		"Clear a field, marking it as null.\n"
 		"\n"
-		"This function is the same as the C++ method\n"
-		"OGRFeature::SetFieldNull().\n"
-		"\n"
-		".. versionadded:: 2.2\n"
+		"See :cpp:func:`OGRFeature::SetFieldNull`.\n"
 		"\n"
 		"Parameters\n"
 		"-----------\n"
-		"hFeat:\n"
-		"    handle to the feature on which the field is.\n"
-		"iField:\n"
-		"    the field to set to null.\n"
-		"\n"
-		""},
-	 { "Feature_SetFieldInteger64", _wrap_Feature_SetFieldInteger64, METH_VARARGS, "\n"
-		"Feature_SetFieldInteger64(Feature self, int id, GIntBig value)\n"
-		"void\n"
-		"OGR_F_SetFieldInteger64(OGRFeatureH hFeat, int iField, GIntBig nValue)\n"
-		"\n"
-		"Set field to 64 bit integer value.\n"
-		"\n"
-		"OFTInteger, OFTInteger64 and OFTReal fields will be set directly.\n"
-		"OFTString fields will be assigned a string representation of the\n"
-		"value, but not necessarily taking into account formatting constraints\n"
-		"on this field. Other field types may be unaffected.\n"
-		"\n"
-		"This function is the same as the C++ method OGRFeature::SetField().\n"
-		"\n"
-		"This method has only an effect on the in-memory feature object. If\n"
-		"this object comes from a layer and the modifications must be\n"
-		"serialized back to the datasource, OGR_L_SetFeature() must be used\n"
-		"afterwards. Or if this is a new feature, OGR_L_CreateFeature() must be\n"
-		"used afterwards.\n"
+		"fld_index : int / str\n"
+		"    Field name or 0-based numeric index. For repeated\n"
+		"    access, use of the numeric index avoids a lookup\n"
+		"    step.\n"
 		"\n"
-		".. versionadded:: 2.0\n"
-		"\n"
-		"Parameters\n"
-		"-----------\n"
-		"hFeat:\n"
-		"    handle to the feature that owned the field.\n"
-		"iField:\n"
-		"    the field to fetch, from 0 to GetFieldCount()-1.\n"
-		"nValue:\n"
-		"    the value to assign.\n"
 		"\n"
 		""},
+	 { "Feature_SetFieldInteger64", _wrap_Feature_SetFieldInteger64, METH_VARARGS, "Feature_SetFieldInteger64(Feature self, int id, GIntBig value)"},
 	 { "Feature_SetField", _wrap_Feature_SetField, METH_VARARGS, "\n"
 		"Feature_SetField(Feature self, int id, char const * value)\n"
 		"Feature_SetField(Feature self, char const * field_name, char const * value)\n"
 		"Feature_SetField(Feature self, int id, double value)\n"
 		"Feature_SetField(Feature self, char const * field_name, double value)\n"
 		"Feature_SetField(Feature self, int id, int year, int month, int day, int hour, int minute, float second, int tzflag)\n"
 		"Feature_SetField(Feature self, char const * field_name, int year, int month, int day, int hour, int minute, float second, int tzflag)\n"
 		""},
 	 { "Feature_SetFieldIntegerList", _wrap_Feature_SetFieldIntegerList, METH_VARARGS, "\n"
 		"Feature_SetFieldIntegerList(Feature self, int id, int nList)\n"
 		"void\n"
-		"OGR_F_SetFieldIntegerList(OGRFeatureH hFeat, int iField, int nCount,\n"
-		"const int \\*panValues)\n"
 		"\n"
-		"Set field to list of integers value.\n"
+		"Set field to list of integer values.\n"
 		"\n"
-		"This function currently on has an effect of OFTIntegerList,\n"
-		"OFTInteger64List and OFTRealList fields.\n"
+		"This function currently on has an effect of :py:const:`OFTIntegerList`,\n"
+		":py:const:`OFTInteger64List`, :py:const:`OFTRealList` fields.\n"
 		"\n"
-		"This function is the same as the C++ method OGRFeature::SetField().\n"
+		"See :cpp:func:`OGRFeature::SetField`.\n"
 		"\n"
 		"This method has only an effect on the in-memory feature object. If\n"
 		"this object comes from a layer and the modifications must be\n"
-		"serialized back to the datasource, OGR_L_SetFeature() must be used\n"
-		"afterwards. Or if this is a new feature, OGR_L_CreateFeature() must be\n"
+		"serialized back to the datasource, :py:meth:`Layer.SetFeature` must be used\n"
+		"afterwards. Or if this is a new feature, :py:meth:`Layer.CreateFeature` must be\n"
 		"used afterwards.\n"
 		"\n"
 		"Parameters\n"
 		"-----------\n"
-		"hFeat:\n"
-		"    handle to the feature that owned the field.\n"
-		"iField:\n"
-		"    the field to set, from 0 to GetFieldCount()-1.\n"
-		"nCount:\n"
-		"    the number of values in the list being assigned.\n"
-		"panValues:\n"
+		"id : int\n"
+		"    the field to set, from 0 to :py:meth:`GetFieldCount`-1.\n"
+		"nList : list\n"
 		"    the values to assign.\n"
 		"\n"
 		""},
 	 { "Feature_SetFieldInteger64List", _wrap_Feature_SetFieldInteger64List, METH_VARARGS, "\n"
 		"Feature_SetFieldInteger64List(Feature self, int id, int nList)\n"
 		"void\n"
-		"OGR_F_SetFieldInteger64List(OGRFeatureH hFeat, int iField, int nCount,\n"
-		"const GIntBig \\*panValues)\n"
 		"\n"
-		"Set field to list of 64 bit integers value.\n"
+		"Set field to list of 64 bit integer values.\n"
 		"\n"
-		"This function currently on has an effect of OFTIntegerList,\n"
-		"OFTInteger64List and OFTRealList fields.\n"
+		"This function currently on has an effect of :py:const:`OFTIntegerList`,\n"
+		":py:const:`OFTInteger64List`, :py:const:`OFTRealList` fields.\n"
 		"\n"
-		"This function is the same as the C++ method OGRFeature::SetField().\n"
+		"See :cpp:func:`OGRFeature::SetField`.\n"
 		"\n"
 		"This method has only an effect on the in-memory feature object. If\n"
 		"this object comes from a layer and the modifications must be\n"
-		"serialized back to the datasource, OGR_L_SetFeature() must be used\n"
-		"afterwards. Or if this is a new feature, OGR_L_CreateFeature() must be\n"
+		"serialized back to the datasource, :py:meth:`Layer.SetFeature` must be used\n"
+		"afterwards. Or if this is a new feature, :py:meth:`Layer.CreateFeature` must be\n"
 		"used afterwards.\n"
 		"\n"
-		".. versionadded:: 2.0\n"
-		"\n"
 		"Parameters\n"
 		"-----------\n"
-		"hFeat:\n"
-		"    handle to the feature that owned the field.\n"
-		"iField:\n"
-		"    the field to set, from 0 to GetFieldCount()-1.\n"
-		"nCount:\n"
-		"    the number of values in the list being assigned.\n"
-		"panValues:\n"
+		"id : int\n"
+		"    the field to set, from 0 to :py:meth:`GetFieldCount`-1.\n"
+		"nList : list\n"
 		"    the values to assign.\n"
 		"\n"
 		""},
 	 { "Feature_SetFieldDoubleList", _wrap_Feature_SetFieldDoubleList, METH_VARARGS, "\n"
 		"Feature_SetFieldDoubleList(Feature self, int id, int nList)\n"
-		"void\n"
-		"OGR_F_SetFieldDoubleList(OGRFeatureH hFeat, int iField, int nCount,\n"
-		"const double \\*padfValues)\n"
 		"\n"
-		"Set field to list of doubles value.\n"
 		"\n"
-		"This function currently on has an effect of OFTIntegerList,\n"
-		"OFTInteger64List, OFTRealList fields.\n"
+		"Set field to list of double values.\n"
 		"\n"
-		"This function is the same as the C++ method OGRFeature::SetField().\n"
+		"This function currently on has an effect of :py:const:`OFTIntegerList`,\n"
+		":py:const:`OFTInteger64List`, :py:const:`OFTRealList` fields.\n"
+		"\n"
+		"See :cpp:func:`OGRFeature::SetField`.\n"
 		"\n"
 		"This method has only an effect on the in-memory feature object. If\n"
 		"this object comes from a layer and the modifications must be\n"
-		"serialized back to the datasource, OGR_L_SetFeature() must be used\n"
-		"afterwards. Or if this is a new feature, OGR_L_CreateFeature() must be\n"
+		"serialized back to the datasource, :py:meth:`Layer.SetFeature` must be used\n"
+		"afterwards. Or if this is a new feature, :py:meth:`Layer.CreateFeature` must be\n"
 		"used afterwards.\n"
 		"\n"
 		"Parameters\n"
 		"-----------\n"
-		"hFeat:\n"
-		"    handle to the feature that owned the field.\n"
-		"iField:\n"
-		"    the field to set, from 0 to GetFieldCount()-1.\n"
-		"nCount:\n"
-		"    the number of values in the list being assigned.\n"
-		"padfValues:\n"
+		"id : int\n"
+		"    the field to set, from 0 to :py:meth:`GetFieldCount`-1.\n"
+		"nList : list\n"
 		"    the values to assign.\n"
 		"\n"
 		""},
 	 { "Feature_SetFieldStringList", _wrap_Feature_SetFieldStringList, METH_VARARGS, "\n"
 		"Feature_SetFieldStringList(Feature self, int id, char ** pList)\n"
-		"void\n"
-		"OGR_F_SetFieldStringList(OGRFeatureH hFeat, int iField, CSLConstList\n"
-		"papszValues)\n"
+		"\n"
 		"\n"
 		"Set field to list of strings value.\n"
 		"\n"
-		"This function currently on has an effect of OFTStringList fields.\n"
+		"This function currently only has an effect of :py:const:`OFTStringList` fields.\n"
 		"\n"
-		"This function is the same as the C++ method OGRFeature::SetField().\n"
+		"See :cpp:func:`OGRFeature::SetField`.\n"
 		"\n"
 		"This method has only an effect on the in-memory feature object. If\n"
 		"this object comes from a layer and the modifications must be\n"
-		"serialized back to the datasource, OGR_L_SetFeature() must be used\n"
-		"afterwards. Or if this is a new feature, OGR_L_CreateFeature() must be\n"
+		"serialized back to the datasource, :py:meth:`Layer.SetFeature` must be used\n"
+		"afterwards. Or if this is a new feature, :py:meth:`Layer.CreateFeature` must be\n"
 		"used afterwards.\n"
 		"\n"
 		"Parameters\n"
 		"-----------\n"
-		"hFeat:\n"
-		"    handle to the feature that owned the field.\n"
-		"iField:\n"
-		"    the field to set, from 0 to GetFieldCount()-1.\n"
-		"papszValues:\n"
-		"    the values to assign. List of NUL-terminated string,\n"
-		"ending with a NULL pointer.\n"
+		"fld_index : int / str\n"
+		"    Field name or 0-based numeric index. For repeated\n"
+		"    access, use of the numeric index avoids a lookup\n"
+		"    step.\n"
+		"value:\n"
+		"    the value to assign.\n"
 		"\n"
 		""},
 	 { "Feature__SetFieldBinary", _wrap_Feature__SetFieldBinary, METH_VARARGS, "Feature__SetFieldBinary(Feature self, int id, int nLen)"},
 	 { "Feature_SetFieldBinaryFromHexString", _wrap_Feature_SetFieldBinaryFromHexString, METH_VARARGS, "\n"
 		"Feature_SetFieldBinaryFromHexString(Feature self, int id, char const * pszValue)\n"
 		"Feature_SetFieldBinaryFromHexString(Feature self, char const * field_name, char const * pszValue)\n"
 		""},
 	 { "Feature_SetFrom", (PyCFunction)(void(*)(void))_wrap_Feature_SetFrom, METH_VARARGS|METH_KEYWORDS, "\n"
 		"Feature_SetFrom(Feature self, Feature other, int forgiving=1) -> OGRErr\n"
-		"OGRErr OGR_F_SetFrom(OGRFeatureH\n"
-		"hFeat, OGRFeatureH hOtherFeat, int bForgiving)\n"
 		"\n"
 		"Set one feature from another.\n"
 		"\n"
 		"Overwrite the contents of this feature from the geometry and\n"
-		"attributes of another. The hOtherFeature does not need to have the\n"
-		"same OGRFeatureDefn. Field values are copied by corresponding field\n"
+		"attributes of another. The other feature does not need to have the\n"
+		"same :py:class:`FeatureDefn`. Field values are copied by corresponding field\n"
 		"names. Field types do not have to exactly match. OGR_F_SetField\\*()\n"
 		"function conversion rules will be applied as needed.\n"
 		"\n"
-		"This function is the same as the C++ method OGRFeature::SetFrom().\n"
+		"See :cpp:func:`OGRFeature::SetFrom`.\n"
 		"\n"
 		"Parameters\n"
 		"-----------\n"
-		"hFeat:\n"
-		"    handle to the feature to set to.\n"
-		"hOtherFeat:\n"
-		"    handle to the feature from which geometry, and field\n"
-		"    values will be copied.\n"
-		"bForgiving:\n"
-		"    TRUE if the operation should continue despite lacking\n"
+		"other : Feature\n"
+		"    feature from which geometry and field values will be copied.\n"
+		"forgiving : bool, default = True\n"
+		"    ``True`` if the operation should continue despite lacking\n"
 		"    output fields matching some of the source fields.\n"
 		"\n"
 		"Returns\n"
 		"--------\n"
-		"OGRErr:\n"
-		"    OGRERR_NONE if the operation succeeds, even if some values are not\n"
+		"int:\n"
+		"    :py:const:`OGRERR_NONE` if the operation succeeds, even if some values are not\n"
 		"    transferred, otherwise an error code.\n"
 		"\n"
 		""},
 	 { "Feature_SetFromWithMap", _wrap_Feature_SetFromWithMap, METH_VARARGS, "\n"
 		"Feature_SetFromWithMap(Feature self, Feature other, int forgiving, int nList) -> OGRErr\n"
-		"OGRErr\n"
-		"OGR_F_SetFromWithMap(OGRFeatureH hFeat, OGRFeatureH hOtherFeat, int\n"
-		"bForgiving, const int \\*panMap)\n"
+		"\n"
 		"\n"
 		"Set one feature from another.\n"
 		"\n"
 		"Overwrite the contents of this feature from the geometry and\n"
-		"attributes of another. The hOtherFeature does not need to have the\n"
-		"same OGRFeatureDefn. Field values are copied according to the provided\n"
+		"attributes of another. The other feature does not need to have the\n"
+		"same :py:class:`FeatureDefn`. Field values are copied according to the provided\n"
 		"indices map. Field types do not have to exactly match.\n"
 		"OGR_F_SetField\\*() function conversion rules will be applied as needed.\n"
-		"This is more efficient than OGR_F_SetFrom() in that this doesn't\n"
+		"This is more efficient than :py:meth:SetFrom` in that this doesn't\n"
 		"lookup the fields by their names. Particularly useful when the field\n"
 		"names don't match.\n"
 		"\n"
-		"This function is the same as the C++ method OGRFeature::SetFrom().\n"
+		"See :cpp:func:`OGRFeature::SetFrom`.\n"
 		"\n"
 		"Parameters\n"
 		"-----------\n"
-		"hFeat:\n"
-		"    handle to the feature to set to.\n"
-		"hOtherFeat:\n"
+		"other : Feature\n"
 		"    handle to the feature from which geometry, and field\n"
 		"    values will be copied.\n"
-		"panMap:\n"
+		"forgiving : bool\n"
+		"    ``True`` if the operation should continue despite lacking\n"
+		"    output fields matching some of the source fields.\n"
+		"nList : list\n"
 		"    Array of the indices of the destination feature's fields\n"
 		"    stored at the corresponding index of the source feature's fields. A\n"
 		"    value of -1 should be used to ignore the source's field. The array\n"
 		"    should not be NULL and be as long as the number of fields in the\n"
 		"    source feature.\n"
-		"bForgiving:\n"
-		"    TRUE if the operation should continue despite lacking\n"
-		"    output fields matching some of the source fields.\n"
 		"\n"
 		"Returns\n"
 		"--------\n"
 		"OGRErr:\n"
-		"    OGRERR_NONE if the operation succeeds, even if some values are not\n"
+		"    :py:const:`OGRERR_NONE` if the operation succeeds, even if some values are not\n"
 		"    transferred, otherwise an error code.\n"
 		"\n"
 		""},
 	 { "Feature_GetStyleString", _wrap_Feature_GetStyleString, METH_O, "\n"
 		"Feature_GetStyleString(Feature self) -> char const *\n"
-		"const char\\*\n"
-		"OGR_F_GetStyleString(OGRFeatureH hFeat)\n"
+		"\n"
 		"\n"
 		"Fetch style string for this feature.\n"
 		"\n"
 		"Set the OGR Feature Style Specification for details on the format of\n"
-		"this string, and ogr_featurestyle.h for services available to parse\n"
+		"this string, and :source_file:`ogr/ogr_featurestyle.h` for services available to parse\n"
 		"it.\n"
 		"\n"
-		"This function is the same as the C++ method\n"
-		"OGRFeature::GetStyleString().\n"
-		"\n"
-		"Parameters\n"
-		"-----------\n"
-		"hFeat:\n"
-		"    handle to the feature to get the style from.\n"
+		"See :cpp:func:`OGRFeature::GetStyleString`.\n"
 		"\n"
 		"Returns\n"
 		"--------\n"
-		"str:\n"
-		"    a reference to a representation in string format, or NULL if there\n"
-		"    isn't one.\n"
+		"str or None\n"
 		"\n"
 		""},
 	 { "Feature_SetStyleString", _wrap_Feature_SetStyleString, METH_VARARGS, "\n"
 		"Feature_SetStyleString(Feature self, char const * the_string)\n"
-		"void\n"
-		"OGR_F_SetStyleString(OGRFeatureH hFeat, const char \\*pszStyle)\n"
 		"\n"
-		"Set feature style string.\n"
 		"\n"
-		"This method operate exactly as OGR_F_SetStyleStringDirectly() except\n"
-		"that it does not assume ownership of the passed string, but instead\n"
-		"makes a copy of it.\n"
+		"Set feature style string.\n"
 		"\n"
-		"This function is the same as the C++ method\n"
-		"OGRFeature::SetStyleString().\n"
+		"See :cpp:func:`OGRFeature::SetStyleString`.\n"
 		"\n"
 		"Parameters\n"
 		"-----------\n"
-		"hFeat:\n"
-		"    handle to the feature to set style to.\n"
-		"pszStyle:\n"
-		"    the style string to apply to this feature, cannot be NULL.\n"
+		"the_string : str\n"
+		"    the style string to apply to this feature\n"
 		"\n"
 		""},
 	 { "Feature_GetFieldType", _wrap_Feature_GetFieldType, METH_VARARGS, "\n"
 		"Feature_GetFieldType(Feature self, int id) -> OGRFieldType\n"
 		"Feature_GetFieldType(Feature self, char const * field_name) -> OGRFieldType\n"
+		"\n"
+		"\n"
+		"Return the type of the given field.\n"
+		"\n"
+		"Parameters\n"
+		"-----------\n"
+		"fld_index : int / str\n"
+		"    Field name or 0-based numeric index. For repeated\n"
+		"    access, use of the numeric index avoids a lookup\n"
+		"    step.\n"
+		"\n"
+		"Returns\n"
+		"--------\n"
+		"int\n"
+		"    field type code (e.g., :py:const:`OFTInteger`)\n"
+		"\n"
 		""},
 	 { "Feature_Validate", _wrap_Feature_Validate, METH_VARARGS, "\n"
 		"Feature_Validate(Feature self, int flags=OGR_F_VAL_ALL, int bEmitError=TRUE) -> int\n"
-		"int OGR_F_Validate(OGRFeatureH\n"
-		"hFeat, int nValidateFlags, int bEmitError)\n"
 		"\n"
-		"Validate that a feature meets constraints of its schema.\n"
 		"\n"
-		"The scope of test is specified with the nValidateFlags parameter.\n"
+		"Validate that a feature meets constraints of its schema.\n"
 		"\n"
-		"Regarding OGR_F_VAL_WIDTH, the test is done assuming the string width\n"
-		"must be interpreted as the number of UTF-8 characters. Some drivers\n"
-		"might interpret the width as the number of bytes instead. So this test\n"
-		"is rather conservative (if it fails, then it will fail for all\n"
-		"interpretations).\n"
+		"The scope of test is specified with the ``flags`` parameter.\n"
 		"\n"
-		"This function is the same as the C++ method OGRFeature::Validate().\n"
+		"Regarding :py:const:`OGR_F_VAL_WIDTH`, the test is done assuming the string\n"
+		"width must be interpreted as the number of UTF-8 characters. Some drivers might\n"
+		"interpret the width as the number of bytes instead. So this test is rather\n"
+		"conservative (if it fails, then it will fail for all interpretations).\n"
 		"\n"
-		".. versionadded:: 2.0\n"
+		"See :cpp:func:`OGRFeature::Validate`.\n"
 		"\n"
 		"Parameters\n"
 		"-----------\n"
-		"hFeat:\n"
-		"    handle to the feature to validate.\n"
-		"nValidateFlags:\n"
-		"    OGR_F_VAL_ALL or combination of OGR_F_VAL_NULL,\n"
-		"    OGR_F_VAL_GEOM_TYPE, OGR_F_VAL_WIDTH and\n"
-		"    OGR_F_VAL_ALLOW_NULL_WHEN_DEFAULT with '|' operator\n"
-		"bEmitError:\n"
+		"flags : int, default = :py:const:`F_VAL_ALL`\n"
+		"    One ore more of :py:const:`OGR_F_VAL_NULL`,\n"
+		"    :py:const:`OGR_F_VAL_GEOM_TYPE`, py:const:`OGR_F_VAL_WIDTH` and\n"
+		"    :py:const:`OGR_F_VAL_ALLOW_NULL_WHEN_DEFAULT` combined with\n"
+		"    the with ``|`` operator\n"
+		"bEmitError : bool, default = True\n"
 		"    TRUE if a CPLError() must be emitted when a check fails\n"
 		"\n"
 		"Returns\n"
 		"-------\n"
 		"int:\n"
 		"    TRUE if all enabled validation tests pass.\n"
 		"\n"
 		""},
 	 { "Feature_FillUnsetWithDefault", _wrap_Feature_FillUnsetWithDefault, METH_VARARGS, "\n"
 		"Feature_FillUnsetWithDefault(Feature self, int bNotNullableOnly=FALSE, char ** options=None)\n"
-		"void\n"
-		"OGR_F_FillUnsetWithDefault(OGRFeatureH hFeat, int bNotNullableOnly,\n"
-		"char \\*\\*papszOptions)\n"
 		"\n"
-		"Fill unset fields with default values that might be defined.\n"
 		"\n"
-		"This function is the same as the C++ method\n"
-		"OGRFeature::FillUnsetWithDefault().\n"
+		"Fill unset fields with default values that might be defined.\n"
 		"\n"
-		".. versionadded:: 2.0\n"
+		"See :cpp:func:`OGRFeature::FillUnsetWithDefault`.\n"
 		"\n"
 		"Parameters\n"
 		"-----------\n"
-		"hFeat:\n"
-		"    handle to the feature.\n"
-		"bNotNullableOnly:\n"
+		"bNotNullableOnly : bool\n"
 		"    if we should fill only unset fields with a not-null\n"
 		"    constraint.\n"
-		"papszOptions:\n"
-		"    unused currently. Must be set to NULL.\n"
+		"options : dict\n"
+		"    unused currently.\n"
 		"\n"
 		""},
 	 { "Feature_GetNativeData", _wrap_Feature_GetNativeData, METH_O, "\n"
 		"Feature_GetNativeData(Feature self) -> char const *\n"
-		"const char\\*\n"
-		"OGR_F_GetNativeData(OGRFeatureH hFeat)\n"
+		"\n"
 		"\n"
 		"Returns the native data for the feature.\n"
 		"\n"
 		"The native data is the representation in a \"natural\" form that comes\n"
 		"from the driver that created this feature, or that is aimed at an\n"
 		"output driver. The native data may be in different format, which is\n"
-		"indicated by OGR_F_GetNativeMediaType().\n"
+		"indicated by :py:func:`GetNativeMediaType`.\n"
 		"\n"
 		"Note that most drivers do not support storing the native data in the\n"
-		"feature object, and if they do, generally the NATIVE_DATA open option\n"
+		"feature object, and if they do, generally the ``NATIVE_DATA`` open option\n"
 		"must be passed at dataset opening.\n"
 		"\n"
 		"The \"native data\" does not imply it is something more performant or\n"
 		"powerful than what can be obtained with the rest of the API, but it\n"
 		"may be useful in round-tripping scenarios where some characteristics\n"
 		"of the underlying format are not captured otherwise by the OGR\n"
 		"abstraction.\n"
 		"\n"
-		"This function is the same as the C++ method\n"
-		"OGRFeature::GetNativeData().\n"
-		"\n"
-		".. note:: See https://trac.osgeo.org/gdal/wiki/rfc60_improved_roundtripping_in_ogr\n"
-		"\n"
-		".. versionadded:: 2.1\n"
-		"\n"
-		"Parameters\n"
-		"-----------\n"
-		"hFeat:\n"
-		"    handle to the feature.\n"
+		"See :cpp:func:`OGRFeature::GetNativeData` and :ref:`rfc-60`.\n"
 		"\n"
 		"Returns\n"
 		"-------\n"
 		"str:\n"
-		"    a string with the native data, or NULL if there is none.\n"
+		"    a string with the native data, or ``None``.\n"
 		"\n"
 		""},
 	 { "Feature_GetNativeMediaType", _wrap_Feature_GetNativeMediaType, METH_O, "\n"
 		"Feature_GetNativeMediaType(Feature self) -> char const *\n"
-		"const char\\*\n"
-		"OGR_F_GetNativeMediaType(OGRFeatureH hFeat)\n"
+		"\n"
 		"\n"
 		"Returns the native media type for the feature.\n"
 		"\n"
 		"The native media type is the identifier for the format of the native\n"
 		"data. It follows the IANA RFC 2045\n"
 		"(seehttps://en.wikipedia.org/wiki/Media_type), e.g.\n"
 		"\"application/vnd.geo+json\" for JSon.\n"
 		"\n"
-		"This function is the same as the C function\n"
-		"OGR_F_GetNativeMediaType().\n"
-		"\n"
-		".. note:: See https://trac.osgeo.org/gdal/wiki/rfc60_improved_roundtripping_in_ogr\n"
-		"\n"
-		".. versionadded:: 2.1\n"
-		"\n"
-		"Parameters\n"
-		"-----------\n"
-		"hFeat:\n"
-		"    handle to the feature.\n"
-		"\n"
+		"See :cpp:func:`OGRFeature::GetNativeMediaType` and :ref:`rfc-60`.\n"
 		"\n"
 		"Returns\n"
 		"--------\n"
 		"str:\n"
-		"    a string with the native media type, or NULL if there is none.\n"
+		"    a string with the native media type, or ``None``.\n"
 		"\n"
 		""},
 	 { "Feature_SetNativeData", _wrap_Feature_SetNativeData, METH_VARARGS, "\n"
 		"Feature_SetNativeData(Feature self, char const * nativeData)\n"
-		"void\n"
-		"OGR_F_SetNativeData(OGRFeatureH hFeat, const char \\*pszNativeData)\n"
+		"\n"
 		"\n"
 		"Sets the native data for the feature.\n"
 		"\n"
 		"The native data is the representation in a \"natural\" form that comes\n"
 		"from the driver that created this feature, or that is aimed at an\n"
 		"output driver. The native data may be in different format, which is\n"
-		"indicated by OGR_F_GetNativeMediaType().\n"
-		"\n"
-		"This function is the same as the C++ method\n"
-		"OGRFeature::SetNativeData().\n"
+		"indicated by :py:meth:`GetNativeMediaType`.\n"
 		"\n"
-		".. note:: See https://trac.osgeo.org/gdal/wiki/rfc60_improved_roundtripping_in_ogr\n"
-		"\n"
-		".. versionadded:: 2.1\n"
+		"See :cpp:func:`OGRFeature::SetNativeData` and :ref:`rfc-60`.\n"
 		"\n"
 		"Parameters\n"
 		"-----------\n"
-		"hFeat:\n"
-		"    handle to the feature.\n"
-		"pszNativeData:\n"
-		"    a string with the native data, or NULL if there is none.\n"
+		"nativeData : str\n"
+		"    a string with the native data, or ``None``\n"
 		"\n"
 		""},
 	 { "Feature_SetNativeMediaType", _wrap_Feature_SetNativeMediaType, METH_VARARGS, "\n"
 		"Feature_SetNativeMediaType(Feature self, char const * nativeMediaType)\n"
-		"void\n"
-		"OGR_F_SetNativeMediaType(OGRFeatureH hFeat, const char\n"
-		"\\*pszNativeMediaType)\n"
+		"\n"
 		"\n"
 		"Sets the native media type for the feature.\n"
 		"\n"
 		"The native media type is the identifier for the format of the native\n"
 		"data. It follows the IANA RFC 2045\n"
-		"(seehttps://en.wikipedia.org/wiki/Media_type), e.g.\n"
+		"(see https://en.wikipedia.org/wiki/Media_type), e.g.\n"
 		"\"application/vnd.geo+json\" for JSon.\n"
 		"\n"
-		"This function is the same as the C++ method\n"
-		"OGRFeature::SetNativeMediaType().\n"
-		"\n"
-		".. note:: See https://trac.osgeo.org/gdal/wiki/rfc60_improved_roundtripping_in_ogr\n"
-		"\n"
-		".. versionadded:: 2.1\n"
-		"\n"
+		"See :cpp:func:`OGRFeature::SetNativeMediaType` and :ref:`rfc-60`.\n"
 		"\n"
 		"Parameters\n"
 		"-----------\n"
-		"hFeat:\n"
-		"    handle to the feature.\n"
-		"pszNativeMediaType:\n"
-		"    a string with the native media type, or NULL if there is none.\n"
+		"nativeMediaType : str\n"
+		"    a string with the native media type, or ``None``\n"
 		"\n"
 		""},
 	 { "Feature_SetFieldString", _wrap_Feature_SetFieldString, METH_VARARGS, "\n"
 		"Feature_SetFieldString(Feature self, int id, char const * value)\n"
-		"void\n"
-		"OGR_F_SetFieldString(OGRFeatureH hFeat, int iField, const char\n"
-		"\\*pszValue)\n"
+		"\n"
 		"\n"
 		"Set field to string value.\n"
 		"\n"
-		"OFTInteger fields will be set based on an atoi() conversion of the\n"
-		"string. OFTInteger64 fields will be set based on an CPLAtoGIntBig()\n"
-		"conversion of the string. OFTReal fields will be set based on an\n"
-		"CPLAtof() conversion of the string. Other field types may be\n"
+		":py:const:`OFTInteger` fields will be set based on an atoi() conversion of the\n"
+		"string. :py:const:`OFTInteger64` fields will be set based on an :cpp:func:`CPLAtoGIntBig`\n"
+		"conversion of the string. :py:const:`OFTReal` fields will be set based on an\n"
+		":cpp:func:`CPLAtof` conversion of the string. Other field types may be\n"
 		"unaffected.\n"
 		"\n"
-		"This function is the same as the C++ method OGRFeature::SetField().\n"
+		"See :cpp:func:`OGRFeature::SetField`.\n"
 		"\n"
 		"This method has only an effect on the in-memory feature object. If\n"
 		"this object comes from a layer and the modifications must be\n"
-		"serialized back to the datasource, OGR_L_SetFeature() must be used\n"
-		"afterwards. Or if this is a new feature, OGR_L_CreateFeature() must be\n"
+		"serialized back to the datasource, :py:meth:`Layer.SetFeature` must be used\n"
+		"afterwards. Or if this is a new feature, :py:meth:`Layer.CreateFeature` must be\n"
 		"used afterwards.\n"
 		"\n"
 		"Parameters\n"
 		"-----------\n"
-		"hFeat:\n"
-		"    handle to the feature that owned the field.\n"
-		"iField:\n"
-		"    the field to fetch, from 0 to GetFieldCount()-1.\n"
-		"pszValue:\n"
+		"fld_index : int / str\n"
+		"    Field name or 0-based numeric index. For repeated\n"
+		"    access, use of the numeric index avoids a lookup\n"
+		"    step.\n"
+		"value:\n"
 		"    the value to assign.\n"
 		"\n"
 		""},
 	 { "Feature_swigregister", Feature_swigregister, METH_O, NULL},
 	 { "Feature_swiginit", Feature_swiginit, METH_VARARGS, NULL},
 	 { "delete_FeatureDefn", _wrap_delete_FeatureDefn, METH_O, "delete_FeatureDefn(FeatureDefn self)"},
-	 { "new_FeatureDefn", (PyCFunction)(void(*)(void))_wrap_new_FeatureDefn, METH_VARARGS|METH_KEYWORDS, "new_FeatureDefn(char const * name_null_ok=None) -> FeatureDefn"},
+	 { "new_FeatureDefn", (PyCFunction)(void(*)(void))_wrap_new_FeatureDefn, METH_VARARGS|METH_KEYWORDS, "\n"
+		"new_FeatureDefn(char const * name_null_ok=None) -> FeatureDefn\n"
+		"\n"
+		"\n"
+		"Create a new feature definition object to hold the field definitions.\n"
+		"\n"
+		"Parameters\n"
+		"----------\n"
+		"name_null_ok : str, optional\n"
+		"    Name for the :py:class:`FeatureDefn`.\n"
+		"\n"
+		""},
 	 { "FeatureDefn_GetName", _wrap_FeatureDefn_GetName, METH_O, "\n"
 		"FeatureDefn_GetName(FeatureDefn self) -> char const *\n"
-		"const char\\*\n"
-		"OGR_FD_GetName(OGRFeatureDefnH hDefn)\n"
 		"\n"
-		"Get name of the OGRFeatureDefn passed as an argument.\n"
 		"\n"
-		"This function is the same as the C++ method OGRFeatureDefn::GetName().\n"
+		"Get name of the :py:class:`FeatureDefn`.\n"
 		"\n"
-		"Parameters\n"
-		"-----------\n"
-		"hDefn:\n"
-		"    handle to the feature definition to get the name from.\n"
+		"See :cpp:func:`OGRFeatureDefn::GetName`.\n"
 		"\n"
 		"Returns\n"
 		"--------\n"
 		"str:\n"
-		"    the name. This name is internal and should not be modified, or freed.\n"
+		"    the name\n"
 		"\n"
 		""},
 	 { "FeatureDefn_GetFieldCount", _wrap_FeatureDefn_GetFieldCount, METH_O, "\n"
 		"FeatureDefn_GetFieldCount(FeatureDefn self) -> int\n"
-		"int\n"
-		"OGR_FD_GetFieldCount(OGRFeatureDefnH hDefn)\n"
 		"\n"
-		"Fetch number of fields on the passed feature definition.\n"
 		"\n"
-		"This function is the same as the C++ OGRFeatureDefn::GetFieldCount().\n"
+		"Fetch number of fields on the passed feature definition.\n"
 		"\n"
-		"Parameters\n"
-		"-----------\n"
-		"hDefn:\n"
-		"    handle to the feature definition to get the fields count from.\n"
+		"See :cpp:func:`OGRFeatureDefn::GetFieldCount`.\n"
 		"\n"
 		"Returns\n"
 		"--------\n"
 		"int:\n"
 		"    count of fields.\n"
 		"\n"
 		""},
 	 { "FeatureDefn_GetFieldDefn", _wrap_FeatureDefn_GetFieldDefn, METH_VARARGS, "\n"
 		"FeatureDefn_GetFieldDefn(FeatureDefn self, int i) -> FieldDefn\n"
-		"OGRFieldDefnH\n"
-		"OGR_FD_GetFieldDefn(OGRFeatureDefnH hDefn, int iField)\n"
+		"\n"
 		"\n"
 		"Fetch field definition of the passed feature definition.\n"
 		"\n"
-		"This function is the same as the C++ method\n"
-		"OGRFeatureDefn::GetFieldDefn().\n"
+		"See :cpp:func:`OGRFeatureDefn::GetFieldDefn`.\n"
 		"\n"
 		"Parameters\n"
 		"-----------\n"
-		"hDefn:\n"
-		"    handle to the feature definition to get the field definition from.\n"
-		"iField:\n"
-		"    the field to fetch, between 0 and GetFieldCount()-1.\n"
+		"i : int / str\n"
+		"    Field name or 0-based numeric index. For repeated\n"
+		"    access, use of the numeric index avoids a lookup\n"
+		"    step.\n"
 		"\n"
 		"Returns\n"
 		"--------\n"
-		"OGRFieldDefnH:\n"
-		"    a handle to an internal field definition object or NULL if invalid\n"
-		"    index. This object should not be modified or freed by the application.\n"
+		"FieldDefn:\n"
+		"    internal field definition object or ``None`` if the field does not\n"
+		"    exist. This object should not be modified by the application.\n"
 		"\n"
 		""},
 	 { "FeatureDefn_GetFieldIndex", _wrap_FeatureDefn_GetFieldIndex, METH_VARARGS, "\n"
 		"FeatureDefn_GetFieldIndex(FeatureDefn self, char const * field_name) -> int\n"
-		"int\n"
-		"OGR_FD_GetFieldIndex(OGRFeatureDefnH hDefn, const char \\*pszFieldName)\n"
+		"\n"
 		"\n"
 		"Find field by name.\n"
 		"\n"
 		"The field index of the first field matching the passed field name\n"
 		"(case insensitively) is returned.\n"
 		"\n"
-		"This function is the same as the C++ method\n"
-		"OGRFeatureDefn::GetFieldIndex.\n"
+		"See :cpp:func:`OGRFeatureDefn::GetFieldIndex`.\n"
 		"\n"
 		"Parameters\n"
 		"-----------\n"
-		"hDefn:\n"
-		"    handle to the feature definition to get field index from.\n"
-		"pszFieldName:\n"
+		"field_name : str\n"
 		"    the field name to search for.\n"
 		"\n"
 		"Returns\n"
 		"--------\n"
 		"int:\n"
 		"    the field index, or -1 if no match found.\n"
 		"\n"
 		""},
 	 { "FeatureDefn_AddFieldDefn", _wrap_FeatureDefn_AddFieldDefn, METH_VARARGS, "\n"
 		"FeatureDefn_AddFieldDefn(FeatureDefn self, FieldDefn defn)\n"
-		"void\n"
-		"OGR_FD_AddFieldDefn(OGRFeatureDefnH hDefn, OGRFieldDefnH hNewField)\n"
 		"\n"
-		"Add a new field definition to the passed feature definition.\n"
+		"\n"
+		"Add a new field definition.\n"
 		"\n"
 		"To add a new field definition to a layer definition, do not use this\n"
-		"function directly, but use OGR_L_CreateField() instead.\n"
+		"function directly, but use :py:meth:`Layer.CreateField` instead.\n"
 		"\n"
-		"This function should only be called while there are no OGRFeature\n"
-		"objects in existence based on this OGRFeatureDefn. The OGRFieldDefn\n"
-		"passed in is copied, and remains the responsibility of the caller.\n"
+		"This function should only be called while there are no :py:class:`Feature`\n"
+		"objects in existence based on this :py:class:`FeatureDefn`. The\n"
+		":py:class:`FieldDefn` passed in is copied.\n"
 		"\n"
-		"This function is the same as the C++ method\n"
-		"OGRFeatureDefn::AddFieldDefn().\n"
+		"See :cpp:func:`OGRFeatureDefn::AddFieldDefn`.\n"
 		"\n"
 		"Parameters\n"
 		"-----------\n"
-		"hDefn:\n"
-		"    handle to the feature definition to add the field definition to.\n"
-		"hNewField:\n"
-		"    handle to the new field definition.\n"
+		"defn : FieldDefn\n"
+		"    the new field definition.\n"
 		"\n"
 		""},
 	 { "FeatureDefn_GetGeomFieldCount", _wrap_FeatureDefn_GetGeomFieldCount, METH_O, "\n"
 		"FeatureDefn_GetGeomFieldCount(FeatureDefn self) -> int\n"
-		"int\n"
-		"OGR_FD_GetGeomFieldCount(OGRFeatureDefnH hDefn)\n"
-		"\n"
-		"Fetch number of geometry fields on the passed feature definition.\n"
 		"\n"
-		"This function is the same as the C++\n"
-		"OGRFeatureDefn::GetGeomFieldCount().\n"
 		"\n"
-		".. versionadded:: 1.11\n"
+		"Fetch number of geometry fields on the passed feature definition.\n"
 		"\n"
-		"Parameters\n"
-		"-----------\n"
-		"hDefn:\n"
-		"    handle to the feature definition to get the fields count from.\n"
+		"See :cpp:func:`OGRFeatureDefn::GetGeomFieldCount`.\n"
 		"\n"
 		"Returns\n"
 		"--------\n"
 		"int:\n"
 		"    count of geometry fields.\n"
 		"\n"
 		""},
 	 { "FeatureDefn_GetGeomFieldDefn", _wrap_FeatureDefn_GetGeomFieldDefn, METH_VARARGS, "\n"
 		"FeatureDefn_GetGeomFieldDefn(FeatureDefn self, int i) -> GeomFieldDefn\n"
-		"OGRGeomFieldDefnH\n"
-		"OGR_FD_GetGeomFieldDefn(OGRFeatureDefnH hDefn, int iGeomField)\n"
 		"\n"
-		"Fetch geometry field definition of the passed feature definition.\n"
 		"\n"
-		"This function is the same as the C++ method\n"
-		"OGRFeatureDefn::GetGeomFieldDefn().\n"
+		"Fetch geometry field definition of the passed feature definition.\n"
 		"\n"
-		".. versionadded:: 1.11\n"
+		"See :cpp:func:`OGRFeatureDefn::GetGeomFieldDefn`.\n"
 		"\n"
 		"Parameters\n"
 		"-----------\n"
-		"hDefn:\n"
-		"    handle to the feature definition to get the field definition from.\n"
-		"iGeomField:\n"
+		"i : int\n"
 		"    the geometry field to fetch, between 0 and GetGeomFieldCount() - 1.\n"
 		"\n"
 		"Returns\n"
 		"--------\n"
-		"OGRGeomFieldDefnH:\n"
-		"    a handle to an internal field definition object or NULL if invalid\n"
-		"    index. This object should not be modified or freed by the application.\n"
+		"GeomFieldDefn:\n"
+		"    an internal field definition object or ``None`` if invalid\n"
+		"    index. This object should not be modified by the application.\n"
 		"\n"
 		""},
 	 { "FeatureDefn_GetGeomFieldIndex", _wrap_FeatureDefn_GetGeomFieldIndex, METH_VARARGS, "\n"
 		"FeatureDefn_GetGeomFieldIndex(FeatureDefn self, char const * field_name) -> int\n"
-		"int\n"
-		"OGR_FD_GetGeomFieldIndex(OGRFeatureDefnH hDefn, const char\n"
-		"\\*pszGeomFieldName)\n"
+		"\n"
 		"\n"
 		"Find geometry field by name.\n"
 		"\n"
 		"The geometry field index of the first geometry field matching the\n"
 		"passed field name (case insensitively) is returned.\n"
 		"\n"
-		"This function is the same as the C++ method\n"
-		"OGRFeatureDefn::GetGeomFieldIndex.\n"
+		"See :cpp:func:`OGRFeatureDefn::GetGeomFieldIndex`.\n"
 		"\n"
 		"Parameters\n"
 		"-----------\n"
-		"hDefn:\n"
-		"    handle to the feature definition to get field index from.\n"
-		"pszGeomFieldName:\n"
+		"field_name : str\n"
 		"    the geometry field name to search for.\n"
 		"\n"
 		"Returns\n"
 		"--------\n"
 		"int:\n"
 		"    the geometry field index, or -1 if no match found.\n"
 		"\n"
 		""},
 	 { "FeatureDefn_AddGeomFieldDefn", _wrap_FeatureDefn_AddGeomFieldDefn, METH_VARARGS, "\n"
 		"FeatureDefn_AddGeomFieldDefn(FeatureDefn self, GeomFieldDefn defn)\n"
-		"void\n"
-		"OGR_FD_AddGeomFieldDefn(OGRFeatureDefnH hDefn, OGRGeomFieldDefnH\n"
-		"hNewGeomField)\n"
 		"\n"
-		"Add a new field definition to the passed feature definition.\n"
 		"\n"
-		"To add a new field definition to a layer definition, do not use this\n"
-		"function directly, but use OGR_L_CreateGeomField() instead.\n"
+		"Add a new geometry field definition.\n"
 		"\n"
-		"This function should only be called while there are no OGRFeature\n"
-		"objects in existence based on this OGRFeatureDefn. The\n"
-		"OGRGeomFieldDefn passed in is copied, and remains the responsibility\n"
-		"of the caller.\n"
+		"To add a new field definition to a layer definition, do not use this\n"
+		"function directly, but use :py:meth:`Layer.CreateGeomField` instead.\n"
 		"\n"
-		"This function is the same as the C++ method\n"
-		"OGRFeatureDefn::AddGeomFieldDefn().\n"
+		"This function should only be called while there are no :py:class:`Feature`\n"
+		"objects in existence based on this :py:class:`FeatureDefn`. The\n"
+		":py:class:`GeomFieldDefn` passed in is copied.\n"
 		"\n"
-		".. versionadded:: 1.11\n"
+		"See :cpp:Func:`OGRFeatureDefn::AddGeomFieldDefn`.\n"
 		"\n"
 		"Parameters\n"
 		"-----------\n"
-		"hDefn:\n"
-		"    handle to the feature definition to add the geometry field\n"
-		"    definition to.\n"
-		"hNewGeomField:\n"
-		"    handle to the new field definition.\n"
+		"defn : GeomFieldDefn\n"
+		"    new geometry field definition.\n"
 		"\n"
 		""},
 	 { "FeatureDefn_DeleteGeomFieldDefn", _wrap_FeatureDefn_DeleteGeomFieldDefn, METH_VARARGS, "\n"
 		"FeatureDefn_DeleteGeomFieldDefn(FeatureDefn self, int idx) -> OGRErr\n"
-		"OGRErr\n"
-		"OGR_FD_DeleteGeomFieldDefn(OGRFeatureDefnH hDefn, int iGeomField)\n"
+		"\n"
 		"\n"
 		"Delete an existing geometry field definition.\n"
 		"\n"
 		"To delete an existing geometry field definition from a layer\n"
 		"definition, do not use this function directly, but use\n"
-		"OGR_L_DeleteGeomField() instead ( not implemented yet).\n"
-		"\n"
-		"This method should only be called while there are no OGRFeature\n"
-		"objects in existence based on this OGRFeatureDefn.\n"
+		":py:meth:`Layer.DeleteGeomField` instead ( not implemented yet).\n"
 		"\n"
-		"This method is the same as the C++ method\n"
-		"OGRFeatureDefn::DeleteGeomFieldDefn().\n"
+		"This function should only be called while there are no :py:class:`Feature`\n"
+		"objects in existence based on this :py:class:`FeatureDefn`.\n"
 		"\n"
-		".. versionadded:: 1.11\n"
+		"See :cpp:func:`OGRFeatureDefn::DeleteGeomFieldDefn`.\n"
 		"\n"
 		"Parameters\n"
 		"-----------\n"
-		"hDefn:\n"
-		"    handle to the feature definition.\n"
-		"iGeomField:\n"
+		"idx : int\n"
 		"    the index of the geometry field definition.\n"
 		"\n"
 		"Returns\n"
 		"--------\n"
-		"OGRErr:\n"
-		"    OGRERR_NONE in case of success.\n"
+		"int:\n"
+		"    :py:const:`OGRERR_NONE` in case of success.\n"
 		"\n"
 		""},
 	 { "FeatureDefn_GetGeomType", _wrap_FeatureDefn_GetGeomType, METH_O, "\n"
 		"FeatureDefn_GetGeomType(FeatureDefn self) -> OGRwkbGeometryType\n"
-		"OGRwkbGeometryType\n"
-		"OGR_FD_GetGeomType(OGRFeatureDefnH hDefn)\n"
 		"\n"
-		"Fetch the geometry base type of the passed feature definition.\n"
 		"\n"
-		"This function is the same as the C++ method\n"
-		"OGRFeatureDefn::GetGeomType().\n"
+		"Fetch the geometry base type of the passed feature definition.\n"
 		"\n"
-		"Starting with GDAL 1.11, this method returns\n"
-		"GetGeomFieldDefn(0)->GetType().\n"
+		"This is equivalent to ``GetGeomFieldDefn(0).GetType()``.\n"
 		"\n"
-		"Parameters\n"
-		"-----------\n"
-		"hDefn:\n"
-		"    handle to the feature definition to get the geometry type from.\n"
+		"See :cpp:func:`OGRFeatureDefn::GetGeomType`.\n"
 		"\n"
 		"Returns\n"
 		"--------\n"
-		"OGRwkbGeometryType:\n"
+		"int :\n"
 		"    the base type for all geometry related to this definition.\n"
 		"\n"
 		""},
 	 { "FeatureDefn_SetGeomType", _wrap_FeatureDefn_SetGeomType, METH_VARARGS, "\n"
 		"FeatureDefn_SetGeomType(FeatureDefn self, OGRwkbGeometryType geom_type)\n"
-		"void\n"
-		"OGR_FD_SetGeomType(OGRFeatureDefnH hDefn, OGRwkbGeometryType eType)\n"
+		"\n"
 		"\n"
 		"Assign the base geometry type for the passed layer (the same as the\n"
 		"feature definition).\n"
 		"\n"
+		"This is equivalent to ``GetGeomFieldDefn(0).SetType()``.\n"
+		"\n"
 		"All geometry objects using this type must be of the defined type or a\n"
-		"derived type. The default upon creation is wkbUnknown which allows for\n"
+		"derived type. The default upon creation is :py:const:`wkbUnknown` which allows for\n"
 		"any geometry type. The geometry type should generally not be changed\n"
-		"after any OGRFeatures have been created against this definition.\n"
-		"\n"
-		"This function is the same as the C++ method\n"
-		"OGRFeatureDefn::SetGeomType().\n"
+		"after any :py:class:`Feature` objects have been created against this definition.\n"
 		"\n"
-		"Starting with GDAL 1.11, this method calls\n"
-		"GetGeomFieldDefn(0)->SetType().\n"
+		"See :cpp:func:`OGRFeatureDefn::SetGeomType`.\n"
 		"\n"
 		"Parameters\n"
 		"-----------\n"
-		"hDefn:\n"
-		"    handle to the layer or feature definition to set the geometry type to.\n"
-		"eType:\n"
+		"geom_type : int\n"
 		"    the new type to assign.\n"
 		"\n"
 		""},
 	 { "FeatureDefn_GetReferenceCount", _wrap_FeatureDefn_GetReferenceCount, METH_O, "\n"
 		"FeatureDefn_GetReferenceCount(FeatureDefn self) -> int\n"
-		"int\n"
-		"OGR_FD_GetReferenceCount(OGRFeatureDefnH hDefn)\n"
 		"\n"
-		"Fetch current reference count.\n"
 		"\n"
-		"This function is the same as the C++ method\n"
-		"OGRFeatureDefn::GetReferenceCount().\n"
+		"Fetch current reference count.\n"
 		"\n"
-		"Parameters\n"
-		"-----------\n"
-		"hDefn:\n"
-		"    handle to the feature definition on witch OGRFeature are based on.\n"
+		"See :cpp:func:`OGRFeatureDefn::GetReferenceCount`.\n"
 		"\n"
 		"Returns\n"
 		"--------\n"
 		"int:\n"
 		"    the current reference count.\n"
 		"\n"
 		""},
 	 { "FeatureDefn_IsGeometryIgnored", _wrap_FeatureDefn_IsGeometryIgnored, METH_O, "\n"
 		"FeatureDefn_IsGeometryIgnored(FeatureDefn self) -> int\n"
-		"int\n"
-		"OGR_FD_IsGeometryIgnored(OGRFeatureDefnH hDefn)\n"
+		"\n"
 		"\n"
 		"Determine whether the geometry can be omitted when fetching features.\n"
 		"\n"
-		"This function is the same as the C++ method\n"
-		"OGRFeatureDefn::IsGeometryIgnored().\n"
+		"Equivalent to ``GetGeomFieldDefn(0).IsIgnored()``.\n"
 		"\n"
-		"Starting with GDAL 1.11, this method returns\n"
-		"GetGeomFieldDefn(0)->IsIgnored().\n"
-		"\n"
-		"Parameters\n"
-		"-----------\n"
-		"hDefn:\n"
-		"    handle to the feature definition on witch OGRFeature are based on.\n"
+		"See :cpp:func:`OGRFeatureDefn::IsGeometryIgnored`.\n"
 		"\n"
 		"Returns\n"
 		"--------\n"
 		"int:\n"
 		"    ignore state\n"
 		"\n"
 		""},
 	 { "FeatureDefn_SetGeometryIgnored", _wrap_FeatureDefn_SetGeometryIgnored, METH_VARARGS, "\n"
 		"FeatureDefn_SetGeometryIgnored(FeatureDefn self, int bIgnored)\n"
-		"void\n"
-		"OGR_FD_SetGeometryIgnored(OGRFeatureDefnH hDefn, int bIgnore)\n"
+		"\n"
 		"\n"
 		"Set whether the geometry can be omitted when fetching features.\n"
 		"\n"
-		"This function is the same as the C++ method\n"
-		"OGRFeatureDefn::SetGeometryIgnored().\n"
+		"This is equivalent to ``GetGeomFieldDefn(0).SetIgnored()``.\n"
 		"\n"
-		"Starting with GDAL 1.11, this method calls\n"
-		"GetGeomFieldDefn(0)->SetIgnored().\n"
+		"See :cpp:func:`OGRFeatureDefn::SetGeometryIgnored`.\n"
 		"\n"
 		"Parameters\n"
 		"-----------\n"
-		"hDefn:\n"
-		"    handle to the feature definition on witch OGRFeature are based on.\n"
-		"bIgnore:\n"
+		"bignored : bool\n"
 		"    ignore state\n"
 		"\n"
 		""},
 	 { "FeatureDefn_IsStyleIgnored", _wrap_FeatureDefn_IsStyleIgnored, METH_O, "\n"
 		"FeatureDefn_IsStyleIgnored(FeatureDefn self) -> int\n"
-		"int\n"
-		"OGR_FD_IsStyleIgnored(OGRFeatureDefnH hDefn)\n"
 		"\n"
-		"Determine whether the style can be omitted when fetching features.\n"
 		"\n"
-		"This function is the same as the C++ method\n"
-		"OGRFeatureDefn::IsStyleIgnored().\n"
+		"Determine whether the style can be omitted when fetching features.\n"
 		"\n"
-		"Parameters\n"
-		"-----------\n"
-		"hDefn:\n"
-		"    handle to the feature definition on which OGRFeature are based on.\n"
+		"See :cpp:func:`OGRFeatureDefn::IsStyleIgnored`.\n"
 		"\n"
 		"Returns\n"
 		"--------\n"
 		"int:\n"
 		"    ignore state\n"
 		"\n"
 		""},
 	 { "FeatureDefn_SetStyleIgnored", _wrap_FeatureDefn_SetStyleIgnored, METH_VARARGS, "\n"
 		"FeatureDefn_SetStyleIgnored(FeatureDefn self, int bIgnored)\n"
-		"void\n"
-		"OGR_FD_SetStyleIgnored(OGRFeatureDefnH hDefn, int bIgnore)\n"
+		"\n"
 		"\n"
 		"Set whether the style can be omitted when fetching features.\n"
 		"\n"
-		"This function is the same as the C++ method\n"
-		"OGRFeatureDefn::SetStyleIgnored().\n"
+		"See :cpp:func:`OGRFeatureDefn::SetStyleIgnored`.\n"
 		"\n"
 		"Parameters\n"
 		"-----------\n"
-		"hDefn:\n"
-		"    handle to the feature definition on witch OGRFeature are based on.\n"
-		"bIgnore:\n"
+		"bignored : bool\n"
 		"    ignore state\n"
 		"\n"
 		""},
 	 { "FeatureDefn_IsSame", _wrap_FeatureDefn_IsSame, METH_VARARGS, "\n"
 		"FeatureDefn_IsSame(FeatureDefn self, FeatureDefn other_defn) -> int\n"
-		"int OGR_FD_IsSame(OGRFeatureDefnH\n"
-		"hFDefn, OGRFeatureDefnH hOtherFDefn)\n"
 		"\n"
-		"Test if the feature definition is identical to the other one.\n"
 		"\n"
-		".. versionadded:: 1.11\n"
+		"Test if the feature definition is identical to the other one.\n"
 		"\n"
 		"Parameters\n"
 		"-----------\n"
-		"hFDefn:\n"
-		"    handle to the feature definition on witch OGRFeature are based on.\n"
-		"hOtherFDefn:\n"
-		"    handle to the other feature definition to compare to.\n"
+		"other_defn : FeatureDefn\n"
+		"    other feature definition to compare to.\n"
 		"\n"
 		"Returns\n"
 		"--------\n"
 		"int:\n"
-		"    TRUE if the feature definition is identical to the other one.\n"
+		"    1 if the feature definition is identical to the other one.\n"
 		"\n"
 		""},
 	 { "FeatureDefn_swigregister", FeatureDefn_swigregister, METH_O, NULL},
 	 { "FeatureDefn_swiginit", FeatureDefn_swiginit, METH_VARARGS, NULL},
 	 { "delete_FieldDefn", _wrap_delete_FieldDefn, METH_O, "delete_FieldDefn(FieldDefn self)"},
-	 { "new_FieldDefn", (PyCFunction)(void(*)(void))_wrap_new_FieldDefn, METH_VARARGS|METH_KEYWORDS, "new_FieldDefn(char const * name_null_ok=\"unnamed\", OGRFieldType field_type=OFTString) -> FieldDefn"},
+	 { "new_FieldDefn", (PyCFunction)(void(*)(void))_wrap_new_FieldDefn, METH_VARARGS|METH_KEYWORDS, "\n"
+		"new_FieldDefn(char const * name_null_ok=\"unnamed\", OGRFieldType field_type=OFTString) -> FieldDefn\n"
+		"\n"
+		"Python proxy of an :cpp:class:`OGRFieldDefn`.\n"
+		"\n"
+		""},
 	 { "FieldDefn_GetName", _wrap_FieldDefn_GetName, METH_O, "FieldDefn_GetName(FieldDefn self) -> char const *"},
 	 { "FieldDefn_GetNameRef", _wrap_FieldDefn_GetNameRef, METH_O, "\n"
 		"FieldDefn_GetNameRef(FieldDefn self) -> char const *\n"
-		"const char\\*\n"
-		"OGR_Fld_GetNameRef(OGRFieldDefnH hDefn)\n"
 		"\n"
-		"Fetch name of this field.\n"
 		"\n"
-		"This function is the same as the CPP method\n"
-		"OGRFieldDefn::GetNameRef().\n"
+		"Fetch name of this field.\n"
 		"\n"
-		"Parameters\n"
-		"-----------\n"
-		"hDefn:\n"
-		"    handle to the field definition.\n"
+		"See :cpp:func:`OGRFieldDefn::GetNameRef`.\n"
 		"\n"
 		"Returns\n"
 		"--------\n"
 		"str:\n"
 		"    the name of the field definition.\n"
 		"\n"
 		""},
 	 { "FieldDefn_SetName", _wrap_FieldDefn_SetName, METH_VARARGS, "\n"
 		"FieldDefn_SetName(FieldDefn self, char const * name)\n"
-		"void OGR_Fld_SetName(OGRFieldDefnH\n"
-		"hDefn, const char \\*pszName)\n"
+		"\n"
 		"\n"
 		"Reset the name of this field.\n"
 		"\n"
-		"This function is the same as the CPP method OGRFieldDefn::SetName().\n"
+		"See :cpp:func:`OGRFieldDefn::SetName`.\n"
 		"\n"
 		"Parameters\n"
 		"-----------\n"
-		"hDefn:\n"
-		"    handle to the field definition to apply the new name to.\n"
-		"pszName:\n"
-		"    the new name to apply.\n"
+		"name : str\n"
+		"    the new name to apply\n"
 		"\n"
 		""},
 	 { "FieldDefn_GetAlternativeName", _wrap_FieldDefn_GetAlternativeName, METH_O, "FieldDefn_GetAlternativeName(FieldDefn self) -> char const *"},
 	 { "FieldDefn_GetAlternativeNameRef", _wrap_FieldDefn_GetAlternativeNameRef, METH_O, "\n"
 		"FieldDefn_GetAlternativeNameRef(FieldDefn self) -> char const *\n"
-		"const char\\*\n"
-		"OGR_Fld_GetAlternativeNameRef(OGRFieldDefnH hDefn)\n"
+		"\n"
 		"\n"
 		"Fetch the alternative name (or \"alias\") for this field.\n"
 		"\n"
 		"The alternative name is an optional attribute for a field which can\n"
 		"provide a more user-friendly, descriptive name of a field which is not\n"
 		"subject to the usual naming constraints defined by the data provider.\n"
 		"\n"
 		"This is a metadata style attribute only: the alternative name cannot\n"
 		"be used in place of the actual field name during SQL queries or other\n"
 		"field name dependent API calls.\n"
 		"\n"
-		"This function is the same as the CPP method\n"
-		"OGRFieldDefn::GetAlternativeNameRef().\n"
+		"See :cpp:func:`OGRFieldDefn::GetAlternativeNameRef`.\n"
 		"\n"
 		".. versionadded:: 3.2\n"
 		"\n"
-		"Parameters\n"
-		"-----------\n"
-		"hDefn:\n"
-		"    handle to the field definition.\n"
-		"\n"
 		"Returns\n"
 		"--------\n"
 		"str:\n"
 		"    the alternative name of the field definition.\n"
 		"\n"
 		""},
 	 { "FieldDefn_SetAlternativeName", _wrap_FieldDefn_SetAlternativeName, METH_VARARGS, "\n"
 		"FieldDefn_SetAlternativeName(FieldDefn self, char const * alternativeName)\n"
-		"void\n"
-		"OGR_Fld_SetAlternativeName(OGRFieldDefnH hDefn, const char\n"
-		"\\*pszAlternativeName)\n"
+		"\n"
 		"\n"
 		"Reset the alternative name (or \"alias\") for this field.\n"
 		"\n"
 		"The alternative name is an optional attribute for a field which can\n"
 		"provide a more user-friendly, descriptive name of a field which is not\n"
 		"subject to the usual naming constraints defined by the data provider.\n"
 		"\n"
 		"This is a metadata style attribute only: the alternative name cannot\n"
 		"be used in place of the actual field name during SQL queries or other\n"
 		"field name dependent API calls.\n"
 		"\n"
-		"This function is the same as the CPP method\n"
-		"OGRFieldDefn::SetAlternativeName().\n"
+		"See :cpp:func:`OGRFieldDefn::SetAlternativeName`.\n"
 		"\n"
 		".. versionadded:: 3.2\n"
 		"\n"
 		"Parameters\n"
 		"-----------\n"
-		"hDefn:\n"
-		"    handle to the field definition to apply the new alternative name to.\n"
-		"pszAlternativeName:\n"
+		"alternativeName : str\n"
 		"    the new alternative name to apply.\n"
 		"\n"
 		""},
 	 { "FieldDefn_GetType", _wrap_FieldDefn_GetType, METH_O, "\n"
 		"FieldDefn_GetType(FieldDefn self) -> OGRFieldType\n"
-		"OGRFieldType\n"
-		"OGR_Fld_GetType(OGRFieldDefnH hDefn)\n"
 		"\n"
-		"Fetch type of this field.\n"
 		"\n"
-		"This function is the same as the CPP method OGRFieldDefn::GetType().\n"
+		"Fetch type of this field.\n"
 		"\n"
-		"Parameters\n"
-		"-----------\n"
-		"hDefn:\n"
-		"    handle to the field definition to get type from.\n"
+		"See :cpp:func:`OGRFieldDefn::GetType`.\n"
 		"\n"
 		"Returns\n"
 		"--------\n"
-		"OGRFieldType:\n"
-		"    field type.\n"
+		"int\n"
+		"    field type code, e.g. :py:const:`OFTInteger`\n"
 		"\n"
 		""},
 	 { "FieldDefn_SetType", _wrap_FieldDefn_SetType, METH_VARARGS, "\n"
 		"FieldDefn_SetType(FieldDefn self, OGRFieldType type)\n"
-		"void OGR_Fld_SetType(OGRFieldDefnH\n"
-		"hDefn, OGRFieldType eType)\n"
+		"\n"
 		"\n"
 		"Set the type of this field.\n"
 		"\n"
-		"This should never be done to an OGRFieldDefn that is already part of\n"
-		"an OGRFeatureDefn.\n"
+		"This should never be done to a :py:class:`FieldDefn` that is already part of\n"
+		"an :py:class:`FeatureDefn`.\n"
 		"\n"
-		"This function is the same as the CPP method OGRFieldDefn::SetType().\n"
+		"See :cpp:func:`OGRFieldDefn::SetType`.\n"
 		"\n"
 		"Parameters\n"
 		"-----------\n"
-		"hDefn:\n"
-		"    handle to the field definition to set type to.\n"
-		"eType:\n"
+		"type : int\n"
 		"    the new field type.\n"
 		"\n"
+		"Examples\n"
+		"--------\n"
+		">>> f = ogr.FieldDefn()\n"
+		">>> f.SetType(ogr.OFTReal)\n"
+		"\n"
 		""},
 	 { "FieldDefn_GetSubType", _wrap_FieldDefn_GetSubType, METH_O, "\n"
 		"FieldDefn_GetSubType(FieldDefn self) -> OGRFieldSubType\n"
-		"OGRFieldSubType\n"
-		"OGR_Fld_GetSubType(OGRFieldDefnH hDefn)\n"
 		"\n"
-		"Fetch subtype of this field.\n"
 		"\n"
-		"This function is the same as the CPP method\n"
-		"OGRFieldDefn::GetSubType().\n"
+		"Fetch subtype of this field.\n"
 		"\n"
-		".. versionadded:: 2.0\n"
-		"\n"
-		"Parameters\n"
-		"-----------\n"
-		"hDefn:\n"
-		"    handle to the field definition to get subtype from.\n"
+		"See :cpp:func:`OGRFieldDefn::GetSubType`.\n"
 		"\n"
 		"Returns\n"
 		"--------\n"
-		"OGRFieldSubType:\n"
-		"    field subtype.\n"
+		"int\n"
+		"    field subtype code, default = :py:const:`OFSTNone`\n"
 		"\n"
 		""},
 	 { "FieldDefn_SetSubType", _wrap_FieldDefn_SetSubType, METH_VARARGS, "\n"
 		"FieldDefn_SetSubType(FieldDefn self, OGRFieldSubType type)\n"
-		"void\n"
-		"OGR_Fld_SetSubType(OGRFieldDefnH hDefn, OGRFieldSubType eSubType)\n"
 		"\n"
-		"Set the subtype of this field.\n"
 		"\n"
-		"This should never be done to an OGRFieldDefn that is already part of\n"
-		"an OGRFeatureDefn.\n"
+		"Set the subtype of this field.\n"
 		"\n"
-		"This function is the same as the CPP method\n"
-		"OGRFieldDefn::SetSubType().\n"
+		"This should never be done to a :py:class:`FieldDefn` that is already part of\n"
+		"an :py:class:FeatureDefn`.\n"
 		"\n"
-		".. versionadded:: 2.0\n"
+		"See :cpp:func:`OGRFieldDefn::SetSubType`.\n"
 		"\n"
 		"Parameters\n"
 		"-----------\n"
-		"hDefn:\n"
-		"    handle to the field definition to set type to.\n"
-		"eSubType:\n"
+		"type :\n"
 		"    the new field subtype.\n"
 		"\n"
+		"Examples\n"
+		"--------\n"
+		">>> f = ogr.FieldDefn()\n"
+		">>> f.SetType(ogr.OFTReal)\n"
+		">>> f.SetSubType(ogr.OFSTJSON)\n"
+		"Warning 1: Type and subtype of field definition are not compatible. Resetting to OFSTNone\n"
+		">>> f.SetSubType(ogr.OFSTFloat32)\n"
+		"\n"
 		""},
 	 { "FieldDefn_GetJustify", _wrap_FieldDefn_GetJustify, METH_O, "\n"
 		"FieldDefn_GetJustify(FieldDefn self) -> OGRJustification\n"
-		"OGRJustification\n"
-		"OGR_Fld_GetJustify(OGRFieldDefnH hDefn)\n"
+		"\n"
 		"\n"
 		"Get the justification for this field.\n"
 		"\n"
-		"This function is the same as the CPP method\n"
-		"OGRFieldDefn::GetJustify().\n"
+		"See :cpp:func:`OGRFieldDefn::GetJustify`.\n"
 		"\n"
 		"Note: no driver is know to use the concept of field justification.\n"
 		"\n"
-		"Parameters\n"
-		"-----------\n"
-		"hDefn:\n"
-		"    handle to the field definition to get justification from.\n"
-		"\n"
 		"Returns\n"
 		"--------\n"
 		"OGRJustification:\n"
 		"    the justification.\n"
 		"\n"
 		""},
 	 { "FieldDefn_SetJustify", _wrap_FieldDefn_SetJustify, METH_VARARGS, "\n"
 		"FieldDefn_SetJustify(FieldDefn self, OGRJustification justify)\n"
-		"void\n"
-		"OGR_Fld_SetJustify(OGRFieldDefnH hDefn, OGRJustification eJustify)\n"
+		"\n"
 		"\n"
 		"Set the justification for this field.\n"
 		"\n"
 		"Note: no driver is know to use the concept of field justification.\n"
 		"\n"
-		"This function is the same as the CPP method\n"
-		"OGRFieldDefn::SetJustify().\n"
+		"See :cpp:func:`OGRFieldDefn::SetJustify`.\n"
 		"\n"
 		"Parameters\n"
 		"-----------\n"
-		"hDefn:\n"
-		"    handle to the field definition to set justification to.\n"
-		"eJustify:\n"
-		"    the new justification.\n"
+		"justify : int\n"
+		"    the new justification\n"
+		"\n"
+		"Examples\n"
+		"--------\n"
+		">>> f = ogr.FieldDefn('desc', ogr.OFTString)\n"
+		">>> f.SetJustify(ogr.OJRight)\n"
 		"\n"
 		""},
 	 { "FieldDefn_GetWidth", _wrap_FieldDefn_GetWidth, METH_O, "\n"
 		"FieldDefn_GetWidth(FieldDefn self) -> int\n"
-		"int OGR_Fld_GetWidth(OGRFieldDefnH\n"
-		"hDefn)\n"
-		"\n"
-		"Get the formatting width for this field.\n"
 		"\n"
-		"This function is the same as the CPP method OGRFieldDefn::GetWidth().\n"
 		"\n"
-		"Parameters\n"
-		"-----------\n"
-		"hDefn:\n"
-		"    handle to the field definition to get width from.\n"
+		"Get the formatting width for this field.\n"
 		"\n"
+		"See :cpp:func:`OGRFieldDefn::GetWidth`.\n"
 		"\n"
 		"Returns\n"
 		"--------\n"
 		"int:\n"
 		"    the width, zero means no specified width.\n"
 		"\n"
 		""},
 	 { "FieldDefn_SetWidth", _wrap_FieldDefn_SetWidth, METH_VARARGS, "\n"
 		"FieldDefn_SetWidth(FieldDefn self, int width)\n"
-		"void OGR_Fld_SetWidth(OGRFieldDefnH\n"
-		"hDefn, int nNewWidth)\n"
+		"\n"
 		"\n"
 		"Set the formatting width for this field in characters.\n"
 		"\n"
-		"This function is the same as the CPP method OGRFieldDefn::SetWidth().\n"
+		"See :cpp:func:`OGRFieldDefn::SetWidth`.\n"
 		"\n"
 		"Parameters\n"
 		"-----------\n"
-		"hDefn:\n"
-		"    handle to the field definition to set width to.\n"
-		"nNewWidth:\n"
-		"    the new width.\n"
+		"width : int\n"
+		"    the new width\n"
 		"\n"
 		""},
 	 { "FieldDefn_GetPrecision", _wrap_FieldDefn_GetPrecision, METH_O, "\n"
 		"FieldDefn_GetPrecision(FieldDefn self) -> int\n"
-		"int\n"
-		"OGR_Fld_GetPrecision(OGRFieldDefnH hDefn)\n"
+		"\n"
 		"\n"
 		"Get the formatting precision for this field.\n"
 		"\n"
-		"This should normally be zero for fields of types other than OFTReal.\n"
+		"This should normally be zero for fields of types other than :py:const:`OFTReal`.\n"
 		"\n"
-		"This function is the same as the CPP method\n"
-		"OGRFieldDefn::GetPrecision().\n"
-		"\n"
-		"Parameters\n"
-		"-----------\n"
-		"hDefn:\n"
-		"    handle to the field definition to get precision from.\n"
+		"See :cpp:func:`OGRFieldDefn::GetPrecision`.\n"
 		"\n"
 		"Returns\n"
 		"--------\n"
 		"int:\n"
 		"    the precision.\n"
 		"\n"
 		""},
 	 { "FieldDefn_SetPrecision", _wrap_FieldDefn_SetPrecision, METH_VARARGS, "\n"
 		"FieldDefn_SetPrecision(FieldDefn self, int precision)\n"
-		"void\n"
-		"OGR_Fld_SetPrecision(OGRFieldDefnH hDefn, int nPrecision)\n"
+		"\n"
 		"\n"
 		"Set the formatting precision for this field in characters.\n"
 		"\n"
-		"This should normally be zero for fields of types other than OFTReal.\n"
+		"This should normally be zero for fields of types other than :py:const:`OFTReal`.\n"
 		"\n"
-		"This function is the same as the CPP method\n"
-		"OGRFieldDefn::SetPrecision().\n"
+		"See :cpp:func:`OGRFieldDefn::SetPrecision`.\n"
 		"\n"
 		"Parameters\n"
 		"-----------\n"
-		"hDefn:\n"
-		"    handle to the field definition to set precision to.\n"
-		"nPrecision:\n"
+		"precision : int\n"
 		"    the new precision.\n"
 		"\n"
 		""},
 	 { "FieldDefn_GetTZFlag", _wrap_FieldDefn_GetTZFlag, METH_O, "FieldDefn_GetTZFlag(FieldDefn self) -> int"},
 	 { "FieldDefn_SetTZFlag", _wrap_FieldDefn_SetTZFlag, METH_VARARGS, "FieldDefn_SetTZFlag(FieldDefn self, int tzflag)"},
 	 { "FieldDefn_GetTypeName", _wrap_FieldDefn_GetTypeName, METH_O, "FieldDefn_GetTypeName(FieldDefn self) -> char const *"},
 	 { "FieldDefn_GetFieldTypeName", _wrap_FieldDefn_GetFieldTypeName, METH_VARARGS, "FieldDefn_GetFieldTypeName(FieldDefn self, OGRFieldType type) -> char const *"},
 	 { "FieldDefn_IsIgnored", _wrap_FieldDefn_IsIgnored, METH_O, "\n"
 		"FieldDefn_IsIgnored(FieldDefn self) -> int\n"
-		"int OGR_Fld_IsIgnored(OGRFieldDefnH\n"
-		"hDefn)\n"
 		"\n"
-		"Return whether this field should be omitted when fetching features.\n"
 		"\n"
-		"This method is the same as the C++ method OGRFieldDefn::IsIgnored().\n"
+		"Return whether this field should be omitted when fetching features.\n"
 		"\n"
-		"Parameters\n"
-		"-----------\n"
-		"hDefn:\n"
-		"    handle to the field definition\n"
+		"See :cpp:func:`OGRFieldDefn::IsIgnored`.\n"
 		"\n"
 		"Returns\n"
 		"--------\n"
 		"int:\n"
 		"    ignore state\n"
 		"\n"
 		""},
 	 { "FieldDefn_SetIgnored", _wrap_FieldDefn_SetIgnored, METH_VARARGS, "\n"
 		"FieldDefn_SetIgnored(FieldDefn self, int bIgnored)\n"
-		"void\n"
-		"OGR_Fld_SetIgnored(OGRFieldDefnH hDefn, int ignore)\n"
+		"\n"
 		"\n"
 		"Set whether this field should be omitted when fetching features.\n"
 		"\n"
-		"This method is the same as the C++ method OGRFieldDefn::SetIgnored().\n"
+		"See :cpp:func:`OGRFieldDefn::SetIgnored`.\n"
 		"\n"
 		"Parameters\n"
 		"-----------\n"
-		"hDefn:\n"
-		"    handle to the field definition\n"
-		"ignore:\n"
+		"bignored : bool\n"
 		"    ignore state\n"
 		"\n"
 		""},
 	 { "FieldDefn_IsNullable", _wrap_FieldDefn_IsNullable, METH_O, "\n"
 		"FieldDefn_IsNullable(FieldDefn self) -> int\n"
-		"int\n"
-		"OGR_Fld_IsNullable(OGRFieldDefnH hDefn)\n"
+		"\n"
 		"\n"
 		"Return whether this field can receive null values.\n"
 		"\n"
 		"By default, fields are nullable.\n"
 		"\n"
 		"Even if this method returns FALSE (i.e not-nullable field), it doesn't\n"
-		"mean that OGRFeature::IsFieldSet() will necessary return TRUE, as\n"
+		"mean that :py:meth:`Feature.IsFieldSet` will necessary return TRUE, as\n"
 		"fields can be temporary unset and null/not-null validation is usually\n"
-		"done when OGRLayer::CreateFeature()/SetFeature() is called.\n"
-		"\n"
-		"This method is the same as the C++ method OGRFieldDefn::IsNullable().\n"
-		"\n"
-		".. versionadded:: 2.0\n"
-		"\n"
-		"Parameters\n"
-		"-----------\n"
-		"hDefn:\n"
-		"    handle to the field definition\n"
+		"done when :py:meth:`Layer.CreateFeature`/:py:meth:`Layer.SetFeature` is called.\n"
 		"\n"
+		"See :cpp:func:`OGRFieldDefn::IsNullable`.\n"
 		"\n"
 		"Returns\n"
 		"--------\n"
 		"int:\n"
 		"    TRUE if the field is authorized to be null.\n"
 		"\n"
 		""},
 	 { "FieldDefn_SetNullable", _wrap_FieldDefn_SetNullable, METH_VARARGS, "\n"
 		"FieldDefn_SetNullable(FieldDefn self, int bNullable)\n"
-		"void\n"
-		"OGR_Fld_SetNullable(OGRFieldDefnH hDefn, int bNullableIn)\n"
+		"\n"
 		"\n"
 		"Set whether this field can receive null values.\n"
 		"\n"
 		"By default, fields are nullable, so this method is generally called\n"
-		"with FALSE to set a not-null constraint.\n"
+		"with ``False`` to set a not-null constraint.\n"
 		"\n"
 		"Drivers that support writing not-null constraint will advertise the\n"
-		"GDAL_DCAP_NOTNULL_FIELDS driver metadata item.\n"
-		"\n"
-		"This method is the same as the C++ method OGRFieldDefn::SetNullable().\n"
+		"``GDAL_DCAP_NOTNULL_FIELDS`` driver metadata item.\n"
 		"\n"
-		".. versionadded:: 2.0\n"
+		"See :cpp:func:`OGRFieldDefn::SetNullable`.\n"
 		"\n"
 		"Parameters\n"
 		"-----------\n"
-		"hDefn:\n"
-		"    handle to the field definition\n"
-		"bNullableIn:\n"
-		"    FALSE if the field must have a not-null constraint.\n"
+		"bNullable : bool\n"
+		"    ``False`` if the field must have a not-null constraint.\n"
 		"\n"
 		""},
 	 { "FieldDefn_IsUnique", _wrap_FieldDefn_IsUnique, METH_O, "\n"
 		"FieldDefn_IsUnique(FieldDefn self) -> int\n"
-		"int OGR_Fld_IsUnique(OGRFieldDefnH\n"
-		"hDefn)\n"
+		"\n"
 		"\n"
 		"Return whether this field has a unique constraint.\n"
 		"\n"
 		"By default, fields have no unique constraint.\n"
 		"\n"
-		"This method is the same as the C++ method OGRFieldDefn::IsUnique().\n"
+		"See :cpp:func:`OGRFieldDefn::IsUnique`.\n"
 		"\n"
 		".. versionadded:: 3.2\n"
 		"\n"
-		"Parameters\n"
-		"-----------\n"
-		"hDefn:\n"
-		"    handle to the field definition\n"
-		"\n"
-		"\n"
 		"Returns\n"
 		"--------\n"
 		"int:\n"
 		"    TRUE if the field has a unique constraint.\n"
 		"\n"
 		""},
 	 { "FieldDefn_SetUnique", _wrap_FieldDefn_SetUnique, METH_VARARGS, "\n"
 		"FieldDefn_SetUnique(FieldDefn self, int bUnique)\n"
-		"void\n"
-		"OGR_Fld_SetUnique(OGRFieldDefnH hDefn, int bUniqueIn)\n"
+		"\n"
 		"\n"
 		"Set whether this field has a unique constraint.\n"
 		"\n"
 		"By default, fields have no unique constraint, so this method is\n"
 		"generally called with TRUE to set a unique constraint.\n"
 		"\n"
 		"Drivers that support writing unique constraint will advertise the\n"
-		"GDAL_DCAP_UNIQUE_FIELDS driver metadata item. field can receive null\n"
-		"values.\n"
+		"``GDAL_DCAP_UNIQUE_FIELDS`` driver metadata item.\n"
+		"\n"
+		"Note that once a :py:class:`FieldDefn` has been added to a layer definition with\n"
+		":py:meth:`Layer.AddFieldDefn`, its setter methods should not be called on the\n"
+		"object returned with ``GetLayerDefn().GetFieldDefn()``. Instead,\n"
+		":py:meth:`Layer::AlterFieldDefn` should be called on a new instance of\n"
+		":py:class:`FieldDefn`, for drivers that support :py:meth:`Layer.AlterFieldDefn`.\n"
 		"\n"
-		"This method is the same as the C++ method OGRFieldDefn::SetUnique().\n"
+		"See :cpp:func:`OGRFieldDefn::SetUnique`.\n"
 		"\n"
 		".. versionadded:: 3.2\n"
 		"\n"
 		"Parameters\n"
 		"-----------\n"
-		"hDefn:\n"
-		"    handle to the field definition\n"
-		"bUniqueIn:\n"
-		"    TRUE if the field must have a unique constraint.\n"
+		"bUnique : bool\n"
+		"    ``True`` if the field must have a unique constraint\n"
 		"\n"
 		""},
 	 { "FieldDefn_GetDefault", _wrap_FieldDefn_GetDefault, METH_O, "\n"
 		"FieldDefn_GetDefault(FieldDefn self) -> char const *\n"
-		"const char\\*\n"
-		"OGR_Fld_GetDefault(OGRFieldDefnH hDefn)\n"
-		"\n"
-		"Get default field value.\n"
 		"\n"
-		"This function is the same as the C++ method\n"
-		"OGRFieldDefn::GetDefault().\n"
 		"\n"
-		".. versionadded:: 2.0\n"
+		"Get default field value.\n"
 		"\n"
-		"Parameters\n"
-		"-----------\n"
-		"hDefn:\n"
-		"    handle to the field definition.\n"
+		"See :cpp:func:`OGRFieldDefn::GetDefault`.\n"
 		"\n"
 		"Returns\n"
 		"--------\n"
 		"str:\n"
-		"    default field value or NULL.\n"
+		"    default field value or ``None``.\n"
 		"\n"
 		""},
 	 { "FieldDefn_SetDefault", _wrap_FieldDefn_SetDefault, METH_VARARGS, "\n"
 		"FieldDefn_SetDefault(FieldDefn self, char const * pszValue)\n"
-		"void\n"
-		"OGR_Fld_SetDefault(OGRFieldDefnH hDefn, const char \\*pszDefault)\n"
+		"\n"
 		"\n"
 		"Set default field value.\n"
 		"\n"
 		"The default field value is taken into account by drivers (generally\n"
 		"those with a SQL interface) that support it at field creation time.\n"
 		"OGR will generally not automatically set the default field value to\n"
 		"null fields by itself when calling OGRFeature::CreateFeature() /\n"
@@ -39555,103 +40660,76 @@
 		"expression (that might be ignored by other drivers). For a datetime\n"
 		"literal value, format should be 'YYYY/MM/DD HH:MM:SS[.sss]'\n"
 		"(considered as UTC time).\n"
 		"\n"
 		"Drivers that support writing DEFAULT clauses will advertise the\n"
 		"GDAL_DCAP_DEFAULT_FIELDS driver metadata item.\n"
 		"\n"
-		"This function is the same as the C++ method\n"
-		"OGRFieldDefn::SetDefault().\n"
-		"\n"
-		".. versionadded:: 2.0\n"
+		"See :cpp:func:`OGRFieldDefn::SetDefault`.\n"
 		"\n"
 		"Parameters\n"
 		"-----------\n"
-		"hDefn:\n"
-		"    handle to the field definition.\n"
-		"pszDefault:\n"
+		"pszValue : str\n"
 		"    new default field value or NULL pointer.\n"
 		"\n"
 		""},
 	 { "FieldDefn_IsDefaultDriverSpecific", _wrap_FieldDefn_IsDefaultDriverSpecific, METH_O, "\n"
 		"FieldDefn_IsDefaultDriverSpecific(FieldDefn self) -> int\n"
-		"int\n"
-		"OGR_Fld_IsDefaultDriverSpecific(OGRFieldDefnH hDefn)\n"
+		"\n"
 		"\n"
 		"Returns whether the default value is driver specific.\n"
 		"\n"
 		"Driver specific default values are those that are not NULL, a numeric\n"
 		"value, a literal value enclosed between single quote characters,\n"
 		"CURRENT_TIMESTAMP, CURRENT_TIME, CURRENT_DATE or datetime literal\n"
 		"value.\n"
 		"\n"
-		"This function is the same as the C++ method\n"
-		"OGRFieldDefn::IsDefaultDriverSpecific().\n"
-		"\n"
-		".. versionadded:: 2.0\n"
-		"\n"
-		"Parameters\n"
-		"-----------\n"
-		"hDefn:\n"
-		"    handle to the field definition\n"
-		"\n"
+		"See :cpp:func:`OGRFieldDefn::IsDefaultDriverSpecific`.\n"
 		"\n"
 		"Returns\n"
 		"--------\n"
 		"int:\n"
 		"    TRUE if the default value is driver specific.\n"
 		"\n"
 		""},
 	 { "FieldDefn_GetDomainName", _wrap_FieldDefn_GetDomainName, METH_O, "\n"
 		"FieldDefn_GetDomainName(FieldDefn self) -> char const *\n"
-		"const char\\*\n"
-		"OGR_Fld_GetDomainName(OGRFieldDefnH hDefn)\n"
+		"\n"
 		"\n"
 		"Return the name of the field domain for this field.\n"
 		"\n"
-		"By default, none (empty string) is returned.\n"
+		"By default an empty string is returned.\n"
 		"\n"
-		"Field domains ( OGRFieldDomain class) are attached at the GDALDataset\n"
-		"level and should be retrieved with GDALDatasetGetFieldDomain().\n"
+		"Field domains ( :py:class:`FieldDomain` class) are attached at the :py:class:`Dataset` level and should be retrieved with :py:meth:`Dataset.GetFieldDomain`.\n"
 		"\n"
-		"This method is the same as the C++ method\n"
-		"OGRFieldDefn::GetDomainName().\n"
+		"See :cpp:func:`OGRFieldDefn::GetDomainName`.\n"
 		"\n"
 		".. versionadded:: 3.3\n"
 		"\n"
-		"Parameters\n"
-		"-----------\n"
-		"hDefn:\n"
-		"    handle to the field definition\n"
-		"\n"
 		"Returns\n"
 		"--------\n"
 		"str:\n"
 		"    the field domain name, or an empty string if there is none.\n"
 		"\n"
 		""},
 	 { "FieldDefn_SetDomainName", _wrap_FieldDefn_SetDomainName, METH_VARARGS, "\n"
 		"FieldDefn_SetDomainName(FieldDefn self, char const * name)\n"
-		"void\n"
-		"OGR_Fld_SetDomainName(OGRFieldDefnH hDefn, const char \\*pszFieldName)\n"
+		"\n"
 		"\n"
 		"Set the name of the field domain for this field.\n"
 		"\n"
-		"Field domains ( OGRFieldDomain) are attached at the GDALDataset level.\n"
+		"Field domains ( :py:class:`FieldDomain`) are attached at the :py:class:`Dataset` level.\n"
 		"\n"
-		"This method is the same as the C++ method\n"
-		"OGRFieldDefn::SetDomainName().\n"
+		"See :cpp:func:`OGRFieldDefn::SetDomainName`.\n"
 		"\n"
 		".. versionadded:: 3.3\n"
 		"\n"
 		"Parameters\n"
 		"-----------\n"
-		"hDefn:\n"
-		"    handle to the field definition\n"
-		"pszFieldName:\n"
+		"name : str\n"
 		"    Field domain name.\n"
 		"\n"
 		""},
 	 { "FieldDefn_GetComment", _wrap_FieldDefn_GetComment, METH_O, "FieldDefn_GetComment(FieldDefn self) -> char const *"},
 	 { "FieldDefn_SetComment", _wrap_FieldDefn_SetComment, METH_VARARGS, "FieldDefn_SetComment(FieldDefn self, char const * comment)"},
 	 { "FieldDefn_swigregister", FieldDefn_swigregister, METH_O, NULL},
 	 { "FieldDefn_swiginit", FieldDefn_swiginit, METH_VARARGS, NULL},
@@ -39664,14 +40742,16 @@
 	 { "GeomFieldDefn_SetType", _wrap_GeomFieldDefn_SetType, METH_VARARGS, "GeomFieldDefn_SetType(GeomFieldDefn self, OGRwkbGeometryType type)"},
 	 { "GeomFieldDefn_GetSpatialRef", _wrap_GeomFieldDefn_GetSpatialRef, METH_O, "GeomFieldDefn_GetSpatialRef(GeomFieldDefn self) -> SpatialReference"},
 	 { "GeomFieldDefn_SetSpatialRef", _wrap_GeomFieldDefn_SetSpatialRef, METH_VARARGS, "GeomFieldDefn_SetSpatialRef(GeomFieldDefn self, SpatialReference srs)"},
 	 { "GeomFieldDefn_IsIgnored", _wrap_GeomFieldDefn_IsIgnored, METH_O, "GeomFieldDefn_IsIgnored(GeomFieldDefn self) -> int"},
 	 { "GeomFieldDefn_SetIgnored", _wrap_GeomFieldDefn_SetIgnored, METH_VARARGS, "GeomFieldDefn_SetIgnored(GeomFieldDefn self, int bIgnored)"},
 	 { "GeomFieldDefn_IsNullable", _wrap_GeomFieldDefn_IsNullable, METH_O, "GeomFieldDefn_IsNullable(GeomFieldDefn self) -> int"},
 	 { "GeomFieldDefn_SetNullable", _wrap_GeomFieldDefn_SetNullable, METH_VARARGS, "GeomFieldDefn_SetNullable(GeomFieldDefn self, int bNullable)"},
+	 { "GeomFieldDefn_GetCoordinatePrecision", _wrap_GeomFieldDefn_GetCoordinatePrecision, METH_O, "GeomFieldDefn_GetCoordinatePrecision(GeomFieldDefn self) -> GeomCoordinatePrecision"},
+	 { "GeomFieldDefn_SetCoordinatePrecision", _wrap_GeomFieldDefn_SetCoordinatePrecision, METH_VARARGS, "GeomFieldDefn_SetCoordinatePrecision(GeomFieldDefn self, GeomCoordinatePrecision coordPrec)"},
 	 { "GeomFieldDefn_swigregister", GeomFieldDefn_swigregister, METH_O, NULL},
 	 { "GeomFieldDefn_swiginit", GeomFieldDefn_swiginit, METH_VARARGS, NULL},
 	 { "CreateGeometryFromWkb", (PyCFunction)(void(*)(void))_wrap_CreateGeometryFromWkb, METH_VARARGS|METH_KEYWORDS, "CreateGeometryFromWkb(size_t len, SpatialReference reference=None) -> Geometry"},
 	 { "CreateGeometryFromWkt", (PyCFunction)(void(*)(void))_wrap_CreateGeometryFromWkt, METH_VARARGS|METH_KEYWORDS, "CreateGeometryFromWkt(char ** val, SpatialReference reference=None) -> Geometry"},
 	 { "CreateGeometryFromGML", _wrap_CreateGeometryFromGML, METH_O, "CreateGeometryFromGML(char const * input_string) -> Geometry"},
 	 { "CreateGeometryFromJson", _wrap_CreateGeometryFromJson, METH_O, "CreateGeometryFromJson(char const * input_string) -> Geometry"},
 	 { "CreateGeometryFromEsriJson", _wrap_CreateGeometryFromEsriJson, METH_O, "CreateGeometryFromEsriJson(char const * input_string) -> Geometry"},
@@ -39798,15 +40878,48 @@
 		"\n"
 		"Returns\n"
 		"--------\n"
 		"str\n"
 		"\n"
 		""},
 	 { "Geometry_Length", _wrap_Geometry_Length, METH_O, "Geometry_Length(Geometry self) -> double"},
-	 { "Geometry_Area", _wrap_Geometry_Area, METH_O, "Geometry_Area(Geometry self) -> double"},
+	 { "Geometry_Area", _wrap_Geometry_Area, METH_O, "\n"
+		"Geometry_Area(Geometry self) -> double\n"
+		"\n"
+		"Compute geometry area.\n"
+		"\n"
+		"The returned area is a 2D Cartesian (planar) area in square units of the\n"
+		"spatial reference system in use, so potentially 'square degrees' for a\n"
+		"geometry expressed in a geographic SRS.\n"
+		"\n"
+		"For more details: :cpp:func:`OGR_G_Area`\n"
+		"\n"
+		"Returns\n"
+		"--------\n"
+		"float:\n"
+		"    the area of the geometry in square units of the spatial reference\n"
+		"    system in use, or 0.0 for unsupported geometry types.\n"
+		"\n"
+		"\n"
+		""},
+	 { "Geometry_GeodesicArea", _wrap_Geometry_GeodesicArea, METH_O, "\n"
+		"Geometry_GeodesicArea(Geometry self) -> double\n"
+		"\n"
+		"Compute geometry area, considered as a surface on the underlying\n"
+		"ellipsoid of the SRS attached to the geometry.\n"
+		"\n"
+		"For more details: :cpp:func:`OGR_G_GeodesicArea`\n"
+		"\n"
+		"Returns\n"
+		"--------\n"
+		"float:\n"
+		"    the area in square meters, or a negative value for unsupported geometry types.\n"
+		"\n"
+		"\n"
+		""},
 	 { "Geometry_IsClockwise", _wrap_Geometry_IsClockwise, METH_O, "Geometry_IsClockwise(Geometry self) -> bool"},
 	 { "Geometry_GetArea", _wrap_Geometry_GetArea, METH_O, "Geometry_GetArea(Geometry self) -> double"},
 	 { "Geometry_GetPointCount", _wrap_Geometry_GetPointCount, METH_O, "Geometry_GetPointCount(Geometry self) -> int"},
 	 { "Geometry_GetPoints", (PyCFunction)(void(*)(void))_wrap_Geometry_GetPoints, METH_VARARGS|METH_KEYWORDS, "Geometry_GetPoints(Geometry self, int nCoordDimension=0)"},
 	 { "Geometry_GetX", (PyCFunction)(void(*)(void))_wrap_Geometry_GetX, METH_VARARGS|METH_KEYWORDS, "Geometry_GetX(Geometry self, int point=0) -> double"},
 	 { "Geometry_GetY", (PyCFunction)(void(*)(void))_wrap_Geometry_GetY, METH_VARARGS|METH_KEYWORDS, "Geometry_GetY(Geometry self, int point=0) -> double"},
 	 { "Geometry_GetZ", (PyCFunction)(void(*)(void))_wrap_Geometry_GetZ, METH_VARARGS|METH_KEYWORDS, "Geometry_GetZ(Geometry self, int point=0) -> double"},
@@ -39962,14 +41075,15 @@
 		"Returns\n"
 		"--------\n"
 		"Geometry:\n"
 		"    A newly allocated geometry now owned by the caller, or None on\n"
 		"    failure.\n"
 		"\n"
 		""},
+	 { "Geometry_SetPrecision", _wrap_Geometry_SetPrecision, METH_VARARGS, "Geometry_SetPrecision(Geometry self, double gridSize, int flags=0) -> Geometry"},
 	 { "Geometry_Normalize", _wrap_Geometry_Normalize, METH_O, "\n"
 		"Geometry_Normalize(Geometry self) -> Geometry\n"
 		"\n"
 		"Attempts to bring geometry into normalized/canonical form.\n"
 		"\n"
 		"For more details: :cpp:func:`OGR_G_Normalize`\n"
 		"\n"
@@ -40051,14 +41165,15 @@
 		"\n"
 		"Returns\n"
 		"--------\n"
 		"Geometry:\n"
 		"    A new geometry representing the union or None if an error occurs.\n"
 		"\n"
 		""},
+	 { "Geometry_UnaryUnion", _wrap_Geometry_UnaryUnion, METH_O, "Geometry_UnaryUnion(Geometry self) -> Geometry"},
 	 { "Geometry_Difference", _wrap_Geometry_Difference, METH_VARARGS, "\n"
 		"Geometry_Difference(Geometry self, Geometry other) -> Geometry\n"
 		"\n"
 		"Compute difference.\n"
 		"\n"
 		"For more details: :cpp:func:`OGR_G_Difference`\n"
 		"\n"
@@ -40647,43 +41762,428 @@
 	 { "PreparedGeometry_swigregister", PreparedGeometry_swigregister, METH_O, NULL},
 	 { "new_GeomTransformer", _wrap_new_GeomTransformer, METH_VARARGS, "new_GeomTransformer(CoordinateTransformation ct, char ** options=None) -> GeomTransformer"},
 	 { "delete_GeomTransformer", _wrap_delete_GeomTransformer, METH_O, "delete_GeomTransformer(GeomTransformer self)"},
 	 { "GeomTransformer_Transform", _wrap_GeomTransformer_Transform, METH_VARARGS, "GeomTransformer_Transform(GeomTransformer self, Geometry src_geom) -> Geometry"},
 	 { "GeomTransformer_swigregister", GeomTransformer_swigregister, METH_O, NULL},
 	 { "GeomTransformer_swiginit", GeomTransformer_swiginit, METH_VARARGS, NULL},
 	 { "delete_FieldDomain", _wrap_delete_FieldDomain, METH_O, "delete_FieldDomain(FieldDomain self)"},
-	 { "FieldDomain_GetName", _wrap_FieldDomain_GetName, METH_O, "FieldDomain_GetName(FieldDomain self) -> char const *"},
-	 { "FieldDomain_GetDescription", _wrap_FieldDomain_GetDescription, METH_O, "FieldDomain_GetDescription(FieldDomain self) -> char const *"},
-	 { "FieldDomain_GetFieldType", _wrap_FieldDomain_GetFieldType, METH_O, "FieldDomain_GetFieldType(FieldDomain self) -> OGRFieldType"},
-	 { "FieldDomain_GetFieldSubType", _wrap_FieldDomain_GetFieldSubType, METH_O, "FieldDomain_GetFieldSubType(FieldDomain self) -> OGRFieldSubType"},
-	 { "FieldDomain_GetDomainType", _wrap_FieldDomain_GetDomainType, METH_O, "FieldDomain_GetDomainType(FieldDomain self) -> OGRFieldDomainType"},
-	 { "FieldDomain_GetSplitPolicy", _wrap_FieldDomain_GetSplitPolicy, METH_O, "FieldDomain_GetSplitPolicy(FieldDomain self) -> OGRFieldDomainSplitPolicy"},
-	 { "FieldDomain_SetSplitPolicy", _wrap_FieldDomain_SetSplitPolicy, METH_VARARGS, "FieldDomain_SetSplitPolicy(FieldDomain self, OGRFieldDomainSplitPolicy policy)"},
-	 { "FieldDomain_GetMergePolicy", _wrap_FieldDomain_GetMergePolicy, METH_O, "FieldDomain_GetMergePolicy(FieldDomain self) -> OGRFieldDomainMergePolicy"},
-	 { "FieldDomain_SetMergePolicy", _wrap_FieldDomain_SetMergePolicy, METH_VARARGS, "FieldDomain_SetMergePolicy(FieldDomain self, OGRFieldDomainMergePolicy policy)"},
-	 { "FieldDomain_GetEnumeration", _wrap_FieldDomain_GetEnumeration, METH_O, "FieldDomain_GetEnumeration(FieldDomain self) -> OGRCodedValue const *"},
-	 { "FieldDomain_GetMinAsDouble", _wrap_FieldDomain_GetMinAsDouble, METH_O, "FieldDomain_GetMinAsDouble(FieldDomain self) -> double"},
-	 { "FieldDomain_GetMinAsString", _wrap_FieldDomain_GetMinAsString, METH_O, "FieldDomain_GetMinAsString(FieldDomain self) -> char const *"},
+	 { "FieldDomain_GetName", _wrap_FieldDomain_GetName, METH_O, "\n"
+		"FieldDomain_GetName(FieldDomain self) -> char const *\n"
+		"\n"
+		"\n"
+		"Get the name of the field domain.\n"
+		"\n"
+		"See :cpp:func:`OGRFieldDomain::GetName`.\n"
+		"\n"
+		".. versionadded:: 3.3\n"
+		"\n"
+		"Returns\n"
+		"--------\n"
+		"str\n"
+		"    the field domain name.\n"
+		"\n"
+		""},
+	 { "FieldDomain_GetDescription", _wrap_FieldDomain_GetDescription, METH_O, "\n"
+		"FieldDomain_GetDescription(FieldDomain self) -> char const *\n"
+		"\n"
+		"\n"
+		"Get the description of the field domain.\n"
+		"\n"
+		"See :cpp:func:`OGRFieldDomain::GetDescription`.\n"
+		"\n"
+		".. versionadded:: 3.3\n"
+		"\n"
+		"Returns\n"
+		"--------\n"
+		"str\n"
+		"    the field domain description (might be empty string).\n"
+		"\n"
+		""},
+	 { "FieldDomain_GetFieldType", _wrap_FieldDomain_GetFieldType, METH_O, "\n"
+		"FieldDomain_GetFieldType(FieldDomain self) -> OGRFieldType\n"
+		"\n"
+		"\n"
+		"Get the field type of the field domain.\n"
+		"\n"
+		"See :cpp:func:`OGRFieldDomain::GetFieldType`.\n"
+		"\n"
+		".. versionadded:: 3.3\n"
+		"\n"
+		"Returns\n"
+		"--------\n"
+		"int\n"
+		"    the field type of the field domain.\n"
+		"\n"
+		""},
+	 { "FieldDomain_GetFieldSubType", _wrap_FieldDomain_GetFieldSubType, METH_O, "\n"
+		"FieldDomain_GetFieldSubType(FieldDomain self) -> OGRFieldSubType\n"
+		"\n"
+		"\n"
+		"Get the field subtype of the field domain.\n"
+		"\n"
+		"See :cpp:func:`OGRFieldDomain::GetFieldSubType`.\n"
+		"\n"
+		".. versionadded:: 3.3\n"
+		"\n"
+		"Returns\n"
+		"--------\n"
+		"int\n"
+		"    the field subtype of the field domain.\n"
+		"\n"
+		""},
+	 { "FieldDomain_GetDomainType", _wrap_FieldDomain_GetDomainType, METH_O, "\n"
+		"FieldDomain_GetDomainType(FieldDomain self) -> OGRFieldDomainType\n"
+		"\n"
+		"\n"
+		"Get the type of the field domain.\n"
+		"\n"
+		"See :cpp:func:`OGRFieldDomain::GetDomainType`.\n"
+		"\n"
+		".. versionadded:: 3.3\n"
+		"\n"
+		"Returns\n"
+		"--------\n"
+		"int\n"
+		"    the type of the field domain.\n"
+		"\n"
+		"Examples\n"
+		"--------\n"
+		">>> d = ogr.CreateCodedFieldDomain('my_code', None, ogr.OFTInteger, ogr.OFSTNone, { 1 : 'owned', 2 : 'leased' })\n"
+		">>> d.GetDomainType() == ogr.OFDT_CODED\n"
+		"True\n"
+		"\n"
+		"\n"
+		""},
+	 { "FieldDomain_GetSplitPolicy", _wrap_FieldDomain_GetSplitPolicy, METH_O, "\n"
+		"FieldDomain_GetSplitPolicy(FieldDomain self) -> OGRFieldDomainSplitPolicy\n"
+		"\n"
+		"\n"
+		"Get the split policy of the field domain.\n"
+		"\n"
+		"See :cpp:func:`OGRFieldDomain::GetSplitPolicy`.\n"
+		"\n"
+		".. versionadded:: 3.3\n"
+		"\n"
+		"Returns\n"
+		"--------\n"
+		"int\n"
+		"    the split policy of the field domain (default = :py:const:`OFDSP_DEFAULT_VALUE`)\n"
+		"\n"
+		""},
+	 { "FieldDomain_SetSplitPolicy", _wrap_FieldDomain_SetSplitPolicy, METH_VARARGS, "\n"
+		"FieldDomain_SetSplitPolicy(FieldDomain self, OGRFieldDomainSplitPolicy policy)\n"
+		"\n"
+		"\n"
+		"Set the split policy of the field domain.\n"
+		"\n"
+		"See :cpp:func:`OGRFieldDomain::SetSplitPolicy`.\n"
+		"\n"
+		".. versionadded:: 3.3\n"
+		"\n"
+		"policy : int\n"
+		"    the split policy code of the field domain.\n"
+		"\n"
+		""},
+	 { "FieldDomain_GetMergePolicy", _wrap_FieldDomain_GetMergePolicy, METH_O, "\n"
+		"FieldDomain_GetMergePolicy(FieldDomain self) -> OGRFieldDomainMergePolicy\n"
+		"\n"
+		"\n"
+		"Get the merge policy of the field domain.\n"
+		"\n"
+		"See :cpp:func:`OGRFieldDomain::GetMergePolicy`.\n"
+		"\n"
+		".. versionadded:: 3.3\n"
+		"\n"
+		"Returns\n"
+		"--------\n"
+		"int\n"
+		"    the merge policy of the field domain (default = :py:const:`OFDMP_DEFAULT_VALUE`)\n"
+		"\n"
+		""},
+	 { "FieldDomain_SetMergePolicy", _wrap_FieldDomain_SetMergePolicy, METH_VARARGS, "\n"
+		"FieldDomain_SetMergePolicy(FieldDomain self, OGRFieldDomainMergePolicy policy)\n"
+		"\n"
+		"\n"
+		"Set the merge policy of the field domain.\n"
+		"\n"
+		"See :cpp:func:`OGRFieldDomain::SetMergePolicy`.\n"
+		"\n"
+		".. versionadded:: 3.3\n"
+		"\n"
+		"Parameters\n"
+		"-----------\n"
+		"policy : int\n"
+		"    the merge policy code of the field domain.\n"
+		"\n"
+		""},
+	 { "FieldDomain_GetEnumeration", _wrap_FieldDomain_GetEnumeration, METH_O, "\n"
+		"FieldDomain_GetEnumeration(FieldDomain self) -> OGRCodedValue const *\n"
+		"\n"
+		"\n"
+		"Get the enumeration as a mapping of codes to values.\n"
+		"\n"
+		"See :cpp:func:`OGRCodedFieldDomain::GetEnumeration`.\n"
+		"\n"
+		".. versionadded:: 3.3\n"
+		"\n"
+		"Returns\n"
+		"--------\n"
+		"dict\n"
+		"\n"
+		"Examples\n"
+		"--------\n"
+		">>> d = ogr.CreateCodedFieldDomain('my_domain', None, ogr.OFTInteger, ogr.OFSTNone, { 1 : 'owned', 2 : 'leased' })\n"
+		">>> d.GetEnumeration()\n"
+		"{'1': 'owned', '2': 'leased'}\n"
+		"\n"
+		"\n"
+		""},
+	 { "FieldDomain_GetMinAsDouble", _wrap_FieldDomain_GetMinAsDouble, METH_O, "\n"
+		"FieldDomain_GetMinAsDouble(FieldDomain self) -> double\n"
+		"\n"
+		"\n"
+		"Get the minimum value of a range domain.\n"
+		"\n"
+		"See :cpp:func:`OGRRangeFieldDomain::GetMin()`\n"
+		"\n"
+		".. versionadded:: 3.3\n"
+		"\n"
+		"Returns\n"
+		"--------\n"
+		"float\n"
+		"    the minimum value of the range\n"
+		"\n"
+		""},
+	 { "FieldDomain_GetMinAsString", _wrap_FieldDomain_GetMinAsString, METH_O, "\n"
+		"FieldDomain_GetMinAsString(FieldDomain self) -> char const *\n"
+		"\n"
+		"\n"
+		"Get the minimum value of a range domain.\n"
+		"\n"
+		"See :cpp:func:`OGRRangeFieldDomain::GetMin()`\n"
+		"\n"
+		".. versionadded:: 3.3\n"
+		"\n"
+		"Returns\n"
+		"--------\n"
+		"str\n"
+		"    the minimum value of the range\n"
+		"\n"
+		""},
 	 { "FieldDomain_IsMinInclusive", _wrap_FieldDomain_IsMinInclusive, METH_O, "FieldDomain_IsMinInclusive(FieldDomain self) -> bool"},
-	 { "FieldDomain_GetMaxAsDouble", _wrap_FieldDomain_GetMaxAsDouble, METH_O, "FieldDomain_GetMaxAsDouble(FieldDomain self) -> double"},
-	 { "FieldDomain_GetMaxAsString", _wrap_FieldDomain_GetMaxAsString, METH_O, "FieldDomain_GetMaxAsString(FieldDomain self) -> char const *"},
+	 { "FieldDomain_GetMaxAsDouble", _wrap_FieldDomain_GetMaxAsDouble, METH_O, "\n"
+		"FieldDomain_GetMaxAsDouble(FieldDomain self) -> double\n"
+		"\n"
+		"\n"
+		"Get the maximum value of a range domain.\n"
+		"\n"
+		"See :cpp:func:`OGRRangeFieldDomain::GetMax()`\n"
+		"\n"
+		".. versionadded:: 3.3\n"
+		"\n"
+		"Returns\n"
+		"--------\n"
+		"float\n"
+		"    the maximum value of the range\n"
+		"\n"
+		""},
+	 { "FieldDomain_GetMaxAsString", _wrap_FieldDomain_GetMaxAsString, METH_O, "\n"
+		"FieldDomain_GetMaxAsString(FieldDomain self) -> char const *\n"
+		"\n"
+		"\n"
+		"Get the maximum value of a range domain.\n"
+		"\n"
+		"See :cpp:func:`OGRRangeFieldDomain::GetMax()`\n"
+		"\n"
+		".. versionadded:: 3.3\n"
+		"\n"
+		"Returns\n"
+		"--------\n"
+		"str\n"
+		"    the maximum value of the range\n"
+		"\n"
+		""},
 	 { "FieldDomain_IsMaxInclusive", _wrap_FieldDomain_IsMaxInclusive, METH_O, "FieldDomain_IsMaxInclusive(FieldDomain self) -> bool"},
-	 { "FieldDomain_GetGlob", _wrap_FieldDomain_GetGlob, METH_O, "FieldDomain_GetGlob(FieldDomain self) -> char const *"},
+	 { "FieldDomain_GetGlob", _wrap_FieldDomain_GetGlob, METH_O, "\n"
+		"FieldDomain_GetGlob(FieldDomain self) -> char const *\n"
+		"\n"
+		"\n"
+		"Get the glob expression.\n"
+		"\n"
+		"See :cpp:func:`OGRGlobFieldDomain::GetGlob`.\n"
+		"\n"
+		".. versionadded:: 3.3\n"
+		"\n"
+		"Returns\n"
+		"--------\n"
+		"str\n"
+		"    the glob expression, or ``None`` in case of error\n"
+		"\n"
+		""},
 	 { "FieldDomain_swigregister", FieldDomain_swigregister, METH_O, NULL},
-	 { "CreateCodedFieldDomain", _wrap_CreateCodedFieldDomain, METH_VARARGS, "CreateCodedFieldDomain(char const * name, char const * description, OGRFieldType type, OGRFieldSubType subtype, OGRCodedValue const * enumeration) -> FieldDomain"},
-	 { "CreateRangeFieldDomain", _wrap_CreateRangeFieldDomain, METH_VARARGS, "CreateRangeFieldDomain(char const * name, char const * description, OGRFieldType type, OGRFieldSubType subtype, double min, bool minIsInclusive, double max, double maxIsInclusive) -> FieldDomain"},
+	 { "CreateCodedFieldDomain", _wrap_CreateCodedFieldDomain, METH_VARARGS, "\n"
+		"CreateCodedFieldDomain(char const * name, char const * description, OGRFieldType type, OGRFieldSubType subtype, OGRCodedValue const * enumeration) -> FieldDomain\n"
+		"\n"
+		"\n"
+		"Creates a new coded field domain.\n"
+		"\n"
+		"See :cpp:func:`OGRCodedFieldDomain::OGRCodedFieldDomain`.\n"
+		"\n"
+		".. versionadded:: 3.3\n"
+		"\n"
+		"Parameters\n"
+		"-----------\n"
+		"name : str\n"
+		"    Domain name. Should not be ``None``.\n"
+		"description : str, optional\n"
+		"    Domain description (can be ``None``)\n"
+		"type : int\n"
+		"    Field type.\n"
+		"subtype : int\n"
+		"    Field subtype.\n"
+		"enumeration : dict\n"
+		"    Enumeration as a dictionary of (code : value) pairs. Should not be ``None``.\n"
+		"\n"
+		"Returns\n"
+		"--------\n"
+		"FieldDomain\n"
+		"\n"
+		""},
+	 { "CreateRangeFieldDomain", _wrap_CreateRangeFieldDomain, METH_VARARGS, "\n"
+		"CreateRangeFieldDomain(char const * name, char const * description, OGRFieldType type, OGRFieldSubType subtype, double min, bool minIsInclusive, double max, double maxIsInclusive) -> FieldDomain\n"
+		"\n"
+		"Creates a new range field domain.\n"
+		"\n"
+		"See :cpp:func:`OGRRangeFieldDomain::OGRRangeFieldDomain`.\n"
+		"\n"
+		".. versionadded:: 3.3\n"
+		"\n"
+		"Parameters\n"
+		"-----------\n"
+		"name : str\n"
+		"    Domain name. Should not be ``None``.\n"
+		"description : str, optional\n"
+		"    Domain description (can be ``None``)\n"
+		"type : int\n"
+		"    Field type. Generally numeric. Potentially :py:const:`OFTDateTime`.\n"
+		"subtype : int\n"
+		"    Field subtype.\n"
+		"min : float, optional\n"
+		"    Minimum value (can be ``None``).\n"
+		"minIsInclusive : bool\n"
+		"    Whether the minimum value is included in the range.\n"
+		"max : float, optional\n"
+		"    Maximum value (can be ``None``).\n"
+		"maxIsInclusive : bool\n"
+		"    Whether the maximum value is included in the range.\n"
+		"\n"
+		"Returns\n"
+		"--------\n"
+		"FieldDomain\n"
+		"\n"
+		""},
 	 { "CreateRangeFieldDomainDateTime", _wrap_CreateRangeFieldDomainDateTime, METH_VARARGS, "CreateRangeFieldDomainDateTime(char const * name, char const * description, char const * min, bool minIsInclusive, char const * max, double maxIsInclusive) -> FieldDomain"},
-	 { "CreateGlobFieldDomain", _wrap_CreateGlobFieldDomain, METH_VARARGS, "CreateGlobFieldDomain(char const * name, char const * description, OGRFieldType type, OGRFieldSubType subtype, char const * glob) -> FieldDomain"},
+	 { "CreateGlobFieldDomain", _wrap_CreateGlobFieldDomain, METH_VARARGS, "\n"
+		"CreateGlobFieldDomain(char const * name, char const * description, OGRFieldType type, OGRFieldSubType subtype, char const * glob) -> FieldDomain\n"
+		"\n"
+		"\n"
+		"Creates a new glob field domain.\n"
+		"\n"
+		"See :cpp:func:`OGRGlobFieldDomain::OGRGlobFieldDomain`\n"
+		"\n"
+		".. versionadded:: 3.3\n"
+		"\n"
+		"Parameters\n"
+		"-----------\n"
+		"name : str\n"
+		"    Domain name. Should not be ``None``.\n"
+		"description : str, optional\n"
+		"    Domain description (can be ``None``)\n"
+		"type : int\n"
+		"    Field type.\n"
+		"subtype : int\n"
+		"    Field subtype.\n"
+		"glob : str\n"
+		"    Glob expression. Should not be ``None``.\n"
+		"\n"
+		"Returns\n"
+		"--------\n"
+		"FieldDomain\n"
+		"\n"
+		""},
+	 { "delete_GeomCoordinatePrecision", _wrap_delete_GeomCoordinatePrecision, METH_O, "delete_GeomCoordinatePrecision(GeomCoordinatePrecision self)"},
+	 { "GeomCoordinatePrecision_Set", _wrap_GeomCoordinatePrecision_Set, METH_VARARGS, "GeomCoordinatePrecision_Set(GeomCoordinatePrecision self, double xyResolution, double zResolution, double mResolution)"},
+	 { "GeomCoordinatePrecision_SetFromMeter", _wrap_GeomCoordinatePrecision_SetFromMeter, METH_VARARGS, "GeomCoordinatePrecision_SetFromMeter(GeomCoordinatePrecision self, SpatialReference srs, double xyMeterResolution, double zMeterResolution, double mResolution)"},
+	 { "GeomCoordinatePrecision_GetXYResolution", _wrap_GeomCoordinatePrecision_GetXYResolution, METH_O, "GeomCoordinatePrecision_GetXYResolution(GeomCoordinatePrecision self) -> double"},
+	 { "GeomCoordinatePrecision_GetZResolution", _wrap_GeomCoordinatePrecision_GetZResolution, METH_O, "GeomCoordinatePrecision_GetZResolution(GeomCoordinatePrecision self) -> double"},
+	 { "GeomCoordinatePrecision_GetMResolution", _wrap_GeomCoordinatePrecision_GetMResolution, METH_O, "GeomCoordinatePrecision_GetMResolution(GeomCoordinatePrecision self) -> double"},
+	 { "GeomCoordinatePrecision_GetFormats", _wrap_GeomCoordinatePrecision_GetFormats, METH_O, "GeomCoordinatePrecision_GetFormats(GeomCoordinatePrecision self) -> char **"},
+	 { "GeomCoordinatePrecision_GetFormatSpecificOptions", _wrap_GeomCoordinatePrecision_GetFormatSpecificOptions, METH_VARARGS, "GeomCoordinatePrecision_GetFormatSpecificOptions(GeomCoordinatePrecision self, char const * formatName) -> char **"},
+	 { "GeomCoordinatePrecision_SetFormatSpecificOptions", _wrap_GeomCoordinatePrecision_SetFormatSpecificOptions, METH_VARARGS, "GeomCoordinatePrecision_SetFormatSpecificOptions(GeomCoordinatePrecision self, char const * formatName, char ** formatSpecificOptions)"},
+	 { "GeomCoordinatePrecision_swigregister", GeomCoordinatePrecision_swigregister, METH_O, NULL},
+	 { "CreateGeomCoordinatePrecision", _wrap_CreateGeomCoordinatePrecision, METH_NOARGS, "CreateGeomCoordinatePrecision() -> GeomCoordinatePrecision"},
 	 { "GetDriverCount", _wrap_GetDriverCount, METH_NOARGS, "GetDriverCount() -> int"},
 	 { "GetOpenDSCount", _wrap_GetOpenDSCount, METH_NOARGS, "GetOpenDSCount() -> int"},
 	 { "SetGenerate_DB2_V72_BYTE_ORDER", _wrap_SetGenerate_DB2_V72_BYTE_ORDER, METH_O, "SetGenerate_DB2_V72_BYTE_ORDER(int bGenerate_DB2_V72_BYTE_ORDER) -> OGRErr"},
 	 { "RegisterAll", _wrap_RegisterAll, METH_NOARGS, "RegisterAll()"},
 	 { "GeometryTypeToName", _wrap_GeometryTypeToName, METH_O, "GeometryTypeToName(OGRwkbGeometryType eType) -> char const *"},
-	 { "GetFieldTypeName", _wrap_GetFieldTypeName, METH_O, "GetFieldTypeName(OGRFieldType type) -> char const *"},
-	 { "GetFieldSubTypeName", _wrap_GetFieldSubTypeName, METH_O, "GetFieldSubTypeName(OGRFieldSubType type) -> char const *"},
+	 { "GetFieldTypeName", _wrap_GetFieldTypeName, METH_O, "\n"
+		"GetFieldTypeName(OGRFieldType type) -> char const *\n"
+		"\n"
+		"Fetch human readable name for a field type.\n"
+		"\n"
+		"See :cpp:func:`OGRFieldDefn::GetFieldTypeName`.\n"
+		"\n"
+		"Parameters\n"
+		"-----------\n"
+		"type : int\n"
+		"    the field type code to get name for\n"
+		"\n"
+		"Returns\n"
+		"--------\n"
+		"str\n"
+		"    the name\n"
+		"\n"
+		"Examples\n"
+		"--------\n"
+		">>> ogr.GetFieldTypeName(0)\n"
+		"'Integer'\n"
+		"\n"
+		">>> ogr.GetFieldTypeName(ogr.OFTReal)\n"
+		"'Real'\n"
+		"\n"
+		""},
+	 { "GetFieldSubTypeName", _wrap_GetFieldSubTypeName, METH_O, "\n"
+		"GetFieldSubTypeName(OGRFieldSubType type) -> char const *\n"
+		"\n"
+		"\n"
+		"Fetch human readable name for a field subtype.\n"
+		"\n"
+		"See :cpp:func:`OGRFieldDefn::GetFieldSubTypeName`.\n"
+		"\n"
+		"Parameters\n"
+		"-----------\n"
+		"type : int\n"
+		"    the field subtype to get name for.\n"
+		"\n"
+		"Returns\n"
+		"--------\n"
+		"str\n"
+		"    the name.\n"
+		"\n"
+		"Examples\n"
+		"--------\n"
+		">>> ogr.GetFieldSubTypeName(1)\n"
+		"'Boolean'\n"
+		"\n"
+		">>> ogr.GetFieldSubTypeName(ogr.OFSTInt16)\n"
+		"'Int16'\n"
+		"\n"
+		"\n"
+		""},
 	 { "GT_Flatten", _wrap_GT_Flatten, METH_O, "GT_Flatten(OGRwkbGeometryType eType) -> OGRwkbGeometryType"},
 	 { "GT_SetZ", _wrap_GT_SetZ, METH_O, "GT_SetZ(OGRwkbGeometryType eType) -> OGRwkbGeometryType"},
 	 { "GT_SetM", _wrap_GT_SetM, METH_O, "GT_SetM(OGRwkbGeometryType eType) -> OGRwkbGeometryType"},
 	 { "GT_SetModifier", _wrap_GT_SetModifier, METH_VARARGS, "GT_SetModifier(OGRwkbGeometryType eType, int bSetZ, int bSetM=FALSE) -> OGRwkbGeometryType"},
 	 { "GT_HasZ", _wrap_GT_HasZ, METH_O, "GT_HasZ(OGRwkbGeometryType eType) -> int"},
 	 { "GT_HasM", _wrap_GT_HasM, METH_O, "GT_HasM(OGRwkbGeometryType eType) -> int"},
 	 { "GT_IsSubClassOf", _wrap_GT_IsSubClassOf, METH_VARARGS, "GT_IsSubClassOf(OGRwkbGeometryType eType, OGRwkbGeometryType eSuperType) -> int"},
@@ -40716,24 +42216,26 @@
 }
 static void *_p_OGRLayerShadowTo_p_GDALMajorObjectShadow(void *x, int *SWIGUNUSEDPARM(newmemory)) {
     return (void *)((GDALMajorObjectShadow *)  ((OGRLayerShadow *) x));
 }
 static swig_type_info _swigt__p_ArrowArray = {"_p_ArrowArray", "ArrowArray *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_ArrowArrayStream = {"_p_ArrowArrayStream", "ArrowArrayStream *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_ArrowSchema = {"_p_ArrowSchema", "ArrowSchema *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_GDALDatasetShadow = {"_p_GDALDatasetShadow", "GDALDatasetShadow *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_GDALMajorObjectShadow = {"_p_GDALMajorObjectShadow", "GDALMajorObjectShadow *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_GDALProgressFunc = {"_p_GDALProgressFunc", "GDALProgressFunc *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_GIntBig = {"_p_GIntBig", "GIntBig *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_OGRCodedValue = {"_p_OGRCodedValue", "OGRCodedValue *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_OGRDataSourceShadow = {"_p_OGRDataSourceShadow", "OGRDataSourceShadow *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_OGRDriverShadow = {"_p_OGRDriverShadow", "OGRDriverShadow *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_OGRFeatureDefnShadow = {"_p_OGRFeatureDefnShadow", "OGRFeatureDefnShadow *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_OGRFeatureShadow = {"_p_OGRFeatureShadow", "OGRFeatureShadow *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_OGRFieldDefnShadow = {"_p_OGRFieldDefnShadow", "OGRFieldDefnShadow *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_OGRFieldDomainShadow = {"_p_OGRFieldDomainShadow", "OGRFieldDomainShadow *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_OGRGeomCoordinatePrecisionShadow = {"_p_OGRGeomCoordinatePrecisionShadow", "OGRGeomCoordinatePrecisionShadow *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_OGRGeomFieldDefnShadow = {"_p_OGRGeomFieldDefnShadow", "OGRGeomFieldDefnShadow *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_OGRGeomTransformerShadow = {"_p_OGRGeomTransformerShadow", "OGRGeomTransformerShadow *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_OGRGeometryShadow = {"_p_OGRGeometryShadow", "OGRGeometryShadow *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_OGRLayerShadow = {"_p_OGRLayerShadow", "OGRLayerShadow *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_OGRPreparedGeometryShadow = {"_p_OGRPreparedGeometryShadow", "OGRPreparedGeometryShadow *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_OGRStyleTableShadow = {"_p_OGRStyleTableShadow", "OGRStyleTableShadow *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_OSRCoordinateTransformationShadow = {"_p_OSRCoordinateTransformationShadow", "OSRCoordinateTransformationShadow *", 0, 0, (void*)0, 0};
@@ -40752,24 +42254,26 @@
 static swig_type_info _swigt__p_p_int = {"_p_p_int", "int **", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_size_t = {"_p_size_t", "size_t *", 0, 0, (void*)0, 0};
 
 static swig_type_info *swig_type_initial[] = {
   &_swigt__p_ArrowArray,
   &_swigt__p_ArrowArrayStream,
   &_swigt__p_ArrowSchema,
+  &_swigt__p_GDALDatasetShadow,
   &_swigt__p_GDALMajorObjectShadow,
   &_swigt__p_GDALProgressFunc,
   &_swigt__p_GIntBig,
   &_swigt__p_OGRCodedValue,
   &_swigt__p_OGRDataSourceShadow,
   &_swigt__p_OGRDriverShadow,
   &_swigt__p_OGRFeatureDefnShadow,
   &_swigt__p_OGRFeatureShadow,
   &_swigt__p_OGRFieldDefnShadow,
   &_swigt__p_OGRFieldDomainShadow,
+  &_swigt__p_OGRGeomCoordinatePrecisionShadow,
   &_swigt__p_OGRGeomFieldDefnShadow,
   &_swigt__p_OGRGeomTransformerShadow,
   &_swigt__p_OGRGeometryShadow,
   &_swigt__p_OGRLayerShadow,
   &_swigt__p_OGRPreparedGeometryShadow,
   &_swigt__p_OGRStyleTableShadow,
   &_swigt__p_OSRCoordinateTransformationShadow,
@@ -40788,24 +42292,26 @@
   &_swigt__p_p_int,
   &_swigt__p_size_t,
 };
 
 static swig_cast_info _swigc__p_ArrowArray[] = {  {&_swigt__p_ArrowArray, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_ArrowArrayStream[] = {  {&_swigt__p_ArrowArrayStream, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_ArrowSchema[] = {  {&_swigt__p_ArrowSchema, 0, 0, 0},{0, 0, 0, 0}};
+static swig_cast_info _swigc__p_GDALDatasetShadow[] = {  {&_swigt__p_GDALDatasetShadow, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_GDALMajorObjectShadow[] = {  {&_swigt__p_GDALMajorObjectShadow, 0, 0, 0},  {&_swigt__p_OGRDataSourceShadow, _p_OGRDataSourceShadowTo_p_GDALMajorObjectShadow, 0, 0},  {&_swigt__p_OGRDriverShadow, _p_OGRDriverShadowTo_p_GDALMajorObjectShadow, 0, 0},  {&_swigt__p_OGRLayerShadow, _p_OGRLayerShadowTo_p_GDALMajorObjectShadow, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_GDALProgressFunc[] = {  {&_swigt__p_GDALProgressFunc, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_GIntBig[] = {  {&_swigt__p_GIntBig, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_OGRCodedValue[] = {  {&_swigt__p_OGRCodedValue, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_OGRDataSourceShadow[] = {  {&_swigt__p_OGRDataSourceShadow, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_OGRDriverShadow[] = {  {&_swigt__p_OGRDriverShadow, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_OGRFeatureDefnShadow[] = {  {&_swigt__p_OGRFeatureDefnShadow, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_OGRFeatureShadow[] = {  {&_swigt__p_OGRFeatureShadow, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_OGRFieldDefnShadow[] = {  {&_swigt__p_OGRFieldDefnShadow, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_OGRFieldDomainShadow[] = {  {&_swigt__p_OGRFieldDomainShadow, 0, 0, 0},{0, 0, 0, 0}};
+static swig_cast_info _swigc__p_OGRGeomCoordinatePrecisionShadow[] = {  {&_swigt__p_OGRGeomCoordinatePrecisionShadow, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_OGRGeomFieldDefnShadow[] = {  {&_swigt__p_OGRGeomFieldDefnShadow, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_OGRGeomTransformerShadow[] = {  {&_swigt__p_OGRGeomTransformerShadow, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_OGRGeometryShadow[] = {  {&_swigt__p_OGRGeometryShadow, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_OGRLayerShadow[] = {  {&_swigt__p_OGRLayerShadow, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_OGRPreparedGeometryShadow[] = {  {&_swigt__p_OGRPreparedGeometryShadow, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_OGRStyleTableShadow[] = {  {&_swigt__p_OGRStyleTableShadow, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_OSRCoordinateTransformationShadow[] = {  {&_swigt__p_OSRCoordinateTransformationShadow, 0, 0, 0},{0, 0, 0, 0}};
@@ -40824,24 +42330,26 @@
 static swig_cast_info _swigc__p_p_int[] = {  {&_swigt__p_p_int, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_size_t[] = {  {&_swigt__p_size_t, 0, 0, 0},{0, 0, 0, 0}};
 
 static swig_cast_info *swig_cast_initial[] = {
   _swigc__p_ArrowArray,
   _swigc__p_ArrowArrayStream,
   _swigc__p_ArrowSchema,
+  _swigc__p_GDALDatasetShadow,
   _swigc__p_GDALMajorObjectShadow,
   _swigc__p_GDALProgressFunc,
   _swigc__p_GIntBig,
   _swigc__p_OGRCodedValue,
   _swigc__p_OGRDataSourceShadow,
   _swigc__p_OGRDriverShadow,
   _swigc__p_OGRFeatureDefnShadow,
   _swigc__p_OGRFeatureShadow,
   _swigc__p_OGRFieldDefnShadow,
   _swigc__p_OGRFieldDomainShadow,
+  _swigc__p_OGRGeomCoordinatePrecisionShadow,
   _swigc__p_OGRGeomFieldDefnShadow,
   _swigc__p_OGRGeomTransformerShadow,
   _swigc__p_OGRGeometryShadow,
   _swigc__p_OGRLayerShadow,
   _swigc__p_OGRPreparedGeometryShadow,
   _swigc__p_OGRStyleTableShadow,
   _swigc__p_OSRCoordinateTransformationShadow,
@@ -41465,14 +42973,15 @@
   SWIG_Python_SetConstant(d, "GGT_GEOMCOLLECTIONZ_TINZ",SWIG_From_int(static_cast< int >(0x4)));
   SWIG_Python_SetConstant(d, "OLCRandomRead",SWIG_FromCharPtr("RandomRead"));
   SWIG_Python_SetConstant(d, "OLCSequentialWrite",SWIG_FromCharPtr("SequentialWrite"));
   SWIG_Python_SetConstant(d, "OLCRandomWrite",SWIG_FromCharPtr("RandomWrite"));
   SWIG_Python_SetConstant(d, "OLCFastSpatialFilter",SWIG_FromCharPtr("FastSpatialFilter"));
   SWIG_Python_SetConstant(d, "OLCFastFeatureCount",SWIG_FromCharPtr("FastFeatureCount"));
   SWIG_Python_SetConstant(d, "OLCFastGetExtent",SWIG_FromCharPtr("FastGetExtent"));
+  SWIG_Python_SetConstant(d, "OLCFastGetExtent3D",SWIG_FromCharPtr("FastGetExtent3D"));
   SWIG_Python_SetConstant(d, "OLCCreateField",SWIG_FromCharPtr("CreateField"));
   SWIG_Python_SetConstant(d, "OLCDeleteField",SWIG_FromCharPtr("DeleteField"));
   SWIG_Python_SetConstant(d, "OLCReorderFields",SWIG_FromCharPtr("ReorderFields"));
   SWIG_Python_SetConstant(d, "OLCAlterFieldDefn",SWIG_FromCharPtr("AlterFieldDefn"));
   SWIG_Python_SetConstant(d, "OLCAlterGeomFieldDefn",SWIG_FromCharPtr("AlterGeomFieldDefn"));
   SWIG_Python_SetConstant(d, "OLCTransactions",SWIG_FromCharPtr("Transactions"));
   SWIG_Python_SetConstant(d, "OLCDeleteFeature",SWIG_FromCharPtr("DeleteFeature"));
@@ -41483,14 +42992,15 @@
   SWIG_Python_SetConstant(d, "OLCIgnoreFields",SWIG_FromCharPtr("IgnoreFields"));
   SWIG_Python_SetConstant(d, "OLCCreateGeomField",SWIG_FromCharPtr("CreateGeomField"));
   SWIG_Python_SetConstant(d, "OLCCurveGeometries",SWIG_FromCharPtr("CurveGeometries"));
   SWIG_Python_SetConstant(d, "OLCMeasuredGeometries",SWIG_FromCharPtr("MeasuredGeometries"));
   SWIG_Python_SetConstant(d, "OLCZGeometries",SWIG_FromCharPtr("ZGeometries"));
   SWIG_Python_SetConstant(d, "OLCRename",SWIG_FromCharPtr("Rename"));
   SWIG_Python_SetConstant(d, "OLCFastGetArrowStream",SWIG_FromCharPtr("FastGetArrowStream"));
+  SWIG_Python_SetConstant(d, "OLCFastWriteArrowBatch",SWIG_FromCharPtr("FastWriteArrowBatch"));
   SWIG_Python_SetConstant(d, "ODsCCreateLayer",SWIG_FromCharPtr("CreateLayer"));
   SWIG_Python_SetConstant(d, "ODsCDeleteLayer",SWIG_FromCharPtr("DeleteLayer"));
   SWIG_Python_SetConstant(d, "ODsCCreateGeomFieldAfterCreateLayer",SWIG_FromCharPtr("CreateGeomFieldAfterCreateLayer"));
   SWIG_Python_SetConstant(d, "ODsCCurveGeometries",SWIG_FromCharPtr("CurveGeometries"));
   SWIG_Python_SetConstant(d, "ODsCTransactions",SWIG_FromCharPtr("Transactions"));
   SWIG_Python_SetConstant(d, "ODsCEmulatedTransactions",SWIG_FromCharPtr("EmulatedTransactions"));
   SWIG_Python_SetConstant(d, "ODsCMeasuredGeometries",SWIG_FromCharPtr("MeasuredGeometries"));
@@ -41499,14 +43009,16 @@
   SWIG_Python_SetConstant(d, "ODsCRandomLayerWrite",SWIG_FromCharPtr("RandomLayerWrite "));
   SWIG_Python_SetConstant(d, "ODsCAddFieldDomain",SWIG_FromCharPtr("AddFieldDomain"));
   SWIG_Python_SetConstant(d, "ODsCDeleteFieldDomain",SWIG_FromCharPtr("DeleteFieldDomain"));
   SWIG_Python_SetConstant(d, "ODsCUpdateFieldDomain",SWIG_FromCharPtr("UpdateFieldDomain"));
   SWIG_Python_SetConstant(d, "ODrCCreateDataSource",SWIG_FromCharPtr("CreateDataSource"));
   SWIG_Python_SetConstant(d, "ODrCDeleteDataSource",SWIG_FromCharPtr("DeleteDataSource"));
   SWIG_Python_SetConstant(d, "OLMD_FID64",SWIG_FromCharPtr("OLMD_FID64"));
+  SWIG_Python_SetConstant(d, "GEOS_PREC_NO_TOPO",SWIG_From_int(static_cast< int >(1)));
+  SWIG_Python_SetConstant(d, "GEOS_PREC_KEEP_COLLAPSED",SWIG_From_int(static_cast< int >(2)));
   SWIG_Python_SetConstant(d, "OGRERR_NONE",SWIG_From_int(static_cast< int >(0)));
   SWIG_Python_SetConstant(d, "OGRERR_NOT_ENOUGH_DATA",SWIG_From_int(static_cast< int >(1)));
   SWIG_Python_SetConstant(d, "OGRERR_NOT_ENOUGH_MEMORY",SWIG_From_int(static_cast< int >(2)));
   SWIG_Python_SetConstant(d, "OGRERR_UNSUPPORTED_GEOMETRY_TYPE",SWIG_From_int(static_cast< int >(3)));
   SWIG_Python_SetConstant(d, "OGRERR_UNSUPPORTED_OPERATION",SWIG_From_int(static_cast< int >(4)));
   SWIG_Python_SetConstant(d, "OGRERR_CORRUPT_DATA",SWIG_From_int(static_cast< int >(5)));
   SWIG_Python_SetConstant(d, "OGRERR_FAILURE",SWIG_From_int(static_cast< int >(6)));
```

### Comparing `GDAL-3.8.5/extensions/osr_wrap.cpp` & `GDAL-3.9.0/extensions/osr_wrap.cpp`

 * *Files 2% similar despite different names*

```diff
@@ -4032,14 +4032,17 @@
   }
 SWIGINTERN int OSRSpatialReferenceShadow_IsDerivedGeographic(OSRSpatialReferenceShadow *self){
     return OSRIsDerivedGeographic(self);
   }
 SWIGINTERN int OSRSpatialReferenceShadow_IsProjected(OSRSpatialReferenceShadow *self){
     return OSRIsProjected(self);
   }
+SWIGINTERN int OSRSpatialReferenceShadow_IsDerivedProjected(OSRSpatialReferenceShadow *self){
+    return OSRIsDerivedProjected(self);
+  }
 SWIGINTERN int OSRSpatialReferenceShadow_IsCompound(OSRSpatialReferenceShadow *self){
     return OSRIsCompound(self);
   }
 SWIGINTERN int OSRSpatialReferenceShadow_IsGeocentric(OSRSpatialReferenceShadow *self){
     return OSRIsGeocentric(self);
   }
 SWIGINTERN int OSRSpatialReferenceShadow_IsLocal(OSRSpatialReferenceShadow *self){
@@ -4412,16 +4415,16 @@
 SWIGINTERN OGRErr OSRSpatialReferenceShadow_SetVerticalPerspective(OSRSpatialReferenceShadow *self,double topoOriginLat,double topoOriginLon,double topoOriginHeight,double viewPointHeight,double fe,double fn){
     return OSRSetVerticalPerspective( self,
         topoOriginLat, topoOriginLon, topoOriginHeight, viewPointHeight, fe, fn );
   }
 SWIGINTERN OGRErr OSRSpatialReferenceShadow_SetWellKnownGeogCS(OSRSpatialReferenceShadow *self,char const *name){
     return OSRSetWellKnownGeogCS( self, name );
   }
-SWIGINTERN OGRErr OSRSpatialReferenceShadow_SetFromUserInput(OSRSpatialReferenceShadow *self,char const *name){
-    return OSRSetFromUserInput( self, name );
+SWIGINTERN OGRErr OSRSpatialReferenceShadow_SetFromUserInput(OSRSpatialReferenceShadow *self,char const *name,char **options=NULL){
+    return OSRSetFromUserInputEx( self, name, options );
   }
 SWIGINTERN OGRErr OSRSpatialReferenceShadow_CopyGeogCSFrom(OSRSpatialReferenceShadow *self,OSRSpatialReferenceShadow *rhs){
     return OSRCopyGeogCSFrom( self, rhs );
   }
 SWIGINTERN OGRErr OSRSpatialReferenceShadow_SetTOWGS84(OSRSpatialReferenceShadow *self,double p1,double p2,double p3,double p4=0.0,double p5=0.0,double p6=0.0,double p7=0.0){
 
     return OSRSetTOWGS84( self, p1, p2, p3, p4, p5, p6, p7 );
@@ -4500,14 +4503,17 @@
   }
 SWIGINTERN OGRErr OSRSpatialReferenceShadow_ImportFromMICoordSys(OSRSpatialReferenceShadow *self,char const *pszCoordSys){
     return OSRImportFromMICoordSys( self, pszCoordSys );
   }
 SWIGINTERN OGRErr OSRSpatialReferenceShadow_ImportFromOzi(OSRSpatialReferenceShadow *self,char const *const *papszLines){
     return OSRImportFromOzi( self, papszLines );
   }
+SWIGINTERN OGRErr OSRSpatialReferenceShadow_ImportFromCF1(OSRSpatialReferenceShadow *self,char **keyValues,char const *units=NULL){
+      return OSRImportFromCF1(self, keyValues, units);
+  }
 SWIGINTERN OGRErr OSRSpatialReferenceShadow_ExportToWkt(OSRSpatialReferenceShadow *self,char **argout,char **options=NULL){
     return OSRExportToWktEx( self, argout, options );
   }
 SWIGINTERN OGRErr OSRSpatialReferenceShadow_ExportToPrettyWkt(OSRSpatialReferenceShadow *self,char **argout,int simplify=0){
     return OSRExportToPrettyWkt( self, argout, simplify );
   }
 SWIGINTERN OGRErr OSRSpatialReferenceShadow_ExportToPROJJSON(OSRSpatialReferenceShadow *self,char **argout,char **options=NULL){
@@ -4535,14 +4541,66 @@
   }
 SWIGINTERN OGRErr OSRSpatialReferenceShadow_ExportToXML(OSRSpatialReferenceShadow *self,char **argout,char const *dialect=""){
     return OSRExportToXML( self, argout, dialect );
   }
 SWIGINTERN OGRErr OSRSpatialReferenceShadow_ExportToMICoordSys(OSRSpatialReferenceShadow *self,char **argout){
     return OSRExportToMICoordSys( self, argout );
   }
+SWIGINTERN char **OSRSpatialReferenceShadow_ExportToCF1(OSRSpatialReferenceShadow *self,char **options=NULL){
+    char** ret = NULL;
+    OSRExportToCF1(self, NULL, &ret, NULL, options);
+    return ret;
+  }
+
+/* Return a PyObject* from a C String */
+static PyObject* GDALPythonObjectFromCStrAndSize(const char *pszStr, size_t nLen)
+{
+  const unsigned char* pszIter = (const unsigned char*) pszStr;
+  for( size_t i = 0; i < nLen; ++i)
+  {
+    if (pszIter[i] > 127)
+    {
+        PyObject* pyObj = PyUnicode_DecodeUTF8(pszStr, nLen, "strict");
+        if (pyObj != NULL && !PyErr_Occurred())
+            return pyObj;
+        PyErr_Clear();
+        return PyBytes_FromStringAndSize(pszStr, nLen);
+    }
+  }
+  return PyUnicode_FromStringAndSize(pszStr, nLen);
+}
+
+
+static PyObject*
+GetCSLStringAsPyDict( char **stringarray, bool bFreeCSL ) {
+  PyObject* dict = PyDict_New();
+  if ( stringarray != NULL ) {
+    for (char** iter = stringarray; *iter; ++iter ) {
+      const char* pszSep = strchr( *iter, '=' );
+      if ( pszSep != NULL) {
+        const char* keyptr = *iter;
+        const char* valptr = pszSep + 1;
+        PyObject *nm = GDALPythonObjectFromCStrAndSize( keyptr, (size_t)(pszSep - keyptr) );
+        PyObject *val = GDALPythonObjectFromCStr( valptr );
+        PyDict_SetItem(dict, nm, val );
+        Py_DECREF(nm);
+        Py_DECREF(val);
+      }
+    }
+  }
+  if( bFreeCSL )
+    CSLDestroy(stringarray);
+  return dict;
+}
+
+SWIGINTERN retStringAndCPLFree *OSRSpatialReferenceShadow_ExportToCF1Units(OSRSpatialReferenceShadow *self,char **options=NULL){
+    char* units = NULL;
+    OSRExportToCF1(self, NULL, NULL, &units, options);
+    return units;
+ }
 SWIGINTERN OSRSpatialReferenceShadow *OSRSpatialReferenceShadow_CloneGeogCS(OSRSpatialReferenceShadow *self){
     return (OSRSpatialReferenceShadow*) OSRCloneGeogCS(self);
   }
 SWIGINTERN OSRSpatialReferenceShadow *OSRSpatialReferenceShadow_Clone(OSRSpatialReferenceShadow *self){
     return (OSRSpatialReferenceShadow*) OSRClone(self);
   }
 SWIGINTERN OGRErr OSRSpatialReferenceShadow_StripVertical(OSRSpatialReferenceShadow *self){
@@ -6318,14 +6376,55 @@
   if ( ReturnSame(bLocalUseExceptionsCode) ) { CPLErr eclass = CPLGetLastErrorType(); if ( eclass == CE_Failure || eclass == CE_Fatal ) { Py_XDECREF(resultobj); SWIG_Error( SWIG_RuntimeError, CPLGetLastErrorMsg() ); return NULL; } }
   return resultobj;
 fail:
   return NULL;
 }
 
 
+SWIGINTERN PyObject *_wrap_SpatialReference_IsDerivedProjected(PyObject *self, PyObject *args) {
+  PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
+  OSRSpatialReferenceShadow *arg1 = (OSRSpatialReferenceShadow *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject *swig_obj[1] ;
+  int result;
+  
+  if (!args) SWIG_fail;
+  swig_obj[0] = args;
+  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialReference_IsDerivedProjected" "', argument " "1"" of type '" "OSRSpatialReferenceShadow *""'"); 
+  }
+  arg1 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp1);
+  {
+    const int bLocalUseExceptions = GetUseExceptions();
+    if ( bLocalUseExceptions ) {
+      pushErrorHandler();
+    }
+    result = (int)OSRSpatialReferenceShadow_IsDerivedProjected(arg1);
+    if ( bLocalUseExceptions ) {
+      popErrorHandler();
+    }
+#ifndef SED_HACKS
+    if ( bLocalUseExceptions ) {
+      CPLErr eclass = CPLGetLastErrorType();
+      if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+        SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+      }
+    }
+#endif
+  }
+  resultobj = SWIG_From_int(static_cast< int >(result));
+  if ( ReturnSame(bLocalUseExceptionsCode) ) { CPLErr eclass = CPLGetLastErrorType(); if ( eclass == CE_Failure || eclass == CE_Fatal ) { Py_XDECREF(resultobj); SWIG_Error( SWIG_RuntimeError, CPLGetLastErrorMsg() ); return NULL; } }
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
 SWIGINTERN PyObject *_wrap_SpatialReference_IsCompound(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
   OSRSpatialReferenceShadow *arg1 = (OSRSpatialReferenceShadow *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   PyObject *swig_obj[1] ;
   int result;
@@ -13149,48 +13248,80 @@
   return resultobj;
 fail:
   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
   return NULL;
 }
 
 
-SWIGINTERN PyObject *_wrap_SpatialReference_SetFromUserInput(PyObject *self, PyObject *args) {
+SWIGINTERN PyObject *_wrap_SpatialReference_SetFromUserInput(PyObject *self, PyObject *args, PyObject *kwargs) {
   PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
   OSRSpatialReferenceShadow *arg1 = (OSRSpatialReferenceShadow *) 0 ;
   char *arg2 = (char *) 0 ;
+  char **arg3 = (char **) NULL ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   int res2 ;
   char *buf2 = 0 ;
   int alloc2 = 0 ;
-  PyObject *swig_obj[2] ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  PyObject * obj2 = 0 ;
+  char * kwnames[] = {
+    (char *)"self",  (char *)"name",  (char *)"options",  NULL 
+  };
   OGRErr result;
   
-  if (!SWIG_Python_UnpackTuple(args, "SpatialReference_SetFromUserInput", 2, 2, swig_obj)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OO|O:SpatialReference_SetFromUserInput", kwnames, &obj0, &obj1, &obj2)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialReference_SetFromUserInput" "', argument " "1"" of type '" "OSRSpatialReferenceShadow *""'"); 
   }
   arg1 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp1);
-  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, NULL, &alloc2);
+  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
   if (!SWIG_IsOK(res2)) {
     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SpatialReference_SetFromUserInput" "', argument " "2"" of type '" "char const *""'");
   }
   arg2 = reinterpret_cast< char * >(buf2);
+  if (obj2) {
+    {
+      /* %typemap(in) char **dict */
+      arg3 = NULL;
+      if ( PySequence_Check( obj2 ) ) {
+        int bErr = FALSE;
+        arg3 = CSLFromPySequence(obj2, &bErr);
+        if ( bErr )
+        {
+          SWIG_fail;
+        }
+      }
+      else if ( PyMapping_Check( obj2 ) ) {
+        int bErr = FALSE;
+        arg3 = CSLFromPyMapping(obj2, &bErr);
+        if ( bErr )
+        {
+          SWIG_fail;
+        }
+      }
+      else {
+        PyErr_SetString(PyExc_TypeError,"Argument must be dictionary or sequence of strings");
+        SWIG_fail;
+      }
+    }
+  }
   {
     if (!arg2) {
       SWIG_exception(SWIG_ValueError,"Received a NULL pointer.");
     }
   }
   {
     const int bLocalUseExceptions = GetUseExceptions();
     if ( bLocalUseExceptions ) {
       pushErrorHandler();
     }
-    result = (OGRErr)OSRSpatialReferenceShadow_SetFromUserInput(arg1,(char const *)arg2);
+    result = (OGRErr)OSRSpatialReferenceShadow_SetFromUserInput(arg1,(char const *)arg2,arg3);
     if ( bLocalUseExceptions ) {
       popErrorHandler();
     }
 #ifndef SED_HACKS
     if ( bLocalUseExceptions ) {
       CPLErr eclass = CPLGetLastErrorType();
       if ( eclass == CE_Failure || eclass == CE_Fatal ) {
@@ -13208,23 +13339,31 @@
       else
       PyErr_SetString( PyExc_RuntimeError, OGRErrMessages(result) );
       SWIG_fail;
     }
   }
   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
   {
+    /* %typemap(freearg) char **dict */
+    CSLDestroy( arg3 );
+  }
+  {
     /* %typemap(ret) OGRErr */
     if ( ReturnSame(resultobj == Py_None || resultobj == 0) ) {
       resultobj = PyInt_FromLong( result );
     }
   }
   if ( ReturnSame(bLocalUseExceptionsCode) ) { CPLErr eclass = CPLGetLastErrorType(); if ( eclass == CE_Failure || eclass == CE_Fatal ) { Py_XDECREF(resultobj); SWIG_Error( SWIG_RuntimeError, CPLGetLastErrorMsg() ); return NULL; } }
   return resultobj;
 fail:
   if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
+  {
+    /* %typemap(freearg) char **dict */
+    CSLDestroy( arg3 );
+  }
   return NULL;
 }
 
 
 SWIGINTERN PyObject *_wrap_SpatialReference_CopyGeogCSFrom(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
   OSRSpatialReferenceShadow *arg1 = (OSRSpatialReferenceShadow *) 0 ;
@@ -15102,14 +15241,116 @@
     /* %typemap(freearg) char **dict */
     CSLDestroy( arg2 );
   }
   return NULL;
 }
 
 
+SWIGINTERN PyObject *_wrap_SpatialReference_ImportFromCF1(PyObject *self, PyObject *args) {
+  PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
+  OSRSpatialReferenceShadow *arg1 = (OSRSpatialReferenceShadow *) 0 ;
+  char **arg2 = (char **) 0 ;
+  char *arg3 = (char *) NULL ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  int res3 ;
+  char *buf3 = 0 ;
+  int alloc3 = 0 ;
+  PyObject *swig_obj[3] ;
+  OGRErr result;
+  
+  if (!SWIG_Python_UnpackTuple(args, "SpatialReference_ImportFromCF1", 2, 3, swig_obj)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialReference_ImportFromCF1" "', argument " "1"" of type '" "OSRSpatialReferenceShadow *""'"); 
+  }
+  arg1 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp1);
+  {
+    /* %typemap(in) char **dict */
+    arg2 = NULL;
+    if ( PySequence_Check( swig_obj[1] ) ) {
+      int bErr = FALSE;
+      arg2 = CSLFromPySequence(swig_obj[1], &bErr);
+      if ( bErr )
+      {
+        SWIG_fail;
+      }
+    }
+    else if ( PyMapping_Check( swig_obj[1] ) ) {
+      int bErr = FALSE;
+      arg2 = CSLFromPyMapping(swig_obj[1], &bErr);
+      if ( bErr )
+      {
+        SWIG_fail;
+      }
+    }
+    else {
+      PyErr_SetString(PyExc_TypeError,"Argument must be dictionary or sequence of strings");
+      SWIG_fail;
+    }
+  }
+  if (swig_obj[2]) {
+    res3 = SWIG_AsCharPtrAndSize(swig_obj[2], &buf3, NULL, &alloc3);
+    if (!SWIG_IsOK(res3)) {
+      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SpatialReference_ImportFromCF1" "', argument " "3"" of type '" "char const *""'");
+    }
+    arg3 = reinterpret_cast< char * >(buf3);
+  }
+  {
+    const int bLocalUseExceptions = GetUseExceptions();
+    if ( bLocalUseExceptions ) {
+      pushErrorHandler();
+    }
+    result = (OGRErr)OSRSpatialReferenceShadow_ImportFromCF1(arg1,arg2,(char const *)arg3);
+    if ( bLocalUseExceptions ) {
+      popErrorHandler();
+    }
+#ifndef SED_HACKS
+    if ( bLocalUseExceptions ) {
+      CPLErr eclass = CPLGetLastErrorType();
+      if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+        SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+      }
+    }
+#endif
+  }
+  {
+    /* %typemap(out) OGRErr */
+    if ( result != 0 && GetUseExceptions()) {
+      const char* pszMessage = CPLGetLastErrorMsg();
+      if( pszMessage[0] != '\0' )
+      PyErr_SetString( PyExc_RuntimeError, pszMessage );
+      else
+      PyErr_SetString( PyExc_RuntimeError, OGRErrMessages(result) );
+      SWIG_fail;
+    }
+  }
+  {
+    /* %typemap(freearg) char **dict */
+    CSLDestroy( arg2 );
+  }
+  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
+  {
+    /* %typemap(ret) OGRErr */
+    if ( ReturnSame(resultobj == Py_None || resultobj == 0) ) {
+      resultobj = PyInt_FromLong( result );
+    }
+  }
+  if ( ReturnSame(bLocalUseExceptionsCode) ) { CPLErr eclass = CPLGetLastErrorType(); if ( eclass == CE_Failure || eclass == CE_Fatal ) { Py_XDECREF(resultobj); SWIG_Error( SWIG_RuntimeError, CPLGetLastErrorMsg() ); return NULL; } }
+  return resultobj;
+fail:
+  {
+    /* %typemap(freearg) char **dict */
+    CSLDestroy( arg2 );
+  }
+  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
+  return NULL;
+}
+
+
 SWIGINTERN PyObject *_wrap_SpatialReference_ExportToWkt(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
   OSRSpatialReferenceShadow *arg1 = (OSRSpatialReferenceShadow *) 0 ;
   char **arg2 = (char **) 0 ;
   char **arg3 = (char **) NULL ;
   void *argp1 = 0 ;
   int res1 = 0 ;
@@ -16082,14 +16323,180 @@
     if ( *arg2 )
     CPLFree( *arg2 );
   }
   return NULL;
 }
 
 
+SWIGINTERN PyObject *_wrap_SpatialReference_ExportToCF1(PyObject *self, PyObject *args) {
+  PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
+  OSRSpatialReferenceShadow *arg1 = (OSRSpatialReferenceShadow *) 0 ;
+  char **arg2 = (char **) NULL ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject *swig_obj[2] ;
+  char **result = 0 ;
+  
+  if (!SWIG_Python_UnpackTuple(args, "SpatialReference_ExportToCF1", 1, 2, swig_obj)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialReference_ExportToCF1" "', argument " "1"" of type '" "OSRSpatialReferenceShadow *""'"); 
+  }
+  arg1 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp1);
+  if (swig_obj[1]) {
+    {
+      /* %typemap(in) char **dict */
+      arg2 = NULL;
+      if ( PySequence_Check( swig_obj[1] ) ) {
+        int bErr = FALSE;
+        arg2 = CSLFromPySequence(swig_obj[1], &bErr);
+        if ( bErr )
+        {
+          SWIG_fail;
+        }
+      }
+      else if ( PyMapping_Check( swig_obj[1] ) ) {
+        int bErr = FALSE;
+        arg2 = CSLFromPyMapping(swig_obj[1], &bErr);
+        if ( bErr )
+        {
+          SWIG_fail;
+        }
+      }
+      else {
+        PyErr_SetString(PyExc_TypeError,"Argument must be dictionary or sequence of strings");
+        SWIG_fail;
+      }
+    }
+  }
+  {
+    const int bLocalUseExceptions = GetUseExceptions();
+    if ( bLocalUseExceptions ) {
+      pushErrorHandler();
+    }
+    result = (char **)OSRSpatialReferenceShadow_ExportToCF1(arg1,arg2);
+    if ( bLocalUseExceptions ) {
+      popErrorHandler();
+    }
+#ifndef SED_HACKS
+    if ( bLocalUseExceptions ) {
+      CPLErr eclass = CPLGetLastErrorType();
+      if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+        SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+      }
+    }
+#endif
+  }
+  {
+    /* %typemap(out) char **dict */
+    resultobj = GetCSLStringAsPyDict(result, true);
+  }
+  {
+    /* %typemap(freearg) char **dict */
+    CSLDestroy( arg2 );
+  }
+  if ( ReturnSame(bLocalUseExceptionsCode) ) { CPLErr eclass = CPLGetLastErrorType(); if ( eclass == CE_Failure || eclass == CE_Fatal ) { Py_XDECREF(resultobj); SWIG_Error( SWIG_RuntimeError, CPLGetLastErrorMsg() ); return NULL; } }
+  return resultobj;
+fail:
+  {
+    /* %typemap(freearg) char **dict */
+    CSLDestroy( arg2 );
+  }
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_SpatialReference_ExportToCF1Units(PyObject *self, PyObject *args) {
+  PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
+  OSRSpatialReferenceShadow *arg1 = (OSRSpatialReferenceShadow *) 0 ;
+  char **arg2 = (char **) NULL ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject *swig_obj[2] ;
+  retStringAndCPLFree *result = 0 ;
+  
+  if (!SWIG_Python_UnpackTuple(args, "SpatialReference_ExportToCF1Units", 1, 2, swig_obj)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_OSRSpatialReferenceShadow, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialReference_ExportToCF1Units" "', argument " "1"" of type '" "OSRSpatialReferenceShadow *""'"); 
+  }
+  arg1 = reinterpret_cast< OSRSpatialReferenceShadow * >(argp1);
+  if (swig_obj[1]) {
+    {
+      /* %typemap(in) char **dict */
+      arg2 = NULL;
+      if ( PySequence_Check( swig_obj[1] ) ) {
+        int bErr = FALSE;
+        arg2 = CSLFromPySequence(swig_obj[1], &bErr);
+        if ( bErr )
+        {
+          SWIG_fail;
+        }
+      }
+      else if ( PyMapping_Check( swig_obj[1] ) ) {
+        int bErr = FALSE;
+        arg2 = CSLFromPyMapping(swig_obj[1], &bErr);
+        if ( bErr )
+        {
+          SWIG_fail;
+        }
+      }
+      else {
+        PyErr_SetString(PyExc_TypeError,"Argument must be dictionary or sequence of strings");
+        SWIG_fail;
+      }
+    }
+  }
+  {
+    const int bLocalUseExceptions = GetUseExceptions();
+    if ( bLocalUseExceptions ) {
+      pushErrorHandler();
+    }
+    result = (retStringAndCPLFree *)OSRSpatialReferenceShadow_ExportToCF1Units(arg1,arg2);
+    if ( bLocalUseExceptions ) {
+      popErrorHandler();
+    }
+#ifndef SED_HACKS
+    if ( bLocalUseExceptions ) {
+      CPLErr eclass = CPLGetLastErrorType();
+      if ( eclass == CE_Failure || eclass == CE_Fatal ) {
+        SWIG_exception( SWIG_RuntimeError, CPLGetLastErrorMsg() );
+      }
+    }
+#endif
+  }
+  {
+    /* %typemap(out) (retStringAndCPLFree*) */
+    Py_XDECREF(resultobj);
+    if(result)
+    {
+      resultobj = GDALPythonObjectFromCStr( (const char *)result);
+      CPLFree(result);
+    }
+    else
+    {
+      resultobj = Py_None;
+      Py_INCREF(resultobj);
+    }
+  }
+  {
+    /* %typemap(freearg) char **dict */
+    CSLDestroy( arg2 );
+  }
+  if ( ReturnSame(bLocalUseExceptionsCode) ) { CPLErr eclass = CPLGetLastErrorType(); if ( eclass == CE_Failure || eclass == CE_Fatal ) { Py_XDECREF(resultobj); SWIG_Error( SWIG_RuntimeError, CPLGetLastErrorMsg() ); return NULL; } }
+  return resultobj;
+fail:
+  {
+    /* %typemap(freearg) char **dict */
+    CSLDestroy( arg2 );
+  }
+  return NULL;
+}
+
+
 SWIGINTERN PyObject *_wrap_SpatialReference_CloneGeogCS(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0; int bLocalUseExceptionsCode = GetUseExceptions();
   OSRSpatialReferenceShadow *arg1 = (OSRSpatialReferenceShadow *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   PyObject *swig_obj[1] ;
   OSRSpatialReferenceShadow *result = 0 ;
@@ -19793,69 +20200,758 @@
 	 { "AreaOfUse_swigregister", AreaOfUse_swigregister, METH_O, NULL},
 	 { "AreaOfUse_swiginit", AreaOfUse_swiginit, METH_VARARGS, NULL},
 	 { "OSRAreaOfUse_west_lon_degree_get", _wrap_OSRAreaOfUse_west_lon_degree_get, METH_O, "OSRAreaOfUse_west_lon_degree_get(AreaOfUse area) -> double"},
 	 { "OSRAreaOfUse_south_lat_degree_get", _wrap_OSRAreaOfUse_south_lat_degree_get, METH_O, "OSRAreaOfUse_south_lat_degree_get(AreaOfUse area) -> double"},
 	 { "OSRAreaOfUse_east_lon_degree_get", _wrap_OSRAreaOfUse_east_lon_degree_get, METH_O, "OSRAreaOfUse_east_lon_degree_get(AreaOfUse area) -> double"},
 	 { "OSRAreaOfUse_north_lat_degree_get", _wrap_OSRAreaOfUse_north_lat_degree_get, METH_O, "OSRAreaOfUse_north_lat_degree_get(AreaOfUse area) -> double"},
 	 { "OSRAreaOfUse_name_get", _wrap_OSRAreaOfUse_name_get, METH_O, "OSRAreaOfUse_name_get(AreaOfUse area) -> char const *"},
-	 { "new_SpatialReference", (PyCFunction)(void(*)(void))_wrap_new_SpatialReference, METH_VARARGS|METH_KEYWORDS, "new_SpatialReference(char const * wkt=\"\") -> SpatialReference"},
+	 { "new_SpatialReference", (PyCFunction)(void(*)(void))_wrap_new_SpatialReference, METH_VARARGS|METH_KEYWORDS, "\n"
+		"new_SpatialReference(char const * wkt=\"\") -> SpatialReference\n"
+		"\n"
+		"Python proxy of an :cpp:class:`OGRSpatialReference`.\n"
+		"\n"
+		""},
 	 { "delete_SpatialReference", _wrap_delete_SpatialReference, METH_O, "delete_SpatialReference(SpatialReference self)"},
 	 { "SpatialReference___str__", _wrap_SpatialReference___str__, METH_O, "SpatialReference___str__(SpatialReference self) -> retStringAndCPLFree *"},
-	 { "SpatialReference_GetName", _wrap_SpatialReference_GetName, METH_O, "SpatialReference_GetName(SpatialReference self) -> char const *"},
-	 { "SpatialReference_IsSame", (PyCFunction)(void(*)(void))_wrap_SpatialReference_IsSame, METH_VARARGS|METH_KEYWORDS, "SpatialReference_IsSame(SpatialReference self, SpatialReference rhs, char ** options=None) -> int"},
-	 { "SpatialReference_IsSameGeogCS", _wrap_SpatialReference_IsSameGeogCS, METH_VARARGS, "SpatialReference_IsSameGeogCS(SpatialReference self, SpatialReference rhs) -> int"},
-	 { "SpatialReference_IsSameVertCS", _wrap_SpatialReference_IsSameVertCS, METH_VARARGS, "SpatialReference_IsSameVertCS(SpatialReference self, SpatialReference rhs) -> int"},
-	 { "SpatialReference_IsGeographic", _wrap_SpatialReference_IsGeographic, METH_O, "SpatialReference_IsGeographic(SpatialReference self) -> int"},
-	 { "SpatialReference_IsDerivedGeographic", _wrap_SpatialReference_IsDerivedGeographic, METH_O, "SpatialReference_IsDerivedGeographic(SpatialReference self) -> int"},
-	 { "SpatialReference_IsProjected", _wrap_SpatialReference_IsProjected, METH_O, "SpatialReference_IsProjected(SpatialReference self) -> int"},
-	 { "SpatialReference_IsCompound", _wrap_SpatialReference_IsCompound, METH_O, "SpatialReference_IsCompound(SpatialReference self) -> int"},
-	 { "SpatialReference_IsGeocentric", _wrap_SpatialReference_IsGeocentric, METH_O, "SpatialReference_IsGeocentric(SpatialReference self) -> int"},
-	 { "SpatialReference_IsLocal", _wrap_SpatialReference_IsLocal, METH_O, "SpatialReference_IsLocal(SpatialReference self) -> int"},
-	 { "SpatialReference_IsVertical", _wrap_SpatialReference_IsVertical, METH_O, "SpatialReference_IsVertical(SpatialReference self) -> int"},
-	 { "SpatialReference_IsDynamic", _wrap_SpatialReference_IsDynamic, METH_O, "SpatialReference_IsDynamic(SpatialReference self) -> bool"},
-	 { "SpatialReference_HasPointMotionOperation", _wrap_SpatialReference_HasPointMotionOperation, METH_O, "SpatialReference_HasPointMotionOperation(SpatialReference self) -> bool"},
-	 { "SpatialReference_GetCoordinateEpoch", _wrap_SpatialReference_GetCoordinateEpoch, METH_O, "SpatialReference_GetCoordinateEpoch(SpatialReference self) -> double"},
+	 { "SpatialReference_GetName", _wrap_SpatialReference_GetName, METH_O, "\n"
+		"SpatialReference_GetName(SpatialReference self) -> char const *\n"
+		"\n"
+		"\n"
+		"Return the CRS name.\n"
+		"\n"
+		"See :cpp:func:`OGRSpatialReference::GetName`.\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"str\n"
+		"\n"
+		"Examples\n"
+		"--------\n"
+		">>> vt_sp = osr.SpatialReference()\n"
+		">>> vt_sp.ImportFromEPSG(5646)\n"
+		"0\n"
+		">>> vt_sp.GetName()\n"
+		"'NAD83 / Vermont (ftUS)'\n"
+		"\n"
+		"\n"
+		""},
+	 { "SpatialReference_IsSame", (PyCFunction)(void(*)(void))_wrap_SpatialReference_IsSame, METH_VARARGS|METH_KEYWORDS, "\n"
+		"SpatialReference_IsSame(SpatialReference self, SpatialReference rhs, char ** options=None) -> int\n"
+		"\n"
+		"\n"
+		"Determine if two spatial references describe the same system.\n"
+		"\n"
+		"See :cpp:func:`OGRSpatialReference::IsSame`.\n"
+		"\n"
+		"Parameters\n"
+		"----------\n"
+		"rhs : SpatialReference\n"
+		"options : list/dict\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"int\n"
+		"    1 if the spatial references describe the same system, 0 otherwise\n"
+		"\n"
+		"\n"
+		""},
+	 { "SpatialReference_IsSameGeogCS", _wrap_SpatialReference_IsSameGeogCS, METH_VARARGS, "\n"
+		"SpatialReference_IsSameGeogCS(SpatialReference self, SpatialReference rhs) -> int\n"
+		"\n"
+		"\n"
+		"Determine if two spatial references share the same geographic coordinate system.\n"
+		"\n"
+		"See :cpp:func:`OGRSpatialReference::IsSameGeogCS`.\n"
+		"\n"
+		"Parameters\n"
+		"----------\n"
+		"rhs : SpatialReference\n"
+		"options : list/dict\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"int\n"
+		"    1 if the spatial references have the same GeogCS, 0 otherwise\n"
+		"\n"
+		"\n"
+		""},
+	 { "SpatialReference_IsSameVertCS", _wrap_SpatialReference_IsSameVertCS, METH_VARARGS, "\n"
+		"SpatialReference_IsSameVertCS(SpatialReference self, SpatialReference rhs) -> int\n"
+		"\n"
+		"\n"
+		"Determine if two spatial references share the same vertical coordinate system.\n"
+		"\n"
+		"See :cpp:func:`OGRSpatialReference::IsSameVertCS`.\n"
+		"\n"
+		"Parameters\n"
+		"----------\n"
+		"rhs : SpatialReference\n"
+		"options : list/dict\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"int\n"
+		"    1 if the spatial references have the same VertCS, 0 otherwise\n"
+		"\n"
+		"\n"
+		""},
+	 { "SpatialReference_IsGeographic", _wrap_SpatialReference_IsGeographic, METH_O, "\n"
+		"SpatialReference_IsGeographic(SpatialReference self) -> int\n"
+		"\n"
+		"\n"
+		"Check if this SRS is a geographic coordinate system.\n"
+		"\n"
+		"See :cpp:func:`OGRSpatialReference::IsGeographic`.\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"int\n"
+		"    1 if the SRS is geographic, 0 otherwise\n"
+		"\n"
+		""},
+	 { "SpatialReference_IsDerivedGeographic", _wrap_SpatialReference_IsDerivedGeographic, METH_O, "\n"
+		"SpatialReference_IsDerivedGeographic(SpatialReference self) -> int\n"
+		"\n"
+		"\n"
+		"Check if this CRS is a derived geographic CRS, such as a rotated long/lat grid.\n"
+		"\n"
+		"See :cpp:func:`OGRSpatialReference::IsDerivedGeographic`.\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"int\n"
+		"    1 if the CRS is derived geographic, 0 otherwise\n"
+		"\n"
+		""},
+	 { "SpatialReference_IsProjected", _wrap_SpatialReference_IsProjected, METH_O, "\n"
+		"SpatialReference_IsProjected(SpatialReference self) -> int\n"
+		"\n"
+		"\n"
+		"Check if this SRS is a projected coordinate system.\n"
+		"\n"
+		"See :cpp:func:`OGRSpatialReference::IsProjected`.\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"int\n"
+		"    1 if the SRS is projected, 0 otherwise\n"
+		"\n"
+		""},
+	 { "SpatialReference_IsDerivedProjected", _wrap_SpatialReference_IsDerivedProjected, METH_O, "SpatialReference_IsDerivedProjected(SpatialReference self) -> int"},
+	 { "SpatialReference_IsCompound", _wrap_SpatialReference_IsCompound, METH_O, "\n"
+		"SpatialReference_IsCompound(SpatialReference self) -> int\n"
+		"\n"
+		"\n"
+		"Check if this CRS is a compound CRS.\n"
+		"\n"
+		"See :cpp:func:`OGRSpatialReference::IsCompound`.\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"int\n"
+		"    1 if the CRS is compound, 0 otherwise\n"
+		"\n"
+		""},
+	 { "SpatialReference_IsGeocentric", _wrap_SpatialReference_IsGeocentric, METH_O, "\n"
+		"SpatialReference_IsGeocentric(SpatialReference self) -> int\n"
+		"\n"
+		"\n"
+		"Check if this SRS is a geocentric coordinate system.\n"
+		"\n"
+		"See :cpp:func:`OGRSpatialReference::IsGeocentric`.\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"int\n"
+		"    1 if the SRS is geocentric, 0 otherwise\n"
+		"\n"
+		""},
+	 { "SpatialReference_IsLocal", _wrap_SpatialReference_IsLocal, METH_O, "\n"
+		"SpatialReference_IsLocal(SpatialReference self) -> int\n"
+		"\n"
+		"\n"
+		"Check if this CRS is a local CRS.\n"
+		"\n"
+		"See :cpp:func:`OGRSpatialReference::IsLocal`.\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"int\n"
+		"    1 if the SRS is local, 0 otherwise\n"
+		"\n"
+		""},
+	 { "SpatialReference_IsVertical", _wrap_SpatialReference_IsVertical, METH_O, "\n"
+		"SpatialReference_IsVertical(SpatialReference self) -> int\n"
+		"\n"
+		"\n"
+		"Check if this is a vertical coordinate system.\n"
+		"\n"
+		"See :cpp:func:`OGRSpatialReference::IsVertical`.\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"int\n"
+		"    1 if the CRS is vertical, 0 otherwise\n"
+		"\n"
+		"\n"
+		""},
+	 { "SpatialReference_IsDynamic", _wrap_SpatialReference_IsDynamic, METH_O, "\n"
+		"SpatialReference_IsDynamic(SpatialReference self) -> bool\n"
+		"\n"
+		"\n"
+		"Check if this CRS is a dynamic coordinate CRS.\n"
+		"\n"
+		"See :cpp:func:`OGRSpatialReference::IsDynamic`.\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"bool\n"
+		"\n"
+		""},
+	 { "SpatialReference_HasPointMotionOperation", _wrap_SpatialReference_HasPointMotionOperation, METH_O, "\n"
+		"SpatialReference_HasPointMotionOperation(SpatialReference self) -> bool\n"
+		"\n"
+		"\n"
+		"Check if a CRS has an associated point motion operation.\n"
+		"\n"
+		"See :cpp:func:`OGRSpatialReference::HasPointMotionOperation`.\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"bool\n"
+		"\n"
+		"\n"
+		""},
+	 { "SpatialReference_GetCoordinateEpoch", _wrap_SpatialReference_GetCoordinateEpoch, METH_O, "\n"
+		"SpatialReference_GetCoordinateEpoch(SpatialReference self) -> double\n"
+		"\n"
+		"\n"
+		"Return the coordinate epoch as a decimal year.\n"
+		"\n"
+		"See :cpp:func:`OGRSpatialReference::GetCoordinateEpoch`.\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"float\n"
+		"    coordinate epoch as a decimal year, or 0 if not set/relevant\n"
+		"\n"
+		"\n"
+		""},
 	 { "SpatialReference_SetCoordinateEpoch", _wrap_SpatialReference_SetCoordinateEpoch, METH_VARARGS, "SpatialReference_SetCoordinateEpoch(SpatialReference self, double coordinateEpoch)"},
 	 { "SpatialReference_EPSGTreatsAsLatLong", _wrap_SpatialReference_EPSGTreatsAsLatLong, METH_O, "SpatialReference_EPSGTreatsAsLatLong(SpatialReference self) -> int"},
 	 { "SpatialReference_EPSGTreatsAsNorthingEasting", _wrap_SpatialReference_EPSGTreatsAsNorthingEasting, METH_O, "SpatialReference_EPSGTreatsAsNorthingEasting(SpatialReference self) -> int"},
 	 { "SpatialReference_SetAuthority", _wrap_SpatialReference_SetAuthority, METH_VARARGS, "SpatialReference_SetAuthority(SpatialReference self, char const * pszTargetKey, char const * pszAuthority, int nCode) -> OGRErr"},
-	 { "SpatialReference_GetAttrValue", _wrap_SpatialReference_GetAttrValue, METH_VARARGS, "SpatialReference_GetAttrValue(SpatialReference self, char const * name, int child=0) -> char const *"},
+	 { "SpatialReference_GetAttrValue", _wrap_SpatialReference_GetAttrValue, METH_VARARGS, "\n"
+		"SpatialReference_GetAttrValue(SpatialReference self, char const * name, int child=0) -> char const *\n"
+		"\n"
+		"\n"
+		"Fetch indicated attribute of named node.\n"
+		"\n"
+		"See :cpp:func:`OGRSpatialReference::GetAttrValue`.\n"
+		"\n"
+		"Parameters\n"
+		"----------\n"
+		"name : str\n"
+		"    tree node to look for (case insensitive)\n"
+		"child : int, default = 0\n"
+		"    0-indexed child of the node\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"str\n"
+		"\n"
+		"Examples\n"
+		"--------\n"
+		">>> vt_sp = osr.SpatialReference()\n"
+		">>> vt_sp.ImportFromEPSG(5646)\n"
+		"0\n"
+		">>> vt_sp.GetAttrValue('UNIT', 0)\n"
+		"'US survey foot'\n"
+		"\n"
+		"\n"
+		""},
 	 { "SpatialReference_SetAttrValue", _wrap_SpatialReference_SetAttrValue, METH_VARARGS, "SpatialReference_SetAttrValue(SpatialReference self, char const * name, char const * value) -> OGRErr"},
 	 { "SpatialReference_SetAngularUnits", _wrap_SpatialReference_SetAngularUnits, METH_VARARGS, "SpatialReference_SetAngularUnits(SpatialReference self, char const * name, double to_radians) -> OGRErr"},
-	 { "SpatialReference_GetAngularUnits", _wrap_SpatialReference_GetAngularUnits, METH_O, "SpatialReference_GetAngularUnits(SpatialReference self) -> double"},
-	 { "SpatialReference_GetAngularUnitsName", _wrap_SpatialReference_GetAngularUnitsName, METH_O, "SpatialReference_GetAngularUnitsName(SpatialReference self) -> char const *"},
+	 { "SpatialReference_GetAngularUnits", _wrap_SpatialReference_GetAngularUnits, METH_O, "\n"
+		"SpatialReference_GetAngularUnits(SpatialReference self) -> double\n"
+		"\n"
+		"\n"
+		"Fetch conversion between angular geographic coordinate system units and radians.\n"
+		"\n"
+		"See :cpp:func:`OGRSpatialReference::GetAngularUnits`.\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"float\n"
+		"    Value to multiply angular distances by to transform them to radians.\n"
+		"\n"
+		"Examples\n"
+		"--------\n"
+		">>> srs = osr.SpatialReference()\n"
+		">>> srs.ImportFromEPSG(4326)\n"
+		"0\n"
+		">>> srs.GetAngularUnits()\n"
+		"0.017453292519943295\n"
+		"\n"
+		"\n"
+		""},
+	 { "SpatialReference_GetAngularUnitsName", _wrap_SpatialReference_GetAngularUnitsName, METH_O, "\n"
+		"SpatialReference_GetAngularUnitsName(SpatialReference self) -> char const *\n"
+		"\n"
+		"\n"
+		"Fetch angular geographic coordinate system units.\n"
+		"\n"
+		"See :cpp:func:`OGRSpatialReference::GetAngularUnits`.\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"str\n"
+		"\n"
+		"Examples\n"
+		"--------\n"
+		">>> srs = osr.SpatialReference()\n"
+		">>> srs.ImportFromEPSG(4326)\n"
+		"0\n"
+		">>> srs.GetAngularUnitsName()\n"
+		"'degree'\n"
+		"\n"
+		"\n"
+		""},
 	 { "SpatialReference_SetTargetLinearUnits", _wrap_SpatialReference_SetTargetLinearUnits, METH_VARARGS, "SpatialReference_SetTargetLinearUnits(SpatialReference self, char const * target, char const * name, double to_meters) -> OGRErr"},
 	 { "SpatialReference_SetLinearUnits", _wrap_SpatialReference_SetLinearUnits, METH_VARARGS, "SpatialReference_SetLinearUnits(SpatialReference self, char const * name, double to_meters) -> OGRErr"},
 	 { "SpatialReference_SetLinearUnitsAndUpdateParameters", _wrap_SpatialReference_SetLinearUnitsAndUpdateParameters, METH_VARARGS, "SpatialReference_SetLinearUnitsAndUpdateParameters(SpatialReference self, char const * name, double to_meters) -> OGRErr"},
-	 { "SpatialReference_GetTargetLinearUnits", _wrap_SpatialReference_GetTargetLinearUnits, METH_VARARGS, "SpatialReference_GetTargetLinearUnits(SpatialReference self, char const * target_key) -> double"},
-	 { "SpatialReference_GetLinearUnits", _wrap_SpatialReference_GetLinearUnits, METH_O, "SpatialReference_GetLinearUnits(SpatialReference self) -> double"},
-	 { "SpatialReference_GetLinearUnitsName", _wrap_SpatialReference_GetLinearUnitsName, METH_O, "SpatialReference_GetLinearUnitsName(SpatialReference self) -> char const *"},
-	 { "SpatialReference_GetAuthorityCode", _wrap_SpatialReference_GetAuthorityCode, METH_VARARGS, "SpatialReference_GetAuthorityCode(SpatialReference self, char const * target_key) -> char const *"},
-	 { "SpatialReference_GetAuthorityName", _wrap_SpatialReference_GetAuthorityName, METH_VARARGS, "SpatialReference_GetAuthorityName(SpatialReference self, char const * target_key) -> char const *"},
-	 { "SpatialReference_GetAreaOfUse", _wrap_SpatialReference_GetAreaOfUse, METH_O, "SpatialReference_GetAreaOfUse(SpatialReference self) -> AreaOfUse"},
-	 { "SpatialReference_GetAxisName", _wrap_SpatialReference_GetAxisName, METH_VARARGS, "SpatialReference_GetAxisName(SpatialReference self, char const * target_key, int iAxis) -> char const *"},
-	 { "SpatialReference_GetAxesCount", _wrap_SpatialReference_GetAxesCount, METH_O, "SpatialReference_GetAxesCount(SpatialReference self) -> int"},
-	 { "SpatialReference_GetAxisOrientation", _wrap_SpatialReference_GetAxisOrientation, METH_VARARGS, "SpatialReference_GetAxisOrientation(SpatialReference self, char const * target_key, int iAxis) -> OGRAxisOrientation"},
-	 { "SpatialReference_GetAxisMappingStrategy", _wrap_SpatialReference_GetAxisMappingStrategy, METH_O, "SpatialReference_GetAxisMappingStrategy(SpatialReference self) -> OSRAxisMappingStrategy"},
+	 { "SpatialReference_GetTargetLinearUnits", _wrap_SpatialReference_GetTargetLinearUnits, METH_VARARGS, "\n"
+		"SpatialReference_GetTargetLinearUnits(SpatialReference self, char const * target_key) -> double\n"
+		"\n"
+		"\n"
+		"Fetch linear units for a target.\n"
+		"\n"
+		"See :cpp:func:`OGRSpatialReference::GetTargetLinearUnits`.\n"
+		"\n"
+		"Parameters\n"
+		"----------\n"
+		"target_key : str\n"
+		"    key to look un, such as 'PROJCS' or 'VERT_CS'\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"double\n"
+		"\n"
+		"\n"
+		""},
+	 { "SpatialReference_GetLinearUnits", _wrap_SpatialReference_GetLinearUnits, METH_O, "\n"
+		"SpatialReference_GetLinearUnits(SpatialReference self) -> double\n"
+		"\n"
+		"\n"
+		"Fetch the conversion between linear projection units and meters.\n"
+		"\n"
+		"See :cpp:func:`OGRSpatialReference::GetLinearUnits`.\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"float\n"
+		"\n"
+		"Examples\n"
+		"--------\n"
+		">>> vt_sp = osr.SpatialReference()\n"
+		">>> vt_sp.ImportFromEPSG(5646)\n"
+		"0\n"
+		">>> vt_sp.GetLinearUnits()\n"
+		"0.30480060960121924\n"
+		"\n"
+		"\n"
+		""},
+	 { "SpatialReference_GetLinearUnitsName", _wrap_SpatialReference_GetLinearUnitsName, METH_O, "\n"
+		"SpatialReference_GetLinearUnitsName(SpatialReference self) -> char const *\n"
+		"\n"
+		"\n"
+		"Fetch the name of the linear projection units.\n"
+		"\n"
+		"See :cpp:func:`OGRSpatialReference::GetLinearUnits`.\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"str\n"
+		"\n"
+		"Examples\n"
+		"--------\n"
+		">>> vt_sp = osr.SpatialReference()\n"
+		">>> vt_sp.ImportFromEPSG(5646)\n"
+		"0\n"
+		">>> vt_sp.GetLinearUnitsName()\n"
+		"'US survey foot'\n"
+		"\n"
+		"\n"
+		""},
+	 { "SpatialReference_GetAuthorityCode", _wrap_SpatialReference_GetAuthorityCode, METH_VARARGS, "\n"
+		"SpatialReference_GetAuthorityCode(SpatialReference self, char const * target_key) -> char const *\n"
+		"\n"
+		"\n"
+		"Get the authority code for a node.\n"
+		"\n"
+		"See :cpp:func:`OGRSpatialReference::GetAuthorityCode`.\n"
+		"\n"
+		"Parameters\n"
+		"----------\n"
+		"target_key : str\n"
+		"    the partial or complete path to the node to get an authority from\n"
+		"    (e.g., 'PROJCS', 'GEOGCS' or ``None`` to get an authority code\n"
+		"    on the root element)\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"str or ``None`` on failure\n"
+		"\n"
+		"Examples\n"
+		"--------\n"
+		">>> srs = osr.SpatialReference()\n"
+		">>> srs.ImportFromEPSG(4326)\n"
+		"0\n"
+		">>> srs.GetAuthorityName('DATUM')\n"
+		"'EPSG'\n"
+		">>> srs.GetAuthorityCode('DATUM')\n"
+		"'6326'\n"
+		">>> srs.GetAuthorityCode(None)\n"
+		"'4326'\n"
+		"\n"
+		"\n"
+		""},
+	 { "SpatialReference_GetAuthorityName", _wrap_SpatialReference_GetAuthorityName, METH_VARARGS, "\n"
+		"SpatialReference_GetAuthorityName(SpatialReference self, char const * target_key) -> char const *\n"
+		"\n"
+		"\n"
+		"Get the authority name for a node.\n"
+		"\n"
+		"See :cpp:func:`OGRSpatialReference::GetAuthorityName`.\n"
+		"\n"
+		"Parameters\n"
+		"----------\n"
+		"target_key : str\n"
+		"    the partial or complete path to the node to get an authority from\n"
+		"    (e.g., 'PROJCS', 'GEOGCS' or ``None`` to get an authority name\n"
+		"    on the root element)\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"str\n"
+		"\n"
+		""},
+	 { "SpatialReference_GetAreaOfUse", _wrap_SpatialReference_GetAreaOfUse, METH_O, "\n"
+		"SpatialReference_GetAreaOfUse(SpatialReference self) -> AreaOfUse\n"
+		"\n"
+		"\n"
+		"Return the area of use of the SRS.\n"
+		"\n"
+		"See :cpp:func:`OGRSpatialReference::GetAreaOfUse`.\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"AreaOfUse\n"
+		"    object providing a description of the area of use as well as bounding parallels / meridians\n"
+		"\n"
+		"Examples\n"
+		"--------\n"
+		"\n"
+		">>> vt_sp = osr.SpatialReference()\n"
+		">>> vt_sp.ImportFromEPSG(5646)\n"
+		"0\n"
+		">>> aou = vt_sp.GetAreaOfUse()\n"
+		">>> aou.name\n"
+		"'United States (USA) - Vermont - counties of Addison; Bennington; Caledonia; Chittenden; Essex; Franklin; Grand Isle; Lamoille; Orange; Orleans; Rutland; Washington; Windham; Windsor.'\n"
+		">>> aou.west_lon_degree, aou.south_lat_degree, aou.east_lon_degree, aou.north_lat_degree\n"
+		"(-73.44, 42.72, -71.5, 45.03)\n"
+		"\n"
+		"\n"
+		""},
+	 { "SpatialReference_GetAxisName", _wrap_SpatialReference_GetAxisName, METH_VARARGS, "\n"
+		"SpatialReference_GetAxisName(SpatialReference self, char const * target_key, int iAxis) -> char const *\n"
+		"\n"
+		"\n"
+		"Fetch an axis description.\n"
+		"\n"
+		"See :cpp:func:`OGRSpatialReference::GetAxis`.\n"
+		"\n"
+		"Parameters\n"
+		"----------\n"
+		"target_key : str\n"
+		"    The portion of the coordinate system, either 'GEOGCS' or 'PROJCS'\n"
+		"iAxis : int\n"
+		"    The 0-based index of the axis to fetch\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"str\n"
+		"\n"
+		"Examples\n"
+		"--------\n"
+		">>> srs = osr.SpatialReference()\n"
+		">>> srs.ImportFromEPSG(4979)\n"
+		"0\n"
+		">>> for i in range(3):\n"
+		"...     srs.GetAxisName('GEOGCS', i)\n"
+		"...\n"
+		"'Geodetic latitude'\n"
+		"'Geodetic longitude'\n"
+		"'Ellipsoidal height'\n"
+		"\n"
+		"\n"
+		""},
+	 { "SpatialReference_GetAxesCount", _wrap_SpatialReference_GetAxesCount, METH_O, "\n"
+		"SpatialReference_GetAxesCount(SpatialReference self) -> int\n"
+		"\n"
+		"\n"
+		"Return the number of axes of the coordinate system of the CRS.\n"
+		"\n"
+		"See :cpp:func:`OGRSpatialReference::GetAxesCount`.\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"int\n"
+		"\n"
+		"Examples\n"
+		"--------\n"
+		">>> srs = osr.SpatialReference()\n"
+		">>> srs.ImportFromEPSG(4326)\n"
+		"0\n"
+		">>> srs.GetAxesCount()\n"
+		"2\n"
+		">>> srs.ImportFromEPSG(4979)\n"
+		"0\n"
+		">>> srs.GetAxesCount()\n"
+		"3\n"
+		"\n"
+		""},
+	 { "SpatialReference_GetAxisOrientation", _wrap_SpatialReference_GetAxisOrientation, METH_VARARGS, "\n"
+		"SpatialReference_GetAxisOrientation(SpatialReference self, char const * target_key, int iAxis) -> OGRAxisOrientation\n"
+		"\n"
+		"\n"
+		"Fetch an axis orientation.\n"
+		"\n"
+		"See :cpp:func:`OGRSpatialReference::GetAxis`.\n"
+		"\n"
+		"Parameters\n"
+		"----------\n"
+		"target_key : str\n"
+		"    The portion of the coordinate system, either 'GEOGCS' or 'PROJCS'\n"
+		"iAxis : int\n"
+		"    The 0-based index of the axis to fetch\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"int\n"
+		"\n"
+		"Examples\n"
+		"--------\n"
+		">>> srs = osr.SpatialReference()\n"
+		">>> srs.ImportFromEPSG(4979)\n"
+		"0\n"
+		">>> srs.GetAxisOrientation('GEOGCS', 0) == osr.OAO_North\n"
+		"True\n"
+		">>> srs.GetAxisOrientation('GEOGCS', 1) == osr.OAO_East\n"
+		"True\n"
+		">>> srs.GetAxisOrientation('GEOGCS', 2) == osr.OAO_Up\n"
+		"True\n"
+		"\n"
+		""},
+	 { "SpatialReference_GetAxisMappingStrategy", _wrap_SpatialReference_GetAxisMappingStrategy, METH_O, "\n"
+		"SpatialReference_GetAxisMappingStrategy(SpatialReference self) -> OSRAxisMappingStrategy\n"
+		"\n"
+		"\n"
+		"Return the data axis to CRS axis mapping strategy:\n"
+		"\n"
+		"- :py:const:`OAMS_TRADITIONAL_GIS_ORDER` means that for geographic CRS\n"
+		"  with lag/long order, the data will still be long/lat ordered. Similarly\n"
+		"  for a projected CRS with northing/easting order, the data will still be\n"
+		"  easting/northing ordered.\n"
+		"- :py:const:`OAMS_AUTHORITY_COMPLIANT` means that the data axis will be\n"
+		"  identical to the CRS axis.\n"
+		"- :py:const:`OAMS_CUSTOM` means that the ordering is defined with\n"
+		"  :py:meth:`SetDataAxisToSRSAxisMapping`.\n"
+		"\n"
+		"See :cpp:func:`OGRSpatialReference::GetAxisMappingStrategy`.\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"int\n"
+		"\n"
+		"\n"
+		""},
 	 { "SpatialReference_SetAxisMappingStrategy", _wrap_SpatialReference_SetAxisMappingStrategy, METH_VARARGS, "SpatialReference_SetAxisMappingStrategy(SpatialReference self, OSRAxisMappingStrategy strategy)"},
-	 { "SpatialReference_GetDataAxisToSRSAxisMapping", _wrap_SpatialReference_GetDataAxisToSRSAxisMapping, METH_O, "SpatialReference_GetDataAxisToSRSAxisMapping(SpatialReference self)"},
+	 { "SpatialReference_GetDataAxisToSRSAxisMapping", _wrap_SpatialReference_GetDataAxisToSRSAxisMapping, METH_O, "\n"
+		"SpatialReference_GetDataAxisToSRSAxisMapping(SpatialReference self)\n"
+		"\n"
+		"\n"
+		"Return the data axis to SRS axis mapping.\n"
+		"\n"
+		"See :cpp:func:`OGRSpatialReference::GetDataAxisToSRSAxisMapping`.\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"tuple\n"
+		"\n"
+		"\n"
+		""},
 	 { "SpatialReference_SetDataAxisToSRSAxisMapping", _wrap_SpatialReference_SetDataAxisToSRSAxisMapping, METH_VARARGS, "SpatialReference_SetDataAxisToSRSAxisMapping(SpatialReference self, int nList) -> OGRErr"},
 	 { "SpatialReference_SetUTM", _wrap_SpatialReference_SetUTM, METH_VARARGS, "SpatialReference_SetUTM(SpatialReference self, int zone, int north=1) -> OGRErr"},
-	 { "SpatialReference_GetUTMZone", _wrap_SpatialReference_GetUTMZone, METH_O, "SpatialReference_GetUTMZone(SpatialReference self) -> int"},
+	 { "SpatialReference_GetUTMZone", _wrap_SpatialReference_GetUTMZone, METH_O, "\n"
+		"SpatialReference_GetUTMZone(SpatialReference self) -> int\n"
+		"\n"
+		"\n"
+		"Get UTM zone.\n"
+		"\n"
+		"See :cpp:func:`OGRSpatialReference::GetUTMZone`.\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"int\n"
+		"    UTM zone number. Negative in the southern hemisphere and positive in the northern hemisphere. If the SRS is not UTM, zero will be returned.\n"
+		"\n"
+		"\n"
+		""},
 	 { "SpatialReference_SetStatePlane", _wrap_SpatialReference_SetStatePlane, METH_VARARGS, "SpatialReference_SetStatePlane(SpatialReference self, int zone, int is_nad83=1, char const * unitsname=\"\", double units=0.0) -> OGRErr"},
-	 { "SpatialReference_AutoIdentifyEPSG", _wrap_SpatialReference_AutoIdentifyEPSG, METH_O, "SpatialReference_AutoIdentifyEPSG(SpatialReference self) -> OGRErr"},
+	 { "SpatialReference_AutoIdentifyEPSG", _wrap_SpatialReference_AutoIdentifyEPSG, METH_O, "\n"
+		"SpatialReference_AutoIdentifyEPSG(SpatialReference self) -> OGRErr\n"
+		"\n"
+		"\n"
+		"Add an EPSG authority code to the CRS\n"
+		"where an aspect of the coordinate system can be easily and safely\n"
+		"corresponded with an EPSG identifier.\n"
+		"\n"
+		"See :cpp:func:`OGRSpatialReference::AutoIdentifyEPSG`.\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"int\n"
+		"    :py:const:`OGRERR_NONE` or :py:const:`OGRERR_UNSUPPORTED_SRS`.\n"
+		"\n"
+		"\n"
+		""},
 	 { "SpatialReference_FindMatches", _wrap_SpatialReference_FindMatches, METH_VARARGS, "SpatialReference_FindMatches(SpatialReference self, char ** options=None)"},
 	 { "SpatialReference_SetProjection", _wrap_SpatialReference_SetProjection, METH_VARARGS, "SpatialReference_SetProjection(SpatialReference self, char const * arg) -> OGRErr"},
 	 { "SpatialReference_SetProjParm", _wrap_SpatialReference_SetProjParm, METH_VARARGS, "SpatialReference_SetProjParm(SpatialReference self, char const * name, double val) -> OGRErr"},
-	 { "SpatialReference_GetProjParm", _wrap_SpatialReference_GetProjParm, METH_VARARGS, "SpatialReference_GetProjParm(SpatialReference self, char const * name, double default_val=0.0) -> double"},
+	 { "SpatialReference_GetProjParm", _wrap_SpatialReference_GetProjParm, METH_VARARGS, "\n"
+		"SpatialReference_GetProjParm(SpatialReference self, char const * name, double default_val=0.0) -> double\n"
+		"\n"
+		"\n"
+		"Fetch a projection parameter value.\n"
+		"\n"
+		"See :cpp:func:`OGRSpatialReference::GetProjParm`.\n"
+		"\n"
+		"Parameters\n"
+		"----------\n"
+		"name : str\n"
+		"    parameter name, available as constants prefixed with `SRS_PP`.\n"
+		"default_val : float, default = 0.0\n"
+		"    value to return if this parameter doesn't exist\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"float\n"
+		"\n"
+		"Examples\n"
+		"--------\n"
+		">>> vt_sp = osr.SpatialReference()\n"
+		">>> vt_sp.ImportFromEPSG(5646)\n"
+		"0\n"
+		">>> vt_sp.GetProjParm(osr.SRS_PP_FALSE_EASTING)\n"
+		"1640416.6667\n"
+		">>> vt_sp.GetProjParm(osr.SRS_PP_FALSE_NORTHING)\n"
+		"0.0\n"
+		"\n"
+		"\n"
+		""},
 	 { "SpatialReference_SetNormProjParm", _wrap_SpatialReference_SetNormProjParm, METH_VARARGS, "SpatialReference_SetNormProjParm(SpatialReference self, char const * name, double val) -> OGRErr"},
-	 { "SpatialReference_GetNormProjParm", _wrap_SpatialReference_GetNormProjParm, METH_VARARGS, "SpatialReference_GetNormProjParm(SpatialReference self, char const * name, double default_val=0.0) -> double"},
-	 { "SpatialReference_GetSemiMajor", _wrap_SpatialReference_GetSemiMajor, METH_O, "SpatialReference_GetSemiMajor(SpatialReference self) -> double"},
-	 { "SpatialReference_GetSemiMinor", _wrap_SpatialReference_GetSemiMinor, METH_O, "SpatialReference_GetSemiMinor(SpatialReference self) -> double"},
-	 { "SpatialReference_GetInvFlattening", _wrap_SpatialReference_GetInvFlattening, METH_O, "SpatialReference_GetInvFlattening(SpatialReference self) -> double"},
+	 { "SpatialReference_GetNormProjParm", _wrap_SpatialReference_GetNormProjParm, METH_VARARGS, "\n"
+		"SpatialReference_GetNormProjParm(SpatialReference self, char const * name, double default_val=0.0) -> double\n"
+		"\n"
+		"\n"
+		"Fetch a normalized projection parameter value.\n"
+		"\n"
+		"This method is the same as :py:meth:`GetProjParm` except that the value of the\n"
+		"parameter is normalized into degrees or meters depending on whether it is\n"
+		"linear or angular.\n"
+		"\n"
+		"See :cpp:func:`OGRSpatialReference::GetNormProjParm`.\n"
+		"\n"
+		"Parameters\n"
+		"----------\n"
+		"name : str\n"
+		"    parameter name, available as constants prefixed with `SRS_PP`.\n"
+		"default_val : float, default = 0.0\n"
+		"    value to return if this parameter doesn't exist\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"float\n"
+		"\n"
+		"Examples\n"
+		"--------\n"
+		">>> vt_sp = osr.SpatialReference()\n"
+		">>> vt_sp.ImportFromEPSG(5646)\n"
+		"0\n"
+		">>> vt_sp.GetProjParm(osr.SRS_PP_FALSE_EASTING)\n"
+		"1640416.6667\n"
+		">>> vt_sp.GetNormProjParm(osr.SRS_PP_FALSE_EASTING)\n"
+		"500000.0000101601\n"
+		"\n"
+		"\n"
+		""},
+	 { "SpatialReference_GetSemiMajor", _wrap_SpatialReference_GetSemiMajor, METH_O, "\n"
+		"SpatialReference_GetSemiMajor(SpatialReference self) -> double\n"
+		"\n"
+		"\n"
+		"Get spheroid semi major axis (in meters starting with GDAL 3.0)\n"
+		"\n"
+		"See :cpp:func:`OGRSpatialReference::GetSemiMajor`.\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"float\n"
+		"    semi-major axis, or :py:const:`SRS_WGS84_SEMIMAJOR` if it cannot be found.\n"
+		"\n"
+		""},
+	 { "SpatialReference_GetSemiMinor", _wrap_SpatialReference_GetSemiMinor, METH_O, "\n"
+		"SpatialReference_GetSemiMinor(SpatialReference self) -> double\n"
+		"\n"
+		"\n"
+		"Get spheroid semi minor axis.\n"
+		"\n"
+		"See :cpp:func:`OGRSpatialReference::GetSemiMinor`.\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"float\n"
+		"    semi-minor axis, or :py:const:`SRS_WGS84_SEMIMINOR` if it cannot be found.\n"
+		"\n"
+		""},
+	 { "SpatialReference_GetInvFlattening", _wrap_SpatialReference_GetInvFlattening, METH_O, "\n"
+		"SpatialReference_GetInvFlattening(SpatialReference self) -> double\n"
+		"\n"
+		"\n"
+		"Get the spheroid inverse flattening.\n"
+		"\n"
+		"See :cpp:func:`OGRSpatialReference::GetInvFlattening`.\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"float\n"
+		"\n"
+		"Examples\n"
+		"--------\n"
+		">>> srs = osr.SpatialReference()\n"
+		">>> srs.ImportFromEPSG(4326) # WGS84\n"
+		"0\n"
+		">>> srs.GetInvFlattening()\n"
+		"298.257223563\n"
+		">>> srs.ImportFromEPSG(4269) # NAD83\n"
+		"0\n"
+		">>> srs.GetInvFlattening()\n"
+		"298.257222101\n"
+		"\n"
+		""},
 	 { "SpatialReference_SetACEA", (PyCFunction)(void(*)(void))_wrap_SpatialReference_SetACEA, METH_VARARGS|METH_KEYWORDS, "SpatialReference_SetACEA(SpatialReference self, double stdp1, double stdp2, double clat, double clong, double fe, double fn) -> OGRErr"},
 	 { "SpatialReference_SetAE", (PyCFunction)(void(*)(void))_wrap_SpatialReference_SetAE, METH_VARARGS|METH_KEYWORDS, "SpatialReference_SetAE(SpatialReference self, double clat, double clong, double fe, double fn) -> OGRErr"},
 	 { "SpatialReference_SetBonne", (PyCFunction)(void(*)(void))_wrap_SpatialReference_SetBonne, METH_VARARGS|METH_KEYWORDS, "SpatialReference_SetBonne(SpatialReference self, double stdp, double cm, double fe, double fn) -> OGRErr"},
 	 { "SpatialReference_SetCEA", (PyCFunction)(void(*)(void))_wrap_SpatialReference_SetCEA, METH_VARARGS|METH_KEYWORDS, "SpatialReference_SetCEA(SpatialReference self, double stdp1, double cm, double fe, double fn) -> OGRErr"},
 	 { "SpatialReference_SetCS", (PyCFunction)(void(*)(void))_wrap_SpatialReference_SetCS, METH_VARARGS|METH_KEYWORDS, "SpatialReference_SetCS(SpatialReference self, double clat, double clong, double fe, double fn) -> OGRErr"},
 	 { "SpatialReference_SetEC", (PyCFunction)(void(*)(void))_wrap_SpatialReference_SetEC, METH_VARARGS|METH_KEYWORDS, "SpatialReference_SetEC(SpatialReference self, double stdp1, double stdp2, double clat, double clong, double fe, double fn) -> OGRErr"},
 	 { "SpatialReference_SetEckertIV", (PyCFunction)(void(*)(void))_wrap_SpatialReference_SetEckertIV, METH_VARARGS|METH_KEYWORDS, "SpatialReference_SetEckertIV(SpatialReference self, double cm, double fe, double fn) -> OGRErr"},
@@ -19891,47 +20987,256 @@
 	 { "SpatialReference_SetTM", (PyCFunction)(void(*)(void))_wrap_SpatialReference_SetTM, METH_VARARGS|METH_KEYWORDS, "SpatialReference_SetTM(SpatialReference self, double clat, double clong, double scale, double fe, double fn) -> OGRErr"},
 	 { "SpatialReference_SetTMVariant", (PyCFunction)(void(*)(void))_wrap_SpatialReference_SetTMVariant, METH_VARARGS|METH_KEYWORDS, "SpatialReference_SetTMVariant(SpatialReference self, char const * pszVariantName, double clat, double clong, double scale, double fe, double fn) -> OGRErr"},
 	 { "SpatialReference_SetTMG", (PyCFunction)(void(*)(void))_wrap_SpatialReference_SetTMG, METH_VARARGS|METH_KEYWORDS, "SpatialReference_SetTMG(SpatialReference self, double clat, double clong, double fe, double fn) -> OGRErr"},
 	 { "SpatialReference_SetTMSO", (PyCFunction)(void(*)(void))_wrap_SpatialReference_SetTMSO, METH_VARARGS|METH_KEYWORDS, "SpatialReference_SetTMSO(SpatialReference self, double clat, double clong, double scale, double fe, double fn) -> OGRErr"},
 	 { "SpatialReference_SetVDG", (PyCFunction)(void(*)(void))_wrap_SpatialReference_SetVDG, METH_VARARGS|METH_KEYWORDS, "SpatialReference_SetVDG(SpatialReference self, double clong, double fe, double fn) -> OGRErr"},
 	 { "SpatialReference_SetVerticalPerspective", (PyCFunction)(void(*)(void))_wrap_SpatialReference_SetVerticalPerspective, METH_VARARGS|METH_KEYWORDS, "SpatialReference_SetVerticalPerspective(SpatialReference self, double topoOriginLat, double topoOriginLon, double topoOriginHeight, double viewPointHeight, double fe, double fn) -> OGRErr"},
 	 { "SpatialReference_SetWellKnownGeogCS", _wrap_SpatialReference_SetWellKnownGeogCS, METH_VARARGS, "SpatialReference_SetWellKnownGeogCS(SpatialReference self, char const * name) -> OGRErr"},
-	 { "SpatialReference_SetFromUserInput", _wrap_SpatialReference_SetFromUserInput, METH_VARARGS, "SpatialReference_SetFromUserInput(SpatialReference self, char const * name) -> OGRErr"},
+	 { "SpatialReference_SetFromUserInput", (PyCFunction)(void(*)(void))_wrap_SpatialReference_SetFromUserInput, METH_VARARGS|METH_KEYWORDS, "SpatialReference_SetFromUserInput(SpatialReference self, char const * name, char ** options=None) -> OGRErr"},
 	 { "SpatialReference_CopyGeogCSFrom", _wrap_SpatialReference_CopyGeogCSFrom, METH_VARARGS, "SpatialReference_CopyGeogCSFrom(SpatialReference self, SpatialReference rhs) -> OGRErr"},
 	 { "SpatialReference_SetTOWGS84", _wrap_SpatialReference_SetTOWGS84, METH_VARARGS, "SpatialReference_SetTOWGS84(SpatialReference self, double p1, double p2, double p3, double p4=0.0, double p5=0.0, double p6=0.0, double p7=0.0) -> OGRErr"},
-	 { "SpatialReference_HasTOWGS84", _wrap_SpatialReference_HasTOWGS84, METH_O, "SpatialReference_HasTOWGS84(SpatialReference self) -> bool"},
-	 { "SpatialReference_GetTOWGS84", _wrap_SpatialReference_GetTOWGS84, METH_O, "SpatialReference_GetTOWGS84(SpatialReference self) -> OGRErr"},
+	 { "SpatialReference_HasTOWGS84", _wrap_SpatialReference_HasTOWGS84, METH_O, "\n"
+		"SpatialReference_HasTOWGS84(SpatialReference self) -> bool\n"
+		"\n"
+		"\n"
+		"Return whether the SRS has a TOWGS84 parameter.\n"
+		"\n"
+		"See :cpp:func:`OGRSpatialReference::GetTOWGS84`.\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"bool\n"
+		"\n"
+		"\n"
+		""},
+	 { "SpatialReference_GetTOWGS84", _wrap_SpatialReference_GetTOWGS84, METH_O, "\n"
+		"SpatialReference_GetTOWGS84(SpatialReference self) -> OGRErr\n"
+		"\n"
+		"\n"
+		"Fetch TOWGS84 parameter, if available.\n"
+		"\n"
+		"See :cpp:func:`OGRSpatialReference::GetTOWGS84`.\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"tuple\n"
+		"\n"
+		"\n"
+		""},
 	 { "SpatialReference_AddGuessedTOWGS84", _wrap_SpatialReference_AddGuessedTOWGS84, METH_O, "SpatialReference_AddGuessedTOWGS84(SpatialReference self) -> OGRErr"},
 	 { "SpatialReference_SetLocalCS", _wrap_SpatialReference_SetLocalCS, METH_VARARGS, "SpatialReference_SetLocalCS(SpatialReference self, char const * pszName) -> OGRErr"},
 	 { "SpatialReference_SetGeogCS", _wrap_SpatialReference_SetGeogCS, METH_VARARGS, "SpatialReference_SetGeogCS(SpatialReference self, char const * pszGeogName, char const * pszDatumName, char const * pszEllipsoidName, double dfSemiMajor, double dfInvFlattening, char const * pszPMName=\"Greenwich\", double dfPMOffset=0.0, char const * pszUnits=\"degree\", double dfConvertToRadians=0.0174532925199433) -> OGRErr"},
 	 { "SpatialReference_SetProjCS", _wrap_SpatialReference_SetProjCS, METH_VARARGS, "SpatialReference_SetProjCS(SpatialReference self, char const * name=\"unnamed\") -> OGRErr"},
 	 { "SpatialReference_SetGeocCS", _wrap_SpatialReference_SetGeocCS, METH_VARARGS, "SpatialReference_SetGeocCS(SpatialReference self, char const * name=\"unnamed\") -> OGRErr"},
 	 { "SpatialReference_SetVertCS", _wrap_SpatialReference_SetVertCS, METH_VARARGS, "SpatialReference_SetVertCS(SpatialReference self, char const * VertCSName=\"unnamed\", char const * VertDatumName=\"unnamed\", int VertDatumType=0) -> OGRErr"},
 	 { "SpatialReference_SetCompoundCS", _wrap_SpatialReference_SetCompoundCS, METH_VARARGS, "SpatialReference_SetCompoundCS(SpatialReference self, char const * name, SpatialReference horizcs, SpatialReference vertcs) -> OGRErr"},
-	 { "SpatialReference_ImportFromWkt", _wrap_SpatialReference_ImportFromWkt, METH_VARARGS, "SpatialReference_ImportFromWkt(SpatialReference self, char ** ppszInput) -> OGRErr"},
-	 { "SpatialReference_ImportFromProj4", _wrap_SpatialReference_ImportFromProj4, METH_VARARGS, "SpatialReference_ImportFromProj4(SpatialReference self, char * ppszInput) -> OGRErr"},
-	 { "SpatialReference_ImportFromUrl", _wrap_SpatialReference_ImportFromUrl, METH_VARARGS, "SpatialReference_ImportFromUrl(SpatialReference self, char * url) -> OGRErr"},
+	 { "SpatialReference_ImportFromWkt", _wrap_SpatialReference_ImportFromWkt, METH_VARARGS, "\n"
+		"SpatialReference_ImportFromWkt(SpatialReference self, char ** ppszInput) -> OGRErr\n"
+		"\n"
+		"\n"
+		"Import from WKT string.\n"
+		"\n"
+		"See :cpp:func:`OGRSpatialReference::importFromWkt`.\n"
+		"\n"
+		"Parameters\n"
+		"----------\n"
+		"ppszInput : str\n"
+		"    WKT string\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"int\n"
+		"    :py:const:`OGRERR_NONE` if import succeeds, or :py:const:`OGRERR_CORRUPT_DATA` if it fails for any reason.\n"
+		"\n"
+		"\n"
+		""},
+	 { "SpatialReference_ImportFromProj4", _wrap_SpatialReference_ImportFromProj4, METH_VARARGS, "\n"
+		"SpatialReference_ImportFromProj4(SpatialReference self, char * ppszInput) -> OGRErr\n"
+		"\n"
+		"\n"
+		"Initialize SRS based on PROJ coordinate string.\n"
+		"\n"
+		"See :cpp:func:`OGRSpatialReference::importFromProj4`.\n"
+		"\n"
+		"Parameters\n"
+		"----------\n"
+		"ppszInput : str\n"
+		"    PROJ coordinate string\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"int\n"
+		"    :py:const:`OGRERR_NONE` on success, or :py:const:`OGRERR_CORRUPT_DATA` on failure\n"
+		"\n"
+		"Examples\n"
+		"--------\n"
+		">>> srs = osr.SpatialReference()\n"
+		">>> srs.ImportFromProj4('+proj=utm +zone=18 +datum=WGS84')\n"
+		"0\n"
+		"\n"
+		""},
+	 { "SpatialReference_ImportFromUrl", _wrap_SpatialReference_ImportFromUrl, METH_VARARGS, "\n"
+		"SpatialReference_ImportFromUrl(SpatialReference self, char * url) -> OGRErr\n"
+		"\n"
+		"\n"
+		"Initialize SRS based on a URL.\n"
+		"\n"
+		"This method will download the spatial reference at a given URL and\n"
+		"feed it into :py:meth:`SetFromUserInput` for you.\n"
+		"\n"
+		"See :cpp:func:`OGRSpatialReference::importFromUrl`.\n"
+		"\n"
+		"Parameters\n"
+		"----------\n"
+		"url : str\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"int\n"
+		"    :py:const:`OGRERR_NONE` on success, or an error code on failure\n"
+		"\n"
+		"\n"
+		""},
 	 { "SpatialReference_ImportFromESRI", _wrap_SpatialReference_ImportFromESRI, METH_VARARGS, "SpatialReference_ImportFromESRI(SpatialReference self, char ** ppszInput) -> OGRErr"},
-	 { "SpatialReference_ImportFromEPSG", _wrap_SpatialReference_ImportFromEPSG, METH_VARARGS, "SpatialReference_ImportFromEPSG(SpatialReference self, int arg) -> OGRErr"},
-	 { "SpatialReference_ImportFromEPSGA", _wrap_SpatialReference_ImportFromEPSGA, METH_VARARGS, "SpatialReference_ImportFromEPSGA(SpatialReference self, int arg) -> OGRErr"},
+	 { "SpatialReference_ImportFromEPSG", _wrap_SpatialReference_ImportFromEPSG, METH_VARARGS, "\n"
+		"SpatialReference_ImportFromEPSG(SpatialReference self, int arg) -> OGRErr\n"
+		"\n"
+		"\n"
+		"Initialize SRS based on EPSG geographic, projected or vertical CRS code.\n"
+		"\n"
+		"Since GDAL 3.0, this method is identical to :py:meth:`ImportFromEPSGA`.\n"
+		"\n"
+		"See :cpp:func:`OGRSpatialReference::importFromEPSG`.\n"
+		"\n"
+		"Parameters\n"
+		"----------\n"
+		"arg : int\n"
+		"    EPSG code to search in PROJ database\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"int\n"
+		"    :py:const:`OGRERR_NONE` on success, or an error code on failure\n"
+		"\n"
+		"Examples\n"
+		"--------\n"
+		">>> srs = osr.SpatialReference()\n"
+		">>> srs.ImportFromEPSG(4326)\n"
+		"0\n"
+		"\n"
+		"\n"
+		""},
+	 { "SpatialReference_ImportFromEPSGA", _wrap_SpatialReference_ImportFromEPSGA, METH_VARARGS, "\n"
+		"SpatialReference_ImportFromEPSGA(SpatialReference self, int arg) -> OGRErr\n"
+		"\n"
+		"\n"
+		"Initialize SRS based on EPSG geographic, projected or vertical CRS code.\n"
+		"\n"
+		"Since GDAL 3.0, this method is identical to :py:meth:`ImportFromEPSG`.\n"
+		"\n"
+		"See :cpp:func:`OGRSpatialReference::importFromEPSGA`.\n"
+		"\n"
+		"Parameters\n"
+		"----------\n"
+		"arg : int\n"
+		"    EPSG code to search in PROJ database\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"int\n"
+		"    :py:const:`OGRERR_NONE` on success, or an error code on failure\n"
+		"\n"
+		"\n"
+		""},
 	 { "SpatialReference_ImportFromPCI", _wrap_SpatialReference_ImportFromPCI, METH_VARARGS, "SpatialReference_ImportFromPCI(SpatialReference self, char const * proj, char const * units=\"METRE\", double [17] argin=0) -> OGRErr"},
 	 { "SpatialReference_ImportFromUSGS", _wrap_SpatialReference_ImportFromUSGS, METH_VARARGS, "SpatialReference_ImportFromUSGS(SpatialReference self, long proj_code, long zone=0, double [15] argin=0, long datum_code=0) -> OGRErr"},
 	 { "SpatialReference_ImportFromXML", _wrap_SpatialReference_ImportFromXML, METH_VARARGS, "SpatialReference_ImportFromXML(SpatialReference self, char const * xmlString) -> OGRErr"},
 	 { "SpatialReference_ImportFromERM", _wrap_SpatialReference_ImportFromERM, METH_VARARGS, "SpatialReference_ImportFromERM(SpatialReference self, char const * proj, char const * datum, char const * units) -> OGRErr"},
 	 { "SpatialReference_ImportFromMICoordSys", _wrap_SpatialReference_ImportFromMICoordSys, METH_VARARGS, "SpatialReference_ImportFromMICoordSys(SpatialReference self, char const * pszCoordSys) -> OGRErr"},
 	 { "SpatialReference_ImportFromOzi", _wrap_SpatialReference_ImportFromOzi, METH_VARARGS, "SpatialReference_ImportFromOzi(SpatialReference self, char const *const * papszLines) -> OGRErr"},
-	 { "SpatialReference_ExportToWkt", _wrap_SpatialReference_ExportToWkt, METH_VARARGS, "SpatialReference_ExportToWkt(SpatialReference self, char ** options=None) -> OGRErr"},
-	 { "SpatialReference_ExportToPrettyWkt", _wrap_SpatialReference_ExportToPrettyWkt, METH_VARARGS, "SpatialReference_ExportToPrettyWkt(SpatialReference self, int simplify=0) -> OGRErr"},
-	 { "SpatialReference_ExportToPROJJSON", _wrap_SpatialReference_ExportToPROJJSON, METH_VARARGS, "SpatialReference_ExportToPROJJSON(SpatialReference self, char ** options=None) -> OGRErr"},
-	 { "SpatialReference_ExportToProj4", _wrap_SpatialReference_ExportToProj4, METH_O, "SpatialReference_ExportToProj4(SpatialReference self) -> OGRErr"},
+	 { "SpatialReference_ImportFromCF1", _wrap_SpatialReference_ImportFromCF1, METH_VARARGS, "SpatialReference_ImportFromCF1(SpatialReference self, char ** keyValues, char const * units=None) -> OGRErr"},
+	 { "SpatialReference_ExportToWkt", _wrap_SpatialReference_ExportToWkt, METH_VARARGS, "\n"
+		"SpatialReference_ExportToWkt(SpatialReference self, char ** options=None) -> OGRErr\n"
+		"\n"
+		"\n"
+		"Export  this SRS into WKT 1 format.\n"
+		"\n"
+		"See :cpp:func:`OGRSpatialReference::exportToWkt`.\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"str\n"
+		"\n"
+		"See Also\n"
+		"--------\n"
+		":py:meth:`ExportToPrettyWkt`\n"
+		"\n"
+		"\n"
+		""},
+	 { "SpatialReference_ExportToPrettyWkt", _wrap_SpatialReference_ExportToPrettyWkt, METH_VARARGS, "\n"
+		"SpatialReference_ExportToPrettyWkt(SpatialReference self, int simplify=0) -> OGRErr\n"
+		"\n"
+		"\n"
+		"Convert this SRS into a nicely formatted WKT 1 string for display to a\n"
+		"person.\n"
+		"\n"
+		"See :cpp:func:`OGRSpatialReference::exportToPrettyWkt`.\n"
+		"\n"
+		"Parameters\n"
+		"----------\n"
+		"simplify : bool, default = False\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"str\n"
+		"\n"
+		"\n"
+		""},
+	 { "SpatialReference_ExportToPROJJSON", _wrap_SpatialReference_ExportToPROJJSON, METH_VARARGS, "\n"
+		"SpatialReference_ExportToPROJJSON(SpatialReference self, char ** options=None) -> OGRErr\n"
+		"\n"
+		"\n"
+		"Export this SRS in `PROJJSON <https://proj.org/en/latest/specifications/projjson.html>`_ format.\n"
+		"\n"
+		"See :cpp:func:`OGRSpatialReference::exportToPROJJSON`.\n"
+		"\n"
+		"Parameters\n"
+		"----------\n"
+		"options : list/dict\n"
+		"    Options to control the format of the output. See :cpp:func:`OGRSpatialReference::ExportToPROJJSON`.\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"str\n"
+		"\n"
+		"\n"
+		""},
+	 { "SpatialReference_ExportToProj4", _wrap_SpatialReference_ExportToProj4, METH_O, "\n"
+		"SpatialReference_ExportToProj4(SpatialReference self) -> OGRErr\n"
+		"\n"
+		"\n"
+		"Export this SRS to PROJ.4 legacy format.\n"
+		"\n"
+		".. warning::\n"
+		"\n"
+		"   Use of this function is discouraged. See :cpp:func:`OGRSpatialReference::exportToProj4`.\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"str\n"
+		"\n"
+		"\n"
+		""},
 	 { "SpatialReference_ExportToPCI", _wrap_SpatialReference_ExportToPCI, METH_O, "SpatialReference_ExportToPCI(SpatialReference self) -> OGRErr"},
 	 { "SpatialReference_ExportToUSGS", _wrap_SpatialReference_ExportToUSGS, METH_O, "SpatialReference_ExportToUSGS(SpatialReference self) -> OGRErr"},
 	 { "SpatialReference_ExportToERM", _wrap_SpatialReference_ExportToERM, METH_O, "SpatialReference_ExportToERM(SpatialReference self) -> OGRErr"},
 	 { "SpatialReference_ExportToXML", _wrap_SpatialReference_ExportToXML, METH_VARARGS, "SpatialReference_ExportToXML(SpatialReference self, char const * dialect=\"\") -> OGRErr"},
 	 { "SpatialReference_ExportToMICoordSys", _wrap_SpatialReference_ExportToMICoordSys, METH_O, "SpatialReference_ExportToMICoordSys(SpatialReference self) -> OGRErr"},
+	 { "SpatialReference_ExportToCF1", _wrap_SpatialReference_ExportToCF1, METH_VARARGS, "SpatialReference_ExportToCF1(SpatialReference self, char ** options=None) -> char **"},
+	 { "SpatialReference_ExportToCF1Units", _wrap_SpatialReference_ExportToCF1Units, METH_VARARGS, "SpatialReference_ExportToCF1Units(SpatialReference self, char ** options=None) -> retStringAndCPLFree *"},
 	 { "SpatialReference_CloneGeogCS", _wrap_SpatialReference_CloneGeogCS, METH_O, "SpatialReference_CloneGeogCS(SpatialReference self) -> SpatialReference"},
 	 { "SpatialReference_Clone", _wrap_SpatialReference_Clone, METH_O, "SpatialReference_Clone(SpatialReference self) -> SpatialReference"},
 	 { "SpatialReference_StripVertical", _wrap_SpatialReference_StripVertical, METH_O, "SpatialReference_StripVertical(SpatialReference self) -> OGRErr"},
 	 { "SpatialReference_Validate", _wrap_SpatialReference_Validate, METH_O, "SpatialReference_Validate(SpatialReference self) -> OGRErr"},
 	 { "SpatialReference_MorphToESRI", _wrap_SpatialReference_MorphToESRI, METH_O, "SpatialReference_MorphToESRI(SpatialReference self) -> OGRErr"},
 	 { "SpatialReference_MorphFromESRI", _wrap_SpatialReference_MorphFromESRI, METH_O, "SpatialReference_MorphFromESRI(SpatialReference self) -> OGRErr"},
 	 { "SpatialReference_ConvertToOtherProjection", _wrap_SpatialReference_ConvertToOtherProjection, METH_VARARGS, "SpatialReference_ConvertToOtherProjection(SpatialReference self, char const * other_projection, char ** options=None) -> SpatialReference"},
@@ -19947,29 +21252,137 @@
 	 { "CoordinateTransformationOptions_SetBallparkAllowed", _wrap_CoordinateTransformationOptions_SetBallparkAllowed, METH_VARARGS, "CoordinateTransformationOptions_SetBallparkAllowed(CoordinateTransformationOptions self, bool allowBallpark) -> bool"},
 	 { "CoordinateTransformationOptions_SetOnlyBest", _wrap_CoordinateTransformationOptions_SetOnlyBest, METH_VARARGS, "CoordinateTransformationOptions_SetOnlyBest(CoordinateTransformationOptions self, bool onlyBest) -> bool"},
 	 { "CoordinateTransformationOptions_swigregister", CoordinateTransformationOptions_swigregister, METH_O, NULL},
 	 { "CoordinateTransformationOptions_swiginit", CoordinateTransformationOptions_swiginit, METH_VARARGS, NULL},
 	 { "new_CoordinateTransformation", _wrap_new_CoordinateTransformation, METH_VARARGS, "\n"
 		"CoordinateTransformation(SpatialReference src, SpatialReference dst)\n"
 		"new_CoordinateTransformation(SpatialReference src, SpatialReference dst, CoordinateTransformationOptions options) -> CoordinateTransformation\n"
+		"\n"
+		"Python proxy of an :cpp:class:`OGRCoordinateTransformation`.\n"
+		"\n"
 		""},
 	 { "delete_CoordinateTransformation", _wrap_delete_CoordinateTransformation, METH_O, "delete_CoordinateTransformation(CoordinateTransformation self)"},
 	 { "CoordinateTransformation_GetInverse", _wrap_CoordinateTransformation_GetInverse, METH_O, "CoordinateTransformation_GetInverse(CoordinateTransformation self) -> CoordinateTransformation"},
 	 { "CoordinateTransformation__TransformPoint3Double", _wrap_CoordinateTransformation__TransformPoint3Double, METH_VARARGS, "CoordinateTransformation__TransformPoint3Double(CoordinateTransformation self, double [3] inout)"},
 	 { "CoordinateTransformation__TransformPoint4Double", _wrap_CoordinateTransformation__TransformPoint4Double, METH_VARARGS, "CoordinateTransformation__TransformPoint4Double(CoordinateTransformation self, double [4] inout)"},
 	 { "CoordinateTransformation_TransformPoint", _wrap_CoordinateTransformation_TransformPoint, METH_VARARGS, "\n"
 		"CoordinateTransformation_TransformPoint(CoordinateTransformation self, double x, double y, double z=0.0)\n"
 		"CoordinateTransformation_TransformPoint(CoordinateTransformation self, double x, double y, double z, double t)\n"
 		""},
-	 { "CoordinateTransformation_TransformPointWithErrorCode", _wrap_CoordinateTransformation_TransformPointWithErrorCode, METH_VARARGS, "CoordinateTransformation_TransformPointWithErrorCode(CoordinateTransformation self, double x, double y, double z, double t)"},
-	 { "CoordinateTransformation_TransformPoints", _wrap_CoordinateTransformation_TransformPoints, METH_VARARGS, "CoordinateTransformation_TransformPoints(CoordinateTransformation self, int nCount)"},
-	 { "CoordinateTransformation_TransformBounds", _wrap_CoordinateTransformation_TransformBounds, METH_VARARGS, "CoordinateTransformation_TransformBounds(CoordinateTransformation self, double minx, double miny, double maxx, double maxy, int densify_pts)"},
+	 { "CoordinateTransformation_TransformPointWithErrorCode", _wrap_CoordinateTransformation_TransformPointWithErrorCode, METH_VARARGS, "\n"
+		"CoordinateTransformation_TransformPointWithErrorCode(CoordinateTransformation self, double x, double y, double z, double t)\n"
+		"\n"
+		"\n"
+		"Variant of :py:meth:`TransformPoint` that provides an error code.\n"
+		"\n"
+		"See :cpp:func:`OCTTransformEx`.\n"
+		"\n"
+		"Parameters\n"
+		"----------\n"
+		"x : float\n"
+		"y : float\n"
+		"z : float\n"
+		"t : float\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"tuple\n"
+		"    tuple of (x, y, z, t, error) values\n"
+		"\n"
+		"\n"
+		""},
+	 { "CoordinateTransformation_TransformPoints", _wrap_CoordinateTransformation_TransformPoints, METH_VARARGS, "\n"
+		"CoordinateTransformation_TransformPoints(CoordinateTransformation self, int nCount)\n"
+		"\n"
+		"\n"
+		"Transform multiple points.\n"
+		"\n"
+		"See :cpp:func:`OCTTransform`.\n"
+		"\n"
+		"Parameters\n"
+		"----------\n"
+		"arg\n"
+		"    A list of tuples, or a 2xN, 3xN, or 4xN numpy array\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"list\n"
+		"    A list of tuples of (x, y, z) or (x, y, z, t) values, depending on the input.\n"
+		"\n"
+		"Examples\n"
+		"--------\n"
+		">>> ct.TransformPoints([(-72.58, 44.26), (-72.59, 44.26)])\n"
+		"[(7390620.052019633, -51202148.77747277, 0.0), (7387261.070131293, -51200373.68798984, 0.0)]\n"
+		"\n"
+		">>> import numpy as np\n"
+		">>> ct.TransformPoints(np.array([[-72.58, 44.26], [-72.59, 44.26]]))\n"
+		"[(7390620.052019633, -51202148.77747277, 0.0), (7387261.070131293, -51200373.68798984, 0.0)]\n"
+		"\n"
+		"\n"
+		"\n"
+		""},
+	 { "CoordinateTransformation_TransformBounds", _wrap_CoordinateTransformation_TransformBounds, METH_VARARGS, "\n"
+		"CoordinateTransformation_TransformBounds(CoordinateTransformation self, double minx, double miny, double maxx, double maxy, int densify_pts)\n"
+		"\n"
+		"\n"
+		"Transform a boundary, densifying the edges to account for nonlinear\n"
+		"transformations along these edges.\n"
+		"\n"
+		"See :cpp:func:`OCTTransformBounds`.\n"
+		"\n"
+		"Parameters\n"
+		"----------\n"
+		"minx : float\n"
+		"    Minimum bounding coordinate of the first axis in source CRS\n"
+		"miny : float\n"
+		"    Minimum bounding coordinate of the second axis in source CRS\n"
+		"maxx : float\n"
+		"    Maximum bounding coordinate of the first axis in source CRS\n"
+		"maxy : float\n"
+		"    Maximum bounding coordinate of the second axis in source CRS\n"
+		"densify_pts : int\n"
+		"    The number of points to use to densify the bounding polygon.\n"
+		"    Recommended to use 21.\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"tuple\n"
+		"    Transformed values of xmin, ymin, xmax, ymax\n"
+		"\n"
+		"Examples\n"
+		"--------\n"
+		">>> ct.TransformBounds(-72.5, 44.2, -72.4, 44.3, 21)\n"
+		"(7415356.140468472, -51238192.683464445, 7454323.154814391, -51210287.42581475)\n"
+		"\n"
+		"\n"
+		""},
 	 { "CoordinateTransformation_swigregister", CoordinateTransformation_swigregister, METH_O, NULL},
 	 { "CoordinateTransformation_swiginit", CoordinateTransformation_swiginit, METH_VARARGS, NULL},
-	 { "CreateCoordinateTransformation", _wrap_CreateCoordinateTransformation, METH_VARARGS, "CreateCoordinateTransformation(SpatialReference src, SpatialReference dst, CoordinateTransformationOptions options=None) -> CoordinateTransformation"},
+	 { "CreateCoordinateTransformation", _wrap_CreateCoordinateTransformation, METH_VARARGS, "\n"
+		"CreateCoordinateTransformation(SpatialReference src, SpatialReference dst, CoordinateTransformationOptions options=None) -> CoordinateTransformation\n"
+		"\n"
+		"\n"
+		"Create a :py:class:`CoordinateTransformation` using a set of :py:class:`CoordinateTransformationOptions`.\n"
+		"\n"
+		"See :cpp:func:`OCTNewCoordinateTransformationEx`.\n"
+		"\n"
+		"Parameters\n"
+		"----------\n"
+		"src : SpatialReference\n"
+		"    source spatial reference system\n"
+		"dst : SpatialReference\n"
+		"    target spatial reference ystem\n"
+		"options : CoordinateTransformationOptions\n"
+		"\n"
+		"Returns\n"
+		"-------\n"
+		"CoordinateTransformation\n"
+		"\n"
+		"\n"
+		""},
 	 { "CRSInfo_auth_name_get", _wrap_CRSInfo_auth_name_get, METH_O, "CRSInfo_auth_name_get(CRSInfo self) -> char *"},
 	 { "CRSInfo_code_get", _wrap_CRSInfo_code_get, METH_O, "CRSInfo_code_get(CRSInfo self) -> char *"},
 	 { "CRSInfo_name_get", _wrap_CRSInfo_name_get, METH_O, "CRSInfo_name_get(CRSInfo self) -> char *"},
 	 { "CRSInfo_type_get", _wrap_CRSInfo_type_get, METH_O, "CRSInfo_type_get(CRSInfo self) -> OSRCRSType"},
 	 { "CRSInfo_deprecated_get", _wrap_CRSInfo_deprecated_get, METH_O, "CRSInfo_deprecated_get(CRSInfo self) -> bool"},
 	 { "CRSInfo_bbox_valid_get", _wrap_CRSInfo_bbox_valid_get, METH_O, "CRSInfo_bbox_valid_get(CRSInfo self) -> bool"},
 	 { "CRSInfo_west_lon_degree_get", _wrap_CRSInfo_west_lon_degree_get, METH_O, "CRSInfo_west_lon_degree_get(CRSInfo self) -> double"},
```

### Comparing `GDAL-3.8.5/gdal-utils/GDAL.egg-info/PKG-INFO` & `GDAL-3.9.0/gdal-utils/GDAL.egg-info/PKG-INFO`

 * *Files 23% similar despite different names*

```diff
@@ -1,28 +1,34 @@
 Metadata-Version: 2.1
 Name: GDAL
-Version: 3.8.5
+Version: 3.9.0
 Summary: GDAL: Geospatial Data Abstraction Library
 Home-page: http://www.gdal.org
-Author: Frank Warmerdam
+Author: Frank Warmerdam, Howard Butler, Even Rouault
 Author-email: warmerdam@pobox.com
-Maintainer: Howard Butler
-Maintainer-email: hobu.inc@gmail.com
+Maintainer: GDAL contributors
+Maintainer-email: GDAL contributors <gdal-dev@lists.osgeo.org>
 License: MIT
+Project-URL: Homepage, https://gdal.org
+Project-URL: Documentation, https://gdal.org
+Project-URL: Repository, https://github.com/OSGeo/GDAL.git
+Project-URL: Changelog, https://github.com/OSGeo/gdal/blob/master/NEWS.md
+Project-URL: Issues, https://github.com/OSGeo/gdal/issues
+Keywords: gis,raster,vector
 Classifier: Development Status :: 5 - Production/Stable
 Classifier: Intended Audience :: Developers
 Classifier: Intended Audience :: Science/Research
 Classifier: License :: OSI Approved :: MIT License
 Classifier: Operating System :: OS Independent
 Classifier: Programming Language :: Python :: 3
 Classifier: Programming Language :: C
 Classifier: Programming Language :: C++
 Classifier: Topic :: Scientific/Engineering :: GIS
 Classifier: Topic :: Scientific/Engineering :: Information Analysis
-Requires-Python: >=3.6.0
+Requires-Python: >=3.8.0
 Description-Content-Type: text/x-rst
 Provides-Extra: numpy
 Requires-Dist: numpy>1.0.0; extra == "numpy"
 
 
 GDAL/OGR in Python
 ==================
@@ -34,15 +40,15 @@
 bindings for GDAL/OGR. Generally speaking the classes and methods mostly
 match those of the GDAL and OGR C++ classes. There is no Python specific
 reference documentation, but the https://gdal.org/api/python_bindings.html#tutorials includes Python examples.
 
 Dependencies
 ------------
 
- * libgdal (3.8.5 or greater) and header files (gdal-devel)
+ * libgdal (3.9.0 or greater) and header files (gdal-devel)
  * numpy (1.0.0 or greater) and header files (numpy-devel) (not explicitly
    required, but many examples and utilities will not work without it)
 
 Installation
 ------------
 
 Conda
@@ -57,37 +63,76 @@
 
 https://conda-forge.org/
 
 Once you have Anaconda or Miniconda installed, you should be able to install GDAL with:
 
 ``conda install -c conda-forge gdal``
 
-Unix
-~~~~
-
-The GDAL Python bindings requires setuptools.
 
 pip
 ~~~
 
+Due to the complex nature of GDAL and its components, different bindings may require additional packages and installation steps.
 GDAL can be installed from the `Python Package Index <https://pypi.org/project/GDAL>`__:
 
 ::
 
-    pip install GDAL
+    pip install gdal
+
+
+In order to enable numpy-based raster support, libgdal and its development headers must be installed as well as the Python packages numpy, setuptools, and wheel.
+To install the Python dependencies and build numpy-based raster support:
+
+
+::
+
+    pip install numpy>1.0.0 wheel setuptools>=67
+    pip install gdal[numpy]=="$(gdal-config --version).*"
+
+
+Users can verify that numpy-based raster support has been installed with:
+
+::
+
+    python3 -c 'from osgeo import gdal_array'
 
-It will be necessary to have libgdal and its development headers installed
-if pip is expected to do a source build because no wheel is available
-for your specified platform and Python version.
 
-To install the version of the Python bindings matching your native GDAL library:
+If this command raises an ImportError, numpy-based raster support has not been properly installed:
 
 ::
 
-    pip install GDAL=="$(gdal-config --version).*"
+    Traceback (most recent call last):
+    File "<string>", line 1, in <module>
+    File "/usr/local/lib/python3.12/dist-packages/osgeo/gdal_array.py", line 10, in <module>
+      from . import _gdal_array
+    ImportError: cannot import name '_gdal_array' from 'osgeo' (/usr/local/lib/python3.12/dist-packages/osgeo/__init__.py)
+
+
+This is most often due to pip reusing a cached GDAL installation.
+Verify that the necessary dependencies have been installed and then run the following to force a clean build:
+
+::
+    pip install --no-cache --force-reinstall gdal[numpy]=="$(gdal-config --version).*"
+
+
+Potential issues with GDAL >= 3.9, Python >= 3.9 and NumPy 2.0
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+The pyproject.toml file of GDAL 3.9 requires numpy >= 2.0.0rc1 (for Python >= 3.9)
+at build time to be able to build bindings that are compatible of both NumPy 1
+and NumPy 2.
+If for some reason the numpy >= 2.0.0rc1 build dependency can not be installed,
+it is possible to manually install the build requirements, and invoke ``pip install``
+with the ``--no-build-isolation`` flag.
+
+::
+
+    pip install numpy==<required_version> wheel setuptools>=67
+    pip install gdal[numpy]=="$(gdal-config --version).*" --no-build-isolation
+
 
 Building as part of the GDAL library source tree
 ------------------------------------------------
 
 Python bindings are generated by default when building GDAL from source.
 For more detail, see `Python bindings options <https://gdal.org/development/building_from_source.html#building-python-bindings>`__
```

### Comparing `GDAL-3.8.5/gdal-utils/GDAL.egg-info/SOURCES.txt` & `GDAL-3.9.0/gdal-utils/GDAL.egg-info/SOURCES.txt`

 * *Files 1% similar despite different names*

```diff
@@ -1,18 +1,20 @@
 README.rst
+pyproject.toml
 setup.py
 extensions/gdal_array_wrap.cpp
 extensions/gdal_wrap.cpp
 extensions/gdalconst_wrap.c
 extensions/gnm_wrap.cpp
 extensions/ogr_wrap.cpp
 extensions/osr_wrap.cpp
 gdal-utils/GDAL.egg-info/PKG-INFO
 gdal-utils/GDAL.egg-info/SOURCES.txt
 gdal-utils/GDAL.egg-info/dependency_links.txt
+gdal-utils/GDAL.egg-info/entry_points.txt
 gdal-utils/GDAL.egg-info/not-zip-safe
 gdal-utils/GDAL.egg-info/requires.txt
 gdal-utils/GDAL.egg-info/top_level.txt
 gdal-utils/osgeo_utils/__init__.py
 gdal-utils/osgeo_utils/gdal2tiles.py
 gdal-utils/osgeo_utils/gdal2xyz.py
 gdal-utils/osgeo_utils/gdal_calc.py
@@ -66,14 +68,15 @@
 gdal-utils/osgeo_utils/samples/gdal_ls.py
 gdal-utils/osgeo_utils/samples/gdal_lut.py
 gdal-utils/osgeo_utils/samples/gdal_mkdir.py
 gdal-utils/osgeo_utils/samples/gdal_remove_towgs84.py
 gdal-utils/osgeo_utils/samples/gdal_rm.py
 gdal-utils/osgeo_utils/samples/gdal_rmdir.py
 gdal-utils/osgeo_utils/samples/gdal_vrtmerge.py
+gdal-utils/osgeo_utils/samples/gdalbuildvrtofvrt.py
 gdal-utils/osgeo_utils/samples/gdalchksum.py
 gdal-utils/osgeo_utils/samples/gdalcopyproj.py
 gdal-utils/osgeo_utils/samples/gdalfilter.py
 gdal-utils/osgeo_utils/samples/gdalident.py
 gdal-utils/osgeo_utils/samples/gdalimport.py
 gdal-utils/osgeo_utils/samples/gdalinfo.py
 gdal-utils/osgeo_utils/samples/gdallocationinfo.py
@@ -82,15 +85,14 @@
 gdal-utils/osgeo_utils/samples/hsv_merge.py
 gdal-utils/osgeo_utils/samples/jpeg_in_tiff_extract.py
 gdal-utils/osgeo_utils/samples/load2odbc.py
 gdal-utils/osgeo_utils/samples/loslas2ntv2.py
 gdal-utils/osgeo_utils/samples/magphase.py
 gdal-utils/osgeo_utils/samples/make_fuzzer_friendly_archive.py
 gdal-utils/osgeo_utils/samples/mkgraticule.py
-gdal-utils/osgeo_utils/samples/ogr2ogr.py
 gdal-utils/osgeo_utils/samples/ogr2vrt.py
 gdal-utils/osgeo_utils/samples/ogr_build_junction_table.py
 gdal-utils/osgeo_utils/samples/ogr_dispatch.py
 gdal-utils/osgeo_utils/samples/ogrinfo.py
 gdal-utils/osgeo_utils/samples/ogrupdate.py
 gdal-utils/osgeo_utils/samples/rel.py
 gdal-utils/osgeo_utils/samples/tigerpoly.py
```

### Comparing `GDAL-3.8.5/gdal-utils/osgeo_utils/auxiliary/array_util.py` & `GDAL-3.9.0/gdal-utils/osgeo_utils/auxiliary/array_util.py`

 * *Files identical despite different names*

### Comparing `GDAL-3.8.5/gdal-utils/osgeo_utils/auxiliary/base.py` & `GDAL-3.9.0/gdal-utils/osgeo_utils/auxiliary/base.py`

 * *Files identical despite different names*

### Comparing `GDAL-3.8.5/gdal-utils/osgeo_utils/auxiliary/batch_creator.py` & `GDAL-3.9.0/gdal-utils/osgeo_utils/auxiliary/batch_creator.py`

 * *Files identical despite different names*

### Comparing `GDAL-3.8.5/gdal-utils/osgeo_utils/auxiliary/color_palette.py` & `GDAL-3.9.0/gdal-utils/osgeo_utils/auxiliary/color_palette.py`

 * *Files identical despite different names*

### Comparing `GDAL-3.8.5/gdal-utils/osgeo_utils/auxiliary/color_table.py` & `GDAL-3.9.0/gdal-utils/osgeo_utils/auxiliary/color_table.py`

 * *Files identical despite different names*

### Comparing `GDAL-3.8.5/gdal-utils/osgeo_utils/auxiliary/extent_util.py` & `GDAL-3.9.0/gdal-utils/osgeo_utils/auxiliary/extent_util.py`

 * *Files identical despite different names*

### Comparing `GDAL-3.8.5/gdal-utils/osgeo_utils/auxiliary/gdal_argparse.py` & `GDAL-3.9.0/gdal-utils/osgeo_utils/auxiliary/gdal_argparse.py`

 * *Files 5% similar despite different names*

```diff
@@ -58,14 +58,17 @@
             if not description:
                 description = title
             else:
                 if formatter_class is None:
                     formatter_class = argparse.RawDescriptionHelpFormatter
                 description = f'{title}\n{"-"*(2+len(title))}\n{description}'
 
+        if formatter_class is None:
+            formatter_class = argparse.HelpFormatter
+
         super().__init__(
             fromfile_prefix_chars=fromfile_prefix_chars,
             description=description,
             formatter_class=formatter_class,
             add_help=not disable_h_option and not add_gdal_generic_options,
             **kwargs,
         )
@@ -221,14 +224,17 @@
         return kwargs
 
     def main(self, argv) -> int:
         kwargs = self.parse(argv[1:])
         try:
             self.doit(**kwargs)
             return 0
+        except IOError as e:
+            print(str(e), file=sys.stderr)
+            return 1
         except Exception:
             import traceback
 
             traceback.print_exc()
             return 1
 
     def get_epilog(self):
```

### Comparing `GDAL-3.8.5/gdal-utils/osgeo_utils/auxiliary/numpy_util.py` & `GDAL-3.9.0/gdal-utils/osgeo_utils/auxiliary/numpy_util.py`

 * *Files identical despite different names*

### Comparing `GDAL-3.8.5/gdal-utils/osgeo_utils/auxiliary/osr_util.py` & `GDAL-3.9.0/gdal-utils/osgeo_utils/auxiliary/osr_util.py`

 * *Files identical despite different names*

### Comparing `GDAL-3.8.5/gdal-utils/osgeo_utils/auxiliary/progress.py` & `GDAL-3.9.0/gdal-utils/osgeo_utils/auxiliary/progress.py`

 * *Files identical despite different names*

### Comparing `GDAL-3.8.5/gdal-utils/osgeo_utils/auxiliary/raster_creation.py` & `GDAL-3.9.0/gdal-utils/osgeo_utils/auxiliary/raster_creation.py`

 * *Files identical despite different names*

### Comparing `GDAL-3.8.5/gdal-utils/osgeo_utils/auxiliary/rectangle.py` & `GDAL-3.9.0/gdal-utils/osgeo_utils/auxiliary/rectangle.py`

 * *Files identical despite different names*

### Comparing `GDAL-3.8.5/gdal-utils/osgeo_utils/auxiliary/util.py` & `GDAL-3.9.0/gdal-utils/osgeo_utils/auxiliary/util.py`

 * *Files 1% similar despite different names*

```diff
@@ -237,17 +237,26 @@
         self.kwargs = kwargs
         self.own = False
         self.silent_fail = silent_fail
 
     def __enter__(self) -> gdal.Dataset:
 
         if self.ds is None:
-            self.ds = self._open_ds(self.filename, *self.args, **self.kwargs)
+            try:
+                self.ds = self._open_ds(self.filename, *self.args, **self.kwargs)
+            except Exception as e:
+                if self.silent_fail:
+                    return None
+                msg = str(e)
+                prefix = f"{self.filename}: "
+                if msg.startswith(prefix):
+                    msg = msg[len(prefix) :]
+                raise IOError(f'Could not open file "{self.filename}": {msg}')
             if self.ds is None and not self.silent_fail:
-                raise IOError('could not open file "{}"'.format(self.filename))
+                raise IOError(f'Could not open file "{self.filename}"')
             self.own = True
         return self.ds
 
     def __exit__(self, exc_type, exc_val, exc_tb):
         if self.own:
             self.ds = False
```

### Comparing `GDAL-3.8.5/gdal-utils/osgeo_utils/gdal2tiles.py` & `GDAL-3.9.0/gdal-utils/osgeo_utils/gdal2tiles.py`

 * *Files 3% similar despite different names*

```diff
@@ -284,15 +284,16 @@
         except Exception:
             j = None
         if j is None:
             logger.error("Cannot parse " + tmsfilename)
             continue
         try:
             tms = TileMatrixSet.parse(j)
-        except UnsupportedTileMatrixSet:
+        except UnsupportedTileMatrixSet as e:
+            gdal.Debug("gdal2tiles", "Cannot parse " + tmsfilename + ": " + str(e))
             continue
         except Exception:
             logger.error("Cannot parse " + tmsfilename)
             continue
         tmsMap[tms.identifier] = tms
         profile_list.append(tms.identifier)
 
@@ -868,15 +869,40 @@
 def scale_query_to_tile(dsquery, dstile, options, tilefilename=""):
     """Scales down query dataset to the tile dataset"""
 
     querysize = dsquery.RasterXSize
     tile_size = dstile.RasterXSize
     tilebands = dstile.RasterCount
 
-    if options.resampling == "average":
+    dsquery.SetGeoTransform(
+        (
+            0.0,
+            tile_size / float(querysize),
+            0.0,
+            0.0,
+            0.0,
+            tile_size / float(querysize),
+        )
+    )
+    dstile.SetGeoTransform((0.0, 1.0, 0.0, 0.0, 0.0, 1.0))
+
+    if options.resampling == "average" and (
+        options.excluded_values or options.nodata_values_pct_threshold < 100
+    ):
+
+        gdal.Warp(
+            dstile,
+            dsquery,
+            options="-r average "
+            + f"-wo EXCLUDED_VALUES={options.excluded_values} "
+            + f"-wo EXCLUDED_VALUES_PCT_THRESHOLD={options.excluded_values_pct_threshold} "
+            + f"-wo NODATA_VALUES_PCT_THRESHOLD={options.nodata_values_pct_threshold}",
+        )
+
+    elif options.resampling == "average":
 
         # Function: gdal.RegenerateOverview()
         for i in range(1, tilebands + 1):
             # Black border around NODATA
             res = gdal.RegenerateOverview(
                 dsquery.GetRasterBand(i), dstile.GetRasterBand(i), "average"
             )
@@ -894,26 +920,33 @@
 
         # Scaling by PIL (Python Imaging Library) - improved Lanczos
         array = numpy.zeros((querysize, querysize, tilebands), numpy.uint8)
         for i in range(tilebands):
             array[:, :, i] = gdalarray.BandReadAsArray(
                 dsquery.GetRasterBand(i + 1), 0, 0, querysize, querysize
             )
-        im = Image.fromarray(array, "RGBA")  # Always four bands
+        if options.tiledriver == "JPEG" and tilebands == 2:
+            im = Image.fromarray(array[:, :, 0], "L")
+        elif options.tiledriver == "JPEG" and tilebands == 4:
+            im = Image.fromarray(array[:, :, 0:3], "RGB")
+        else:
+            im = Image.fromarray(array, "RGBA")
         im1 = im.resize((tile_size, tile_size), Image.LANCZOS)
         if os.path.exists(tilefilename):
             im0 = Image.open(tilefilename)
             im1 = Image.composite(im1, im0, im1)
 
         params = {}
         if options.tiledriver == "WEBP":
             if options.webp_lossless:
                 params["lossless"] = True
             else:
                 params["quality"] = options.webp_quality
+        elif options.tiledriver == "JPEG":
+            params["quality"] = options.jpeg_quality
         im1.save(tilefilename, options.tiledriver, **params)
 
     else:
 
         if options.resampling == "near":
             gdal_resampling = gdal.GRA_NearestNeighbour
 
@@ -944,26 +977,14 @@
         elif options.resampling == "q1":
             gdal_resampling = gdal.GRA_Q1
 
         elif options.resampling == "q3":
             gdal_resampling = gdal.GRA_Q3
 
         # Other algorithms are implemented by gdal.ReprojectImage().
-        dsquery.SetGeoTransform(
-            (
-                0.0,
-                tile_size / float(querysize),
-                0.0,
-                0.0,
-                0.0,
-                tile_size / float(querysize),
-            )
-        )
-        dstile.SetGeoTransform((0.0, 1.0, 0.0, 0.0, 0.0, 1.0))
-
         res = gdal.ReprojectImage(dsquery, dstile, None, None, gdal_resampling)
         if res != 0:
             exit_with_error(
                 "ReprojectImage() failed on %s, error %d" % (tilefilename, res)
             )
 
 
@@ -1301,14 +1322,16 @@
 def _get_creation_options(options):
     copts = []
     if options.tiledriver == "WEBP":
         if options.webp_lossless:
             copts = ["LOSSLESS=True"]
         else:
             copts = ["QUALITY=" + str(options.webp_quality)]
+    elif options.tiledriver == "JPEG":
+        copts = ["QUALITY=" + str(options.jpeg_quality)]
     return copts
 
 
 def create_base_tile(tile_job_info: "TileJobInfo", tile_detail: "TileDetail") -> None:
 
     dataBandsCount = tile_job_info.nb_data_bands
     output = tile_job_info.output_file_path
@@ -1341,14 +1364,15 @@
     wxsize = tile_detail.wxsize
     wysize = tile_detail.wysize
     querysize = tile_detail.querysize
 
     # Tile dataset in memory
     tilefilename = os.path.join(output, str(tz), str(tx), "%s.%s" % (ty, tileext))
     dstile = mem_drv.Create("", tile_size, tile_size, tilebands)
+    dstile.GetRasterBand(tilebands).SetColorInterpretation(gdal.GCI_AlphaBand)
 
     data = alpha = None
 
     if options.verbose:
         logger.debug(
             f"\tReadRaster Extent: ({rx}, {ry}, {rxsize}, {rysize}), ({wx}, {wy}, {wxsize}, {wysize})"
         )
@@ -1394,14 +1418,16 @@
             # MrSID) the ReadRaster function returns high-quality raster (not ugly
             # nearest neighbour)
             # TODO: Use directly 'near' for WaveLet files
         else:
             # Big ReadRaster query in memory scaled to the tile_size - all but 'near'
             # algo
             dsquery = mem_drv.Create("", querysize, querysize, tilebands)
+            dsquery.GetRasterBand(tilebands).SetColorInterpretation(gdal.GCI_AlphaBand)
+
             # TODO: fill the null value in case a tile without alpha is produced (now
             # only png tiles are supported)
             dsquery.WriteRaster(
                 wx,
                 wy,
                 wxsize,
                 wysize,
@@ -1414,17 +1440,27 @@
             del dsquery
 
     del data
 
     if options.resampling != "antialias":
         # Write a copy of tile to png/jpg
         out_drv.CreateCopy(
-            tilefilename, dstile, strict=0, options=_get_creation_options(options)
+            tilefilename,
+            dstile
+            if tile_job_info.tile_driver != "JPEG"
+            else remove_alpha_band(dstile),
+            strict=0,
+            options=_get_creation_options(options),
         )
 
+        # Remove useless side car file
+        aux_xml = tilefilename + ".aux.xml"
+        if gdal.VSIStatL(aux_xml) is not None:
+            gdal.Unlink(aux_xml)
+
     del dstile
 
     # Create a KML file for this tile.
     if tile_job_info.kml:
         swne = get_tile_swne(tile_job_info, options)
         if swne is not None:
             kmlfilename = os.path.join(
@@ -1444,14 +1480,46 @@
                             tile_job_info.tile_size,
                             swne,
                             tile_job_info.options,
                         ).encode("utf-8")
                     )
 
 
+def remove_alpha_band(src_ds):
+    if (
+        src_ds.GetRasterBand(src_ds.RasterCount).GetColorInterpretation()
+        != gdal.GCI_AlphaBand
+    ):
+        return src_ds
+
+    new_band_count = src_ds.RasterCount - 1
+
+    dst_ds = gdal.GetDriverByName("MEM").Create(
+        "",
+        src_ds.RasterXSize,
+        src_ds.RasterYSize,
+        new_band_count,
+        src_ds.GetRasterBand(1).DataType,
+    )
+
+    gt = src_ds.GetGeoTransform(can_return_null=True)
+    if gt:
+        dst_ds.SetGeoTransform(gt)
+    srs = src_ds.GetSpatialRef()
+    if srs:
+        dst_ds.SetSpatialRef(srs)
+
+    for i in range(1, new_band_count + 1):
+        src_band = src_ds.GetRasterBand(i)
+        dst_band = dst_ds.GetRasterBand(i)
+        dst_band.WriteArray(src_band.ReadAsArray())
+
+    return dst_ds
+
+
 def create_overview_tile(
     base_tz: int,
     base_tiles: List[Tuple[int, int]],
     output_folder: str,
     tile_job_info: "TileJobInfo",
     options: Options,
 ):
@@ -1480,18 +1548,20 @@
     out_driver = gdal.GetDriverByName(tile_driver)
 
     tilebands = tile_job_info.nb_data_bands + 1
 
     dsquery = mem_driver.Create(
         "", 2 * tile_job_info.tile_size, 2 * tile_job_info.tile_size, tilebands
     )
+    dsquery.GetRasterBand(tilebands).SetColorInterpretation(gdal.GCI_AlphaBand)
     # TODO: fill the null value
     dstile = mem_driver.Create(
         "", tile_job_info.tile_size, tile_job_info.tile_size, tilebands
     )
+    dstile.GetRasterBand(tilebands).SetColorInterpretation(gdal.GCI_AlphaBand)
 
     usable_base_tiles = []
 
     for base_tile in base_tiles:
         base_tx = base_tile[0]
         base_ty = base_tile[1]
         base_ty_real = GDAL2Tiles.getYTile(base_ty, base_tz, options)
@@ -1519,15 +1589,43 @@
                 tileposy = tile_job_info.tile_size
         else:
             if base_ty % 2 == 0:
                 tileposy = tile_job_info.tile_size
             else:
                 tileposy = 0
 
-        if dsquerytile.RasterCount == tilebands - 1:
+        if (
+            tile_job_info.tile_driver == "JPEG"
+            and dsquerytile.RasterCount == 3
+            and tilebands == 2
+        ):
+            # Input is RGB with R=G=B. Add An alpha band
+            tmp_ds = mem_driver.Create(
+                "", dsquerytile.RasterXSize, dsquerytile.RasterYSize, 2
+            )
+            tmp_ds.GetRasterBand(1).WriteRaster(
+                0,
+                0,
+                tile_job_info.tile_size,
+                tile_job_info.tile_size,
+                dsquerytile.GetRasterBand(1).ReadRaster(),
+            )
+            mask = bytearray(
+                [255] * (tile_job_info.tile_size * tile_job_info.tile_size)
+            )
+            tmp_ds.GetRasterBand(2).WriteRaster(
+                0,
+                0,
+                tile_job_info.tile_size,
+                tile_job_info.tile_size,
+                mask,
+            )
+            tmp_ds.GetRasterBand(2).SetColorInterpretation(gdal.GCI_AlphaBand)
+            dsquerytile = tmp_ds
+        elif dsquerytile.RasterCount == tilebands - 1:
             # assume that the alpha band is missing and add it
             tmp_ds = mem_driver.CreateCopy("", dsquerytile, 0)
             tmp_ds.AddBand()
             mask = bytearray(
                 [255] * (tile_job_info.tile_size * tile_job_info.tile_size)
             )
             tmp_ds.WriteRaster(
@@ -1536,15 +1634,18 @@
                 tile_job_info.tile_size,
                 tile_job_info.tile_size,
                 mask,
                 band_list=[tilebands],
             )
             dsquerytile = tmp_ds
         elif dsquerytile.RasterCount != tilebands:
-            raise Exception("Unexpected number of bands in base tile")
+            raise Exception(
+                "Unexpected number of bands in base tile. Got %d, expected %d"
+                % (dsquerytile.RasterCount, tilebands)
+            )
 
         base_data = dsquerytile.ReadRaster(
             0, 0, tile_job_info.tile_size, tile_job_info.tile_size
         )
 
         dsquery.WriteRaster(
             tileposx,
@@ -1561,15 +1662,20 @@
         return
 
     scale_query_to_tile(dsquery, dstile, options, tilefilename=tilefilename)
     # Write a copy of tile to png/jpg
     if options.resampling != "antialias":
         # Write a copy of tile to png/jpg
         out_driver.CreateCopy(
-            tilefilename, dstile, strict=0, options=_get_creation_options(options)
+            tilefilename,
+            dstile
+            if tile_job_info.tile_driver != "JPEG"
+            else remove_alpha_band(dstile),
+            strict=0,
+            options=_get_creation_options(options),
         )
         # Remove useless side car file
         aux_xml = tilefilename + ".aux.xml"
         if gdal.VSIStatL(aux_xml) is not None:
             gdal.Unlink(aux_xml)
 
     if options.verbose:
@@ -1749,19 +1855,39 @@
         default=256,
         type="int",
         help="Width and height in pixel of a tile",
     )
     p.add_option(
         "--tiledriver",
         dest="tiledriver",
-        choices=["PNG", "WEBP"],
+        choices=["PNG", "WEBP", "JPEG"],
         default="PNG",
         type="choice",
         help="which tile driver to use for the tiles",
     )
+    p.add_option(
+        "--excluded-values",
+        dest="excluded_values",
+        type=str,
+        help="Tuples of values (e.g. <R>,<G>,<B> or (<R1>,<G1>,<B1>),(<R2>,<G2>,<B2>)) that must be ignored as contributing source pixels during resampling. Only taken into account for average resampling",
+    )
+    p.add_option(
+        "--excluded-values-pct-threshold",
+        dest="excluded_values_pct_threshold",
+        type=float,
+        default=50,
+        help="Minimum percentage of source pixels that must be set at one of the --excluded-values to cause the excluded value, that is in majority among source pixels, to be used as the target pixel value. Default value is 50 (%)",
+    )
+    p.add_option(
+        "--nodata-values-pct-threshold",
+        dest="nodata_values_pct_threshold",
+        type=float,
+        default=100,
+        help="Minimum percentage of source pixels that must be at nodata (or alpha=0 or any other way to express transparent pixel) to cause the target pixel value to be transparent. Default value is 100 (%). Only taken into account for average resampling",
+    )
 
     # KML options
     g = optparse.OptionGroup(
         p,
         "KML (Google Earth) options",
         "Options for generated Google Earth SuperOverlay metadata",
     )
@@ -1847,14 +1973,25 @@
         "--webp-lossless",
         dest="webp_lossless",
         action="store_true",
         help="use lossless compression for the webp image",
     )
     p.add_option_group(g)
 
+    # Jpeg options
+    g = optparse.OptionGroup(p, "JPEG options", "Options for JPEG tiledriver")
+    g.add_option(
+        "--jpeg-quality",
+        dest="jpeg_quality",
+        type=int,
+        default=75,
+        help="quality of jpeg image, integer between 1 and 100, default is 75",
+    )
+    p.add_option_group(g)
+
     p.set_defaults(
         verbose=False,
         profile="mercator",
         kml=None,
         url="",
         webviewer="all",
         copyright="",
@@ -1881,17 +2018,22 @@
         exit_with_error(
             "Processing of several input files is not supported.",
             "Please first use a tool like gdal_vrtmerge.py or gdal_merge.py on the "
             "files: gdal_vrtmerge.py -o merged.vrt %s" % " ".join(args),
         )
 
     input_file = args[0]
-    if not isfile(input_file):
+    try:
+        input_file_exists = gdal.Open(input_file) is not None
+    except Exception:
+        input_file_exists = False
+    if not input_file_exists:
         exit_with_error(
-            "The provided input file %s does not exist or is not a file" % input_file
+            "The provided input file %s does not exist or is not a recognized GDAL dataset"
+            % input_file
         )
 
     if len(args) == 2:
         output_folder = args[1]
     else:
         # Directory with input filename without extension in actual directory
         output_folder = os.path.splitext(os.path.basename(input_file))[0]
@@ -1960,14 +2102,21 @@
         if gdal.GetDriverByName(options.tiledriver) is None:
             exit_with_error("WEBP driver is not available")
 
         if not options.webp_lossless:
             if options.webp_quality <= 0 or options.webp_quality > 100:
                 exit_with_error("webp_quality should be in the range [1-100]")
             options.webp_quality = int(options.webp_quality)
+    elif options.tiledriver == "JPEG":
+        if gdal.GetDriverByName(options.tiledriver) is None:
+            exit_with_error("JPEG driver is not available")
+
+        if options.jpeg_quality <= 0 or options.jpeg_quality > 100:
+            exit_with_error("jpeg_quality should be in the range [1-100]")
+        options.jpeg_quality = int(options.jpeg_quality)
 
     # Output the results
     if options.verbose:
         logger.debug("Options: %s" % str(options))
         logger.debug(f"Input: {input_file}")
         logger.debug(f"Output: {output_folder}")
         logger.debug("Cache: %d MB" % (gdal.GetCacheMax() / 1024 / 1024))
@@ -2077,16 +2226,18 @@
         self.tile_size = 256
         if options.tilesize:
             self.tile_size = options.tilesize
 
         self.tiledriver = options.tiledriver
         if options.tiledriver == "PNG":
             self.tileext = "png"
-        else:
+        elif options.tiledriver == "WEBP":
             self.tileext = "webp"
+        else:
+            self.tileext = "jpg"
         if options.mpi:
             makedirs(output_folder)
             self.tmp_dir = tempfile.mkdtemp(dir=output_folder)
         else:
             self.tmp_dir = tempfile.mkdtemp()
         self.tmp_vrt_filename = os.path.join(self.tmp_dir, str(uuid4()) + ".vrt")
 
@@ -2796,14 +2947,19 @@
                     wysize = int(rysize / float(tsize) * self.tile_size)
 
                     if not self.options.xyz:
                         ry = ysize - (ty * tsize) - rysize
                         if wysize != self.tile_size:
                             wy = self.tile_size - wysize
 
+                if rxsize == 0 or rysize == 0 or wxsize == 0 or wysize == 0:
+                    if self.options.verbose:
+                        logger.debug("\tExcluding tile with no pixel coverage")
+                    continue
+
                 # Read the source raster if anything is going inside the tile as per the computed
                 # geo_query
                 tile_details.append(
                     TileDetail(
                         tx=tx,
                         ty=ytile,
                         tz=tz,
```

### Comparing `GDAL-3.8.5/gdal-utils/osgeo_utils/gdal2xyz.py` & `GDAL-3.9.0/gdal-utils/osgeo_utils/gdal2xyz.py`

 * *Files 1% similar despite different names*

```diff
@@ -255,15 +255,15 @@
             help="How many rows/cols to skip in each iteration.",
         )
 
         parser.add_argument(
             "-srcwin",
             metavar=("xoff", "yoff", "xsize", "ysize"),
             dest="srcwin",
-            type=float,
+            type=int,
             nargs=4,
             help="Selects a subwindow from the source image for copying based on pixel/line location",
         )
 
         parser.add_argument(
             "-b",
             "-band",
```

### Comparing `GDAL-3.8.5/gdal-utils/osgeo_utils/gdal_calc.py` & `GDAL-3.9.0/gdal-utils/osgeo_utils/gdal_calc.py`

 * *Files identical despite different names*

### Comparing `GDAL-3.8.5/gdal-utils/osgeo_utils/gdal_edit.py` & `GDAL-3.9.0/gdal-utils/osgeo_utils/gdal_edit.py`

 * *Files 9% similar despite different names*

```diff
@@ -48,14 +48,15 @@
     print(
         "                 [-offset <value>] [-scale <value>] [-units <value>]", file=f
     )
     print(
         "                 [-colorinterp_<X> {red|green|blue|alpha|gray|undefined]]...",
         file=f,
     )
+    print("                 [-a_coord_epoch <epoch>] [-unsetepoch]", file=f)
     print("                 [-unsetstats] [-stats] [-approx_stats]", file=f)
     print("                 [-setstats <min> <max> <mean> <stddev>]", file=f)
     print(
         "                 [-gcp <pixel> <line> <easting> <northing> [<elevation>]]...",
         file=f,
     )
     print(
@@ -103,14 +104,16 @@
     lry = None
     nodata = None
     unsetnodata = False
     units = None
     xres = None
     yres = None
     unsetgt = False
+    epoch = None
+    unsetepoch = False
     unsetstats = False
     stats = False
     setstats = False
     approx_stats = False
     unsetmd = False
     ro = False
     molist = []
@@ -127,14 +130,17 @@
         if argv[i] == "--help":
             return Usage(isError=False)
         elif argv[i] == "-ro":
             ro = True
         elif argv[i] == "-a_srs" and i < len(argv) - 1:
             srs = argv[i + 1]
             i = i + 1
+        elif argv[i] == "-a_coord_epoch" and i < len(argv) - 1:
+            epoch = float(argv[i + 1])
+            i = i + 1
         elif argv[i] == "-a_ullr" and i < len(argv) - 4:
             ulx = float(argv[i + 1])
             i = i + 1
             uly = float(argv[i + 1])
             i = i + 1
             lrx = float(argv[i + 1])
             i = i + 1
@@ -195,14 +201,16 @@
                 z = 0
             gcp = gdal.GCP(x, y, z, pixel, line)
             gcp_list.append(gcp)
         elif argv[i] == "-unsetgt":
             unsetgt = True
         elif argv[i] == "-unsetrpc":
             unsetrpc = True
+        elif argv[i] == "-unsetepoch":
+            unsetepoch = True
         elif argv[i] == "-unsetstats":
             unsetstats = True
         elif argv[i] == "-approx_stats":
             stats = True
             approx_stats = True
         elif argv[i] == "-stats":
             stats = True
@@ -275,17 +283,19 @@
         i = i + 1
 
     if datasetname is None:
         return Usage(isError=True)
 
     if (
         srs is None
+        and epoch is None
         and lry is None
         and yres is None
         and not unsetgt
+        and not unsetepoch
         and not unsetstats
         and not stats
         and not setstats
         and nodata is None
         and not units
         and not molist
         and not unsetmd
@@ -326,14 +336,19 @@
         return Usage(isError=True)
 
     if unsetnodata and nodata:
         print("-unsetnodata and -nodata options are exclusive.", file=sys.stderr)
         print("", file=sys.stderr)
         return Usage(isError=True)
 
+    if unsetepoch and epoch:
+        print("-unsetepoch and -a_coord_epoch options are exclusive.", file=sys.stderr)
+        print("", file=sys.stderr)
+        return Usage(isError=True)
+
     if open_options is not None:
         if ro:
             ds = gdal.OpenEx(datasetname, gdal.OF_RASTER, open_options=open_options)
         else:
             ds = gdal.OpenEx(
                 datasetname, gdal.OF_RASTER | gdal.OF_UPDATE, open_options=open_options
             )
@@ -375,14 +390,34 @@
         if sr.SetFromUserInput(srs) != 0:
             print("Failed to process SRS definition: %s" % srs, file=sys.stderr)
             return -1
         wkt = sr.ExportToWkt()
         if not gcp_list:
             ds.SetProjection(wkt)
 
+    if epoch is not None:
+        sr = ds.GetSpatialRef()
+        if sr is None:
+            print(
+                "Dataset SRS is undefined, cannot set epoch. See the -a_srs option.",
+                file=sys.stderr,
+            )
+            return -1
+        sr.SetCoordinateEpoch(epoch)
+        ds.SetSpatialRef(sr)
+
+    if unsetepoch:
+        sr = ds.GetSpatialRef()
+        if sr is None:
+            print("Dataset SRS is undefined, with no epoch specified.", file=sys.stderr)
+            return -1
+        # Set to 0.0, which is what GetCoordinateEpoch() returns for SRS with no epoch defined
+        sr.SetCoordinateEpoch(0.0)
+        ds.SetSpatialRef(sr)
+
     if lry is not None:
         gt = [
             ulx,
             (lrx - ulx) / ds.RasterXSize,
             0,
             uly,
             0,
```

### Comparing `GDAL-3.8.5/gdal-utils/osgeo_utils/gdal_fillnodata.py` & `GDAL-3.9.0/gdal-utils/osgeo_utils/gdal_fillnodata.py`

 * *Files 5% similar despite different names*

```diff
@@ -53,19 +53,23 @@
     dst_filename: Optional[str] = None,
     driver_name: str = "GTiff",
     creation_options: Optional[list] = None,
     quiet: bool = False,
     mask: str = "default",
     max_distance: Real = 100,
     smoothing_iterations: int = 0,
+    interpolation: Optional[str] = None,
     options: Optional[list] = None,
 ):
     options = options or []
     creation_options = creation_options or []
 
+    if interpolation:
+        options.append("INTERPOLATION=" + interpolation)
+
     # =============================================================================
     # 	Verify we have next gen bindings with the sievefilter method.
     # =============================================================================
     try:
         gdal.FillNodata
     except AttributeError:
         print("")
@@ -219,14 +223,22 @@
             metavar="filename",
             default="default",
             help="Use the first band of the specified file as a validity mask "
             "(zero is invalid, non-zero is valid).",
         )
 
         parser.add_argument(
+            "-interp",
+            "--interpolation",
+            dest="interpolation",
+            choices=["inv_dist", "nearest"],
+            help="Interpolation method.",
+        )
+
+        parser.add_argument(
             "-b",
             "-band",
             dest="band_number",
             metavar="band",
             type=int,
             default=1,
             help="The band to operate on, defaults to 1.",
```

### Comparing `GDAL-3.8.5/gdal-utils/osgeo_utils/gdal_merge.py` & `GDAL-3.9.0/gdal-utils/osgeo_utils/gdal_merge.py`

 * *Files identical despite different names*

### Comparing `GDAL-3.8.5/gdal-utils/osgeo_utils/gdal_pansharpen.py` & `GDAL-3.9.0/gdal-utils/osgeo_utils/gdal_pansharpen.py`

 * *Files identical despite different names*

### Comparing `GDAL-3.8.5/gdal-utils/osgeo_utils/gdal_polygonize.py` & `GDAL-3.9.0/gdal-utils/osgeo_utils/gdal_polygonize.py`

 * *Files 1% similar despite different names*

```diff
@@ -142,14 +142,17 @@
     # 	Create output file.
     # =============================================================================
     if dst_ds is None:
         drv = ogr.GetDriverByName(driver_name)
         if not quiet:
             print("Creating output %s of format %s." % (dst_filename, driver_name))
         dst_ds = drv.CreateDataSource(dst_filename)
+        if dst_ds is None:
+            print('Cannot create datasource "%s"' % dst_filename)
+            return 1
 
     # =============================================================================
     #       Find or create destination layer.
     # =============================================================================
     try:
         dst_layer = dst_ds.GetLayerByName(dst_layername)
     except Exception:
```

### Comparing `GDAL-3.8.5/gdal-utils/osgeo_utils/gdal_proximity.py` & `GDAL-3.9.0/gdal-utils/osgeo_utils/gdal_proximity.py`

 * *Files identical despite different names*

### Comparing `GDAL-3.8.5/gdal-utils/osgeo_utils/gdal_retile.py` & `GDAL-3.9.0/gdal-utils/osgeo_utils/gdal_retile.py`

 * *Files identical despite different names*

### Comparing `GDAL-3.8.5/gdal-utils/osgeo_utils/gdal_sieve.py` & `GDAL-3.9.0/gdal-utils/osgeo_utils/gdal_sieve.py`

 * *Files identical despite different names*

### Comparing `GDAL-3.8.5/gdal-utils/osgeo_utils/gdalattachpct.py` & `GDAL-3.9.0/gdal-utils/osgeo_utils/gdalattachpct.py`

 * *Files identical despite different names*

### Comparing `GDAL-3.8.5/gdal-utils/osgeo_utils/gdalcompare.py` & `GDAL-3.9.0/gdal-utils/osgeo_utils/gdalcompare.py`

 * *Files identical despite different names*

### Comparing `GDAL-3.8.5/gdal-utils/osgeo_utils/gdalmove.py` & `GDAL-3.9.0/gdal-utils/osgeo_utils/gdalmove.py`

 * *Files identical despite different names*

### Comparing `GDAL-3.8.5/gdal-utils/osgeo_utils/ogr_layer_algebra.py` & `GDAL-3.9.0/gdal-utils/osgeo_utils/ogr_layer_algebra.py`

 * *Files identical despite different names*

### Comparing `GDAL-3.8.5/gdal-utils/osgeo_utils/ogrmerge.py` & `GDAL-3.9.0/gdal-utils/osgeo_utils/ogrmerge.py`

 * *Files identical despite different names*

### Comparing `GDAL-3.8.5/gdal-utils/osgeo_utils/pct2rgb.py` & `GDAL-3.9.0/gdal-utils/osgeo_utils/pct2rgb.py`

 * *Files identical despite different names*

### Comparing `GDAL-3.8.5/gdal-utils/osgeo_utils/rgb2pct.py` & `GDAL-3.9.0/gdal-utils/osgeo_utils/rgb2pct.py`

 * *Files identical despite different names*

### Comparing `GDAL-3.8.5/gdal-utils/osgeo_utils/samples/assemblepoly.py` & `GDAL-3.9.0/gdal-utils/osgeo_utils/samples/assemblepoly.py`

 * *Files identical despite different names*

### Comparing `GDAL-3.8.5/gdal-utils/osgeo_utils/samples/build_jp2_from_xml.py` & `GDAL-3.9.0/gdal-utils/osgeo_utils/samples/build_jp2_from_xml.py`

 * *Files identical despite different names*

### Comparing `GDAL-3.8.5/gdal-utils/osgeo_utils/samples/classify.py` & `GDAL-3.9.0/gdal-utils/osgeo_utils/samples/classify.py`

 * *Files identical despite different names*

### Comparing `GDAL-3.8.5/gdal-utils/osgeo_utils/samples/crs2crs2grid.py` & `GDAL-3.9.0/gdal-utils/osgeo_utils/samples/crs2crs2grid.py`

 * *Files identical despite different names*

### Comparing `GDAL-3.8.5/gdal-utils/osgeo_utils/samples/densify.py` & `GDAL-3.9.0/gdal-utils/osgeo_utils/samples/densify.py`

 * *Files identical despite different names*

### Comparing `GDAL-3.8.5/gdal-utils/osgeo_utils/samples/dump_jp2.py` & `GDAL-3.9.0/gdal-utils/osgeo_utils/samples/dump_jp2.py`

 * *Files identical despite different names*

### Comparing `GDAL-3.8.5/gdal-utils/osgeo_utils/samples/epsg_tr.py` & `GDAL-3.9.0/gdal-utils/osgeo_utils/samples/epsg_tr.py`

 * *Files identical despite different names*

### Comparing `GDAL-3.8.5/gdal-utils/osgeo_utils/samples/esri2wkt.py` & `GDAL-3.9.0/gdal-utils/osgeo_utils/samples/esri2wkt.py`

 * *Files identical despite different names*

### Comparing `GDAL-3.8.5/gdal-utils/osgeo_utils/samples/fft.py` & `GDAL-3.9.0/gdal-utils/osgeo_utils/samples/fft.py`

 * *Files identical despite different names*

### Comparing `GDAL-3.8.5/gdal-utils/osgeo_utils/samples/fix_gpkg.py` & `GDAL-3.9.0/gdal-utils/osgeo_utils/samples/fix_gpkg.py`

 * *Files identical despite different names*

### Comparing `GDAL-3.8.5/gdal-utils/osgeo_utils/samples/gcps2ogr.py` & `GDAL-3.9.0/gdal-utils/osgeo_utils/samples/gcps2ogr.py`

 * *Files identical despite different names*

### Comparing `GDAL-3.8.5/gdal-utils/osgeo_utils/samples/gcps2vec.py` & `GDAL-3.9.0/gdal-utils/osgeo_utils/samples/gcps2vec.py`

 * *Files identical despite different names*

### Comparing `GDAL-3.8.5/gdal-utils/osgeo_utils/samples/gcps2wld.py` & `GDAL-3.9.0/gdal-utils/osgeo_utils/samples/gcps2wld.py`

 * *Files identical despite different names*

### Comparing `GDAL-3.8.5/gdal-utils/osgeo_utils/samples/gdal2grd.py` & `GDAL-3.9.0/gdal-utils/osgeo_utils/samples/gdal2grd.py`

 * *Files identical despite different names*

### Comparing `GDAL-3.8.5/gdal-utils/osgeo_utils/samples/gdal_auth.py` & `GDAL-3.9.0/gdal-utils/osgeo_utils/samples/gdal_auth.py`

 * *Files identical despite different names*

### Comparing `GDAL-3.8.5/gdal-utils/osgeo_utils/samples/gdal_cp.py` & `GDAL-3.9.0/gdal-utils/osgeo_utils/samples/gdal_cp.py`

 * *Files identical despite different names*

### Comparing `GDAL-3.8.5/gdal-utils/osgeo_utils/samples/gdal_create_pdf.py` & `GDAL-3.9.0/gdal-utils/osgeo_utils/samples/gdal_create_pdf.py`

 * *Files identical despite different names*

### Comparing `GDAL-3.8.5/gdal-utils/osgeo_utils/samples/gdal_ls.py` & `GDAL-3.9.0/gdal-utils/osgeo_utils/samples/gdal_ls.py`

 * *Files identical despite different names*

### Comparing `GDAL-3.8.5/gdal-utils/osgeo_utils/samples/gdal_lut.py` & `GDAL-3.9.0/gdal-utils/osgeo_utils/samples/gdal_lut.py`

 * *Files identical despite different names*

### Comparing `GDAL-3.8.5/gdal-utils/osgeo_utils/samples/gdal_mkdir.py` & `GDAL-3.9.0/gdal-utils/osgeo_utils/samples/gdal_mkdir.py`

 * *Files identical despite different names*

### Comparing `GDAL-3.8.5/gdal-utils/osgeo_utils/samples/gdal_remove_towgs84.py` & `GDAL-3.9.0/gdal-utils/osgeo_utils/samples/gdal_remove_towgs84.py`

 * *Files identical despite different names*

### Comparing `GDAL-3.8.5/gdal-utils/osgeo_utils/samples/gdal_rm.py` & `GDAL-3.9.0/gdal-utils/osgeo_utils/samples/gdal_rm.py`

 * *Files identical despite different names*

### Comparing `GDAL-3.8.5/gdal-utils/osgeo_utils/samples/gdal_rmdir.py` & `GDAL-3.9.0/gdal-utils/osgeo_utils/samples/gdal_rmdir.py`

 * *Files identical despite different names*

### Comparing `GDAL-3.8.5/gdal-utils/osgeo_utils/samples/gdal_vrtmerge.py` & `GDAL-3.9.0/gdal-utils/osgeo_utils/samples/gdal_vrtmerge.py`

 * *Files identical despite different names*

### Comparing `GDAL-3.8.5/gdal-utils/osgeo_utils/samples/gdalchksum.py` & `GDAL-3.9.0/gdal-utils/osgeo_utils/samples/gdalchksum.py`

 * *Files identical despite different names*

### Comparing `GDAL-3.8.5/gdal-utils/osgeo_utils/samples/gdalcopyproj.py` & `GDAL-3.9.0/gdal-utils/osgeo_utils/samples/gdalcopyproj.py`

 * *Files identical despite different names*

### Comparing `GDAL-3.8.5/gdal-utils/osgeo_utils/samples/gdalfilter.py` & `GDAL-3.9.0/gdal-utils/osgeo_utils/samples/gdalfilter.py`

 * *Files identical despite different names*

### Comparing `GDAL-3.8.5/gdal-utils/osgeo_utils/samples/gdalident.py` & `GDAL-3.9.0/gdal-utils/osgeo_utils/samples/gdalident.py`

 * *Files identical despite different names*

### Comparing `GDAL-3.8.5/gdal-utils/osgeo_utils/samples/gdalimport.py` & `GDAL-3.9.0/gdal-utils/osgeo_utils/samples/gdalimport.py`

 * *Files identical despite different names*

### Comparing `GDAL-3.8.5/gdal-utils/osgeo_utils/samples/gdalinfo.py` & `GDAL-3.9.0/gdal-utils/osgeo_utils/samples/gdalinfo.py`

 * *Files identical despite different names*

### Comparing `GDAL-3.8.5/gdal-utils/osgeo_utils/samples/gdallocationinfo.py` & `GDAL-3.9.0/gdal-utils/osgeo_utils/samples/gdallocationinfo.py`

 * *Files identical despite different names*

### Comparing `GDAL-3.8.5/gdal-utils/osgeo_utils/samples/get_soundg.py` & `GDAL-3.9.0/gdal-utils/osgeo_utils/samples/get_soundg.py`

 * *Files identical despite different names*

### Comparing `GDAL-3.8.5/gdal-utils/osgeo_utils/samples/histrep.py` & `GDAL-3.9.0/gdal-utils/osgeo_utils/samples/histrep.py`

 * *Files identical despite different names*

### Comparing `GDAL-3.8.5/gdal-utils/osgeo_utils/samples/hsv_merge.py` & `GDAL-3.9.0/gdal-utils/osgeo_utils/samples/hsv_merge.py`

 * *Files identical despite different names*

### Comparing `GDAL-3.8.5/gdal-utils/osgeo_utils/samples/jpeg_in_tiff_extract.py` & `GDAL-3.9.0/gdal-utils/osgeo_utils/samples/jpeg_in_tiff_extract.py`

 * *Files identical despite different names*

### Comparing `GDAL-3.8.5/gdal-utils/osgeo_utils/samples/load2odbc.py` & `GDAL-3.9.0/gdal-utils/osgeo_utils/samples/load2odbc.py`

 * *Files identical despite different names*

### Comparing `GDAL-3.8.5/gdal-utils/osgeo_utils/samples/loslas2ntv2.py` & `GDAL-3.9.0/gdal-utils/osgeo_utils/samples/loslas2ntv2.py`

 * *Files identical despite different names*

### Comparing `GDAL-3.8.5/gdal-utils/osgeo_utils/samples/magphase.py` & `GDAL-3.9.0/gdal-utils/osgeo_utils/samples/magphase.py`

 * *Files identical despite different names*

### Comparing `GDAL-3.8.5/gdal-utils/osgeo_utils/samples/make_fuzzer_friendly_archive.py` & `GDAL-3.9.0/gdal-utils/osgeo_utils/samples/make_fuzzer_friendly_archive.py`

 * *Files identical despite different names*

### Comparing `GDAL-3.8.5/gdal-utils/osgeo_utils/samples/mkgraticule.py` & `GDAL-3.9.0/gdal-utils/osgeo_utils/samples/mkgraticule.py`

 * *Files identical despite different names*

### Comparing `GDAL-3.8.5/gdal-utils/osgeo_utils/samples/ogr2ogr.py` & `GDAL-3.9.0/gdal-utils/osgeo_utils/samples/validate_jp2.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,1920 +1,1753 @@
 #!/usr/bin/env python3
 # -*- coding: utf-8 -*-
-# *****************************************************************************
-# $Id$
+# ******************************************************************************
+#  $Id$
 #
-# Project:  OpenGIS Simple Features Reference Implementation
-# Purpose:  Python port of a simple client for translating between formats.
-# Author:   Even Rouault, <even dot rouault at spatialys.com>
+#  Project:  GDAL
+#  Purpose:  Validate JPEG2000 file structure
+#  Author:   Even Rouault, <even dot rouault at spatialys dot com>
 #
-# Port from ogr2ogr.cpp whose author is Frank Warmerdam
+# ******************************************************************************
+#  Copyright (c) 2015, European Union (European Environment Agency)
 #
-# *****************************************************************************
-# Copyright (c) 2010-2013, Even Rouault <even dot rouault at spatialys.com>
-# Copyright (c) 1999, Frank Warmerdam
+#  Permission is hereby granted, free of charge, to any person obtaining a
+#  copy of this software and associated documentation files (the "Software"),
+#  to deal in the Software without restriction, including without limitation
+#  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+#  and/or sell copies of the Software, and to permit persons to whom the
+#  Software is furnished to do so, subject to the following conditions:
 #
-# Permission is hereby granted, free of charge, to any person obtaining a
-# copy of this software and associated documentation files (the "Software"),
-# to deal in the Software without restriction, including without limitation
-# the rights to use, copy, modify, merge, publish, distribute, sublicense,
-# and/or sell copies of the Software, and to permit persons to whom the
-# Software is furnished to do so, subject to the following conditions:
+#  The above copyright notice and this permission notice shall be included
+#  in all copies or substantial portions of the Software.
 #
-# The above copyright notice and this permission notice shall be included
-# in all copies or substantial portions of the Software.
-#
-# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
-# OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
-# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-# DEALINGS IN THE SOFTWARE.
-# **************************************************************************
-
-# Note : this is the most direct port of ogr2ogr.cpp possible
-# It could be made much more Python'ish !
+#  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+#  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+#  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+#  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+#  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+#  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+#  DEALINGS IN THE SOFTWARE.
+# ******************************************************************************
 
 import os
-import stat
 import sys
 
-from osgeo import gdal, ogr, osr
-
-###############################################################################
-
-
-class ScaledProgressObject(object):
-    def __init__(self, mini, maxi, cbk, cbk_data=None):
-        self.min = mini
-        self.max = maxi
-        self.cbk = cbk
-        self.cbk_data = cbk_data
-
-
-###############################################################################
-
-
-def ScaledProgressFunc(pct, msg, data):
-    if data.cbk is None:
-        return True
-    return data.cbk(data.min + pct * (data.max - data.min), msg, data.cbk_data)
-
-
-###############################################################################
-
-
-def EQUAL(a, b):
-    return a.lower() == b.lower()
-
-
-###############################################################################
-# Redefinition of GDALTermProgress, so that test_ogr2ogr_py.py
-# can check that the progress bar is displayed
-
-
-nLastTick = -1
-
-
-def TermProgress(dfComplete, pszMessage, pProgressArg):
-    # pylint: disable=unused-argument
-
-    global nLastTick
-    nThisTick = int(dfComplete * 40.0)
-
-    if nThisTick < 0:
-        nThisTick = 0
-    if nThisTick > 40:
-        nThisTick = 40
+from osgeo import gdal, osr
 
-    # Have we started a new progress run?
-    if nThisTick < nLastTick and nLastTick >= 39:
-        nLastTick = -1
 
-    if nThisTick <= nLastTick:
-        return True
-
-    while nThisTick > nLastTick:
-        nLastTick = nLastTick + 1
-        if (nLastTick % 4) == 0:
-            sys.stdout.write("%d" % ((nLastTick / 4) * 10))
-        else:
-            sys.stdout.write(".")
-
-    if nThisTick == 40:
-        print(" - done.")
-    else:
-        sys.stdout.flush()
-
-    return True
-
-
-class TargetLayerInfo(object):
-    def __init__(self):
-        self.poDstLayer = None
-        self.poCT = None
-        # self.papszTransformOptions = None
-        self.panMap = None
-        self.iSrcZField = None
-
-
-class AssociatedLayers(object):
-    def __init__(self):
-        self.poSrcLayer = None
-        self.psInfo = None
-
-
-# **********************************************************************
-#                                main()
-# **********************************************************************
-
-
-bSkipFailures = False
-nGroupTransactions = 200
-bPreserveFID = False
-nFIDToFetch = ogr.NullFID
-
-
-class Enum(set):
-    def __getattr__(self, name):
-        if name in self:
-            return name
-        raise AttributeError
-
-
-GeomOperation = Enum(["NONE", "SEGMENTIZE", "SIMPLIFY_PRESERVE_TOPOLOGY"])
-
-
-def main(args=None, progress_func=TermProgress, progress_data=None):
-
-    global bSkipFailures
-    global nGroupTransactions
-    global bPreserveFID
-    global nFIDToFetch
-
-    version_num = int(gdal.VersionInfo("VERSION_NUM"))
-    if version_num < 1800:  # because of ogr.GetFieldTypeName
-        print("ERROR: Python bindings of GDAL 1.8.0 or later required")
-        return 1
-
-    pszFormat = "ESRI Shapefile"
-    pszDataSource = None
-    pszDestDataSource = None
-    papszLayers = []
-    papszDSCO = []
-    papszLCO = []
-    bTransform = False
-    bAppend = False
-    bUpdate = False
-    bOverwrite = False
-    pszOutputSRSDef = None
-    pszSourceSRSDef = None
-    poOutputSRS = None
-    bNullifyOutputSRS = False
-    poSourceSRS = None
-    pszNewLayerName = None
-    pszWHERE = None
-    poSpatialFilter = None
-    pszSelect = None
-    papszSelFields = None
-    pszSQLStatement = None
-    eGType = -2
-    bPromoteToMulti = False
-    eGeomOp = GeomOperation.NONE
-    dfGeomOpParam = 0
-    papszFieldTypesToString = []
-    bDisplayProgress = False
-    pfnProgress = None
-    pProgressArg = None
-    bClipSrc = False
-    bWrapDateline = False
-    poClipSrc = None
-    pszClipSrcDS = None
-    pszClipSrcSQL = None
-    pszClipSrcLayer = None
-    pszClipSrcWhere = None
-    poClipDst = None
-    pszClipDstDS = None
-    pszClipDstSQL = None
-    pszClipDstLayer = None
-    pszClipDstWhere = None
-    # pszSrcEncoding = None
-    # pszDstEncoding = None
-    bWrapDateline = False
-    bExplodeCollections = False
-    pszZField = None
-    nCoordDim = -1
-
-    if args is None:
-        args = sys.argv
-
-    args = ogr.GeneralCmdLineProcessor(args)
-
-    # --------------------------------------------------------------------
-    #      Processing command line arguments.
-    # --------------------------------------------------------------------
-    if args is None:
-        return 2
-
-    nArgc = len(args)
-
-    iArg = 1
-    while iArg < nArgc:
-        if EQUAL(args[iArg], "-f") and iArg < nArgc - 1:
-            iArg = iArg + 1
-            pszFormat = args[iArg]
-
-        elif EQUAL(args[iArg], "-dsco") and iArg < nArgc - 1:
-            iArg = iArg + 1
-            papszDSCO.append(args[iArg])
-
-        elif EQUAL(args[iArg], "-lco") and iArg < nArgc - 1:
-            iArg = iArg + 1
-            papszLCO.append(args[iArg])
-
-        elif EQUAL(args[iArg], "-preserve_fid"):
-            bPreserveFID = True
-
-        elif len(args[iArg]) >= 5 and EQUAL(args[iArg][0:5], "-skip"):
-            bSkipFailures = True
-            nGroupTransactions = 1  # 2409
-
-        elif EQUAL(args[iArg], "-append"):
-            bAppend = True
-            bUpdate = True
-
-        elif EQUAL(args[iArg], "-overwrite"):
-            bOverwrite = True
-            bUpdate = True
-
-        elif EQUAL(args[iArg], "-update"):
-            bUpdate = True
-
-        elif EQUAL(args[iArg], "-fid") and iArg < nArgc - 1:
-            iArg = iArg + 1
-            nFIDToFetch = int(args[iArg])
-
-        elif EQUAL(args[iArg], "-sql") and iArg < nArgc - 1:
-            iArg = iArg + 1
-            pszSQLStatement = args[iArg]
-
-        elif EQUAL(args[iArg], "-nln") and iArg < nArgc - 1:
-            iArg = iArg + 1
-            pszNewLayerName = args[iArg]
-
-        elif EQUAL(args[iArg], "-nlt") and iArg < nArgc - 1:
-
-            if EQUAL(args[iArg + 1], "NONE"):
-                eGType = ogr.wkbNone
-            elif EQUAL(args[iArg + 1], "GEOMETRY"):
-                eGType = ogr.wkbUnknown
-            elif EQUAL(args[iArg + 1], "PROMOTE_TO_MULTI"):
-                bPromoteToMulti = True
-            elif EQUAL(args[iArg + 1], "POINT"):
-                eGType = ogr.wkbPoint
-            elif EQUAL(args[iArg + 1], "LINESTRING"):
-                eGType = ogr.wkbLineString
-            elif EQUAL(args[iArg + 1], "POLYGON"):
-                eGType = ogr.wkbPolygon
-            elif EQUAL(args[iArg + 1], "GEOMETRYCOLLECTION"):
-                eGType = ogr.wkbGeometryCollection
-            elif EQUAL(args[iArg + 1], "MULTIPOINT"):
-                eGType = ogr.wkbMultiPoint
-            elif EQUAL(args[iArg + 1], "MULTILINESTRING"):
-                eGType = ogr.wkbMultiLineString
-            elif EQUAL(args[iArg + 1], "MULTIPOLYGON"):
-                eGType = ogr.wkbMultiPolygon
-            elif EQUAL(args[iArg + 1], "GEOMETRY25D"):
-                eGType = ogr.wkbUnknown | ogr.wkb25DBit
-            elif EQUAL(args[iArg + 1], "POINT25D"):
-                eGType = ogr.wkbPoint25D
-            elif EQUAL(args[iArg + 1], "LINESTRING25D"):
-                eGType = ogr.wkbLineString25D
-            elif EQUAL(args[iArg + 1], "POLYGON25D"):
-                eGType = ogr.wkbPolygon25D
-            elif EQUAL(args[iArg + 1], "GEOMETRYCOLLECTION25D"):
-                eGType = ogr.wkbGeometryCollection25D
-            elif EQUAL(args[iArg + 1], "MULTIPOINT25D"):
-                eGType = ogr.wkbMultiPoint25D
-            elif EQUAL(args[iArg + 1], "MULTILINESTRING25D"):
-                eGType = ogr.wkbMultiLineString25D
-            elif EQUAL(args[iArg + 1], "MULTIPOLYGON25D"):
-                eGType = ogr.wkbMultiPolygon25D
-            else:
-                print("-nlt %s: type not recognised." % args[iArg + 1])
-                return 1
+def Usage():
+    print(
+        "Usage: validate_jp2 [-expected_gmljp2] [-inspire_tg] [-datatype imagery|non_imagery]"
+    )
+    print(
+        "                    [-oidoc in.xml] [-ogc_schemas_location path|disabled] test.jp2"
+    )
+    print("")
+    print("Options:")
+    print("-expected_gmljp2: hint to indicate that a GMLJP2 box should be present.")
+    print("-inspire_tg: Validate using Inspire Orthoimagery technical guidelines.")
+    print(
+        "-datatype imagery|non_imagery: To specify the nature of the data. Defaults is imagery."
+    )
+    print("                               Only used by -inspire_tg")
+    print(
+        "-oidoc: XML document conforming with Inspire Orthoimagery GML application schema."
+    )
+    print(
+        "-ogc_schemas_location: Path to directory with OGC schemas. Needed for GMLJP2 validation."
+    )
+    return 2
 
-            iArg = iArg + 1
 
-        elif EQUAL(args[iArg], "-dim") and iArg < nArgc - 1:
+XML_TYPE_IDX = 0
+XML_VALUE_IDX = 1
+XML_FIRST_CHILD_IDX = 2
+
+
+def find_xml_node(ar, element_name, only_attributes=False):
+    # type = ar[XML_TYPE_IDX]
+    value = ar[XML_VALUE_IDX]
+    if value == element_name:
+        return ar
+    for child_idx in range(XML_FIRST_CHILD_IDX, len(ar)):
+        child = ar[child_idx]
+        if only_attributes and child[XML_TYPE_IDX] != gdal.CXT_Attribute:
+            continue
+        found = find_xml_node(child, element_name)
+        if found is not None:
+            return found
+    return None
+
+
+def get_attribute_val(ar, attr_name):
+    node = find_xml_node(ar, attr_name, True)
+    if node is None or node[XML_TYPE_IDX] != gdal.CXT_Attribute:
+        return None
+    if (
+        len(ar) > XML_FIRST_CHILD_IDX
+        and node[XML_FIRST_CHILD_IDX][XML_TYPE_IDX] == gdal.CXT_Text
+    ):
+        return node[XML_FIRST_CHILD_IDX][XML_VALUE_IDX]
+    return None
 
-            nCoordDim = int(args[iArg + 1])
-            if nCoordDim != 2 and nCoordDim != 3:
-                print("-dim %s: value not handled." % args[iArg + 1])
-                return 1
-            iArg = iArg + 1
 
-        elif (
-            EQUAL(args[iArg], "-tg") or EQUAL(args[iArg], "-gt")
-        ) and iArg < nArgc - 1:
-            iArg = iArg + 1
-            nGroupTransactions = int(args[iArg])
-
-        elif EQUAL(args[iArg], "-s_srs") and iArg < nArgc - 1:
-            iArg = iArg + 1
-            pszSourceSRSDef = args[iArg]
-
-        elif EQUAL(args[iArg], "-a_srs") and iArg < nArgc - 1:
-            iArg = iArg + 1
-            pszOutputSRSDef = args[iArg]
-            if EQUAL(pszOutputSRSDef, "NULL") or EQUAL(pszOutputSRSDef, "NONE"):
-                pszOutputSRSDef = None
-                bNullifyOutputSRS = True
-
-        elif EQUAL(args[iArg], "-t_srs") and iArg < nArgc - 1:
-            iArg = iArg + 1
-            pszOutputSRSDef = args[iArg]
-            bTransform = True
-
-        elif EQUAL(args[iArg], "-spat") and iArg + 4 < nArgc:
-            oRing = ogr.Geometry(ogr.wkbLinearRing)
-
-            oRing.AddPoint_2D(float(args[iArg + 1]), float(args[iArg + 2]))
-            oRing.AddPoint_2D(float(args[iArg + 1]), float(args[iArg + 4]))
-            oRing.AddPoint_2D(float(args[iArg + 3]), float(args[iArg + 4]))
-            oRing.AddPoint_2D(float(args[iArg + 3]), float(args[iArg + 2]))
-            oRing.AddPoint_2D(float(args[iArg + 1]), float(args[iArg + 2]))
-
-            poSpatialFilter = ogr.Geometry(ogr.wkbPolygon)
-            poSpatialFilter.AddGeometry(oRing)
-            iArg = iArg + 4
-
-        elif EQUAL(args[iArg], "-where") and iArg < nArgc - 1:
-            iArg = iArg + 1
-            pszWHERE = args[iArg]
-
-        elif EQUAL(args[iArg], "-select") and iArg < nArgc - 1:
-            iArg = iArg + 1
-            pszSelect = args[iArg]
-            if pszSelect.find(",") != -1:
-                papszSelFields = pszSelect.split(",")
-            else:
-                papszSelFields = pszSelect.split(" ")
-            if papszSelFields[0] == "":
-                papszSelFields = []
-
-        elif EQUAL(args[iArg], "-simplify") and iArg < nArgc - 1:
-            iArg = iArg + 1
-            eGeomOp = GeomOperation.SIMPLIFY_PRESERVE_TOPOLOGY
-            dfGeomOpParam = float(args[iArg])
-
-        elif EQUAL(args[iArg], "-segmentize") and iArg < nArgc - 1:
-            iArg = iArg + 1
-            eGeomOp = GeomOperation.SEGMENTIZE
-            dfGeomOpParam = float(args[iArg])
-
-        elif EQUAL(args[iArg], "-fieldTypeToString") and iArg < nArgc - 1:
-            iArg = iArg + 1
-            pszFieldTypeToString = args[iArg]
-            if pszFieldTypeToString.find(",") != -1:
-                tokens = pszFieldTypeToString.split(",")
+def find_message(ar):
+    msg = get_attribute_val(ar, "message")
+    if msg is None:
+        return "unknown"
+    return msg
+
+
+def find_element_with_name(ar, element_name, name, attribute_name="name"):
+    typ = ar[XML_TYPE_IDX]
+    value = ar[XML_VALUE_IDX]
+    if (
+        typ == gdal.CXT_Element
+        and value == element_name
+        and get_attribute_val(ar, attribute_name) == name
+    ):
+        return ar
+    for child_idx in range(XML_FIRST_CHILD_IDX, len(ar)):
+        child = ar[child_idx]
+        found = find_element_with_name(child, element_name, name, attribute_name)
+        if found:
+            return found
+    return None
+
+
+def find_jp2box(ar, jp2box_name):
+    return find_element_with_name(ar, "JP2Box", jp2box_name)
+
+
+def find_marker(ar, marker_name):
+    return find_element_with_name(ar, "Marker", marker_name)
+
+
+def get_count_and_indices_of_jp2boxes(ar):
+    the_dic = {}
+    for child_idx in range(XML_FIRST_CHILD_IDX, len(ar)):
+        child = ar[child_idx]
+        if child[XML_TYPE_IDX] == gdal.CXT_Element and child[XML_VALUE_IDX] == "JP2Box":
+            jp2box_name = get_attribute_val(child, "name")
+            if jp2box_name in the_dic:
+                the_dic[jp2box_name] = (
+                    the_dic[jp2box_name][0] + 1,
+                    the_dic[jp2box_name][1],
+                )
             else:
-                tokens = pszFieldTypeToString.split(" ")
+                the_dic[jp2box_name] = (1, child_idx)
 
-            for token in tokens:
-                if (
-                    EQUAL(token, "Integer")
-                    or EQUAL(token, "Real")
-                    or EQUAL(token, "String")
-                    or EQUAL(token, "Date")
-                    or EQUAL(token, "Time")
-                    or EQUAL(token, "DateTime")
-                    or EQUAL(token, "Binary")
-                    or EQUAL(token, "IntegerList")
-                    or EQUAL(token, "RealList")
-                    or EQUAL(token, "StringList")
-                ):
+    return the_dic
 
-                    papszFieldTypesToString.append(token)
-
-                elif EQUAL(token, "All"):
-                    papszFieldTypesToString = ["All"]
-                    break
 
+def get_count_of_uuidboxes(ar):
+    the_dic = {}
+    for child_idx in range(XML_FIRST_CHILD_IDX, len(ar)):
+        child = ar[child_idx]
+        if child[XML_TYPE_IDX] == gdal.CXT_Element and child[XML_VALUE_IDX] == "JP2Box":
+            jp2box_name = get_attribute_val(child, "name")
+            if jp2box_name == "uuid":
+                uuid = get_element_val(find_xml_node(child, "UUID"))
+                if uuid in the_dic:
+                    the_dic[uuid] += 1
                 else:
-                    print("Unhandled type for fieldtypeasstring option : %s " % token)
-                    return Usage()
+                    the_dic[uuid] = 1
 
-        elif EQUAL(args[iArg], "-progress"):
-            bDisplayProgress = True
+    return the_dic
 
-        # elif EQUAL(args[iArg],"-wrapdateline") )
-        # {
-        #    bWrapDateline = True;
-        # }
-        #
-        elif EQUAL(args[iArg], "-clipsrc") and iArg < nArgc - 1:
-
-            bClipSrc = True
-            if IsNumber(args[iArg + 1]) and iArg < nArgc - 4:
-                oRing = ogr.Geometry(ogr.wkbLinearRing)
-
-                oRing.AddPoint_2D(float(args[iArg + 1]), float(args[iArg + 2]))
-                oRing.AddPoint_2D(float(args[iArg + 1]), float(args[iArg + 4]))
-                oRing.AddPoint_2D(float(args[iArg + 3]), float(args[iArg + 4]))
-                oRing.AddPoint_2D(float(args[iArg + 3]), float(args[iArg + 2]))
-                oRing.AddPoint_2D(float(args[iArg + 1]), float(args[iArg + 2]))
-
-                poClipSrc = ogr.Geometry(ogr.wkbPolygon)
-                poClipSrc.AddGeometry(oRing)
-                iArg = iArg + 4
-
-            elif (
-                len(args[iArg + 1]) >= 7 and EQUAL(args[iArg + 1][0:7], "POLYGON")
-            ) or (
-                len(args[iArg + 1]) >= 12
-                and EQUAL(args[iArg + 1][0:12], "MULTIPOLYGON")
-            ):
-                poClipSrc = ogr.CreateGeometryFromWkt(args[iArg + 1])
-                if poClipSrc is None:
-                    print(
-                        "FAILURE: Invalid geometry. Must be a valid POLYGON or MULTIPOLYGON WKT\n"
-                    )
-                    return Usage()
 
-                iArg = iArg + 1
+def find_field(ar, field_name):
+    return find_element_with_name(ar, "Field", field_name)
 
-            elif EQUAL(args[iArg + 1], "spat_extent"):
-                iArg = iArg + 1
-
-            else:
-                pszClipSrcDS = args[iArg + 1]
-                iArg = iArg + 1
 
-        elif EQUAL(args[iArg], "-clipsrcsql") and iArg < nArgc - 1:
-            pszClipSrcSQL = args[iArg + 1]
-            iArg = iArg + 1
-
-        elif EQUAL(args[iArg], "-clipsrclayer") and iArg < nArgc - 1:
-            pszClipSrcLayer = args[iArg + 1]
-            iArg = iArg + 1
-
-        elif EQUAL(args[iArg], "-clipsrcwhere") and iArg < nArgc - 1:
-            pszClipSrcWhere = args[iArg + 1]
-            iArg = iArg + 1
-
-        elif EQUAL(args[iArg], "-clipdst") and iArg < nArgc - 1:
-
-            if IsNumber(args[iArg + 1]) and iArg < nArgc - 4:
-                oRing = ogr.Geometry(ogr.wkbLinearRing)
-
-                oRing.AddPoint_2D(float(args[iArg + 1]), float(args[iArg + 2]))
-                oRing.AddPoint_2D(float(args[iArg + 1]), float(args[iArg + 4]))
-                oRing.AddPoint_2D(float(args[iArg + 3]), float(args[iArg + 4]))
-                oRing.AddPoint_2D(float(args[iArg + 3]), float(args[iArg + 2]))
-                oRing.AddPoint_2D(float(args[iArg + 1]), float(args[iArg + 2]))
-
-                poClipDst = ogr.Geometry(ogr.wkbPolygon)
-                poClipDst.AddGeometry(oRing)
-                iArg = iArg + 4
-
-            elif (
-                len(args[iArg + 1]) >= 7 and EQUAL(args[iArg + 1][0:7], "POLYGON")
-            ) or (
-                len(args[iArg + 1]) >= 12
-                and EQUAL(args[iArg + 1][0:12], "MULTIPOLYGON")
-            ):
-                poClipDst = ogr.CreateGeometryFromWkt(args[iArg + 1])
-                if poClipDst is None:
-                    print(
-                        "FAILURE: Invalid geometry. Must be a valid POLYGON or MULTIPOLYGON WKT\n"
-                    )
-                    return Usage()
-
-                iArg = iArg + 1
-
-            elif EQUAL(args[iArg + 1], "spat_extent"):
-                iArg = iArg + 1
-
-            else:
-                pszClipDstDS = args[iArg + 1]
-                iArg = iArg + 1
-
-        elif EQUAL(args[iArg], "-clipdstsql") and iArg < nArgc - 1:
-            pszClipDstSQL = args[iArg + 1]
-            iArg = iArg + 1
-
-        elif EQUAL(args[iArg], "-clipdstlayer") and iArg < nArgc - 1:
-            pszClipDstLayer = args[iArg + 1]
-            iArg = iArg + 1
-
-        elif EQUAL(args[iArg], "-clipdstwhere") and iArg < nArgc - 1:
-            pszClipDstWhere = args[iArg + 1]
-            iArg = iArg + 1
-
-        elif EQUAL(args[iArg], "-explodecollections"):
-            bExplodeCollections = True
+def get_element_val(node):
+    if node is None:
+        return None
+    for child_idx in range(XML_FIRST_CHILD_IDX, len(node)):
+        child = node[child_idx]
+        if child[XML_TYPE_IDX] == gdal.CXT_Text:
+            return child[XML_VALUE_IDX]
+    return None
+
+
+def get_field_val(ar, field_name):
+    return get_element_val(find_field(ar, field_name))
+
+
+def gdalOpenWithOpenJPEGDriverPreferably(filename):
+    drivers = []
+    jp2openjpeg_drv = gdal.GetDriverByName("JP2OpenJPEG")
+    if jp2openjpeg_drv:
+        # Deregister all drivers except JP2OpenJPEG if it exists
+        for drvname in ["JP2KAK", "JP2ECW", "JP2OpenJPEG", "JP2MrSID", "JPEG2000"]:
+            drv = gdal.GetDriverByName(drvname)
+            if drvname != "JP2OpenJPEG" and drv is not None:
+                drv.Deregister()
+            drivers.append(drv)
+
+    ds = gdal.Open(filename)
+
+    # Re-register drivers
+    if jp2openjpeg_drv:
+        jp2openjpeg_drv.Deregister()
+        for drv in drivers:
+            if drv is not None:
+                drv.Register()
+
+    return ds
+
+
+def get_gmljp2(filename):
+    ds = gdalOpenWithOpenJPEGDriverPreferably(filename)
+    if ds is None:
+        return None
+    mdd = ds.GetMetadata("xml:gml.root-instance")
+    if mdd is None:
+        return None
+    return mdd[0]
 
-        elif EQUAL(args[iArg], "-zfield") and iArg < nArgc - 1:
-            pszZField = args[iArg + 1]
-            iArg = iArg + 1
 
-        elif args[iArg][0] == "-":
-            return Usage()
+class ErrorReport(object):
+    def __init__(self, collect_internally=False):
+        self.error_count = 0
+        self.warning_count = 0
+        self.collect_internally = collect_internally
+        self.error_array = []
+        self.warning_array = []
+
+    def EmitError(self, category, msg, requirement=None, conformance_class=None):
+        self.error_count += 1
+
+        if category == "PROFILE_1" and conformance_class is None:
+            conformance_class = "A.8.14"
+
+        if requirement is not None and conformance_class is not None:
+            full_msg = "ERROR[%s, Requirement %d, Conformance class %s]: %s" % (
+                category,
+                requirement,
+                conformance_class,
+                msg,
+            )
+        elif requirement is not None:
+            full_msg = "ERROR[%s, Requirement %d]: %s" % (category, requirement, msg)
+        elif conformance_class is not None:
+            full_msg = "ERROR[%s, Conformance class %s]: %s" % (
+                category,
+                conformance_class,
+                msg,
+            )
+        else:
+            full_msg = "ERROR[%s]: %s" % (category, msg)
+        if self.collect_internally:
+            self.error_array.append(full_msg)
+        else:
+            print(full_msg)
 
-        elif pszDestDataSource is None:
-            pszDestDataSource = args[iArg]
-        elif pszDataSource is None:
-            pszDataSource = args[iArg]
+    def EmitWarning(self, category, msg, recommendation=None):
+        self.warning_count += 1
+        if recommendation is not None:
+            full_msg = "WARNING[%s, Recommendation %d]: %s" % (
+                category,
+                recommendation,
+                msg,
+            )
+        else:
+            full_msg = "WARNING[%s]: %s" % (category, msg)
+        if self.collect_internally:
+            self.warning_array.append(full_msg)
         else:
-            papszLayers.append(args[iArg])
+            print(full_msg)
 
-        iArg = iArg + 1
 
-    if pszDataSource is None:
-        return Usage()
+# Report JP2 boxes errors
 
-    if bPreserveFID and bExplodeCollections:
-        print(
-            "FAILURE: cannot use -preserve_fid and -explodecollections at the same time\n\n"
-        )
-        return Usage()
 
-    if bClipSrc and pszClipSrcDS is not None:
-        poClipSrc = LoadGeometry(
-            pszClipSrcDS, pszClipSrcSQL, pszClipSrcLayer, pszClipSrcWhere
+def find_remaining_bytes(error_report, ar, parent_node_name=None):
+    typ = ar[XML_TYPE_IDX]
+    value = ar[XML_VALUE_IDX]
+    if typ == gdal.CXT_Element and value == "JP2Box":
+        parent_node_name = get_attribute_val(ar, "name")
+    if typ == gdal.CXT_Element and value == "RemainingBytes":
+        error_report.EmitError(
+            "GENERAL",
+            "Remaining bytes in JP2 box %s: %s"
+            % (parent_node_name, get_element_val(ar)),
         )
-        if poClipSrc is None:
-            print("FAILURE: cannot load source clip geometry\n")
-            return Usage()
-
-    elif bClipSrc and poClipSrc is None:
-        if poSpatialFilter is not None:
-            poClipSrc = poSpatialFilter.Clone()
-        if poClipSrc is None:
-            print(
-                "FAILURE: -clipsrc must be used with -spat option or a\n"
-                + "bounding box, WKT string or datasource must be specified\n"
-            )
-            return Usage()
 
-    if pszClipDstDS is not None:
-        poClipDst = LoadGeometry(
-            pszClipDstDS, pszClipDstSQL, pszClipDstLayer, pszClipDstWhere
+    for child_idx in range(XML_FIRST_CHILD_IDX, len(ar)):
+        child = ar[child_idx]
+        find_remaining_bytes(error_report, child, parent_node_name)
+
+
+# Report codestream errors
+def find_errors(error_report, ar, parent_node=None):
+    typ = ar[XML_TYPE_IDX]
+    value = ar[XML_VALUE_IDX]
+    if typ == gdal.CXT_Element and value == "Error":
+        parent_node_name = ""
+        if parent_node is not None:
+            parent_node_name = get_attribute_val(parent_node, "name")
+            if parent_node_name is None:
+                parent_node_name = parent_node[XML_VALUE_IDX]
+        error_report.EmitError(
+            "GENERAL",
+            "Codestream error found on element %s: %s"
+            % (parent_node_name, find_message(ar)),
         )
-        if poClipDst is None:
-            print("FAILURE: cannot load dest clip geometry\n")
-            return Usage()
 
-    # --------------------------------------------------------------------
-    #      Open data source.
-    # --------------------------------------------------------------------
-    poDS = ogr.Open(pszDataSource, False)
-
-    # --------------------------------------------------------------------
-    #      Report failure
-    # --------------------------------------------------------------------
-    if poDS is None:
-        print(
-            "FAILURE:\n"
-            + "Unable to open datasource `%s' with the following drivers."
-            % pszDataSource
+    for child_idx in range(XML_FIRST_CHILD_IDX, len(ar)):
+        child = ar[child_idx]
+        find_errors(error_report, child, ar)
+
+
+def validate_bitsize(error_report, inspire_tg, val_ori, field_name, datatype):
+    val = val_ori
+    signedness = "unsigned"
+    nbits = 0
+    if val is not None:
+        if val >= 128:
+            signedness = "signed"
+            val -= 128
+        val += 1
+        nbits = val
+    if inspire_tg and val != 1 and val != 8 and val != 16 and val != 32:
+        error_report.EmitError(
+            "INSPIRE_TG",
+            "%s=%s (%s %d bits), which is not allowed"
+            % (field_name, str(val_ori), signedness, nbits),
+            requirement=24,
+            conformance_class="A.8.9",
+        )
+    elif (
+        inspire_tg
+        and datatype == "imagery"
+        and ((val != 1 and val != 8 and val != 16) or val_ori >= 128)
+    ):
+        error_report.EmitError(
+            "INSPIRE_TG",
+            "%s=%s (%s %d bits), which is not allowed for Orthoimagery (but OK for other data)"
+            % (field_name, str(val_ori), signedness, nbits),
+            requirement=27,
+            conformance_class="A.8.9",
+        )
+    elif val is None or val > 37:
+        error_report.EmitError(
+            "GENERAL",
+            "%s=%s (%s %d bits), which is not allowed"
+            % (field_name, str(val_ori), signedness, nbits),
         )
 
-        for iDriver in range(ogr.GetDriverCount()):
-            print("  ->  " + ogr.GetDriver(iDriver).GetName())
 
-        return 1
+def int_or_none(val):
+    if val is None:
+        return None
+    return int(val)
 
-    # --------------------------------------------------------------------
-    #      Try opening the output datasource as an existing, writable
-    # --------------------------------------------------------------------
-    poODS = None
-    poDriver = None
-
-    if bUpdate:
-        with ogr.ExceptionMgr(useExceptions=False), gdal.quiet_errors():
-            poODS = ogr.Open(pszDestDataSource, True)
-        if poODS is None:
-
-            if bOverwrite or bAppend:
-                with ogr.ExceptionMgr(useExceptions=False), gdal.quiet_errors():
-                    poODS = ogr.Open(pszDestDataSource, False)
-                if poODS is None:
-                    # the datasource doesn't exist at all
-                    bUpdate = False
-                else:
-                    poODS.delete()
-                    poODS = None
 
-            if bUpdate:
-                print(
-                    "FAILURE:\n"
-                    + "Unable to open existing output datasource `%s'."
-                    % pszDestDataSource
-                )
-                return 1
+def check_geojp2_gmljp2_consistency(filename, error_report):
+    gdal.SetConfigOption("GDAL_USE_GEOJP2", "YES")
+    gdal.SetConfigOption("GDAL_USE_GMLJP2", "NO")
+    ds = gdalOpenWithOpenJPEGDriverPreferably(filename)
+    if ds is None:
+        error_report.EmitError(
+            "GENERAL", "Cannot open %s with a JPEG2000 compatible driver" % filename
+        )
+        return
+    geojp2_gt = ds.GetGeoTransform()
+    geojp2_wkt = ds.GetProjectionRef()
+    geojp2_gcps = ds.GetGCPCount()
+    ds = None
+
+    gdal.SetConfigOption("GDAL_USE_GEOJP2", "NO")
+    gdal.SetConfigOption("GDAL_USE_GMLJP2", "YES")
+    ds = gdalOpenWithOpenJPEGDriverPreferably(filename)
+    gmljp2_gt = ds.GetGeoTransform()
+    gmljp2_wkt = ds.GetProjectionRef()
+    ds = None
+
+    gdal.SetConfigOption("GDAL_USE_GEOJP2", None)
+    gdal.SetConfigOption("GDAL_USE_GMLJP2", None)
+
+    if geojp2_gcps == 0:
+        diff = False
+        for i in range(6):
+            if abs(geojp2_gt[i] - gmljp2_gt[i] > 1e-8):
+                diff = True
+        if diff:
+            error_report.EmitError(
+                "GENERAL",
+                "Inconsistent geotransform between GeoJP2 (%s) and GMLJP2 (%s)"
+                % (str(geojp2_gt), str(gmljp2_gt)),
+            )
 
-        elif papszDSCO:
-            print(
-                "WARNING: Datasource creation options ignored since an existing datasource\n"
-                + "         being updated."
+    geojp2_sr = osr.SpatialReference()
+    geojp2_sr.ImportFromWkt(geojp2_wkt)
+    geojp2_epsg_code = geojp2_sr.GetAuthorityCode(None)
+    gmljp2_sr = osr.SpatialReference()
+    gmljp2_sr.ImportFromWkt(gmljp2_wkt)
+    gmljp2_epsg_code = gmljp2_sr.GetAuthorityCode(None)
+    if geojp2_sr.IsSame(gmljp2_sr) == 0 and geojp2_epsg_code != gmljp2_epsg_code:
+        geojp2_proj4 = geojp2_sr.ExportToProj4()
+        gmljp2_proj4 = gmljp2_sr.ExportToProj4()
+        if geojp2_proj4 != gmljp2_proj4:
+            error_report.EmitError(
+                "GENERAL",
+                "Inconsistent SRS between GeoJP2 (wkt=%s, proj4=%s) and GMLJP2 (wkt=%s, proj4=%s)"
+                % (geojp2_wkt, geojp2_proj4, gmljp2_wkt, gmljp2_proj4),
             )
 
-        if poODS is not None:
-            poDriver = poODS.GetDriver()
 
-    # --------------------------------------------------------------------
-    #      Find the output driver.
-    # --------------------------------------------------------------------
-    if not bUpdate:
-        poDriver = ogr.GetDriverByName(pszFormat)
-        if poDriver is None:
-            print("Unable to find driver `%s'." % pszFormat)
-            print("The following drivers are available:")
-
-            for iDriver in range(ogr.GetDriverCount()):
-                print("  ->  %s" % ogr.GetDriver(iDriver).GetName())
-
-            return 1
-
-        if not poDriver.TestCapability(ogr.ODrCCreateDataSource):
-            print("%s driver does not support data source creation." % pszFormat)
-            return 1
-
-        # --------------------------------------------------------------------
-        #      Special case to improve user experience when translating
-        #      a datasource with multiple layers into a shapefile. If the
-        #      user gives a target datasource with .shp and it does not exist,
-        #      the shapefile driver will try to create a file, but this is not
-        #      appropriate because here we have several layers, so create
-        #      a directory instead.
-        # --------------------------------------------------------------------
-        if (
-            EQUAL(poDriver.GetName(), "ESRI Shapefile")
-            and pszSQLStatement is None
-            and (len(papszLayers) > 1 or (not papszLayers and poDS.GetLayerCount() > 1))
-            and pszNewLayerName is None
-            and EQUAL(os.path.splitext(pszDestDataSource)[1], ".SHP")
-        ):
+# Check consistency of georeferencing of OrthoimageCoverage with the one embedded in the JPEG2000 file
+def check_oi_rg_consistency(filename, serialized_oi_rg, error_report):
+    if gdal.GetDriverByName("JP2OpenJPEG") is None:
+        return
 
-            try:
-                os.stat(pszDestDataSource)
-            except OSError:
-                try:
-                    # decimal 493 = octal 0755. Python 3 needs 0o755, but
-                    # this syntax is only supported by Python >= 2.6
-                    os.mkdir(pszDestDataSource, 493)
-                except OSError:
-                    print(
-                        "Failed to create directory %s\n"
-                        "for shapefile datastore.\n" % pszDestDataSource
-                    )
-                    return 1
-
-        # --------------------------------------------------------------------
-        #      Create the output data source.
-        # --------------------------------------------------------------------
-        poODS = poDriver.CreateDataSource(pszDestDataSource, options=papszDSCO)
-        if poODS is None:
-            print("%s driver failed to create %s" % (pszFormat, pszDestDataSource))
-            return 1
-
-    # --------------------------------------------------------------------
-    #      Parse the output SRS definition if possible.
-    # --------------------------------------------------------------------
-    if pszOutputSRSDef is not None:
-        poOutputSRS = osr.SpatialReference()
-        poOutputSRS.SetAxisMappingStrategy(osr.OAMS_TRADITIONAL_GIS_ORDER)
-        if poOutputSRS.SetFromUserInput(pszOutputSRSDef) != 0:
-            print("Failed to process SRS definition: %s" % pszOutputSRSDef)
-            return 1
-
-    # --------------------------------------------------------------------
-    #      Parse the source SRS definition if possible.
-    # --------------------------------------------------------------------
-    if pszSourceSRSDef is not None:
-        poSourceSRS = osr.SpatialReference()
-        poSourceSRS.SetAxisMappingStrategy(osr.OAMS_TRADITIONAL_GIS_ORDER)
-        if poSourceSRS.SetFromUserInput(pszSourceSRSDef) != 0:
-            print("Failed to process SRS definition: %s" % pszSourceSRSDef)
-            return 1
-
-    # --------------------------------------------------------------------
-    #      For OSM file.
-    # --------------------------------------------------------------------
-    bSrcIsOSM = poDS.GetDriver() is not None and poDS.GetDriver().GetName() == "OSM"
-    nSrcFileSize = 0
-    if bSrcIsOSM and poDS.GetName() != "/vsistdin/":
-        sStat = gdal.VSIStatL(poDS.GetName())
-        if sStat is not None:
-            nSrcFileSize = sStat.size
-
-    # --------------------------------------------------------------------
-    #      Special case for -sql clause.  No source layers required.
-    # --------------------------------------------------------------------
-    if pszSQLStatement is not None:
-        if pszWHERE is not None:
-            print("-where clause ignored in combination with -sql.")
-        if papszLayers:
-            print("layer names ignored in combination with -sql.")
-
-        poResultSet = poDS.ExecuteSQL(pszSQLStatement, poSpatialFilter, None)
-
-        if poResultSet is not None:
-            nCountLayerFeatures = 0
-            if bDisplayProgress:
-                if bSrcIsOSM:
-                    pfnProgress = progress_func
-                    pProgressArg = progress_data
-
-                elif not poResultSet.TestCapability(ogr.OLCFastFeatureCount):
-                    print("Progress turned off as fast feature count is not available.")
-                    bDisplayProgress = False
+    ds = gdalOpenWithOpenJPEGDriverPreferably(filename)
+    if ds is None:
+        error_report.EmitError(
+            "GENERAL", "Cannot open %s with a JPEG2000 compatible driver" % filename
+        )
+        return "fail"
+    gt = ds.GetGeoTransform()
+    wkt = ds.GetProjectionRef()
+    gcps = ds.GetGCPCount()
+    ds = None
+
+    gmljp2_from_oi = (
+        """<gml:FeatureCollection xmlns:gml="http://www.opengis.net/gml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.opengis.net/gml http://schemas.opengis.net/gml/3.1.1/profiles/gmlJP2Profile/1.0.0/gmlJP2Profile.xsd">
+        <gml:boundedBy>
+        <gml:Null>withheld</gml:Null>
+        </gml:boundedBy>
+        <gml:featureMember>
+        <gml:FeatureCollection>
+            <gml:featureMember>
+            <gml:RectifiedGridCoverage dimension="2" gml:id="RGC0001">
+                <gml:rectifiedGridDomain>
+                    %s
+                </gml:rectifiedGridDomain>
+                <gml:rangeSet>
+                <gml:File>
+                    <gml:rangeParameters />
+                    <gml:fileName>gmljp2://codestream/0</gml:fileName>
+                    <gml:fileStructure>Record Interleaved</gml:fileStructure>
+                </gml:File>
+                </gml:rangeSet>
+            </gml:RectifiedGridCoverage>
+            </gml:featureMember>
+        </gml:FeatureCollection>
+        </gml:featureMember>
+    </gml:FeatureCollection>"""
+        % serialized_oi_rg
+    )
+    gdal.SetConfigOption("GMLJP2OVERRIDE", "/vsimem/override.gml")
+    gdal.FileFromMemBuffer("/vsimem/override.gml", gmljp2_from_oi)
+    fake_in_ds = gdal.GetDriverByName("MEM").Create("", 10, 10, 1)
+    fake_in_ds.SetGeoTransform([0, 60, 0, 0, 0, -60])
+    gdal.GetDriverByName("JP2OpenJPEG").CreateCopy(
+        "/vsimem/temp.jp2", fake_in_ds, options=["GeoJP2=NO"]
+    )
+    gdal.SetConfigOption("GMLJP2OVERRIDE", None)
+    gdal.Unlink("/vsimem/override.gml")
 
-                else:
-                    nCountLayerFeatures = poResultSet.GetFeatureCount()
-                    pfnProgress = progress_func
-                    pProgressArg = progress_data
-
-            # --------------------------------------------------------------------
-            #      Special case to improve user experience when translating into
-            #      single file shapefile and source has only one layer, and that
-            #      the layer name isn't specified
-            # --------------------------------------------------------------------
-            if EQUAL(poDriver.GetName(), "ESRI Shapefile") and pszNewLayerName is None:
-                try:
-                    mode = os.stat(pszDestDataSource).st_mode
-                    if (mode & stat.S_IFDIR) == 0:
-                        pszNewLayerName = os.path.splitext(
-                            os.path.basename(pszDestDataSource)
-                        )[0]
-                except OSError:
-                    pass
-
-            psInfo = SetupTargetLayer(
-                poDS,
-                poResultSet,
-                poODS,
-                papszLCO,
-                pszNewLayerName,
-                bTransform,
-                poOutputSRS,
-                bNullifyOutputSRS,
-                poSourceSRS,
-                papszSelFields,
-                bAppend,
-                eGType,
-                bPromoteToMulti,
-                nCoordDim,
-                bOverwrite,
-                papszFieldTypesToString,
-                bWrapDateline,
-                bExplodeCollections,
-                pszZField,
-                pszWHERE,
+    ds = gdalOpenWithOpenJPEGDriverPreferably("/vsimem/temp.jp2")
+    oi_gt = ds.GetGeoTransform()
+    oi_wkt = ds.GetProjectionRef()
+    ds = None
+    gdal.Unlink("/vsimem/temp.jp2")
+
+    if gcps == 0:
+        diff = False
+        for i in range(6):
+            if abs(oi_gt[i] - gt[i] > 1e-8):
+                diff = True
+        if diff:
+            error_report.EmitError(
+                "INSPIRE_TG",
+                "Inconsistent geotransform between OrthoImagery (%s) and GMLJP2/GeoJP2 (%s)"
+                % (str(oi_gt), str(gt)),
+                conformance_class="A.8.8",
             )
 
-            poResultSet.ResetReading()
-
-            if psInfo is None or not TranslateLayer(
-                psInfo,
-                poDS,
-                poResultSet,
-                poODS,
-                poOutputSRS,
-                bNullifyOutputSRS,
-                eGType,
-                bPromoteToMulti,
-                nCoordDim,
-                eGeomOp,
-                dfGeomOpParam,
-                nCountLayerFeatures,
-                poClipSrc,
-                poClipDst,
-                bExplodeCollections,
-                nSrcFileSize,
-                None,
-                pfnProgress,
-                pProgressArg,
-            ):
-                print(
-                    "Terminating translation prematurely after failed\n"
-                    + "translation from sql statement."
-                )
-
-                return 1
+    sr = osr.SpatialReference()
+    sr.ImportFromWkt(wkt)
+    epsg_code = sr.GetAuthorityCode(None)
+    oi_sr = osr.SpatialReference()
+    oi_sr.ImportFromWkt(oi_wkt)
+    oi_epsg_code = oi_sr.GetAuthorityCode(None)
+    if sr.IsSame(oi_sr) == 0 and epsg_code != oi_epsg_code:
+        proj4 = sr.ExportToProj4()
+        oi_proj4 = oi_sr.ExportToProj4()
+        if proj4 != oi_proj4:
+            error_report.EmitError(
+                "INSPIRE_TG",
+                "Inconsistent SRS between OrthoImagery (wkt=%s, proj4=%s) and GMLJP2/GeoJP2 (wkt=%s, proj4=%s)"
+                % (wkt, proj4, oi_wkt, oi_proj4),
+                conformance_class="A.8.8",
+            )
 
-            poDS.ReleaseResultSet(poResultSet)
 
-    # --------------------------------------------------------------------
-    #      Special case for layer interleaving mode.
-    # --------------------------------------------------------------------
-    elif bSrcIsOSM and gdal.GetConfigOption("OGR_INTERLEAVED_READING", None) is None:
-
-        gdal.SetConfigOption("OGR_INTERLEAVED_READING", "YES")
-
-        # if (bSplitListFields)
-        # {
-        #    fprintf( stderr, "FAILURE: -splitlistfields not supported in this mode\n" );
-        #    exit( 1 );
-        # }
-
-        nSrcLayerCount = poDS.GetLayerCount()
-        pasAssocLayers = [AssociatedLayers() for _ in range(nSrcLayerCount)]
-
-        # --------------------------------------------------------------------
-        #      Special case to improve user experience when translating into
-        #      single file shapefile and source has only one layer, and that
-        #      the layer name isn't specified
-        # --------------------------------------------------------------------
-
-        if (
-            EQUAL(poDriver.GetName(), "ESRI Shapefile")
-            and (len(papszLayers) == 1 or nSrcLayerCount == 1)
-            and pszNewLayerName is None
-        ):
-            try:
-                mode = os.stat(pszDestDataSource).st_mode
-                if (mode & stat.S_IFDIR) == 0:
-                    pszNewLayerName = os.path.splitext(
-                        os.path.basename(pszDestDataSource)
-                    )[0]
-            except OSError:
-                pass
+def validate(
+    filename,
+    oidoc,
+    inspire_tg,
+    expected_gmljp2,
+    ogc_schemas_location,
+    datatype="imagery",
+    error_report=None,
+    expected_ftyp_branding=None,
+):
 
-        if bDisplayProgress and bSrcIsOSM:
-            pfnProgress = progress_func
-            pProgressArg = progress_data
-
-        # --------------------------------------------------------------------
-        #      If no target layer specified, use all source layers.
-        # --------------------------------------------------------------------
-        if not papszLayers:
-            papszLayers = [None] * nSrcLayerCount
-            for iLayer in range(nSrcLayerCount):
-                poLayer = poDS.GetLayer(iLayer)
-                if poLayer is None:
-                    print("FAILURE: Couldn't fetch advertised layer %d!" % iLayer)
-                    return 1
+    if error_report is None:
+        error_report = ErrorReport()
 
-                papszLayers[iLayer] = poLayer.GetName()
-        else:
-            if bSrcIsOSM:
-                osInterestLayers = "SET interest_layers ="
-                for iLayer, papszLayer in enumerate(papszLayers):
-                    if iLayer != 0:
-                        osInterestLayers = osInterestLayers + ","
-                    osInterestLayers = osInterestLayers + papszLayer
-
-                poDS.ExecuteSQL(osInterestLayers, None, None)
-
-        # --------------------------------------------------------------------
-        #      First pass to set filters and create target layers.
-        # --------------------------------------------------------------------
-        for iLayer in range(nSrcLayerCount):
-            poLayer = poDS.GetLayer(iLayer)
-            if poLayer is None:
-                print("FAILURE: Couldn't fetch advertised layer %d!" % iLayer)
-                return 1
+    ar = gdal.GetJPEG2000Structure(filename, ["ALL=YES"])
+    if ar is None:
+        error_report.error_count = 1
+        return error_report
+
+    find_remaining_bytes(error_report, ar)
+    find_errors(error_report, ar)
+
+    if inspire_tg and ar[XML_VALUE_IDX] != "JP2File":
+        error_report.EmitError(
+            "INSPIRE_TG",
+            "The file contains only a JPEG2000 codestream, instead of being a JP2 file",
+        )
+        return error_report
 
-            pasAssocLayers[iLayer].poSrcLayer = poLayer
+    ihdr = None
+    ihdr_nc = 0
+    pclr = None
+    bpc_vals = []
+
+    if ar[XML_VALUE_IDX] == "JP2File":
+
+        # Check "jP " box
+        if not find_jp2box(ar, "jP  "):
+            error_report.EmitError("GENERAL", '"jp  " box not found')
+
+        # Detect GMLJP2 and validate it if possible
+        gmljp2 = get_gmljp2(filename)
+        gmljp2_found = gmljp2 is not None
+        if expected_gmljp2 and not gmljp2_found:
+            error_report.EmitError(
+                "GMLJP2", "No GMLJP2 box found whereas it was expected"
+            )
+        if gmljp2_found and inspire_tg and "gmljp2:GMLJP2CoverageCollection" in gmljp2:
+            error_report.EmitError(
+                "INSPIRE_TG",
+                "GMLJP2 v2 box found, but Inspire TG require GMLJP2 v1",
+                conformance_class="A.8.6",
+            )
+        if gmljp2_found and ogc_schemas_location != "disabled":
+            if ogc_schemas_location is not None:
+                sys.path.append(
+                    os.path.dirname(os.path.realpath(__file__))
+                    + "/../../../../autotest/pymod"
+                )
+                try:
+                    import xmlvalidate
 
-            if CSLFindString(papszLayers, poLayer.GetName()) >= 0:
-                if pszWHERE is not None:
-                    if poLayer.SetAttributeFilter(pszWHERE) != 0:
-                        print(
-                            "FAILURE: SetAttributeFilter(%s) on layer '%s' failed.\n"
-                            % (pszWHERE, poLayer.GetName())
+                    xml_validate_found = True
+                except ImportError:
+                    error_report.EmitWarning(
+                        "GMLJP2", "xmlvalidate not found or not runnable"
+                    )
+                    xml_validate_found = False
+                if xml_validate_found:
+                    if not xmlvalidate.validate(
+                        gmljp2, ogc_schemas_location=ogc_schemas_location
+                    ):
+                        error_report.EmitError(
+                            "GMLJP2",
+                            "Validation of GMLJP2 document failed",
+                            conformance_class="A.8.6",
                         )
-                        if not bSkipFailures:
-                            return 1
-
-                if poSpatialFilter is not None:
-                    poLayer.SetSpatialFilter(poSpatialFilter)
-
-                psInfo = SetupTargetLayer(
-                    poDS,
-                    poLayer,
-                    poODS,
-                    papszLCO,
-                    pszNewLayerName,
-                    bTransform,
-                    poOutputSRS,
-                    bNullifyOutputSRS,
-                    poSourceSRS,
-                    papszSelFields,
-                    bAppend,
-                    eGType,
-                    bPromoteToMulti,
-                    nCoordDim,
-                    bOverwrite,
-                    papszFieldTypesToString,
-                    bWrapDateline,
-                    bExplodeCollections,
-                    pszZField,
-                    pszWHERE,
+            else:
+                error_report.EmitWarning(
+                    "GMLJP2", "-ogc_schemas_location not specified"
                 )
 
-                if psInfo is None and not bSkipFailures:
-                    return 1
+        # Check that there's only one GeoTIFF box
+        count_uuidboxes = get_count_of_uuidboxes(ar)
+        if "B14BF8BD083D4B43A5AE8CD7D5A6CE03" in count_uuidboxes:
+            count_geotiff_boxes = count_uuidboxes["B14BF8BD083D4B43A5AE8CD7D5A6CE03"]
+            if count_geotiff_boxes > 1:
+                error_report.EmitError(
+                    "GeoJP2", "%d GeoTIFF UUID box found" % count_geotiff_boxes
+                )
 
-                pasAssocLayers[iLayer].psInfo = psInfo
+        # Check the content of a GeoTIFF UUID box
+        geotiff_found = (
+            find_element_with_name(ar, "UUID", "GeoTIFF", attribute_name="description")
+            is not None
+        )
+        decoded_geotiff = find_xml_node(ar, "DecodedGeoTIFF")
+        if geotiff_found:
+            if not decoded_geotiff:
+                error_report.EmitError(
+                    "GeoJP2", "GeoTIFF UUID box found, but content is not valid GeoTIFF"
+                )
             else:
-                pasAssocLayers[iLayer].psInfo = None
-
-        # --------------------------------------------------------------------
-        #      Second pass to process features in a interleaved layer mode.
-        # --------------------------------------------------------------------
-        bHasLayersNonEmpty = True
-        while bHasLayersNonEmpty:
-            bHasLayersNonEmpty = False
-
-            for iLayer in range(nSrcLayerCount):
-                poLayer = pasAssocLayers[iLayer].poSrcLayer
-                psInfo = pasAssocLayers[iLayer].psInfo
-                anReadFeatureCount = [0]
-
-                if psInfo is not None:
-                    if (
-                        not TranslateLayer(
-                            psInfo,
-                            poDS,
-                            poLayer,
-                            poODS,
-                            poOutputSRS,
-                            bNullifyOutputSRS,
-                            eGType,
-                            bPromoteToMulti,
-                            nCoordDim,
-                            eGeomOp,
-                            dfGeomOpParam,
-                            0,
-                            poClipSrc,
-                            poClipDst,
-                            bExplodeCollections,
-                            nSrcFileSize,
-                            anReadFeatureCount,
-                            pfnProgress,
-                            pProgressArg,
-                        )
-                        and not bSkipFailures
-                    ):
-                        print(
-                            "Terminating translation prematurely after failed\n"
-                            + "translation of layer "
-                            + poLayer.GetName()
-                            + " (use -skipfailures to skip errors)"
-                        )
+                vrtdataset = find_xml_node(ar, "VRTDataset")
+                w = get_attribute_val(vrtdataset, "rasterXSize")
+                if w != "1":
+                    error_report.EmitError(
+                        "GeoJP2",
+                        "GeoTIFF should have width of 1 pixel, not %s" % str(w),
+                    )
+                h = get_attribute_val(vrtdataset, "rasterXSize")
+                if h != "1":
+                    error_report.EmitError(
+                        "GeoJP2",
+                        "GeoTIFF should have height of 1 pixel, not %s" % str(h),
+                    )
 
-                        return 1
+        # Check that information of GeoJP2 and GMLJP2 are consistent
+        if geotiff_found and gmljp2_found:
+            check_geojp2_gmljp2_consistency(filename, error_report)
+
+        # Check "ftyp" box
+        ftyp = find_jp2box(ar, "ftyp")
+        if ftyp:
+            JP2CLFound = False
+            JPXCLFound = False
+
+            if expected_ftyp_branding is None:
+                if gmljp2_found and "gmljp2:GMLJP2CoverageCollection" in gmljp2:
+                    expected_ftyp_branding = "jpx "
                 else:
-                    # No matching target layer : just consumes the features
-
-                    poFeature = poLayer.GetNextFeature()
-                    while poFeature is not None:
-                        anReadFeatureCount[0] = anReadFeatureCount[0] + 1
-                        poFeature = poLayer.GetNextFeature()
+                    expected_ftyp_branding = "jp2 "
 
-                if anReadFeatureCount[0] != 0:
-                    bHasLayersNonEmpty = True
-
-    else:
+            if get_field_val(ftyp, "BR") != expected_ftyp_branding:
+                error_report.EmitError(
+                    "GENERAL",
+                    'ftyp.BR = "%s" instead of "%s"'
+                    % (get_field_val(ftyp, "BR"), expected_ftyp_branding),
+                )
 
-        nLayerCount = 0
-        papoLayers = []
+            if get_field_val(ftyp, "MinV") != "0":
+                error_report.EmitError(
+                    "GENERAL",
+                    'ftyp.MinV = "%s" instead of 0' % get_field_val(ftyp, "MinV"),
+                )
 
-        # --------------------------------------------------------------------
-        #      Process each data source layer.
-        # --------------------------------------------------------------------
-        if not papszLayers:
-            nLayerCount = poDS.GetLayerCount()
-            papoLayers = [None] * nLayerCount
-            iLayer = 0
-
-            for iLayer in range(nLayerCount):
-                poLayer = poDS.GetLayer(iLayer)
-
-                if poLayer is None:
-                    print("FAILURE: Couldn't fetch advertised layer %d!" % iLayer)
-                    return 1
-
-                papoLayers[iLayer] = poLayer
-                iLayer = iLayer + 1
-
-        # --------------------------------------------------------------------
-        #      Process specified data source layers.
-        # --------------------------------------------------------------------
-        else:
-            nLayerCount = len(papszLayers)
-            papoLayers = [None] * nLayerCount
-            iLayer = 0
-
-            for layername in papszLayers:
-                poLayer = poDS.GetLayerByName(layername)
-
-                if poLayer is None:
-                    print("FAILURE: Couldn't fetch advertised layer %s!" % layername)
-                    return 1
-
-                papoLayers[iLayer] = poLayer
-                iLayer = iLayer + 1
-
-        panLayerCountFeatures = [0] * nLayerCount
-        nCountLayersFeatures = 0
-        nAccCountFeatures = 0
-
-        # First pass to apply filters and count all features if necessary
-        for iLayer in range(nLayerCount):
-            poLayer = papoLayers[iLayer]
-
-            if pszWHERE is not None:
-                if poLayer.SetAttributeFilter(pszWHERE) != 0:
-                    print("FAILURE: SetAttributeFilter(%s) failed." % pszWHERE)
-                    if not bSkipFailures:
-                        return 1
-
-            if poSpatialFilter is not None:
-                poLayer.SetSpatialFilter(poSpatialFilter)
-
-            if bDisplayProgress and not bSrcIsOSM:
-                if not poLayer.TestCapability(ogr.OLCFastFeatureCount):
-                    print("Progress turned off as fast feature count is not available.")
-                    bDisplayProgress = False
+            for i in range(10):
+                val = get_field_val(ftyp, "CL%d" % i)
+                if val is None:
+                    break
+                if val == "jp2 ":
+                    JP2CLFound = True
+                if val == "jpx ":
+                    JPXCLFound = True
+            if not JP2CLFound:
+                error_report.EmitError(
+                    "GENERAL", '"jp2 " not found in compatibility list of ftyp'
+                )
+            if gmljp2_found and not JPXCLFound:
+                if inspire_tg:
+                    error_report.EmitError(
+                        "INSPIRE_TG",
+                        '"jpx " not found in compatibility list of ftyp, but GMLJP2 box present',
+                    )
                 else:
-                    panLayerCountFeatures[iLayer] = poLayer.GetFeatureCount()
-                    nCountLayersFeatures += panLayerCountFeatures[iLayer]
+                    error_report.EmitWarning(
+                        "GENERAL",
+                        '"jpx " not found in compatibility list of ftyp, but GMLJP2 box present',
+                    )
+        else:
+            error_report.EmitError("GENERAL", '"ftyp" box not found')
 
-        # Second pass to do the real job
-        for iLayer in range(nLayerCount):
-            poLayer = papoLayers[iLayer]
-
-            if bDisplayProgress:
-                if bSrcIsOSM:
-                    pfnProgress = progress_func
-                    pProgressArg = progress_data
-                else:
-                    pfnProgress = ScaledProgressFunc
-                    pProgressArg = ScaledProgressObject(
-                        nAccCountFeatures * 1.0 / nCountLayersFeatures,
-                        (nAccCountFeatures + panLayerCountFeatures[iLayer])
-                        * 1.0
-                        / nCountLayersFeatures,
-                        progress_func,
-                        progress_data,
-                    )
-
-            nAccCountFeatures += panLayerCountFeatures[iLayer]
-
-            # --------------------------------------------------------------------
-            #      Special case to improve user experience when translating into
-            #      single file shapefile and source has only one layer, and that
-            #      the layer name isn't specified
-            # --------------------------------------------------------------------
-            if (
-                EQUAL(poDriver.GetName(), "ESRI Shapefile")
-                and nLayerCount == 1
-                and pszNewLayerName is None
-            ):
-                try:
-                    mode = os.stat(pszDestDataSource).st_mode
-                    if (mode & stat.S_IFDIR) == 0:
-                        pszNewLayerName = os.path.splitext(
-                            os.path.basename(pszDestDataSource)
-                        )[0]
-                except OSError:
-                    pass
-
-            psInfo = SetupTargetLayer(
-                poDS,
-                poLayer,
-                poODS,
-                papszLCO,
-                pszNewLayerName,
-                bTransform,
-                poOutputSRS,
-                bNullifyOutputSRS,
-                poSourceSRS,
-                papszSelFields,
-                bAppend,
-                eGType,
-                bPromoteToMulti,
-                nCoordDim,
-                bOverwrite,
-                papszFieldTypesToString,
-                bWrapDateline,
-                bExplodeCollections,
-                pszZField,
-                pszWHERE,
+        # Check "rreq" box
+        rreq = find_jp2box(ar, "rreq")
+        if inspire_tg and gmljp2_found and not rreq:
+            error_report.EmitError(
+                "INSPIRE_TG", '"rreq" box not found, but GMLJP2 box present'
             )
-
-            poLayer.ResetReading()
-
-            if (
-                psInfo is None
-                or not TranslateLayer(
-                    psInfo,
-                    poDS,
-                    poLayer,
-                    poODS,
-                    poOutputSRS,
-                    bNullifyOutputSRS,
-                    eGType,
-                    bPromoteToMulti,
-                    nCoordDim,
-                    eGeomOp,
-                    dfGeomOpParam,
-                    panLayerCountFeatures[iLayer],
-                    poClipSrc,
-                    poClipDst,
-                    bExplodeCollections,
-                    nSrcFileSize,
-                    None,
-                    pfnProgress,
-                    pProgressArg,
-                )
-            ) and not bSkipFailures:
-                print(
-                    "Terminating translation prematurely after failed\n"
-                    + "translation of layer "
-                    + poLayer.GetLayerDefn().GetName()
-                    + " (use -skipfailures to skip errors)"
+        elif rreq:
+            NSF = get_field_val(rreq, "NSF")
+            if NSF is None:
+                error_report.EmitError("GENERAL", "rreq.NSF not found")
+                NSF = 0
+            NSF = int(NSF)
+            SF67Found = False
+            NSF_found = 0
+            for i in range(1000):
+                val = get_field_val(rreq, "SF%d" % i)
+                if val is None:
+                    break
+                if val == "67":
+                    SF67Found = True
+                val = get_field_val(rreq, "SM%d" % i)
+                if val is None:
+                    error_report.EmitError("GENERAL", "rreq.SM[%d] not found" % i)
+                    break
+                NSF_found += 1
+            if NSF != NSF_found:
+                error_report.EmitError(
+                    "GENERAL", "rreq.NSF (=%d) != NSF_found (=%d)" % (NSF, NSF_found)
                 )
+            if gmljp2_found and not SF67Found:
+                if inspire_tg:
+                    error_report.EmitError(
+                        "INSPIRE_TG",
+                        '"rreq" box does not advertise standard flag 67 whereas GMLJP2 box is present',
+                    )
+                else:
+                    error_report.EmitWarning(
+                        "GENERAL",
+                        '"rreq" box does not advertise standard flag 67 whereas GMLJP2 box is present',
+                    )
 
-                return 1
-
-    # --------------------------------------------------------------------
-    #      Close down.
-    # --------------------------------------------------------------------
-    # We must explicitly destroy the output dataset in order the file
-    # to be properly closed !
-    poODS.Destroy()
-    poDS.Destroy()
-
-    return 0
-
-
-# **********************************************************************
-#                               Usage()
-# **********************************************************************
-
-
-def Usage():
-
-    print(
-        "Usage: ogr2ogr [--help-general] [-skipfailures] [-append] [-update] [-gt n]\n"
-        + "               [-select field_list] [-where restricted_where] \n"
-        + "               [-progress] [-sql <sql statement>] \n"
-        + "               [-spat xmin ymin xmax ymax] [-preserve_fid] [-fid FID]\n"
-        + "               [-a_srs srs_def] [-t_srs srs_def] [-s_srs srs_def]\n"
-        + "               [-f format_name] [-overwrite] [[-dsco NAME=VALUE] ...]\n"
-        + "               [-simplify tolerance]\n"
-        + "               [-fieldTypeToString All|(type1[,type2]...)] [-explodecollections] \n"  # // "               [-segmentize max_dist] [-fieldTypeToString All|(type1[,type2]...)]\n" + \
-        + "               dst_datasource_name src_datasource_name\n"
-        + "               [-lco NAME=VALUE] [-nln name] [-nlt type] [-dim 2|3] [layer [layer ...]]\n"
-        + "\n"
-        + " -f format_name: output file format name, possible values are:"
-    )
-
-    for iDriver in range(ogr.GetDriverCount()):
-        poDriver = ogr.GetDriver(iDriver)
-
-        if poDriver.TestCapability(ogr.ODrCCreateDataSource):
-            print('     -f "' + poDriver.GetName() + '"')
-
-    print(
-        " -append: Append to existing layer instead of creating new if it exists\n"
-        + " -overwrite: delete the output layer and recreate it empty\n"
-        + " -update: Open existing output datasource in update mode\n"
-        + ' -progress: Display progress on terminal. Only works if input layers have the "fast feature count" capability\n'
-        + " -select field_list: Comma-delimited list of fields from input layer to\n"
-        + "                     copy to the new layer (defaults to all)\n"
-        + " -where restricted_where: Attribute query (like SQL WHERE)\n"
-        + " -sql statement: Execute given SQL statement and save result.\n"
-        + " -skipfailures: skip features or layers that fail to convert\n"
-        + " -gt n: group n features per transaction (default 200)\n"
-        + " -spat xmin ymin xmax ymax: spatial query extents\n"
-        + " -simplify tolerance: distance tolerance for simplification.\n"
-        +  # //" -segmentize max_dist: maximum distance between 2 nodes.\n" + \
-        # //"                       Used to create intermediate points\n" + \
-        " -dsco NAME=VALUE: Dataset creation option (format specific)\n"
-        + " -lco  NAME=VALUE: Layer creation option (format specific)\n"
-        + " -nln name: Assign an alternate name to the new layer\n"
-        + " -nlt type: Force a geometry type for new layer.  One of NONE, GEOMETRY,\n"
-        + "      POINT, LINESTRING, POLYGON, GEOMETRYCOLLECTION, MULTIPOINT,\n"
-        + '      MULTIPOLYGON, or MULTILINESTRING.  Add "25D" for 3D layers.\n'
-        + "      Default is type of source layer.\n"
-        + " -dim dimension: Force the coordinate dimension to the specified value.\n"
-        + " -fieldTypeToString type1,...: Converts fields of specified types to\n"
-        + "      fields of type string in the new layer. Valid types are : \n"
-        + "      Integer, Real, String, Date, Time, DateTime, Binary, IntegerList, RealList,\n"
-        + "      StringList. Special value All can be used to convert all fields to strings."
-    )
-
-    print(
-        " -a_srs srs_def: Assign an output SRS\n"
-        " -t_srs srs_def: Reproject/transform to this SRS on output\n"
-        " -s_srs srs_def: Override source SRS\n"
-        "\n"
-        " Srs_def can be a full WKT definition (hard to escape properly),\n"
-        " or a well known definition (i.e. EPSG:4326) or a file with a WKT\n"
-        " definition."
-    )
-
-    return 2
+            NVF = get_field_val(rreq, "NVF")
+            if NVF is None:
+                error_report.EmitError("GENERAL", "rreq.NVF not found")
+                NVF = 0
+            NVF = int(NVF)
+            NVF_found = 0
+            for i in range(1000):
+                val = get_field_val(rreq, "VF%d" % i)
+                if val is None:
+                    break
+                val = get_field_val(rreq, "VM%d" % i)
+                if val is None:
+                    error_report.EmitError("GENERAL", "rreq.VM[%d] not found" % i)
+                    break
+                NVF_found += 1
+            if NVF != NVF_found:
+                error_report.EmitError(
+                    "GENERAL", "rreq.NVF (=%d) != NVF_found (=%d)" % (NVF, NVF_found)
+                )
 
+        # Check "jp2h" box
+        jp2h = find_jp2box(ar, "jp2h")
+        if not jp2h:
+            error_report.EmitError("GENERAL", '"jp2h" box not found')
+        else:
+            # Check "ihdr" subbox
+            ihdr = find_jp2box(jp2h, "ihdr")
+            if not ihdr:
+                error_report.EmitError("GENERAL", '"ihdr" box not found')
+            else:
+                ihdr_height = int_or_none(get_field_val(ihdr, "HEIGHT"))
+                if ihdr_height is None:
+                    error_report.EmitError(
+                        "GENERAL", "invalid value ihdr.HEIGHT = %s" % str(ihdr_height)
+                    )
+                    ihdr_height = 0
+                elif inspire_tg and ihdr_height > 2**31:
+                    error_report.EmitError(
+                        "INSPIRE_TG",
+                        "ihdr.height = %d, whereas only 31 bits are allowed for Profile 1"
+                        % ihdr_height,
+                    )
 
-def CSLFindString(v, mystr):
-    i = 0
-    for strIter in v:
-        if EQUAL(strIter, mystr):
-            return i
-        i = i + 1
-    return -1
+                ihdr_width = int_or_none(get_field_val(ihdr, "WIDTH"))
+                if ihdr_width is None:
+                    error_report.EmitError(
+                        "GENERAL", "invalid value ihdr.WIDTH = %s" % str(ihdr_width)
+                    )
+                    ihdr_width = 0
+                elif inspire_tg and ihdr_width > 2**31:
+                    error_report.EmitError(
+                        "INSPIRE_TG",
+                        "ihdr.width = %d, whereas only 31 bits are allowed for Profile 1"
+                        % ihdr_width,
+                    )
 
+                ihdr_nc = int_or_none(get_field_val(ihdr, "NC"))
+                if ihdr_nc is None or ihdr_nc > 16384:
+                    error_report.EmitError(
+                        "GENERAL", "invalid value ihdr.NC = %s" % str(ihdr_nc)
+                    )
+                    ihdr_nc = 0
 
-def IsNumber(pszStr):
-    try:
-        float(pszStr)
-        return True
-    except ValueError:
-        return False
+                ihdr_bpcc = int_or_none(get_field_val(ihdr, "BPC"))
+                if ihdr_bpcc != 255:
+                    validate_bitsize(
+                        error_report, inspire_tg, ihdr_bpcc, "ihdr.bpcc", datatype
+                    )
 
+                ihdr_c = int_or_none(get_field_val(ihdr, "C"))
+                if ihdr_c != 7:
+                    error_report.EmitError(
+                        "GENERAL", "ihdr.C = %s instead of 7" % str(ihdr_c)
+                    )
 
-def LoadGeometry(pszDS, pszSQL, pszLyr, pszWhere):
-    poGeom = None
+                ihdr_unkc = int_or_none(get_field_val(ihdr, "UnkC"))
+                if ihdr_unkc is None or ihdr_unkc > 1:
+                    error_report.EmitError(
+                        "GENERAL", "ihdr.UnkC = %s instead of 0 or 1" % str(ihdr_unkc)
+                    )
 
-    poDS = ogr.Open(pszDS, False)
-    if poDS is None:
-        return None
+                ihdr_ipr = int_or_none(get_field_val(ihdr, "IPR"))
+                if ihdr_ipr is None or ihdr_ipr > 1:
+                    error_report.EmitError(
+                        "GENERAL", "ihdr.IPR = %s instead of 0 or 1" % str(ihdr_ipr)
+                    )
 
-    if pszSQL is not None:
-        poLyr = poDS.ExecuteSQL(pszSQL, None, None)
-    elif pszLyr is not None:
-        poLyr = poDS.GetLayerByName(pszLyr)
-    else:
-        poLyr = poDS.GetLayer(0)
+            # Check optional "bpcc" subbox
+            bpcc = find_jp2box(jp2h, "bpcc")
+            if ihdr and ihdr_bpcc == 255:
+                if not bpcc:
+                    error_report.EmitError(
+                        "GENERAL", '"bpcc" box not found whereas ihdr.bpcc requires it'
+                    )
+            elif ihdr and bpcc and ihdr_bpcc != 255:
+                error_report.EmitWarning(
+                    "GENERAL", '"bpcc" box found whereas ihdr.bpcc does not require it'
+                )
+            if ihdr and bpcc:
+                for i in range(16384):
+                    val = get_field_val(bpcc, "BPC%d" % i)
+                    if val is None:
+                        break
+                    val = int(val)
+                    bpc_vals.append(val)
 
-    if poLyr is None:
-        print("Failed to identify source layer from datasource.")
-        poDS.Destroy()
-        return None
+                    validate_bitsize(
+                        error_report, inspire_tg, val, "bpcc.BPC[%d]" % i, datatype
+                    )
 
-    if pszWhere is not None:
-        poLyr.SetAttributeFilter(pszWhere)
+                if len(bpc_vals) != ihdr_nc:
+                    error_report.EmitWarning(
+                        "GENERAL",
+                        '"bpcc" box has %d elements whereas ihdr.nc = %d'
+                        % (len(bpc_vals), ihdr_nc),
+                    )
 
-    poFeat = poLyr.GetNextFeature()
-    while poFeat is not None:
-        poSrcGeom = poFeat.GetGeometryRef()
-        if poSrcGeom is not None:
-            eType = wkbFlatten(poSrcGeom.GetGeometryType())
-
-            if poGeom is None:
-                poGeom = ogr.Geometry(ogr.wkbMultiPolygon)
-
-            if eType == ogr.wkbPolygon:
-                poGeom.AddGeometry(poSrcGeom)
-            elif eType == ogr.wkbMultiPolygon:
-                for iGeom in range(poSrcGeom.GetGeometryCount()):
-                    poGeom.AddGeometry(poSrcGeom.GetGeometryRef(iGeom))
+            if ihdr and not bpcc:
+                bpc_vals = [ihdr_bpcc for i in range(ihdr_nc)]
 
+            # Check "colr" subbox
+            colr = find_jp2box(jp2h, "colr")
+            if not colr:
+                error_report.EmitError("GENERAL", '"colr" box not found')
             else:
-                print("ERROR: Geometry not of polygon type.")
-                if pszSQL is not None:
-                    poDS.ReleaseResultSet(poLyr)
-                poDS.Destroy()
-                return None
+                meth = int_or_none(get_field_val(colr, "METH"))
+                if meth != 1 and meth != 2:
+                    error_report.EmitWarning(
+                        "GENERAL", "Unknown value %s for colr.METH" % str(meth)
+                    )
 
-        poFeat = poLyr.GetNextFeature()
+                prec = int_or_none(get_field_val(colr, "PREC"))
+                if prec is None or (inspire_tg and prec != 0):
+                    error_report.EmitWarning(
+                        "GENERAL", "Unknown value %s for colr.PREC" % str(prec)
+                    )
 
-    if pszSQL is not None:
-        poDS.ReleaseResultSet(poLyr)
-    poDS.Destroy()
+                approx = int_or_none(get_field_val(colr, "APPROX"))
+                if approx or (inspire_tg and approx != 0):
+                    error_report.EmitWarning(
+                        "GENERAL", "Unknown value %s for colr.APPROX" % str(approx)
+                    )
 
-    return poGeom
+                if meth == 1:
+                    enum_cs = int_or_none(get_field_val(colr, "EnumCS"))
+                    if enum_cs is None or (
+                        inspire_tg and enum_cs != 16 and enum_cs != 17 and enum_cs != 18
+                    ):
+                        error_report.EmitWarning(
+                            "GENERAL", "Unknown value %s for colr.EnumCS" % str(enum_cs)
+                        )
+                else:
+                    enum_cs = None
 
+            # Check optional "pclr" subbox
+            pclr = find_jp2box(jp2h, "pclr")
+            if ihdr and pclr:
+                if inspire_tg and ihdr_nc != 1:
+                    error_report.EmitError(
+                        "INSPIRE_TG", "pclr box found but ihdr.nc = %d" % (ihdr_nc)
+                    )
+                pclr_NE = int_or_none(get_field_val(pclr, "NE"))
+                if pclr_NE is None:
+                    error_report.EmitWarning(
+                        "GENERAL", "Invalid value %s for pclr.NE" % str(pclr_NE)
+                    )
+                    pclr_NE = 0
 
-def wkbFlatten(x):
-    return x & (~ogr.wkb25DBit)
+                pclr_NPC = int_or_none(get_field_val(pclr, "NPC"))
+                if pclr_NPC is None:
+                    error_report.EmitWarning(
+                        "GENERAL", "Invalid value %s for pclr.NPC" % str(pclr_NPC)
+                    )
+                    pclr_NPC = 0
+                if inspire_tg and pclr_NPC != 3:
+                    error_report.EmitError(
+                        "INSPIRE_TG",
+                        "pclr.NPC(=%d) != 3 (for color table)" % (pclr_NPC),
+                        conformance_class="A.8.6",
+                    )
 
+                if ihdr_bpcc == 7 and pclr_NE > 256:
+                    error_report.EmitError(
+                        "GENERAL", "%d entries in pclr box, but 8 bit depth" % (pclr_NE)
+                    )
+                for i in range(pclr_NPC):
+                    val = get_field_val(pclr, "B%d" % i)
+                    if val is None:
+                        error_report.EmitError("GENERAL", "pclr.B%d not found" % (i))
+                        break
+                    val = int(val)
+                    validate_bitsize(
+                        error_report, inspire_tg, val, "pclr.B[%d]" % i, datatype
+                    )
+                if pclr_NE > 0 and pclr_NPC > 0:
+                    val = get_field_val(pclr, "C_%d_%d" % (pclr_NE - 1, pclr_NPC - 1))
+                    if val is None:
+                        error_report.EmitError(
+                            "GENERAL",
+                            "pclr.C_%d_%d not found" % (pclr_NE - 1, pclr_NPC - 1),
+                        )
 
-# **********************************************************************
-#                               SetZ()
-# **********************************************************************
+            # Check optional "cmap" subbox
+            cmap = find_jp2box(jp2h, "cmap")
+            if cmap:
+                if pclr is None:
+                    error_report.EmitError("GENERAL", "cmap box found but no pclr box")
+                else:
+                    cmap_count = 0
+                    PCOL_mapping = {}
+                    for i in range(16384):
+                        CMP = get_field_val(cmap, "CMP%d" % i)
+                        if CMP is None:
+                            break
+                        CMP = int(CMP)
+                        if CMP >= ihdr_nc:
+                            error_report.EmitError(
+                                "GENERAL", "cmap.CMP[%d] = %d is invalid" % (i, CMP)
+                            )
 
+                        MTYP = get_field_val(cmap, "MTYP%d" % i)
+                        if MTYP is None:
+                            error_report.EmitError(
+                                "GENERAL", "cmap.MTYP[%d] missing" % i
+                            )
+                            break
+                        MTYP = int(MTYP)
+                        if inspire_tg and MTYP != 1:
+                            error_report.EmitError(
+                                "INSPIRE_TG",
+                                "cmap.MTYP[%d] = %d is invalid" % (i, MTYP),
+                            )
 
-def SetZ(poGeom, dfZ):
+                        PCOL = get_field_val(cmap, "PCOL%d" % i)
+                        if PCOL is None:
+                            error_report.EmitError(
+                                "GENERAL", "cmap.PCOL[%d] missing" % i
+                            )
+                            break
+                        PCOL = int(PCOL)
+                        if ihdr_nc == 1 and PCOL >= pclr_NPC:
+                            error_report.EmitError(
+                                "GENERAL", "cmap.PCOL[%d] = %d is invalid" % (i, PCOL)
+                            )
+                        if MTYP == 1:
+                            if PCOL in PCOL_mapping:
+                                error_report.EmitError(
+                                    "GENERAL",
+                                    "cmap.PCOL[%d] = %d is invalid since already used"
+                                    % (i, PCOL),
+                                )
+                            PCOL_mapping[PCOL] = True
+
+                        cmap_count += 1
+
+                    if ihdr_nc == 1 and cmap_count != pclr_NPC:
+                        error_report.EmitError(
+                            "GENERAL",
+                            "cmap box contains %d channel definitions but pclr.NPC = %d"
+                            % (cmap_count, pclr_NPC),
+                        )
 
-    if poGeom is None:
-        return
+            else:
+                if pclr:
+                    error_report.EmitError(
+                        "GENERAL", "cmap box not found but pclr exists"
+                    )
 
-    eGType = wkbFlatten(poGeom.GetGeometryType())
-    if eGType == ogr.wkbPoint:
-        poGeom.SetPoint(0, poGeom.GetX(), poGeom.GetY(), dfZ)
-
-    elif eGType == ogr.wkbLineString or eGType == ogr.wkbLinearRing:
-        for i in range(poGeom.GetPointCount()):
-            poGeom.SetPoint(i, poGeom.GetX(i), poGeom.GetY(i), dfZ)
+            # Check optional "cdef" subbox
+            cdef = find_jp2box(jp2h, "cdef")
+            transparent_index = -1
+            if cdef and pclr:
+                error_report.EmitWarning(
+                    "GENERAL",
+                    "cdef found and pclr also. Ignoring cdef as it is unusual",
+                )
+            elif ihdr and cdef:
+                cdef_N = int(get_field_val(cdef, "N"))
+                if cdef_N != ihdr_nc:
+                    error_report.EmitError(
+                        "GENERAL",
+                        "cdef.N = %d whereas ihdr.nc = %d" % (cdef_N, ihdr_nc),
+                    )
+                cdef_count = 0
+                cn_mapping = {}
+                typ_alpha_used = False
+                asoc_mapping = {}
+                asoc_whole_used = False
+                for i in range(16384):
+                    cn = get_field_val(cdef, "Cn%d" % i)
+                    if cn is None:
+                        break
+                    cn = int(cn)
+                    if cn < 0 or cn >= ihdr_nc:
+                        error_report.EmitError(
+                            "GENERAL", "cdef.cn[%d] = %d is invalid" % (i, cn)
+                        )
+                    elif cn in cn_mapping:
+                        error_report.EmitError(
+                            "GENERAL",
+                            "cdef.cn[%d] = %d is invalid since already used" % (i, cn),
+                        )
+                    cn_mapping[cn] = True
 
-    elif (
-        eGType == ogr.wkbPolygon
-        or eGType == ogr.wkbMultiPoint
-        or eGType == ogr.wkbMultiLineString
-        or eGType == ogr.wkbMultiPolygon
-        or eGType == ogr.wkbGeometryCollection
-    ):
-        for i in range(poGeom.GetGeometryCount()):
-            SetZ(poGeom.GetGeometryRef(i), dfZ)
+                    typ = get_field_val(cdef, "Typ%d" % i)
+                    if typ is None:
+                        error_report.EmitError("GENERAL", "cdef.typ[%d] missing" % i)
+                        break
+                    typ = int(typ)
+                    if typ != 0 and typ != 1 and typ != 2 and typ != 65535:
+                        error_report.EmitError(
+                            "GENERAL", "cdef.typ[%d] = %d is invalid" % (i, typ)
+                        )
+                    if typ == 1 or typ == 2:
+                        if inspire_tg and cn < len(bpc_vals) and bpc_vals[cn] != 0:
+                            error_report.EmitWarning(
+                                "INSPIRE_TG",
+                                "Bit depth of alpha channel should be 1 (BPCC 0), but its BPCC is %d"
+                                % bpc_vals[cn],
+                                recommendation=38,
+                            )
+                        if typ_alpha_used and inspire_tg:
+                            error_report.EmitError(
+                                "GENERAL",
+                                "cdef.typ[%d] = %d is invalid since another alpha channel has already been defined"
+                                % (i, typ),
+                            )
+                        transparent_index = cn
+                        typ_alpha_used = True
 
+                    asoc = get_field_val(cdef, "Asoc%d" % i)
+                    if asoc is None:
+                        error_report.EmitError("GENERAL", "cdef.asoc[%d] missing" % i)
+                        break
+                    asoc = int(asoc)
+                    if inspire_tg and asoc == 0:
+                        if not (typ == 1 or typ == 2):
+                            error_report.EmitError(
+                                "GENERAL",
+                                "cdef.asoc[%d] = %d whereas cdef.typ[%d] = %d"
+                                % (i, asoc, i, typ),
+                            )
+                        if asoc_whole_used:
+                            error_report.EmitError(
+                                "GENERAL",
+                                "cdef.asoc[%d] = %d is invalid since another band has already been associated to whole image"
+                                % (i, asoc),
+                            )
+                        asoc_whole_used = True
+                    elif colr and asoc > 0 and asoc < 65535:
+                        if asoc > ihdr_nc:
+                            error_report.EmitError(
+                                "GENERAL", "cdef.asoc[%d] = %d is invalid" % (i, asoc)
+                            )
+                        elif asoc in asoc_mapping:
+                            error_report.EmitError(
+                                "GENERAL",
+                                "cdef.asoc[%d] = %d is invalid since already used"
+                                % asoc,
+                            )
+                        asoc_mapping[asoc] = True
 
-# **********************************************************************
-#                         SetupTargetLayer()
-# **********************************************************************
-
-
-def SetupTargetLayer(
-    poSrcDS,
-    poSrcLayer,
-    poDstDS,
-    papszLCO,
-    pszNewLayerName,
-    bTransform,
-    poOutputSRS,
-    bNullifyOutputSRS,
-    poSourceSRS,
-    papszSelFields,
-    bAppend,
-    eGType,
-    bPromoteToMulti,
-    nCoordDim,
-    bOverwrite,
-    papszFieldTypesToString,
-    bWrapDateline,
-    bExplodeCollections,
-    pszZField,
-    pszWHERE,
-):
-    # pylint: disable=unused-argument
-    if pszNewLayerName is None:
-        pszNewLayerName = poSrcLayer.GetLayerDefn().GetName()
-
-    # --------------------------------------------------------------------
-    #      Setup coordinate transformation if we need it.
-    # --------------------------------------------------------------------
-    poCT = None
-
-    if bTransform:
-        if poSourceSRS is None:
-            poSourceSRS = poSrcLayer.GetSpatialRef()
-
-        if poSourceSRS is None:
-            print(
-                "Can't transform coordinates, source layer has no\n"
-                + "coordinate system.  Use -s_srs to set one."
-            )
-            return None
+                    cdef_count += 1
 
-        poCT = osr.CoordinateTransformation(poSourceSRS, poOutputSRS)
-        if poCT is None:
-            pszWKT = None
-
-            print(
-                "Failed to create coordinate transformation between the\n"
-                + "following coordinate systems.  This may be because they\n"
-                + "are not transformable."
-            )
+                if cdef_count != cdef_N:
+                    error_report.EmitError(
+                        "GENERAL",
+                        "cdef.N = %d whereas there are %d channel definitions"
+                        % (cdef_N, cdef_count),
+                    )
 
-            pszWKT = poSourceSRS.ExportToPrettyWkt(0)
-            print("Source:\n" + pszWKT)
+            # Check that all bands have the same bit-depth, except the alpha band than can (should) be 1-bit
+            if inspire_tg:
+                for i, bpc_val in enumerate(bpc_vals):
+                    if i == transparent_index:
+                        if bpc_val != bpc_vals[0] and bpc_val != 0:
+                            error_report.EmitError(
+                                "INSPIRE_TG",
+                                "Band %d has bpc=%d, which is different from first band whose value is %d"
+                                % (i, bpc_val, bpc_vals[0]),
+                                requirement=25,
+                            )
+                    elif bpc_val != bpc_vals[0]:
+                        error_report.EmitError(
+                            "INSPIRE_TG",
+                            "Band %d has bpc=%d, which is different from first band whose value is %d"
+                            % (i, bpc_val, bpc_vals[0]),
+                            requirement=25,
+                        )
 
-            pszWKT = poOutputSRS.ExportToPrettyWkt(0)
-            print("Target:\n" + pszWKT)
-            return None
-
-    # --------------------------------------------------------------------
-    #      Get other info.
-    # --------------------------------------------------------------------
-    poSrcFDefn = poSrcLayer.GetLayerDefn()
-
-    if poOutputSRS is None and not bNullifyOutputSRS:
-        poOutputSRS = poSrcLayer.GetSpatialRef()
-
-    # --------------------------------------------------------------------
-    #      Find the layer.
-    # --------------------------------------------------------------------
-
-    # GetLayerByName() can instantiate layers that would have been
-    # 'hidden' otherwise, for example, non-spatial tables in a
-    # PostGIS-enabled database, so this apparently useless command is
-    # not useless. (#4012)
-    gdal.PushErrorHandler("CPLQuietErrorHandler")
-    poDstLayer = poDstDS.GetLayerByName(pszNewLayerName)
-    gdal.PopErrorHandler()
-    gdal.ErrorReset()
-
-    iLayer = -1
-    if poDstLayer is not None:
-        nLayerCount = poDstDS.GetLayerCount()
-        for iLayer in range(nLayerCount):
-            poLayer = poDstDS.GetLayer(iLayer)
-            # The .cpp version compares on pointers directly, but we cannot
-            # do this with swig object, so just compare the names.
-            if poLayer is not None and poLayer.GetName() == poDstLayer.GetName():
-                break
+            # Check optional "res " subbox
+            res = find_jp2box(jp2h, "res ")
+            if res:
+                count_boxes = get_count_and_indices_of_jp2boxes(res)
+                for key in count_boxes:
+                    (val, _) = count_boxes[key]
+                    if val > 1:
+                        error_report.EmitError(
+                            "GENERAL",
+                            '"%s" box expected to be found zero or one time, but present %d times'
+                            % (key, val),
+                        )
+                    if key not in ("resd", "resc"):
+                        error_report.EmitWarning(
+                            "GENERAL", '"%s" box not expected' % key
+                        )
 
-        if iLayer == nLayerCount:
-            # Shouldn't happen with an ideal driver
-            poDstLayer = None
-
-    # --------------------------------------------------------------------
-    #      If the user requested overwrite, and we have the layer in
-    #      question we need to delete it now so it will get recreated
-    #      (overwritten).
-    # --------------------------------------------------------------------
-    if poDstLayer is not None and bOverwrite:
-        if poDstDS.DeleteLayer(iLayer) != 0:
-            print("DeleteLayer() failed when overwrite requested.")
-            return None
-
-        poDstLayer = None
-
-    # --------------------------------------------------------------------
-    #      If the layer does not exist, then create it.
-    # --------------------------------------------------------------------
-    if poDstLayer is None:
-        if eGType == -2:
-            eGType = poSrcFDefn.GetGeomType()
-
-            n25DBit = eGType & ogr.wkb25DBit
-            if bPromoteToMulti:
-                if wkbFlatten(eGType) == ogr.wkbLineString:
-                    eGType = ogr.wkbMultiLineString | n25DBit
-                elif wkbFlatten(eGType) == ogr.wkbPolygon:
-                    eGType = ogr.wkbMultiPolygon | n25DBit
-
-            if bExplodeCollections:
-                if wkbFlatten(eGType) == ogr.wkbMultiPoint:
-                    eGType = ogr.wkbPoint | n25DBit
-                elif wkbFlatten(eGType) == ogr.wkbMultiLineString:
-                    eGType = ogr.wkbLineString | n25DBit
-                elif wkbFlatten(eGType) == ogr.wkbMultiPolygon:
-                    eGType = ogr.wkbPolygon | n25DBit
-                elif wkbFlatten(eGType) == ogr.wkbGeometryCollection:
-                    eGType = ogr.wkbUnknown | n25DBit
-
-            if pszZField is not None:
-                eGType = eGType | ogr.wkb25DBit
-
-        if nCoordDim == 2:
-            eGType = eGType & ~ogr.wkb25DBit
-        elif nCoordDim == 3:
-            eGType = eGType | ogr.wkb25DBit
-
-        if not poDstDS.TestCapability(ogr.ODsCCreateLayer):
-            print(
-                "Layer "
-                + pszNewLayerName
-                + "not found, and CreateLayer not supported by driver."
-            )
-            return None
+            # Check number of sub-boxes
+            count_boxes = get_count_and_indices_of_jp2boxes(jp2h)
+            for key in count_boxes:
+                (val, _) = count_boxes[key]
+                if val > 1:
+                    error_report.EmitError(
+                        "GENERAL",
+                        '"%s" box expected to be found zero or one time, but present %d times'
+                        % (key, val),
+                    )
+                if key not in ("ihdr", "bpcc", "colr", "pclr", "cmap", "cdef", "res "):
+                    error_report.EmitWarning("GENERAL", '"%s" box not expected' % key)
 
-        gdal.ErrorReset()
+            # Check order of boxes
+            last_idx = -1
+            for box_name in ["ihdr", "bpcc", "colr", "pclr", "cmap", "cdef", "res "]:
+                if box_name in count_boxes:
+                    (_, idx) = count_boxes[box_name]
+                    if idx < last_idx:
+                        error_report.EmitWarning(
+                            "GENERAL", '"%s" box not at expected index' % box_name
+                        )
+                    last_idx = idx
 
-        poDstLayer = poDstDS.CreateLayer(pszNewLayerName, poOutputSRS, eGType, papszLCO)
+        # Check "jp2c" box
+        jp2c = find_jp2box(ar, "jp2c")
+        if not jp2c:
+            error_report.EmitError("GENERAL", '"jp2c" box not found')
+
+        if ihdr and ihdr_ipr == 1 and not find_jp2box(ar, "jp2i"):
+            error_report.EmitWarning("GENERAL", "ihdr.ipr = 1 but no jp2i box found")
+        elif ihdr and ihdr_ipr == 0 and find_jp2box(ar, "jp2i"):
+            error_report.EmitWarning("GENERAL", "ihdr.ipr = 0 but jp2i box found")
+
+        # Check number of boxes
+        count_boxes = get_count_and_indices_of_jp2boxes(ar)
+        for key in count_boxes:
+            (val, _) = count_boxes[key]
+            if key in ("jP  ", "ftyp", "rreq", "jp2h", "jp2c"):
+                if key == "jp2c":
+                    if inspire_tg and val > 1:
+                        error_report.EmitError(
+                            "INSPIRE_TG",
+                            '"%s" box expected to be found one time, but present %d times'
+                            % (key, val),
+                            requirement=23,
+                            conformance_class="A.8.15",
+                        )
+                elif val > 1:
+                    error_report.EmitError(
+                        "GENERAL",
+                        '"%s" box expected to be found zero or one time, but present %d times'
+                        % (key, val),
+                    )
+            elif key not in ("jp2i", "asoc", "xml ", "uuid", "uinf"):
+                error_report.EmitWarning("GENERAL", '"%s" box not expected' % key)
 
-        if poDstLayer is None:
-            return None
+        # Check order of boxes
+        last_idx = -1
+        for box_name in ["jP  ", "ftyp", "rreq", "jp2h", "jp2c", "jp2i"]:
+            if box_name in count_boxes:
+                (_, idx) = count_boxes[box_name]
+                if idx < last_idx:
+                    error_report.EmitWarning(
+                        "GENERAL", '"%s" box not at expected index' % box_name
+                    )
+                last_idx = idx
+        if inspire_tg:
+            for box_name in ["asoc", "xml ", "uuid", "uinf"]:
+                if box_name in count_boxes:
+                    (_, idx) = count_boxes[box_name]
+                    if idx < last_idx:
+                        error_report.EmitWarning(
+                            "INSPIRE_TG", '"%s" box not at expected index' % box_name
+                        )
+                    last_idx = idx
 
-        bAppend = False
-
-    # --------------------------------------------------------------------
-    #      Otherwise we will append to it, if append was requested.
-    # --------------------------------------------------------------------
-    elif not bAppend:
-        print(
-            "FAILED: Layer "
-            + pszNewLayerName
-            + "already exists, and -append not specified.\n"
-            + "        Consider using -append, or -overwrite."
-        )
-        return None
+    cs = find_xml_node(ar, "JP2KCodeStream")
+    if cs is None:
+        return error_report
+
+    soc = find_marker(cs, "SOC")
+    if not soc:
+        error_report.EmitError("GENERAL", "No SOC marker found")
+
+    # Validate content of SIZ marker
+    siz = find_marker(cs, "SIZ")
+    Csiz = 0
+    Xsiz = 0
+    Ysiz = 0
+    XOsiz = 0
+    YOsiz = 0
+    Rsiz = 0
+    tab_Ssiz = []
+    if not siz:
+        error_report.EmitError("GENERAL", "No SIZ marker found")
     else:
-        if papszLCO:
-            print(
-                "WARNING: Layer creation options ignored since an existing layer is\n"
-                + "         being appended to."
-            )
-
-    # --------------------------------------------------------------------
-    #      Add fields.  Default to copy all field.
-    #      If only a subset of all fields requested, then output only
-    #      the selected fields, and in the order that they were
-    #      selected.
-    # --------------------------------------------------------------------
-
-    # Initialize the index-to-index map to -1's
-    nSrcFieldCount = poSrcFDefn.GetFieldCount()
-    panMap = [-1] * nSrcFieldCount
-
-    poDstFDefn = poDstLayer.GetLayerDefn()
-
-    if papszSelFields is not None and not bAppend:
-
-        nDstFieldCount = 0
-        if poDstFDefn is not None:
-            nDstFieldCount = poDstFDefn.GetFieldCount()
-
-        for papszSelField in papszSelFields:
-
-            iSrcField = poSrcFDefn.GetFieldIndex(papszSelField)
-            if iSrcField >= 0:
-                poSrcFieldDefn = poSrcFDefn.GetFieldDefn(iSrcField)
-                oFieldDefn = ogr.FieldDefn(
-                    poSrcFieldDefn.GetNameRef(), poSrcFieldDefn.GetType()
-                )
-                oFieldDefn.SetWidth(poSrcFieldDefn.GetWidth())
-                oFieldDefn.SetPrecision(poSrcFieldDefn.GetPrecision())
-
-                if papszFieldTypesToString is not None and (
-                    CSLFindString(papszFieldTypesToString, "All") != -1
-                    or CSLFindString(
-                        papszFieldTypesToString,
-                        ogr.GetFieldTypeName(poSrcFieldDefn.GetType()),
-                    )
-                    != -1
-                ):
-
-                    oFieldDefn.SetType(ogr.OFTString)
-
-                # The field may have been already created at layer creation
-                iDstField = -1
-                if poDstFDefn is not None:
-                    iDstField = poDstFDefn.GetFieldIndex(oFieldDefn.GetNameRef())
-                if iDstField >= 0:
-                    panMap[iSrcField] = iDstField
-                elif poDstLayer.CreateField(oFieldDefn) == 0:
-                    # now that we've created a field, GetLayerDefn() won't return NULL
-                    if poDstFDefn is None:
-                        poDstFDefn = poDstLayer.GetLayerDefn()
-
-                    # Sanity check : if it fails, the driver is buggy
-                    if (
-                        poDstFDefn is not None
-                        and poDstFDefn.GetFieldCount() != nDstFieldCount + 1
-                    ):
-                        print(
-                            "The output driver has claimed to have added the %s field, but it did not!"
-                            % oFieldDefn.GetNameRef()
-                        )
-                    else:
-                        panMap[iSrcField] = nDstFieldCount
-                        nDstFieldCount = nDstFieldCount + 1
+        while True:
+            Csiz = get_field_val(siz, "Csiz")
+            if Csiz is None:
+                error_report.EmitError("GENERAL", "SIZ.Csiz not found")
+                break
+            Csiz = int(Csiz)
 
-            else:
-                print("Field '" + papszSelField + "' not found in source layer.")
-                if not bSkipFailures:
-                    return None
-
-        # --------------------------------------------------------------------
-        # Use SetIgnoredFields() on source layer if available
-        # --------------------------------------------------------------------
-
-        # Here we differ from the ogr2ogr.cpp implementation since the OGRFeatureQuery
-        # isn't mapped to swig. So in that case just don't use SetIgnoredFields()
-        # to avoid issue raised in #4015
-        if poSrcLayer.TestCapability(ogr.OLCIgnoreFields) and pszWHERE is None:
-            papszIgnoredFields = []
-            for iSrcField in range(nSrcFieldCount):
-                pszFieldName = poSrcFDefn.GetFieldDefn(iSrcField).GetNameRef()
-                bFieldRequested = False
-                for papszSelField in papszSelFields:
-                    if EQUAL(pszFieldName, papszSelField):
-                        bFieldRequested = True
-                        break
+            Rsiz = int(get_field_val(siz, "Rsiz"))
+            if inspire_tg and Rsiz != 2:
+                error_report.EmitError(
+                    "INSPIRE_TG",
+                    "SIZ.Rsiz=%d found but 2 (Profile 1) expected" % Rsiz,
+                    requirement=21,
+                )
 
-                if pszZField is not None and EQUAL(pszFieldName, pszZField):
-                    bFieldRequested = True
+            Xsiz = int(get_field_val(siz, "Xsiz"))
+            Ysiz = int(get_field_val(siz, "Ysiz"))
+            XOsiz = int(get_field_val(siz, "XOsiz"))
+            YOsiz = int(get_field_val(siz, "YOsiz"))
+            XTsiz = int(get_field_val(siz, "XTsiz"))
+            YTsiz = int(get_field_val(siz, "YTsiz"))
+            XTOSiz = int(get_field_val(siz, "XTOSiz"))
+            YTOSiz = int(get_field_val(siz, "YTOSiz"))
+
+            if (inspire_tg or Rsiz == 2) and Xsiz >= 2**31:
+                error_report.EmitError(
+                    "PROFILE_1",
+                    "Xsiz = %d, whereas only 31 bits are allowed for Profile 1" % Xsiz,
+                )
+            if (inspire_tg or Rsiz == 2) and Ysiz >= 2**31:
+                error_report.EmitError(
+                    "PROFILE_1",
+                    "Ysiz = %d, whereas only 31 bits are allowed for Profile 1" % Ysiz,
+                )
+            if (inspire_tg or Rsiz == 2) and XOsiz >= 2**31:
+                error_report.EmitError(
+                    "PROFILE_1",
+                    "XOsiz = %d, whereas only 31 bits are allowed for Profile 1"
+                    % XOsiz,
+                )
+            if (inspire_tg or Rsiz == 2) and YOsiz >= 2**31:
+                error_report.EmitError(
+                    "PROFILE_1",
+                    "YOsiz = %d, whereas only 31 bits are allowed for Profile 1"
+                    % YOsiz,
+                )
+            if (inspire_tg or Rsiz == 2) and XTOSiz >= 2**31:
+                error_report.EmitError(
+                    "PROFILE_1",
+                    "XTOSiz = %d, whereas only 31 bits are allowed for Profile 1"
+                    % XTOSiz,
+                )
+            if (inspire_tg or Rsiz == 2) and YTOSiz >= 2**31:
+                error_report.EmitError(
+                    "PROFILE_1",
+                    "YTOSiz = %d, whereas only 31 bits are allowed for Profile 1"
+                    % YTOSiz,
+                )
+            if ihdr and ihdr_width != Xsiz - XOsiz:
+                error_report.EmitError(
+                    "GENERAL",
+                    "ihdr_width(=%d) != Xsiz (=%d)- XOsiz(=%d)"
+                    % (ihdr_width, Xsiz, XOsiz),
+                )
+            if ihdr and ihdr_height != Ysiz - YOsiz:
+                error_report.EmitError(
+                    "GENERAL",
+                    "ihdr_height(=%d) != Ysiz(=%d) - YOsiz(=%d)"
+                    % (ihdr_height, Ysiz, YOsiz),
+                )
+            if ihdr and ihdr_nc != Csiz:
+                error_report.EmitError(
+                    "GENERAL", "ihdr_nc(=%d) != Csiz (=%d)" % (ihdr_nc, Csiz)
+                )
 
-                # If source field not requested, add it to ignored files list
-                if not bFieldRequested:
-                    papszIgnoredFields.append(pszFieldName)
+            min_XYRSiz = 255
+            for i in range(Csiz):
+                Ssiz = get_field_val(siz, "Ssiz%d" % i)
+                if Ssiz is None:
+                    error_report.EmitError("GENERAL", "SIZ.Ssiz[%d] not found" % i)
+                    break
+                Ssiz = int(Ssiz)
+                validate_bitsize(
+                    error_report, inspire_tg, Ssiz, "SIZ.Ssiz[%d]" % i, datatype
+                )
+                tab_Ssiz.append(Ssiz)
 
-            poSrcLayer.SetIgnoredFields(papszIgnoredFields)
+                if bpc_vals and i < len(bpc_vals) and bpc_vals[i] != Ssiz:
+                    error_report.EmitError(
+                        "GENERAL",
+                        "SIZ.Ssiz[%d]=%s, whereas bpcc[%d]=%s"
+                        % (i, str(Ssiz), i, str(bpc_vals[i])),
+                    )
 
-    elif not bAppend:
+                XRsiz = get_field_val(siz, "XRsiz%d" % i)
+                if XRsiz is None:
+                    error_report.EmitError("GENERAL", "SIZ.XRsiz[%d] not found" % i)
+                    break
+                XRsiz = int(XRsiz)
+                if XRsiz == 0:
+                    error_report.EmitError(
+                        "GENERAL", "XRsiz[%d] = %d is invalid" % (i, XRsiz)
+                    )
+                elif XRsiz < min_XYRSiz:
+                    min_XYRSiz = XRsiz
 
-        nDstFieldCount = 0
-        if poDstFDefn is not None:
-            nDstFieldCount = poDstFDefn.GetFieldCount()
+                YRsiz = get_field_val(siz, "YRsiz%d" % i)
+                if YRsiz is None:
+                    error_report.EmitError("GENERAL", "SIZ.YRsiz[%d] not found" % i)
+                    break
+                YRsiz = int(YRsiz)
+                if YRsiz == 0:
+                    error_report.EmitError(
+                        "GENERAL", "YRsiz[%d] = %d is invalid" % (i, YRsiz)
+                    )
+                elif YRsiz < min_XYRSiz:
+                    min_XYRSiz = YRsiz
 
-        for iField in range(nSrcFieldCount):
+            tiled = not (XTsiz + XTOSiz >= Xsiz and YTsiz + YTOSiz >= Ysiz)
+            if (inspire_tg or Rsiz == 2) and XTsiz / min_XYRSiz > 1024 and tiled:
+                error_report.EmitError(
+                    "PROFILE_1",
+                    "XTsiz / min_XYRSiz = %f > 1024" % (1.0 * XTsiz / min_XYRSiz),
+                )
+            if (inspire_tg or Rsiz == 2) and XTsiz != YTsiz and tiled:
+                error_report.EmitError(
+                    "PROFILE_1", "XTsiz (=%d) != YTsiz (=%d)" % (XTsiz, YTsiz)
+                )
 
-            poSrcFieldDefn = poSrcFDefn.GetFieldDefn(iField)
-            oFieldDefn = ogr.FieldDefn(
-                poSrcFieldDefn.GetNameRef(), poSrcFieldDefn.GetType()
-            )
-            oFieldDefn.SetWidth(poSrcFieldDefn.GetWidth())
-            oFieldDefn.SetPrecision(poSrcFieldDefn.GetPrecision())
+            break
 
-            if papszFieldTypesToString is not None and (
-                CSLFindString(papszFieldTypesToString, "All") != -1
-                or CSLFindString(
-                    papszFieldTypesToString,
-                    ogr.GetFieldTypeName(poSrcFieldDefn.GetType()),
-                )
-                != -1
-            ):
-
-                oFieldDefn.SetType(ogr.OFTString)
-
-            # The field may have been already created at layer creation
-            iDstField = -1
-            if poDstFDefn is not None:
-                iDstField = poDstFDefn.GetFieldIndex(oFieldDefn.GetNameRef())
-            if iDstField >= 0:
-                panMap[iField] = iDstField
-            elif poDstLayer.CreateField(oFieldDefn) == 0:
-                # now that we've created a field, GetLayerDefn() won't return NULL
-                if poDstFDefn is None:
-                    poDstFDefn = poDstLayer.GetLayerDefn()
-
-                # Sanity check : if it fails, the driver is buggy
-                if (
-                    poDstFDefn is not None
-                    and poDstFDefn.GetFieldCount() != nDstFieldCount + 1
-                ):
-                    print(
-                        "The output driver has claimed to have added the %s field, but it did not!"
-                        % oFieldDefn.GetNameRef()
+    # Check GMLJP2 RectifiedGrid envelope against codestream dimensions
+    if gmljp2_found:
+        gmljp2_node = gdal.ParseXMLString(gmljp2)
+        rg = find_xml_node(gmljp2_node, "gml:RectifiedGrid")
+        if rg is None:
+            rg = find_xml_node(gmljp2_node, "RectifiedGrid")
+        if rg is None:
+            error_report.EmitError("GMLJP2", "Cannot find RectifiedGrid in GMLJP2")
+        else:
+            low = find_xml_node(rg, "low")
+            if low is None:
+                low = find_xml_node(rg, "gml:low")
+            high = find_xml_node(rg, "high")
+            if high is None:
+                high = find_xml_node(rg, "gml:high")
+            if low and high:
+                low = get_element_val(low)
+                (low_x, low_y) = low.split(" ")[0:2]
+                low_x = int(low_x)
+                low_y = int(low_y)
+
+                if low_x != XOsiz:
+                    error_report.EmitError(
+                        "GMLJP2", "RectifiedGrid.limits.GridEnvelope.low[x] != XOsiz"
+                    )
+                if low_y != YOsiz:
+                    error_report.EmitError(
+                        "GMLJP2", "RectifiedGrid.limits.GridEnvelope.low[y] != YOsiz"
                     )
-                else:
-                    panMap[iField] = nDstFieldCount
-                    nDstFieldCount = nDstFieldCount + 1
 
-    else:
-        # For an existing layer, build the map by fetching the index in the destination
-        # layer for each source field
-        if poDstFDefn is None:
-            print("poDstFDefn == NULL.\n")
-            return None
-
-        for iField in range(nSrcFieldCount):
-            poSrcFieldDefn = poSrcFDefn.GetFieldDefn(iField)
-            iDstField = poDstFDefn.GetFieldIndex(poSrcFieldDefn.GetNameRef())
-            if iDstField >= 0:
-                panMap[iField] = iDstField
-
-    iSrcZField = -1
-    if pszZField is not None:
-        iSrcZField = poSrcFDefn.GetFieldIndex(pszZField)
-
-    psInfo = TargetLayerInfo()
-    psInfo.poDstLayer = poDstLayer
-    psInfo.poCT = poCT
-    # psInfo.papszTransformOptions = papszTransformOptions
-    psInfo.panMap = panMap
-    psInfo.iSrcZField = iSrcZField
-
-    return psInfo
-
-
-# **********************************************************************
-#                           TranslateLayer()
-# **********************************************************************
-
-
-def TranslateLayer(
-    psInfo,
-    poSrcDS,
-    poSrcLayer,
-    poDstDS,
-    poOutputSRS,
-    bNullifyOutputSRS,
-    eGType,
-    bPromoteToMulti,
-    nCoordDim,
-    eGeomOp,
-    dfGeomOpParam,
-    nCountLayerFeatures,
-    poClipSrc,
-    poClipDst,
-    bExplodeCollections,
-    nSrcFileSize,
-    pnReadFeatureCount,
-    pfnProgress,
-    pProgressArg,
-):
-    # pylint: disable=unused-argument
-    bForceToPolygon = False
-    bForceToMultiPolygon = False
-    bForceToMultiLineString = False
-
-    poDstLayer = psInfo.poDstLayer
-    # papszTransformOptions = psInfo.papszTransformOptions
-    poCT = psInfo.poCT
-    panMap = psInfo.panMap
-    iSrcZField = psInfo.iSrcZField
-
-    if poOutputSRS is None and not bNullifyOutputSRS:
-        poOutputSRS = poSrcLayer.GetSpatialRef()
-
-    if wkbFlatten(eGType) == ogr.wkbPolygon:
-        bForceToPolygon = True
-    elif wkbFlatten(eGType) == ogr.wkbMultiPolygon:
-        bForceToMultiPolygon = True
-    elif wkbFlatten(eGType) == ogr.wkbMultiLineString:
-        bForceToMultiLineString = True
-
-    # --------------------------------------------------------------------
-    #      Transfer features.
-    # --------------------------------------------------------------------
-    nFeaturesInTransaction = 0
-    nCount = 0
-
-    if nGroupTransactions > 0:
-        poDstLayer.StartTransaction()
-
-    while True:
-        poDstFeature = None
-
-        if nFIDToFetch != ogr.NullFID:
-
-            # // Only fetch feature on first pass.
-            if nFeaturesInTransaction == 0:
-                poFeature = poSrcLayer.GetFeature(nFIDToFetch)
+                high = get_element_val(high)
+                (high_x, high_y) = high.split(" ")[0:2]
+                high_x = int(high_x)
+                high_y = int(high_y)
+
+                if high_x != Xsiz - 1:
+                    error_report.EmitError(
+                        "GMLJP2",
+                        "RectifiedGrid.limits.GridEnvelope.high[x] != Xsiz - 1",
+                    )
+                if high_y != Ysiz - 1:
+                    error_report.EmitError(
+                        "GMLJP2",
+                        "RectifiedGrid.limits.GridEnvelope.high[y] != Ysiz - 1",
+                    )
             else:
-                poFeature = None
+                error_report.EmitError(
+                    "GMLJP2", "Cannot find low/high node in RectifiedGrid"
+                )
 
+    # Check against Orthoimagery document
+    if oidoc:
+        oidoc_content = open(oidoc).read()
+        oidoc_node = gdal.ParseXMLString(oidoc_content)
+        if oidoc_node is None:
+            error_report.EmitError("GENERAL", "Cannot parse %s" % oidoc)
         else:
-            poFeature = poSrcLayer.GetNextFeature()
+            oic = find_xml_node(oidoc_node, "OrthoimageCoverage")
+            if oic is None:
+                oic = find_xml_node(oidoc_node, "oi:OrthoimageCoverage")
+            if oic is None:
+                error_report.EmitError(
+                    "GENERAL", "Cannot find OrthoimageCoverage in %s" % oidoc
+                )
+            else:
+                # Check RectifiedGrid envelope against codestream dimensions
+                rg = find_xml_node(oic, "gml:RectifiedGrid")
+                if rg is None:
+                    rg = find_xml_node(oic, "RectifiedGrid")
+                if rg is None:
+                    if expected_gmljp2:
+                        error_report.EmitError(
+                            "INSPIRE_TG",
+                            "Cannot find RectifiedGrid in OrthoImageryCoverage",
+                        )
+                else:
+                    low = find_xml_node(rg, "low")
+                    if low is None:
+                        low = find_xml_node(rg, "gml:low")
+                    high = find_xml_node(rg, "high")
+                    if high is None:
+                        high = find_xml_node(rg, "gml:high")
+                    if low and high:
+                        low = get_element_val(low)
+                        (low_x, low_y) = low.split(" ")[0:2]
+                        low_x = int(low_x)
+                        low_y = int(low_y)
+
+                        if low_x != XOsiz:
+                            error_report.EmitError(
+                                "INSPIRE_TG",
+                                "RectifiedGrid.limits.GridEnvelope.low[x](=%d) != XOsiz(=%d)"
+                                % (low_x, XOsiz),
+                                conformance_class="A.8.6",
+                            )
+                        if low_y != YOsiz:
+                            error_report.EmitError(
+                                "INSPIRE_TG",
+                                "RectifiedGrid.limits.GridEnvelope.low[y](=%d) != YOsiz(=%d)"
+                                % (low_y, YOsiz),
+                                conformance_class="A.8.6",
+                            )
 
-        if poFeature is None:
-            break
+                        high = get_element_val(high)
+                        (high_x, high_y) = high.split(" ")[0:2]
+                        high_x = int(high_x)
+                        high_y = int(high_y)
+
+                        if high_x != Xsiz - 1:
+                            error_report.EmitError(
+                                "INSPIRE_TG",
+                                "RectifiedGrid.limits.GridEnvelope.high[x](=%d) != Xsiz(=%d) - 1"
+                                % (high_x, Xsiz),
+                                conformance_class="A.8.6",
+                            )
+                        if high_y != Ysiz - 1:
+                            error_report.EmitError(
+                                "INSPIRE_TG",
+                                "RectifiedGrid.limits.GridEnvelope.high[y](=%d) != Ysiz(=%d) - 1"
+                                % (high_y, Ysiz),
+                                conformance_class="A.8.6",
+                            )
+                    else:
+                        error_report.EmitError(
+                            "INSPIRE_TG", "Cannot find low/high node in RectifiedGrid"
+                        )
 
-        nParts = 0
-        nIters = 1
-        if bExplodeCollections:
-            poSrcGeometry = poFeature.GetGeometryRef()
-            if poSrcGeometry is not None:
-                eSrcType = wkbFlatten(poSrcGeometry.GetGeometryType())
-                if (
-                    eSrcType == ogr.wkbMultiPoint
-                    or eSrcType == ogr.wkbMultiLineString
-                    or eSrcType == ogr.wkbMultiPolygon
-                    or eSrcType == ogr.wkbGeometryCollection
-                ):
-                    nParts = poSrcGeometry.GetGeometryCount()
-                    nIters = nParts
-                    if nIters == 0:
-                        nIters = 1
-
-        for iPart in range(nIters):
-            nFeaturesInTransaction = nFeaturesInTransaction + 1
-            if nFeaturesInTransaction == nGroupTransactions:
-                poDstLayer.CommitTransaction()
-                poDstLayer.StartTransaction()
-                nFeaturesInTransaction = 0
+                    check_oi_rg_consistency(
+                        filename, gdal.SerializeXMLTree(rg), error_report
+                    )
 
-            gdal.ErrorReset()
-            poDstFeature = ogr.Feature(poDstLayer.GetLayerDefn())
+                rangetype = find_xml_node(oic, "gmlcov:rangeType")
+                if rangetype is None:
+                    rangetype = find_xml_node(oic, "rangeType")
+                if rangetype is None:
+                    error_report.EmitError(
+                        "INSPIRE_TG",
+                        "Cannot find gmlcov:rangeType in OrthoImageryCoverage",
+                    )
+                else:
+                    datarecord = find_xml_node(rangetype, "swe:DataRecord")
+                    if datarecord is None:
+                        datarecord = find_xml_node(rangetype, "DataRecord")
+                    if datarecord is None:
+                        error_report.EmitError(
+                            "INSPIRE_TG",
+                            "Cannot find swe:DataRecord in OrthoImageryCoverage.rangeType",
+                        )
+                    else:
+                        count_fields = 0
+                        min_vals = []
+                        max_vals = []
+                        for child_idx in range(XML_FIRST_CHILD_IDX, len(datarecord)):
+                            child = datarecord[child_idx]
+                            if child[XML_TYPE_IDX] == gdal.CXT_Element and (
+                                child[XML_VALUE_IDX] == "swe:field"
+                                or child[XML_VALUE_IDX] == "field"
+                            ):
+                                count_fields += 1
+
+                                interval = None
+                                constraint = find_xml_node(child, "swe:constraint")
+                                if constraint is None:
+                                    constraint = find_xml_node(child, "constraint")
+                                if constraint is not None:
+                                    AllowedValues = find_xml_node(
+                                        constraint, "swe:AllowedValues"
+                                    )
+                                    if AllowedValues is None:
+                                        AllowedValues = find_xml_node(
+                                            constraint, "AllowedValues"
+                                        )
+                                    if AllowedValues is not None:
+                                        interval = find_xml_node(
+                                            AllowedValues, "swe:interval"
+                                        )
+                                        if interval is None:
+                                            interval = find_xml_node(
+                                                AllowedValues, "interval"
+                                            )
+                                        if interval is not None:
+                                            interval = get_element_val(interval)
+                                if interval is None:
+                                    error_report.EmitError(
+                                        "INSPIRE_TG",
+                                        "Cannot find constraint.AllowedValues.interval for field %d"
+                                        % count_fields,
+                                    )
+                                    min_vals.append(None)
+                                    max_vals.append(None)
+                                else:
+                                    (min_val, max_val) = interval.split(" ")
+                                    min_val = int(min_val)
+                                    max_val = int(max_val)
+                                    min_vals.append(min_val)
+                                    max_vals.append(max_val)
+
+                        # Check number of fields regarding number of components
+                        if pclr is None:
+                            if count_fields != Csiz:
+                                error_report.EmitError(
+                                    "INSPIRE_TG",
+                                    "count(OrthoImageryCoverage.rangeType.field)(=%d) != Csiz(=%d) "
+                                    % (count_fields, Csiz),
+                                    conformance_class="A.8.6",
+                                )
+                            else:
+                                # Check consistency of each channel bit-depth
+                                # with the corresponding rangeType.field.
+                                for i in range(Csiz):
+                                    if tab_Ssiz[i] >= 128:
+                                        tab_Ssiz[i] -= 128
+                                        minSsiz = -(2 ** tab_Ssiz[i])
+                                        maxSsiz = 2 ** tab_Ssiz[i] - 1
+                                    else:
+                                        minSsiz = 0
+                                        maxSsiz = 2 ** (tab_Ssiz[i] + 1) - 1
+                                    if (
+                                        min_vals[i] is not None
+                                        and max_vals[i] is not None
+                                    ):
+                                        if min_vals[i] != minSsiz:
+                                            error_report.EmitError(
+                                                "INSPIRE_TG",
+                                                "rangeType.field[%d].min(=%d) != min(Ssiz[%d])(=%d)"
+                                                % (i, min_vals[i], i, minSsiz),
+                                                conformance_class="A.8.6",
+                                            )
+                                        if max_vals[i] != maxSsiz:
+                                            error_report.EmitError(
+                                                "INSPIRE_TG",
+                                                "rangeType.field[%d].max(=%d) != max(Ssiz[%d])(=%d)"
+                                                % (i, max_vals[i], i, maxSsiz),
+                                                conformance_class="A.8.6",
+                                            )
+                        else:
+                            if count_fields != 3:
+                                error_report.EmitError(
+                                    "INSPIRE_TG",
+                                    "count(OrthoImageryCoverage.rangeType.field)(=%d) != 3 (for color table)"
+                                    % (count_fields),
+                                    conformance_class="A.8.6",
+                                )
+
+    # Validate content of COD marker
+    cod = find_marker(cs, "COD")
+    if not cod:
+        error_report.EmitError("GENERAL", "No COD marker found")
+    else:
+        while True:
+            SPcod_transformation = get_field_val(cod, "SPcod_transformation")
+            if SPcod_transformation is None:
+                error_report.EmitError(
+                    "GENERAL",
+                    "cod.SPcod_transformation not found (and perhaps other fields)",
+                )
+                break
 
-            if poDstFeature.SetFromWithMap(poFeature, 1, panMap) != 0:
+            Scod = int_or_none(get_field_val(cod, "Scod"))
 
-                if nGroupTransactions > 0:
-                    poDstLayer.CommitTransaction()
+            SPcod_NumDecompositions = int(get_field_val(cod, "SPcod_NumDecompositions"))
+            if (inspire_tg or Rsiz == 2) and siz:
+                if XTsiz <= Xsiz - XOsiz and YTsiz <= Ysiz - YOsiz:
+                    max_dim = max(XTsiz, YTsiz)
+                else:
+                    max_dim = max(Xsiz - XOsiz, Ysiz - YOsiz)
+                if max_dim > 128 * 2**SPcod_NumDecompositions:
+                    error_report.EmitError(
+                        "PROFILE_1",
+                        "Not enough decomposition levels = %d (max_dim=%d, 128 * 2**SPcod_NumDecompositions=%d)"
+                        % (
+                            SPcod_NumDecompositions,
+                            max_dim,
+                            128 * 2**SPcod_NumDecompositions,
+                        ),
+                    )
 
-                print(
-                    "Unable to translate feature %d from layer %s"
-                    % (poFeature.GetFID(), poSrcLayer.GetName())
+            SPcod_xcb_minus_2 = int(get_field_val(cod, "SPcod_xcb_minus_2"))
+            SPcod_ycb_minus_2 = int(get_field_val(cod, "SPcod_ycb_minus_2"))
+            if (inspire_tg or Rsiz == 2) and SPcod_xcb_minus_2 > 6 - 2:
+                error_report.EmitError(
+                    "PROFILE_1",
+                    "SPcod_xcb_minus_2 = %d, whereas max allowed for Profile 1 is 4"
+                    % SPcod_xcb_minus_2,
+                )
+            if (inspire_tg or Rsiz == 2) and SPcod_ycb_minus_2 > 6 - 2:
+                error_report.EmitError(
+                    "PROFILE_1",
+                    "SPcod_ycb_minus_2 = %d, whereas max allowed for Profile 1 is 4"
+                    % SPcod_ycb_minus_2,
+                )
+            if SPcod_xcb_minus_2 + SPcod_ycb_minus_2 > 8:
+                error_report.EmitError(
+                    "GENERAL",
+                    "SPcod_xcb_minus_2 + SPcod_ycb_minus_2 = %d, whereas max allowed is 8"
+                    % (SPcod_xcb_minus_2 + SPcod_ycb_minus_2),
                 )
 
-                return False
-
-            if bPreserveFID:
-                poDstFeature.SetFID(poFeature.GetFID())
-
-            poDstGeometry = poDstFeature.GetGeometryRef()
-            if poDstGeometry is not None:
-
-                if nParts > 0:
-                    # For -explodecollections, extract the iPart(th) of the geometry
-                    poPart = poDstGeometry.GetGeometryRef(iPart).Clone()
-                    poDstFeature.SetGeometryDirectly(poPart)
-                    poDstGeometry = poPart
-
-                if iSrcZField != -1:
-                    SetZ(poDstGeometry, poFeature.GetFieldAsDouble(iSrcZField))
-                    # This will correct the coordinate dimension to 3
-                    poDupGeometry = poDstGeometry.Clone()
-                    poDstFeature.SetGeometryDirectly(poDupGeometry)
-                    poDstGeometry = poDupGeometry
-
-                if nCoordDim == 2 or nCoordDim == 3:
-                    poDstGeometry.SetCoordinateDimension(nCoordDim)
-
-                if eGeomOp == GeomOperation.SEGMENTIZE:
-                    pass
-                    # if (poDstFeature.GetGeometryRef() is not None and dfGeomOpParam > 0)
-                    #    poDstFeature.GetGeometryRef().segmentize(dfGeomOpParam);
-                elif (
-                    eGeomOp == GeomOperation.SIMPLIFY_PRESERVE_TOPOLOGY
-                    and dfGeomOpParam > 0
-                ):
-                    poNewGeom = poDstGeometry.SimplifyPreserveTopology(dfGeomOpParam)
-                    if poNewGeom is not None:
-                        poDstFeature.SetGeometryDirectly(poNewGeom)
-                        poDstGeometry = poNewGeom
-
-                if poClipSrc is not None:
-                    poClipped = poDstGeometry.Intersection(poClipSrc)
-                    if poClipped is None or poClipped.IsEmpty():
-                        # Report progress
-                        nCount = nCount + 1
-                        if pfnProgress is not None:
-                            pfnProgress(
-                                nCount * 1.0 / nCountLayerFeatures, "", pProgressArg
-                            )
-                        continue
+            for i in range(SPcod_NumDecompositions + 1):
+                SPcod_Precincts = get_field_val(cod, "SPcod_Precincts%d" % i)
+                if SPcod_Precincts is not None and (Scod & 1) == 0:
+                    error_report.EmitWarning(
+                        "GENERAL",
+                        "User-defined precincts %d found but "
+                        "SPcod_transformation did not advertise it" % i,
+                    )
+                elif SPcod_Precincts is None and (Scod & 1) != 0:
+                    error_report.EmitWarning(
+                        "GENERAL",
+                        "No user-defined precincts %d defined but SPcod_transformation advertized it"
+                        % i,
+                    )
+                elif SPcod_Precincts is None and inspire_tg:
+                    error_report.EmitWarning(
+                        "INSPIRE_TG",
+                        "No user-defined precincts %d defined" % i,
+                        recommendation=39,
+                    )
 
-                    poDstFeature.SetGeometryDirectly(poClipped)
-                    poDstGeometry = poClipped
+            break
 
-                if poCT is not None:
-                    eErr = poDstGeometry.Transform(poCT)
-                    if eErr != 0:
-                        if nGroupTransactions > 0:
-                            poDstLayer.CommitTransaction()
-
-                        print(
-                            "Failed to reproject feature %d (geometry probably out of source or destination SRS)."
-                            % poFeature.GetFID()
-                        )
-                        if not bSkipFailures:
-                            return False
+    # Check QCD marker
+    qcd = find_marker(cs, "QCD")
+    if not qcd:
+        error_report.EmitError("GENERAL", "No QCD marker found")
+
+    # Check SOT marker
+    sot = find_marker(cs, "SOT")
+    if not sot:
+        error_report.EmitError("GENERAL", "No SOT marker found")
+
+    # Check RGN marker presence
+    rgn = find_marker(cs, "RGN")
+    if inspire_tg and rgn:
+        error_report.EmitError(
+            "INSPIRE_TG",
+            "RGN marker found, which is not allowed",
+            requirement=26,
+            conformance_class="A.8.16",
+        )
 
-                elif poOutputSRS is not None:
-                    poDstGeometry.AssignSpatialReference(poOutputSRS)
+    # Check EOC marker
+    eoc = find_marker(cs, "EOC")
+    if not eoc:
+        error_report.EmitError("GENERAL", "No EOC marker found")
+
+    return error_report
+
+
+def main(argv=sys.argv):
+    i = 1
+    filename = None
+    oidoc = None
+    ogc_schemas_location = None
+    inspire_tg = False
+    expected_gmljp2 = False
+    datatype = "imagery"
+    while i < len(argv):
+        if argv[i] == "-oidoc":
+            if i >= len(argv) - 1:
+                return Usage()
+            oidoc = argv[i + 1]
+            i = i + 1
+        elif argv[i] == "-ogc_schemas_location":
+            if i >= len(argv) - 1:
+                return Usage()
+            ogc_schemas_location = argv[i + 1]
+            i = i + 1
+        elif argv[i] == "-datatype":
+            if i >= len(argv) - 1:
+                return Usage()
+            datatype = argv[i + 1]
+            i = i + 1
+        elif argv[i] == "-inspire_tg":
+            inspire_tg = True
+        elif argv[i] == "-expected_gmljp2":
+            expected_gmljp2 = True
+        elif argv[i][0] == "-":
+            return Usage()
+        elif filename is None:
+            filename = argv[i]
+        else:
+            return Usage()
 
-                if poClipDst is not None:
-                    poClipped = poDstGeometry.Intersection(poClipDst)
-                    if poClipped is None or poClipped.IsEmpty():
-                        continue
-
-                    poDstFeature.SetGeometryDirectly(poClipped)
-                    poDstGeometry = poClipped
-
-                if bForceToPolygon:
-                    poDstFeature.SetGeometryDirectly(ogr.ForceToPolygon(poDstGeometry))
-
-                elif bForceToMultiPolygon or (
-                    bPromoteToMulti
-                    and wkbFlatten(poDstGeometry.GetGeometryType()) == ogr.wkbPolygon
-                ):
-                    poDstFeature.SetGeometryDirectly(
-                        ogr.ForceToMultiPolygon(poDstGeometry)
-                    )
-
-                elif bForceToMultiLineString or (
-                    bPromoteToMulti
-                    and wkbFlatten(poDstGeometry.GetGeometryType()) == ogr.wkbLineString
-                ):
-                    poDstFeature.SetGeometryDirectly(
-                        ogr.ForceToMultiLineString(poDstGeometry)
-                    )
-
-            gdal.ErrorReset()
-            if poDstLayer.CreateFeature(poDstFeature) != 0 and not bSkipFailures:
-                if nGroupTransactions > 0:
-                    poDstLayer.RollbackTransaction()
-
-                return False
-
-        # Report progress
-        nCount = nCount + 1
-        if pfnProgress is not None:
-            if nSrcFileSize != 0:
-                if (nCount % 1000) == 0:
-                    poFCLayer = poSrcDS.ExecuteSQL("GetBytesRead()", None, None)
-                    if poFCLayer is not None:
-                        poFeat = poFCLayer.GetNextFeature()
-                        if poFeat is not None:
-                            pszReadSize = poFeat.GetFieldAsString(0)
-                            nReadSize = int(pszReadSize)
-                            pfnProgress(
-                                nReadSize * 1.0 / nSrcFileSize, "", pProgressArg
-                            )
-                    poSrcDS.ReleaseResultSet(poFCLayer)
-            else:
-                pfnProgress(nCount * 1.0 / nCountLayerFeatures, "", pProgressArg)
+        i = i + 1
 
-        if pnReadFeatureCount is not None:
-            pnReadFeatureCount[0] = nCount
+    if filename is None:
+        return Usage()
 
-    if nGroupTransactions > 0:
-        poDstLayer.CommitTransaction()
+    if ogc_schemas_location is None:
+        try:
+            os.stat("SCHEMAS_OPENGIS_NET")
+            ogc_schemas_location = "SCHEMAS_OPENGIS_NET"
+        except OSError:
+            pass
+
+    if ogc_schemas_location is not None:
+        try:
+            os.stat("%s/xml.xsd" % ogc_schemas_location)
+        except OSError:
+            try:
+                os.stat("%s/SCHEMAS_OPENGIS_NET/xml.xsd" % ogc_schemas_location)
+                ogc_schemas_location = "%s/SCHEMAS_OPENGIS_NET" % ogc_schemas_location
+            except OSError:
+                print(
+                    "Cannot find %s/xml.xsd. -ogc_schemas_location value is probably wrong"
+                    % ogc_schemas_location
+                )
+                return 1
 
-    return True
+    return validate(
+        filename, oidoc, inspire_tg, expected_gmljp2, ogc_schemas_location, datatype
+    ).error_count
 
 
 if __name__ == "__main__":
     sys.exit(main(sys.argv))
```

### Comparing `GDAL-3.8.5/gdal-utils/osgeo_utils/samples/ogr2vrt.py` & `GDAL-3.9.0/gdal-utils/osgeo_utils/samples/ogr2vrt.py`

 * *Files identical despite different names*

### Comparing `GDAL-3.8.5/gdal-utils/osgeo_utils/samples/ogr_build_junction_table.py` & `GDAL-3.9.0/gdal-utils/osgeo_utils/samples/ogr_build_junction_table.py`

 * *Files identical despite different names*

### Comparing `GDAL-3.8.5/gdal-utils/osgeo_utils/samples/ogr_dispatch.py` & `GDAL-3.9.0/gdal-utils/osgeo_utils/samples/ogr_dispatch.py`

 * *Files identical despite different names*

### Comparing `GDAL-3.8.5/gdal-utils/osgeo_utils/samples/ogrinfo.py` & `GDAL-3.9.0/gdal-utils/osgeo_utils/samples/ogrinfo.py`

 * *Files identical despite different names*

### Comparing `GDAL-3.8.5/gdal-utils/osgeo_utils/samples/ogrupdate.py` & `GDAL-3.9.0/gdal-utils/osgeo_utils/samples/ogrupdate.py`

 * *Files identical despite different names*

### Comparing `GDAL-3.8.5/gdal-utils/osgeo_utils/samples/rel.py` & `GDAL-3.9.0/gdal-utils/osgeo_utils/samples/rel.py`

 * *Files identical despite different names*

### Comparing `GDAL-3.8.5/gdal-utils/osgeo_utils/samples/tigerpoly.py` & `GDAL-3.9.0/gdal-utils/osgeo_utils/samples/tigerpoly.py`

 * *Files identical despite different names*

### Comparing `GDAL-3.8.5/gdal-utils/osgeo_utils/samples/tile_extent_from_raster.py` & `GDAL-3.9.0/gdal-utils/osgeo_utils/samples/tile_extent_from_raster.py`

 * *Files identical despite different names*

### Comparing `GDAL-3.8.5/gdal-utils/osgeo_utils/samples/tolatlong.py` & `GDAL-3.9.0/gdal-utils/osgeo_utils/samples/tolatlong.py`

 * *Files identical despite different names*

### Comparing `GDAL-3.8.5/gdal-utils/osgeo_utils/samples/val_repl.py` & `GDAL-3.9.0/gdal-utils/osgeo_utils/samples/val_repl.py`

 * *Files identical despite different names*

### Comparing `GDAL-3.8.5/gdal-utils/osgeo_utils/samples/validate_cloud_optimized_geotiff.py` & `GDAL-3.9.0/gdal-utils/osgeo_utils/samples/validate_cloud_optimized_geotiff.py`

 * *Files identical despite different names*

### Comparing `GDAL-3.8.5/gdal-utils/osgeo_utils/samples/validate_geoparquet.py` & `GDAL-3.9.0/gdal-utils/osgeo_utils/samples/validate_geoparquet.py`

 * *Files 17% similar despite different names*

```diff
@@ -177,24 +177,31 @@
             self._error(
                 "'geo' metadata item lacks a 'version' member. Value of 'geo' = '%s'"
                 % geo
             )
             if not self.local_schema:
                 return
 
-        if self.local_schema:
-            schema_j = json.loads(open(self.local_schema, "rb").read())
+            version = None
         else:
             version = geo_j["version"]
             if not isinstance(version, str):
                 return self._error(
                     "'geo[\"version\"]' is not a string. Value of 'geo' = '%s'" % geo
                 )
 
-            schema_url = f"https://github.com/opengeospatial/geoparquet/releases/download/v{version}/schema.json"
+        if self.local_schema:
+            schema_j = json.loads(open(self.local_schema, "rb").read())
+        else:
+            # FIXME: Remove that temporary hack once GeoParquet 1.1 schema is released
+            if version == "1.1.0":
+                schema_url = "https://github.com/opengeospatial/geoparquet/releases/download/v1.0.0/schema.json"
+            else:
+                schema_url = f"https://github.com/opengeospatial/geoparquet/releases/download/v{version}/schema.json"
+
             if schema_url not in geoparquet_schemas:
                 import urllib
 
                 try:
                     response = urllib.request.urlopen(schema_url).read()
                 except Exception as e:
                     return self._error(
@@ -206,14 +213,24 @@
                 except Exception as e:
                     return self._error(
                         f"Failed to read GeoParquet schema at {schema_url} as JSON. Schema content = '{response}'. Exception = {repr(e)}"
                     )
 
             schema_j = geoparquet_schemas[schema_url]
 
+        # FIXME: Remove that temporary hack once GeoParquet 1.1 schema is released
+        if version == "1.1.0":
+            schema_j["properties"]["version"] = {"const": "1.1.0", "type": "string"}
+            schema_j["properties"]["columns"]["patternProperties"][".+"]["properties"][
+                "encoding"
+            ] = {
+                "type": "string",
+                "pattern": "^(WKB|point|linestring|polygon|multipoint|multilinestring|multipolygon)$",
+            }
+
         try:
             self._validate(schema_j, geo_j)
         except Exception as e:
             self._error(
                 "'geo' metadata item fails to validate its schema: %s'" % str(e)
             )
 
@@ -309,15 +326,108 @@
                 set_geometry_types = set()
                 for geometry_type in geometry_types:
                     if geometry_type in set_geometry_types:
                         self._error(
                             f"{geometry_type} is declared several times in geometry_types[]"
                         )
 
+    def _check_data_with_high_level_ogr_api(self, lyr, columns):
+        """Use for GeoArrow validation"""
+
+        if gdal.VersionInfo() < "3090000":
+            raise Exception("GDAL 3.9 or later required for GeoArrow data validation")
+
+        lyr.SetIgnoredFields(
+            [
+                lyr.GetLayerDefn().GetFieldDefn(i).GetName()
+                for i in range(lyr.GetLayerDefn().GetFieldCount())
+            ]
+        )
+
+        list_of_set_geometry_types = []
+        orientations = []
+        encodings = []
+        assert len(columns) == lyr.GetLayerDefn().GetGeomFieldCount()
+        for i in range(lyr.GetLayerDefn().GetGeomFieldCount()):
+            column_def = columns[lyr.GetLayerDefn().GetGeomFieldDefn(i).GetName()]
+
+            encodings.append(column_def["encoding"])
+
+            if "geometry_types" in column_def:
+                geometry_types = column_def["geometry_types"]
+                set_geometry_types = set(geometry_types)
+            else:
+                set_geometry_types = set()
+            list_of_set_geometry_types.append(set_geometry_types)
+
+            if "orientation" in column_def:
+                orientation = column_def["orientation"]
+            else:
+                orientation = None
+            orientations.append(orientation)
+
+        map_ogr_geom_type_to_geoarrow_encoding = {
+            ogr.wkbPoint: "point",
+            ogr.wkbLineString: "linestring",
+            ogr.wkbPolygon: "polygon",
+            ogr.wkbMultiPoint: "multipoint",
+            ogr.wkbMultiLineString: "multilinestring",
+            ogr.wkbMultiPolygon: "multipolygon",
+        }
+
+        for row, f in enumerate(lyr):
+            for i in range(lyr.GetLayerDefn().GetGeomFieldCount()):
+                g = f.GetGeomFieldRef(i)
+                if g:
+                    ogr_geom_type = g.GetGeometryType()
+                    if ogr_geom_type not in map_ogr_geom_type_to_geoparquet:
+                        self._error(
+                            f"Geometry at row {row} is of unexpected type for GeoParquet: %s"
+                            % g.GetGeometryName()
+                        )
+                    elif list_of_set_geometry_types[i]:
+                        geoparquet_geom_type = map_ogr_geom_type_to_geoparquet[
+                            ogr_geom_type
+                        ]
+                        if geoparquet_geom_type not in list_of_set_geometry_types[i]:
+                            self._error(
+                                f"Geometry at row {row} is of type {geoparquet_geom_type}, but not listed in geometry_types[]"
+                            )
+
+                    ogr_flat_geom_type = ogr.GT_Flatten(ogr_geom_type)
+                    if ogr_flat_geom_type not in map_ogr_geom_type_to_geoarrow_encoding:
+                        self._error(
+                            f"Geometry at row {row} is of unexpected type for a GeoArrow encoding of GeoParquet: %s"
+                            % g.GetGeometryName()
+                        )
+                    elif (
+                        map_ogr_geom_type_to_geoarrow_encoding[ogr_flat_geom_type]
+                        != encodings[i]
+                    ):
+                        self._error(
+                            f"Geometry at row {row} is a %s but does not match the declared encoding of %s"
+                            % (ogr.GeometryTypeToName(ogr_geom_type), encodings[i])
+                        )
+
+                    if orientations[i] == "counterclockwise":
+                        self._check_counterclockwise(g, row)
+
     def _check_data(self, lyr, columns):
+
+        # For non-WKB encoding, just use the high level OGR API
+        use_high_level_ogr_api = False
+        for _, column_def in columns.items():
+            if column_def["encoding"] != "WKB":
+                use_high_level_ogr_api = True
+                break
+
+        if use_high_level_ogr_api:
+            self._check_data_with_high_level_ogr_api(lyr, columns)
+            return
+
         lyr.SetIgnoredFields(
             [
                 lyr.GetLayerDefn().GetFieldDefn(i).GetName()
                 for i in range(lyr.GetLayerDefn().GetFieldCount())
             ]
         )
```

### Comparing `GDAL-3.8.5/gdal-utils/osgeo_utils/samples/validate_gpkg.py` & `GDAL-3.9.0/gdal-utils/osgeo_utils/samples/validate_gpkg.py`

 * *Files identical despite different names*

### Comparing `GDAL-3.8.5/gdal-utils/osgeo_utils/samples/vec_tr.py` & `GDAL-3.9.0/gdal-utils/osgeo_utils/samples/vec_tr.py`

 * *Files identical despite different names*

### Comparing `GDAL-3.8.5/gdal-utils/osgeo_utils/samples/vec_tr_spat.py` & `GDAL-3.9.0/gdal-utils/osgeo_utils/samples/vec_tr_spat.py`

 * *Files identical despite different names*

### Comparing `GDAL-3.8.5/gdal-utils/osgeo_utils/samples/wcs_virtds_params.py` & `GDAL-3.9.0/gdal-utils/osgeo_utils/samples/wcs_virtds_params.py`

 * *Files identical despite different names*

### Comparing `GDAL-3.8.5/gdal-utils/scripts/gdal2tiles.py` & `GDAL-3.9.0/gdal-utils/scripts/gdal2tiles.py`

 * *Files identical despite different names*

### Comparing `GDAL-3.8.5/osgeo/__init__.py` & `GDAL-3.9.0/osgeo/__init__.py`

 * *Files identical despite different names*

### Comparing `GDAL-3.8.5/osgeo/gdal.py` & `GDAL-3.9.0/osgeo/gdal.py`

 * *Files 24% similar despite different names*

```diff
@@ -410,14 +410,15 @@
 
 
 def VectorInfoOptions(options=None,
                       format='text',
                       deserialize=True,
                       layers=None,
                       dumpFeatures=False,
+                      limit=None,
                       featureCount=True,
                       extent=True,
                       SQLStatement=None,
                       SQLDialect=None,
                       where=None,
                       wktFormat=None):
     """ Create a VectorInfoOptions() object that can be passed to gdal.VectorInfo()
@@ -438,17 +439,19 @@
         where:
             WHERE clause to apply to source layer(s)
         layers:
             list of layers of interest
         featureCount:
             whether to compute and display the feature count
         extent:
-            whether to compute and display the layer extent
+            whether to compute and display the layer extent. Can also be set to the string '3D' to request a 3D extent
         dumpFeatures:
             set to True to get the dump of all features
+        limit:
+            maximum number of features to read per layer
     """
 
     options = [] if options is None else options
     deserialize=True
 
     if isinstance(options, str):
         new_options = ParseCommandLine(options)
@@ -470,28 +473,32 @@
             new_options += ['-dialect', SQLDialect]
         if where:
             new_options += ['-where', where]
         if wktFormat:
             new_options += ['-wkt_format', wktFormat]
         if not featureCount:
             new_options += ['-nocount']
-        if not extent:
+        if extent in ('3d', '3D'):
+            new_options += ['-extent3D']
+        elif not extent:
             new_options += ['-noextent']
         if layers:
             new_options += ["dummy_dataset_name"]
             for layer in layers:
                 new_options += [layer]
         else:
             new_options += ["-al"]
         if format == 'json':
             if dumpFeatures:
                 new_options += ["-features"]
         else:
             if not dumpFeatures:
                 new_options += ["-so"]
+        if limit:
+            new_options += ["-limit", str(limit)]
 
     return (GDALVectorInfoOptions(new_options), format, deserialize)
 
 
 def VectorInfo(ds, **kwargs):
     """Return information on a vector dataset.
 
@@ -600,15 +607,16 @@
               creationOptions=None, srcWin=None, projWin=None, projWinSRS=None, strict = False,
               unscale = False, scaleParams=None, exponents=None,
               outputBounds=None, outputGeotransform=None, metadataOptions=None,
               outputSRS=None, nogcp=False, GCPs=None,
               noData=None, rgbExpand=None,
               stats = False, rat = True, xmp = True, resampleAlg=None,
               overviewLevel = 'AUTO',
-              callback=None, callback_data=None):
+              callback=None, callback_data=None,
+              domainMetadataOptions = None):
     """Create a TranslateOptions() object that can be passed to gdal.Translate()
 
     Parameters
     ----------
     options:
         can be be an array of strings, a string or let empty and filled from other keywords.
     format:
@@ -673,14 +681,16 @@
         resampling mode
     overviewLevel:
         To specify which overview level of source files must be used
     callback:
         callback method
     callback_data:
         user data for callback
+    domainMetadataOptions:
+        list or dict of domain-specific metadata options
     """
 
 # Only used for tests
     return_option_list = options == '__RETURN_OPTION_LIST__'
 
     if return_option_list:
         options = []
@@ -742,14 +752,25 @@
                 new_options += ['-mo', metadataOptions]
             elif isinstance(metadataOptions, dict):
                 for k, v in metadataOptions.items():
                     new_options += ['-mo', f'{k}={v}']
             else:
                 for opt in metadataOptions:
                     new_options += ['-mo', opt]
+        if domainMetadataOptions is not None:
+            if isinstance(domainMetadataOptions, str):
+                new_options += ['-dmo', domainMetadataOptions]
+            elif isinstance(domainMetadataOptions, dict):
+                for d in domainMetadataOptions:
+                  things = domainMetadataOptions[d]
+                  for k, v in things.items():
+                    new_options += ['-dmo', f'{d}:{k}={v}']
+            else:
+                for opt in domainMetadataOptions:
+                    new_options += ['-dmo', opt]
         if outputSRS is not None:
             new_options += ['-a_srs', str(outputSRS)]
         if nogcp:
             new_options += ['-nogcp']
         if GCPs is not None:
             for gcp in GCPs:
                 new_options += ['-gcp', _strHighPrec(gcp.GCPPixel), _strHighPrec(gcp.GCPLine), _strHighPrec(gcp.GCPX), str(gcp.GCPY), _strHighPrec(gcp.GCPZ)]
@@ -834,14 +855,16 @@
          srcAlpha = None, dstAlpha = False,
          warpOptions=None, errorThreshold=None,
          warpMemoryLimit=None, creationOptions=None, outputType = gdalconst.GDT_Unknown,
          workingType = gdalconst.GDT_Unknown, resampleAlg=None,
          srcNodata=None, dstNodata=None, multithread = False,
          tps = False, rpc = False, geoloc = False, polynomialOrder=None,
          transformerOptions=None, cutlineDSName=None,
+         cutlineWKT=None,
+         cutlineSRS=None,
          cutlineLayer=None, cutlineWhere=None, cutlineSQL=None, cutlineBlend=None, cropToCutline = False,
          copyMetadata = True, metadataConflictValue=None,
          setColorInterpretation = False,
          overviewLevel = 'AUTO',
          callback=None, callback_data=None):
     """Create a WarpOptions() object that can be passed to gdal.Warp()
 
@@ -907,15 +930,19 @@
     geoloc:
         whether to use GeoLocation array transformer
     polynomialOrder:
         order of polynomial GCP interpolation
     transformerOptions:
         list or dict of transformer options
     cutlineDSName:
-        cutline dataset name
+        cutline dataset name (mutually exclusive with cutlineDSName)
+    cutlineWKT:
+        cutline WKT geometry (POLYGON or MULTIPOLYGON) (mutually exclusive with cutlineWKT)
+    cutlineSRS:
+        set/override cutline SRS
     cutlineLayer:
         cutline layer name
     cutlineWhere:
         cutline WHERE clause
     cutlineSQL:
         cutline SQL statement
     cutlineBlend:
@@ -1041,15 +1068,21 @@
             if isinstance(transformerOptions, dict):
                 for k, v in transformerOptions.items():
                     new_options += ['-to', opt]
             else:
                 for opt in transformerOptions:
                     new_options += ['-to', opt]
         if cutlineDSName is not None:
+            if cutlineWKT is not None:
+                raise Exception("cutlineDSName and cutlineWKT are mutually exclusive")
             new_options += ['-cutline', str(cutlineDSName)]
+        if cutlineWKT is not None:
+            new_options += ['-cutline', str(cutlineWKT)]
+        if cutlineSRS is not None:
+            new_options += ['-cutline_srs', str(cutlineSRS)]
         if cutlineLayer is not None:
             new_options += ['-cl', str(cutlineLayer)]
         if cutlineWhere is not None:
             new_options += ['-cwhere', str(cutlineWhere)]
         if cutlineSQL is not None:
             new_options += ['-csql', str(cutlineSQL)]
         if cutlineBlend is not None:
@@ -1153,14 +1186,18 @@
          makeValid=False,
          mapFieldType=None,
          explodeCollections=False,
          zField=None,
          resolveDomains=False,
          skipFailures=False,
          limit=None,
+         xyRes=None,
+         zRes=None,
+         mRes=None,
+         setCoordPrecision=True,
          callback=None, callback_data=None):
     """
     Create a VectorTranslateOptions() object that can be passed to
     gdal.VectorTranslate()
 
     Parameters
     ----------
@@ -1273,14 +1310,22 @@
     resolveDomains:
         whether to create an additional field for each field associated with a coded
         field domain.
     skipFailures:
         whether to skip failures
     limit:
         maximum number of features to read per layer
+    xyRes:
+        Geometry X,Y coordinate resolution. Numeric value, or numeric value suffixed with " m", " mm" or "deg".
+    zRes:
+        Geometry Z coordinate resolution. Numeric value, or numeric value suffixed with " m" or " mm".
+    mRes:
+        Geometry M coordinate resolution. Numeric value.
+    setCoordPrecision:
+        Set to False to unset the geometry coordinate precision.
     callback:
         callback method
     callback_data:
         user data for callback
     """
 
 # Only used for tests
@@ -1330,15 +1375,18 @@
         if emptyStrAsNull:
             new_options += ['-emptyStrAsNull']
         if selectFields is not None:
             val = ''
             for item in selectFields:
                 if val:
                     val += ','
-                val += item
+                if ',' in item or ' ' in item or '"' in item:
+                    val += '"' + item.replace('"', '\\"') + '"'
+                else:
+                    val += item
             new_options += ['-select', val]
 
         if datasetCreationOptions is not None:
             if isinstance(datasetCreationOptions, dict):
                 for k, v in datasetCreationOptions.items():
                     new_options += ['-dsco', f'{k}={v}']
             else:
@@ -1453,14 +1501,23 @@
             new_options += ['-zfield', zField]
         if resolveDomains:
             new_options += ['-resolveDomains']
         if skipFailures:
             new_options += ['-skip']
         if limit is not None:
             new_options += ['-limit', str(limit)]
+        if xyRes is not None:
+            new_options += ['-xyRes', str(xyRes)]
+        if zRes is not None:
+            new_options += ['-zRes', str(zRes)]
+        if mRes is not None:
+            new_options += ['-mRes', str(mRes)]
+        if setCoordPrecision is False:
+            new_options += ["-unsetCoordPrecision"]
+
     if callback is not None:
         new_options += ['-progress']
 
     if return_option_list:
         return new_options
 
     return (GDALVectorTranslateOptions(new_options), callback, callback_data)
@@ -2132,14 +2189,16 @@
                      splitPolys=None,
                      convexHull=None,
                      densify=None,
                      simplify=None,
                      maxPoints=None,
                      minRingArea=None,
                      layerName=None,
+                     locationFieldName="location",
+                     writeAbsolutePath=False,
                      layerCreationOptions=None,
                      datasetCreationOptions=None,
                      callback=None, callback_data=None):
     """Create a FootprintOptions() object that can be passed to gdal.Footprint()
 
     Parameters
     ----------
@@ -2171,14 +2230,18 @@
         tolerance value for polygon densification
     simplify:
         tolerance value for polygon simplification
     maxPoints:
         maximum number of points (100 by default, "unlimited" for unlimited)
     minRingArea:
         Minimum value for the area of a ring The unit of the area is in square pixels if targetCoordinateSystem equals "pixel", or otherwise in georeferenced units of the target vector dataset. This option is applied after the reprojection implied by dstSRS
+    locationFieldName:
+        Specifies the name of the field in the resulting vector dataset where the path of the input dataset will be stored. The default field name is "location". Can be set to None to disable creation of such field.
+    writeAbsolutePath:
+        Enables writing the absolute path of the input dataset. By default, the filename is written in the location field exactly as the dataset name.
     layerName:
         output layer name
     callback:
         callback method
     callback_data:
         user data for callback
     """
@@ -2235,14 +2298,20 @@
         if layerCreationOptions is not None:
             if isinstance(layerCreationOptions, dict):
                 for k, v in layerCreationOptions.items():
                     new_options += ['-lco', f'{k}={v}']
             else:
                 for opt in layerCreationOptions:
                     new_options += ['-lco', opt]
+        if locationFieldName is not None:
+            new_options += ['-location_field_name', locationFieldName]
+        else:
+            new_options += ['-no_location']
+        if writeAbsolutePath:
+            new_options += ['-write_absolute_path']
 
     if return_option_list:
         return new_options
 
     return (GDALFootprintOptions(new_options), callback, callback_data)
 
 def Footprint(destNameOrDestDS, srcDS, **kwargs):
@@ -2352,14 +2421,15 @@
                     addAlpha=None,
                     resampleAlg=None,
                     outputSRS=None,
                     allowProjectionDifference=None,
                     srcNodata=None,
                     VRTNodata=None,
                     hideNodata=None,
+                    nodataMaxMaskThreshold=None,
                     strict=False,
                     callback=None, callback_data=None):
     """Create a BuildVRTOptions() object that can be passed to gdal.BuildVRT()
 
     Parameters
     ----------
     options:l
@@ -2389,14 +2459,16 @@
         Note: they will *not* be reprojected.
     srcNodata:
         source nodata value(s).
     VRTNodata:
         nodata values at the VRT band level.
     hideNodata:
         whether to make the VRT band not report the NoData value.
+    nodataMaxMaskThreshold:
+        value of the mask band of a source below which the source band values should be replaced by VRTNodata (or 0 if not specified)
     strict:
         set to True if warnings should be failures
     callback:
         callback method.
     callback_data:
         user data for callback.
     """
@@ -2437,14 +2509,16 @@
             new_options += ['-a_srs', str(outputSRS)]
         if allowProjectionDifference:
             new_options += ['-allow_projection_difference']
         if srcNodata is not None:
             new_options += ['-srcnodata', str(srcNodata)]
         if VRTNodata is not None:
             new_options += ['-vrtnodata', str(VRTNodata)]
+        if nodataMaxMaskThreshold is not None:
+            new_options += ['-nodata_max_mask_threshold', str(nodataMaxMaskThreshold)]
         if hideNodata:
             new_options += ['-hidenodata']
         if strict:
             new_options += ['-strict']
 
     if return_option_list:
         return new_options
@@ -2494,30 +2568,241 @@
 
     if srcDSTab:
         return BuildVRTInternalObjects(destName, srcDSTab, opts, callback, callback_data)
     else:
         return BuildVRTInternalNames(destName, srcDSNamesTab, opts, callback, callback_data)
 
 
+def TileIndexOptions(options=None,
+                     overwrite=None,
+                     recursive=None,
+                     filenameFilter=None,
+                     minPixelSize=None,
+                     maxPixelSize=None,
+                     format=None,
+                     layerName=None,
+                     layerCreationOptions=None,
+                     locationFieldName="location",
+                     outputSRS=None,
+                     writeAbsolutePath=None,
+                     skipDifferentProjection=None,
+                     gtiFilename=None,
+                     xRes=None,
+                     yRes=None,
+                     outputBounds=None,
+                     colorInterpretation=None,
+                     noData=None,
+                     bandCount=None,
+                     mask=None,
+                     metadataOptions=None,
+                     fetchMD=None):
+    """Create a TileIndexOptions() object that can be passed to gdal.TileIndex()
+
+    Parameters
+    ----------
+    options:
+        can be be an array of strings, a string or let empty and filled from other keywords.
+    overwrite:
+        Whether to overwrite the existing tile index
+    recursive:
+        Whether directories specified in source filenames should be explored recursively
+    filenameFilter:
+        Pattern that the filenames contained in directories pointed by <file_or_dir> should follow. '*' and '?' wildcard can be used. String or list of strings.
+    minPixelSize:
+        Minimum pixel size in term of geospatial extent per pixel (resolution) that a raster should have to be selected.
+    maxPixelSize:
+        Maximum pixel size in term of geospatial extent per pixel (resolution) that a raster should have to be selected.
+    format:
+        output format ("ESRI Shapefile", "GPKG", etc...)
+    layerName:
+        output layer name
+    layerCreationOptions:
+        list or dict of layer creation options
+    locationFieldName:
+        Specifies the name of the field in the resulting vector dataset where the path of the input dataset will be stored. The default field name is "location". Can be set to None to disable creation of such field.
+    outputSRS:
+        assigned output SRS
+    writeAbsolutePath:
+        Enables writing the absolute path of the input dataset. By default, the filename is written in the location field exactly as the dataset name.
+    skipDifferentProjection:
+        Whether to skip sources that have a different SRS
+    gtiFilename:
+        Filename of the GDAL XML Tile Index file
+    xRes:
+        output horizontal resolution
+    yRes:
+        output vertical resolution
+    outputBounds:
+        output bounds as [minx, miny, maxx, maxy]
+    colorInterpretation:
+        tile color interpretation, as a single value or a list, of the following values: "red", "green", "blue", "alpha", "grey", "undefined"
+    noData:
+        tile nodata value, as a single value or a list
+    bandCount:
+        number of band of tiles in the index
+    mask:
+        whether tiles have a band mask
+    metadataOptions:
+        list or dict of metadata options
+    fetchMD:
+        Fetch a metadata item from the raster tile and write it as a field in the
+        tile index.
+        Tuple (raster metadata item name, target field name, target field type), or list of such tuples, with target field type in "String", "Integer", "Integer64", "Real", "Date", "DateTime";
+    """
+
+# Only used for tests
+    return_option_list = options == '__RETURN_OPTION_LIST__'
+    if return_option_list:
+        options = []
+    else:
+        options = [] if options is None else options
+
+    if isinstance(options, str):
+        new_options = ParseCommandLine(options)
+    else:
+        import copy
+        new_options = copy.copy(options)
+        if overwrite:
+            new_options += ['-overwrite']
+        if recursive:
+            new_options += ['-recursive']
+        if filenameFilter is not None:
+            if isinstance(filenameFilter, list):
+                for filter in filenameFilter:
+                    new_options += ['-filename_filter', filter]
+            else:
+                new_options += ['-filename_filter', filenameFilter]
+        if minPixelSize is not None:
+            new_options += ['-min_pixel_size', _strHighPrec(minPixelSize)]
+        if maxPixelSize is not None:
+            new_options += ['-max_pixel_size', _strHighPrec(maxPixelSize)]
+        if format:
+            new_options += ['-f', format]
+        if layerName is not None:
+            new_options += ['-lyr_name', layerName]
+
+        if layerCreationOptions is not None:
+            if isinstance(layerCreationOptions, dict):
+                for k, v in layerCreationOptions.items():
+                    new_options += ['-lco', f'{k}={v}']
+            else:
+                for opt in layerCreationOptions:
+                    new_options += ['-lco', opt]
+
+        if locationFieldName is not None:
+            new_options += ['-tileindex', locationFieldName]
+        if outputSRS is not None:
+            new_options += ['-t_srs', str(outputSRS)]
+        if writeAbsolutePath:
+            new_options += ['-write_absolute_path']
+        if skipDifferentProjection:
+            new_options += ['-skip_different_projection']
+        if gtiFilename is not None:
+            new_options += ['-gti_filename', gtiFilename]
+        if xRes is not None and yRes is not None:
+            new_options += ['-tr', _strHighPrec(xRes), _strHighPrec(yRes)]
+        elif xRes is not None:
+            raise Exception("yRes should also be specified")
+        elif yRes is not None:
+            raise Exception("xRes should also be specified")
+        if outputBounds is not None:
+            new_options += ['-te', _strHighPrec(outputBounds[0]), _strHighPrec(outputBounds[1]), _strHighPrec(outputBounds[2]), _strHighPrec(outputBounds[3])]
+        if colorInterpretation is not None:
+            if isinstance(noData, list):
+                new_options += ['-colorinterp', ','.join(colorInterpretation)]
+            else:
+                new_options += ['-colorinterp', colorInterpretation]
+        if noData is not None:
+            if isinstance(noData, list):
+                new_options += ['-nodata', ','.join([_strHighPrec(x) for x in noData])]
+            else:
+                new_options += ['-nodata', _strHighPrec(noData)]
+        if bandCount is not None:
+            new_options += ['-bandcount', str(bandCount)]
+        if mask:
+            new_options += ['-mask']
+        if metadataOptions is not None:
+            if isinstance(metadataOptions, str):
+                new_options += ['-mo', metadataOptions]
+            elif isinstance(metadataOptions, dict):
+                for k, v in metadataOptions.items():
+                    new_options += ['-mo', f'{k}={v}']
+            else:
+                for opt in metadataOptions:
+                    new_options += ['-mo', opt]
+        if fetchMD is not None:
+            if isinstance(fetchMD, list):
+                for mdItemName, fieldName, fieldType in fetchMD:
+                    new_options += ['-fetch_md', mdItemName, fieldName, fieldType]
+            else:
+                new_options += ['-fetch_md', fetchMD[0], fetchMD[1], fetchMD[2]]
+
+    if return_option_list:
+        return new_options
+
+    callback = None
+    callback_data = None
+    return (GDALTileIndexOptions(new_options), callback, callback_data)
+
+def TileIndex(destName, srcFilenames, **kwargs):
+    """Build a tileindex from a list of datasets.
+
+    Parameters
+    ----------
+    destName:
+        Output dataset name.
+    srcFilenames:
+        An array of filenames.
+    kwargs:
+        options: return of gdal.TileIndexOptions(), string or array of strings,
+        other keywords arguments of gdal.TileIndexOptions().
+        If options is provided as a gdal.TileIndexOptions() object,
+        other keywords are ignored.
+    """
+
+    _WarnIfUserHasNotSpecifiedIfUsingExceptions()
+
+    if 'options' not in kwargs or isinstance(kwargs['options'], (list, str)):
+        (opts, callback, callback_data) = TileIndexOptions(**kwargs)
+    else:
+        (opts, callback, callback_data) = kwargs['options']
+
+    srcDSNamesTab = []
+
+    import os
+
+    if isinstance(srcFilenames, (str, os.PathLike)):
+        srcDSNamesTab = [str(srcFilenames)]
+    elif isinstance(srcFilenames, list):
+        for elt in srcFilenames:
+            srcDSNamesTab.append(str(elt))
+    else:
+        raise Exception("Unexpected type for srcFilenames")
+
+    return TileIndexInternalNames(destName, srcDSNamesTab, opts, callback, callback_data)
+
+
 def MultiDimTranslateOptions(options=None, format=None, creationOptions=None,
-         arraySpecs=None, groupSpecs=None, subsetSpecs=None, scaleAxesSpecs=None,
+         arraySpecs=None, arrayOptions=None, groupSpecs=None, subsetSpecs=None, scaleAxesSpecs=None,
          callback=None, callback_data=None):
     """Create a MultiDimTranslateOptions() object that can be passed to gdal.MultiDimTranslate()
 
     Parameters
     ----------
     options:
         can be be an array of strings, a string or let empty and filled from other keywords.
     format:
         output format ("GTiff", etc...)
     creationOptions:
         list or dict of creation options
     arraySpecs:
         list of array specifications, each of them being an array name or
         "name={src_array_name},dstname={dst_name},transpose=[1,0],view=[:,::-1]"
+    arrayOptions:
+        list of options passed to `GDALGroup.GetMDArrayNames` to filter reported arrays.
     groupSpecs:
         list of group specifications, each of them being a group name or
         "name={src_array_name},dstname={dst_name},recursive=no"
     subsetSpecs:
         list of subset specifications, each of them being like
         "{dim_name}({min_val},{max_val})" or "{dim_name}({slice_va})"
     scaleAxesSpecs:
@@ -2550,14 +2835,17 @@
                     new_options += ['-co', f'{k}={v}']
             else:
                 for opt in creationOptions:
                     new_options += ['-co', opt]
         if arraySpecs is not None:
             for s in arraySpecs:
                 new_options += ['-array', s]
+        if arrayOptions:
+            for option in arrayOptions:
+                new_options += ['-arrayoption', option]
         if groupSpecs is not None:
             for s in groupSpecs:
                 new_options += ['-group', s]
         if subsetSpecs is not None:
             for s in subsetSpecs:
                 new_options += ['-subset', s]
         if scaleAxesSpecs is not None:
@@ -2666,27 +2954,27 @@
 def config_options(options, thread_local=True):
     """Temporarily define a set of configuration options.
 
        Parameters
        ----------
        options: dict
             Dictionary of configuration options passed as key, value
-       thread_local: bool
+       thread_local: bool, default=True
             Whether the configuration options should be only set on the current
-            thread. The default is True.
+            thread.
 
        Returns
        -------
             A context manager
 
        Example
        -------
 
-           with gdal.config_options({"GDAL_NUM_THREADS": "ALL_CPUS"}):
-               gdal.Warp("out.tif", "in.tif", dstSRS="EPSG:4326")
+       >>> with gdal.config_options({"GDAL_NUM_THREADS": "ALL_CPUS"}):
+       ...     gdal.Warp("out.tif", "in.tif", dstSRS="EPSG:4326")
     """
     get_config_option = GetThreadLocalConfigOption if thread_local else GetGlobalConfigOption
     set_config_option = SetThreadLocalConfigOption if thread_local else SetConfigOption
 
     oldvals = {key: get_config_option(key) for key in options}
 
     for key in options:
@@ -2703,27 +2991,27 @@
 
        Parameters
        ----------
        key: str
             Name of the configuration option
        value: str
             Value of the configuration option
-       thread_local: bool
+       thread_local: bool, default=True
             Whether the configuration option should be only set on the current
-            thread. The default is True.
+            thread.
 
        Returns
        -------
             A context manager
 
        Example
        -------
 
-           with gdal.config_option("GDAL_NUM_THREADS", "ALL_CPUS"):
-               gdal.Warp("out.tif", "in.tif", dstSRS="EPSG:4326")
+       >>> with gdal.config_option("GDAL_NUM_THREADS", "ALL_CPUS"):
+       ...     gdal.Warp("out.tif", "in.tif", dstSRS="EPSG:4326")
     """
     return config_options({key: value}, thread_local=thread_local)
 
 
 @contextlib.contextmanager
 def quiet_errors():
     """Temporarily install an error handler that silents all warnings and errors.
@@ -2731,16 +3019,16 @@
        Returns
        -------
             A context manager
 
        Example
        -------
 
-           with gdal.ExceptionMgr(useExceptions=False), gdal.quiet_errors():
-               gdal.Error(gdal.CE_Failure, gdal.CPLE_AppDefined, "you will never see me")
+       >>> with gdal.ExceptionMgr(useExceptions=False), gdal.quiet_errors():
+       ...     gdal.Error(gdal.CE_Failure, gdal.CPLE_AppDefined, "you will never see me")
     """
     PushErrorHandler("CPLQuietErrorHandler")
     try:
         yield
     finally:
         PopErrorHandler()
 
@@ -2879,35 +3167,160 @@
     return _gdal.GetNextDirEntry(*args)
 
 def CloseDir(*args):
     r"""CloseDir(VSIDIR * dir)"""
     return _gdal.CloseDir(*args)
 
 def SetConfigOption(*args):
-    r"""SetConfigOption(char const * pszKey, char const * pszValue)"""
+    r"""
+    SetConfigOption(char const * pszKey, char const * pszValue)
+
+
+    Set the value of a configuration option for all threads.
+    See :cpp:func:`CPLSetConfigOption`.
+
+    Parameters
+    ----------
+    pszKey : str
+        name of the configuration option
+    pszValue : str
+        value of the configuration option
+
+    See Also
+    --------
+    :py:func:`SetThreadLocalConfigOption`
+    :py:func:`config_option`
+    :py:func:`config_options`
+
+
+    """
     return _gdal.SetConfigOption(*args)
 
 def SetThreadLocalConfigOption(*args):
-    r"""SetThreadLocalConfigOption(char const * pszKey, char const * pszValue)"""
+    r"""
+    SetThreadLocalConfigOption(char const * pszKey, char const * pszValue)
+
+
+    Set the value of a configuration option for the current thread.
+    See :cpp:func:`CPLSetThreadLocalConfigOption`.
+
+    Parameters
+    ----------
+    pszKey : str
+        name of the configuration option
+    pszValue : str
+        value of the configuration option
+
+    See Also
+    --------
+    :py:func:`SetConfigOption`
+    :py:func:`config_option`
+    :py:func:`config_options`
+
+    """
     return _gdal.SetThreadLocalConfigOption(*args)
 
 def GetConfigOption(*args):
-    r"""GetConfigOption(char const * pszKey, char const * pszDefault=None) -> char const *"""
+    r"""
+    GetConfigOption(char const * pszKey, char const * pszDefault=None) -> char const *
+
+
+    Return the value of a configuration option.
+    See :cpp:func:`CPLGetConfigOption`.
+
+    Parameters
+    ----------
+    pszKey : str
+        name of the configuration option
+    pszDefault : str, optional
+        default value to return if the option has not been set
+
+    Returns
+    -------
+    str
+
+    See Also
+    --------
+    :py:func:`GetConfigOptions`
+    :py:func:`GetThreadLocalConfigOption`
+
+    """
     return _gdal.GetConfigOption(*args)
 
 def GetGlobalConfigOption(*args):
-    r"""GetGlobalConfigOption(char const * pszKey, char const * pszDefault=None) -> char const *"""
+    r"""
+    GetGlobalConfigOption(char const * pszKey, char const * pszDefault=None) -> char const *
+
+
+    Return the value of a global (not thread-local) configuration option.
+    See :cpp:func:`CPLGetGlobalConfigOption`.
+
+    Parameters
+    ----------
+    pszKey : str
+        name of the configuration option
+    pszDefault : str, optional
+        default value to return if the option has not been set
+
+    Returns
+    -------
+    str
+
+    """
     return _gdal.GetGlobalConfigOption(*args)
 
 def GetThreadLocalConfigOption(*args):
-    r"""GetThreadLocalConfigOption(char const * pszKey, char const * pszDefault=None) -> char const *"""
+    r"""
+    GetThreadLocalConfigOption(char const * pszKey, char const * pszDefault=None) -> char const *
+
+
+    Return the value of a thread-local configuration option.
+    See :cpp:func:`CPLGetThreadLocalConfigOption`.
+
+    Parameters
+    ----------
+    pszKey : str
+        name of the configuration option
+    pszDefault : str, optional
+        default value to return if the option has not been set
+
+    Returns
+    -------
+    str
+
+
+    """
     return _gdal.GetThreadLocalConfigOption(*args)
 
 def GetConfigOptions(*args):
-    r"""GetConfigOptions() -> char **"""
+    r"""
+    GetConfigOptions() -> char **
+
+
+    Return a dictionary of currently set configuration options.
+    See :cpp:func:`CPLGetConfigOptions`.
+
+    Returns
+    -------
+    dict
+
+    Examples
+    --------
+    >>> with gdal.config_options({'A': '3', 'B': '4'}):
+    ...     gdal.SetConfigOption('C', '5')
+    ...     gdal.GetConfigOptions()
+    ...
+    {'C': '5', 'A': '3', 'B': '4'}
+
+    See Also
+    --------
+    :py:func:`GetConfigOption`
+    :py:func:`GetGlobalConfigOptions`
+
+    """
     return _gdal.GetConfigOptions(*args)
 
 def SetPathSpecificOption(*args):
     r"""SetPathSpecificOption(char const * pszPathPrefix, char const * pszKey, char const * pszValue)"""
     return _gdal.SetPathSpecificOption(*args)
 
 def SetCredential(*args):
@@ -3061,34 +3474,69 @@
 
 def VSIFOpenExL(*args):
     r"""VSIFOpenExL(char const * utf8_path, char const * pszMode, int bSetError=FALSE, char ** options=None) -> VSILFILE"""
     return _gdal.VSIFOpenExL(*args)
 
 def VSIFEofL(*args):
     r"""VSIFEofL(VSILFILE fp) -> int"""
+
+    if args[0].this is None:
+        raise ValueError("I/O operation on closed file.")
+
+
     return _gdal.VSIFEofL(*args)
 
 def VSIFFlushL(*args):
     r"""VSIFFlushL(VSILFILE fp) -> int"""
+
+    if args[0].this is None:
+        raise ValueError("I/O operation on closed file.")
+
+
     return _gdal.VSIFFlushL(*args)
 
 def VSIFCloseL(*args):
     r"""VSIFCloseL(VSILFILE fp) -> VSI_RETVAL"""
-    return _gdal.VSIFCloseL(*args)
+
+    if args[0].this is None:
+        raise ValueError("I/O operation on closed file.")
+
+
+    val = _gdal.VSIFCloseL(*args)
+
+    args[0].this = None
+
+
+    return val
 
 def VSIFSeekL(*args):
     r"""VSIFSeekL(VSILFILE fp, GIntBig offset, int whence) -> int"""
+
+    if args[0].this is None:
+        raise ValueError("I/O operation on closed file.")
+
+
     return _gdal.VSIFSeekL(*args)
 
 def VSIFTellL(*args):
     r"""VSIFTellL(VSILFILE fp) -> GIntBig"""
+
+    if args[0].this is None:
+        raise ValueError("I/O operation on closed file.")
+
+
     return _gdal.VSIFTellL(*args)
 
 def VSIFTruncateL(*args):
     r"""VSIFTruncateL(VSILFILE fp, GIntBig length) -> int"""
+
+    if args[0].this is None:
+        raise ValueError("I/O operation on closed file.")
+
+
     return _gdal.VSIFTruncateL(*args)
 
 def VSISupportsSparseFiles(*args):
     r"""VSISupportsSparseFiles(char const * utf8_path) -> int"""
     return _gdal.VSISupportsSparseFiles(*args)
 VSI_RANGE_STATUS_UNKNOWN = _gdal.VSI_RANGE_STATUS_UNKNOWN
 
@@ -3099,14 +3547,19 @@
 
 def VSIFGetRangeStatusL(*args):
     r"""VSIFGetRangeStatusL(VSILFILE fp, GIntBig offset, GIntBig length) -> int"""
     return _gdal.VSIFGetRangeStatusL(*args)
 
 def VSIFWriteL(*args):
     r"""VSIFWriteL(int nLen, int size, int memb, VSILFILE fp) -> int"""
+
+    if args[3].this is None:
+        raise ValueError("I/O operation on closed file.")
+
+
     return _gdal.VSIFWriteL(*args)
 
 def VSICurlClearCache(*args):
     r"""VSICurlClearCache()"""
     return _gdal.VSICurlClearCache(*args)
 
 def VSICurlPartialClearCache(*args):
@@ -3122,15 +3575,25 @@
     return _gdal.NetworkStatsGetAsSerializedJSON(*args)
 
 def ParseCommandLine(*args):
     r"""ParseCommandLine(char const * utf8_path) -> char **"""
     return _gdal.ParseCommandLine(*args)
 
 def GetNumCPUs(*args):
-    r"""GetNumCPUs() -> int"""
+    r"""
+    GetNumCPUs() -> int
+
+
+    Return the number of processors detected by GDAL.
+
+    Returns
+    -------
+    int
+
+    """
     return _gdal.GetNumCPUs(*args)
 
 def GetUsablePhysicalRAM(*args):
     r"""GetUsablePhysicalRAM() -> GIntBig"""
     return _gdal.GetUsablePhysicalRAM(*args)
 class MajorObject(object):
     r"""Proxy of C++ GDALMajorObjectShadow class."""
@@ -3181,75 +3644,269 @@
         return self.GetMetadata_List(domain)
       return self.GetMetadata_Dict(domain)
 
 
 # Register MajorObject in _gdal:
 _gdal.MajorObject_swigregister(MajorObject)
 class Driver(MajorObject):
-    r"""Proxy of C++ GDALDriverShadow class."""
+    r"""
+
+    Python proxy of a :cpp:class:`GDALDriver`.
+
+    """
 
     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
 
     def __init__(self, *args, **kwargs):
         raise AttributeError("No constructor defined")
     __repr__ = _swig_repr
-    ShortName = property(_gdal.Driver_ShortName_get, doc=r"""ShortName : p.q(const).char""")
-    LongName = property(_gdal.Driver_LongName_get, doc=r"""LongName : p.q(const).char""")
-    HelpTopic = property(_gdal.Driver_HelpTopic_get, doc=r"""HelpTopic : p.q(const).char""")
+    ShortName = property(_gdal.Driver_ShortName_get, doc=r"""
+    ShortName : p.q(const).char
+
+    The short name of a :py:class:`Driver` that can be passed to
+    :py:func:`GetDriverByName`.
+    See :cpp:func:`GDALGetDriverShortName`.
+
+    """)
+    LongName = property(_gdal.Driver_LongName_get, doc=r"""
+    LongName : p.q(const).char
+
+    The long name of the driver.
+    See :cpp:func:`GDALGetDriverLongName`.
+
+    """)
+    HelpTopic = property(_gdal.Driver_HelpTopic_get, doc=r"""
+    HelpTopic : p.q(const).char
+
+    The URL for driver documentation, relative to the GDAL documentation directory.
+    See :cpp:func:`GDALGetDriverHelpTopic`.
+
+    """)
 
     def Create(self, *args, **kwargs):
-        r"""Create(Driver self, char const * utf8_path, int xsize, int ysize, int bands=1, GDALDataType eType=GDT_Byte, char ** options=None) -> Dataset"""
+        r"""
+        Create(Driver self, char const * utf8_path, int xsize, int ysize, int bands=1, GDALDataType eType=GDT_Byte, char ** options=None) -> Dataset
+
+
+        Create a new :py:class:`Dataset` with this driver.
+        See :cpp:func:`GDALDriver::Create`.
+
+        Parameters
+        ----------
+        utf8_path : str
+           Path of the dataset to create.
+        xsize : int
+           Width of created raster in pixels. Set to zero for vector datasets.
+        ysize : int
+           Height of created raster in pixels. Set to zero for vector datasets.
+        bands : int, default = 1
+            Number of bands. Set to zero for vector datasets.
+        eType : int, default = :py:const:`GDT_Byte`
+            Raster data type. Set to :py:const:`GDT_Unknown` for vector datasets.
+        options : list/dict
+            List of driver-specific options
+
+        Returns
+        -------
+        Dataset
+
+        Examples
+        --------
+        >>> with gdal.GetDriverByName('GTiff').Create('test.tif', 12, 4, 2, gdal.GDT_Float32, {'COMPRESS': 'DEFLATE'}) as ds:
+        ...     print(gdal.Info(ds))
+        ...
+        Driver: GTiff/GeoTIFF
+        Files: test.tif
+        Size is 12, 4
+        Image Structure Metadata:
+          INTERLEAVE=PIXEL
+        Corner Coordinates:
+        Upper Left  (    0.0,    0.0)
+        Lower Left  (    0.0,    4.0)
+        Upper Right (   12.0,    0.0)
+        Lower Right (   12.0,    4.0)
+        Center      (    6.0,    2.0)
+        Band 1 Block=12x4 Type=Float32, ColorInterp=Gray
+        Band 2 Block=12x4 Type=Float32, ColorInterp=Undefined
+
+        >>> with gdal.GetDriverByName('ESRI Shapefile').Create('test.shp', 0, 0, 0, gdal.GDT_Unknown) as ds:
+        ...     print(gdal.VectorInfo(ds))
+        ...
+        INFO: Open of `test.shp'
+              using driver `ESRI Shapefile' successful.
+
+        """
 
         _WarnIfUserHasNotSpecifiedIfUsingExceptions()
 
 
         return _gdal.Driver_Create(self, *args, **kwargs)
 
 
     def CreateMultiDimensional(self, *args, **kwargs):
-        r"""CreateMultiDimensional(Driver self, char const * utf8_path, char ** root_group_options=None, char ** options=None) -> Dataset"""
+        r"""
+        CreateMultiDimensional(Driver self, char const * utf8_path, char ** root_group_options=None, char ** options=None) -> Dataset
+
+
+        Create a new multidimensional dataset.
+        See :cpp:func:`GDALDriver::CreateMultiDimensional`.
+
+        Parameters
+        ----------
+        utf8_path : str
+           Path of the dataset to create.
+        root_group_options : dict/list
+           Driver-specific options regarding the creation of the
+           root group.
+        options : list/dict
+           List of driver-specific options regarding the creation
+           of the Dataset.
+
+        Returns
+        -------
+        Dataset
+
+        Examples
+        --------
+        >>> with gdal.GetDriverByName('netCDF').CreateMultiDimensional('test.nc') as ds:
+        ...     gdal.MultiDimInfo(ds)
+        ...
+        {'type': 'group', 'driver': 'netCDF', 'name': '/', 'attributes': {'Conventions': 'CF-1.6'}, 'structural_info': {'NC_FORMAT': 'NETCDF4'}}
+
+
+        """
 
         _WarnIfUserHasNotSpecifiedIfUsingExceptions()
 
 
         return _gdal.Driver_CreateMultiDimensional(self, *args, **kwargs)
 
 
     def CreateCopy(self, *args, **kwargs):
-        r"""CreateCopy(Driver self, char const * utf8_path, Dataset src, int strict=1, char ** options=None, GDALProgressFunc callback=0, void * callback_data=None) -> Dataset"""
+        r"""
+        CreateCopy(Driver self, char const * utf8_path, Dataset src, int strict=1, char ** options=None, GDALProgressFunc callback=0, void * callback_data=None) -> Dataset
+
+
+        Create a copy of a :py:class:`Dataset`.
+        See :cpp:func:`GDALDriver::CreateCopy`.
+
+        Parameters
+        ----------
+        utf8_path : str
+           Path of the dataset to create.
+        src : Dataset
+           The Dataset being duplicated.
+        strict : bool, default=1
+           Indicates whether the copy must be strictly equivalent or if
+           it may be adapted as needed for the output format.
+        options : list/dict
+           List of driver-specific options
+        callback : function, optional
+           A progress callback function
+        callback_data: optional
+           Optional data to be passed to callback function
+
+        Returns
+        -------
+        Dataset
+
+        """
 
         _WarnIfUserHasNotSpecifiedIfUsingExceptions()
 
 
         return _gdal.Driver_CreateCopy(self, *args, **kwargs)
 
 
     def Delete(self, *args):
-        r"""Delete(Driver self, char const * utf8_path) -> CPLErr"""
+        r"""
+        Delete(Driver self, char const * utf8_path) -> CPLErr
+
+        Delete a :py:class:`Dataset`.
+        See :cpp:func:`GDALDriver::Delete`.
+
+        Parameters
+        ----------
+        utf8_path : str
+           Path of the dataset to delete.
+
+        Returns
+        -------
+        int:
+           :py:const:`CE_None` on success or :py:const:`CE_Failure` on failure.
+
+        """
 
         _WarnIfUserHasNotSpecifiedIfUsingExceptions()
 
 
         return _gdal.Driver_Delete(self, *args)
 
 
     def Rename(self, *args):
-        r"""Rename(Driver self, char const * newName, char const * oldName) -> CPLErr"""
+        r"""
+        Rename(Driver self, char const * newName, char const * oldName) -> CPLErr
+
+        Rename a :py:class:`Dataset`.
+        See :cpp:func:`GDALDriver::Rename`.
+
+        Parameters
+        ----------
+        newName : str
+            new path for the dataset
+        oldName : str
+            old path for the dataset
+
+        Returns
+        -------
+        int:
+           :py:const:`CE_None` on success or :py:const:`CE_Failure` on failure.
+
+        """
         return _gdal.Driver_Rename(self, *args)
 
     def CopyFiles(self, *args):
-        r"""CopyFiles(Driver self, char const * newName, char const * oldName) -> CPLErr"""
+        r"""
+        CopyFiles(Driver self, char const * newName, char const * oldName) -> CPLErr
+
+        Copy all the files associated with a :py:class:`Dataset`.
+
+        Parameters
+        ----------
+        newName : str
+            new path for the dataset
+        oldName : str
+            old path for the dataset
+
+        Returns
+        -------
+        int:
+           :py:const:`CE_None` on success or :py:const:`CE_Failure` on failure.
+
+        """
         return _gdal.Driver_CopyFiles(self, *args)
 
     def Register(self, *args):
-        r"""Register(Driver self) -> int"""
+        r"""
+        Register(Driver self) -> int
+
+        Register the driver for use.
+        See :cpp:func:`GDALDriverManager::RegisterDriver`.
+
+        """
         return _gdal.Driver_Register(self, *args)
 
     def Deregister(self, *args):
-        r"""Deregister(Driver self)"""
+        r"""
+        Deregister(Driver self)
+
+        Deregister the driver.
+        See :cpp:func:`GDALDriverManager::DeregisterDriver`.
+
+        """
         return _gdal.Driver_Deregister(self, *args)
 
 # Register Driver in _gdal:
 _gdal.Driver_swigregister(Driver)
 from . import ogr
 from . import osr
 class ColorEntry(object):
@@ -3418,151 +4075,483 @@
         return _gdal.AsyncReader_UnlockBuffer(self, *args)
 
 # Register AsyncReader in _gdal:
 _gdal.AsyncReader_swigregister(AsyncReader)
 class Dataset(MajorObject):
     r"""
 
-    Python proxy of a raster :cpp:class:`GDALDataset`.
+    Python proxy of a :cpp:class:`GDALDataset`.
 
     Since GDAL 3.8, a Dataset can be used as a context manager.
     When exiting the context, the Dataset will be closed and
     data will be written to disk.
 
     """
 
     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
 
     def __init__(self, *args, **kwargs):
         raise AttributeError("No constructor defined")
     __repr__ = _swig_repr
-    RasterXSize = property(_gdal.Dataset_RasterXSize_get, doc=r"""RasterXSize : int""")
-    RasterYSize = property(_gdal.Dataset_RasterYSize_get, doc=r"""RasterYSize : int""")
-    RasterCount = property(_gdal.Dataset_RasterCount_get, doc=r"""RasterCount : int""")
+    RasterXSize = property(_gdal.Dataset_RasterXSize_get, doc=r"""
+    RasterXSize : int
+
+
+    Raster width in pixels. See :cpp:func:`GDALGetRasterXSize`.
+
+
+    """)
+    RasterYSize = property(_gdal.Dataset_RasterYSize_get, doc=r"""
+    RasterYSize : int
+
+
+    Raster height in pixels. See :cpp:func:`GDALGetRasterYSize`.
+
+
+    """)
+    RasterCount = property(_gdal.Dataset_RasterCount_get, doc=r"""
+    RasterCount : int
+
+
+    The number of bands in this dataset.
+
+
+    """)
     __swig_destroy__ = _gdal.delete_Dataset
 
     def Close(self, *args):
         r"""
         Close(Dataset self) -> CPLErr
 
         Closes opened dataset and releases allocated resources.
 
         This method can be used to force the dataset to close
         when one more references to the dataset are still
-        reachable. If Close is never called, the dataset will
+        reachable. If :py:meth:`Close` is never called, the dataset will
         be closed automatically during garbage collection.
 
+        In most cases, it is preferable to open or create a dataset
+        using a context manager instead of calling :py:meth:`Close`
+        directly.
+
+
         """
         val = _gdal.Dataset_Close(self, *args)
 
         self.thisown = 0
         self.this = None
-        self._invalidate_bands()
-        return val
+        self._invalidate_children()
 
 
         return val
 
 
     def GetDriver(self, *args):
-        r"""GetDriver(Dataset self) -> Driver"""
+        r"""
+        GetDriver(Dataset self) -> Driver
+
+
+        Fetch the driver used to open or create this :py:class:`Dataset`.
+
+
+        """
         return _gdal.Dataset_GetDriver(self, *args)
 
     def GetRasterBand(self, *args):
-        r"""GetRasterBand(Dataset self, int nBand) -> Band"""
+        r"""
+        GetRasterBand(Dataset self, int nBand) -> Band
+
+
+        Fetch a :py:class:`Band` band from a :py:class:`Dataset`. See :cpp:func:`GDALGetRasterBand`.
+
+        Parameters
+        -----------
+        nBand : int
+            the index of the band to fetch, from 1 to :py:attr:`RasterCount`
+
+        Returns
+        --------
+        Band:
+            the :py:class:`Band`, or ``None`` on error.
+
+
+        """
         val = _gdal.Dataset_GetRasterBand(self, *args)
 
-        self._add_band_ref(val)
+        self._add_child_ref(val)
 
 
         return val
 
 
     def GetRootGroup(self, *args):
-        r"""GetRootGroup(Dataset self) -> Group"""
+        r"""
+        GetRootGroup(Dataset self) -> Group
+
+
+        Return the root :py:class:`Group` of this dataset.
+        Only value for multidimensional datasets.
+
+        Returns
+        -------
+        Group
+
+
+        """
         return _gdal.Dataset_GetRootGroup(self, *args)
 
     def GetProjection(self, *args):
-        r"""GetProjection(Dataset self) -> char const *"""
+        r"""
+        GetProjection(Dataset self) -> char const *
+
+
+        Return a WKT representation of the dataset spatial reference.
+        Equivalent to :py:meth:`GetProjectionRef`.
+
+        Returns
+        -------
+        str
+
+
+        """
         return _gdal.Dataset_GetProjection(self, *args)
 
     def GetProjectionRef(self, *args):
-        r"""GetProjectionRef(Dataset self) -> char const *"""
+        r"""
+        GetProjectionRef(Dataset self) -> char const *
+
+
+        Return a WKT representation of the dataset spatial reference.
+
+        Returns
+        -------
+        str
+
+
+        """
         return _gdal.Dataset_GetProjectionRef(self, *args)
 
     def GetSpatialRef(self, *args):
-        r"""GetSpatialRef(Dataset self) -> SpatialReference"""
+        r"""
+        GetSpatialRef(Dataset self) -> SpatialReference
+
+
+        Fetch the spatial reference for this dataset.
+
+        Returns
+        --------
+        osr.SpatialReference
+
+
+        """
         return _gdal.Dataset_GetSpatialRef(self, *args)
 
     def SetProjection(self, *args):
-        r"""SetProjection(Dataset self, char const * prj) -> CPLErr"""
+        r"""
+        SetProjection(Dataset self, char const * prj) -> CPLErr
+
+
+        Set the spatial reference system for this dataset.
+
+        See :cpp:func:`GDALDataset::SetProjection`.
+
+        Parameters
+        ----------
+        prj:
+           The projection string in OGC WKT or PROJ.4 format
+
+        Returns
+        -------
+        :py:const:`CE_Failure` if an error occurs, otherwise :py:const:`CE_None`.
+
+
+        """
         return _gdal.Dataset_SetProjection(self, *args)
 
     def SetSpatialRef(self, *args):
-        r"""SetSpatialRef(Dataset self, SpatialReference srs) -> CPLErr"""
+        r"""
+        SetSpatialRef(Dataset self, SpatialReference srs) -> CPLErr
+
+
+        Set the spatial reference system for this dataset.
+
+        Parameters
+        ----------
+        srs : SpatialReference
+
+        Returns
+        -------
+        :py:const:`CE_Failure` if an error occurs, otherwise :py:const:`CE_None`.
+
+
+        """
         return _gdal.Dataset_SetSpatialRef(self, *args)
 
     def GetGeoTransform(self, *args, **kwargs):
-        r"""GetGeoTransform(Dataset self, int * can_return_null=None)"""
+        r"""
+        GetGeoTransform(Dataset self, int * can_return_null=None)
+
+
+        Fetch the affine transformation coefficients.
+
+        See :cpp:func:`GDALGetGeoTransform`.
+
+        Parameters
+        -----------
+        can_return_null : bool, default=False
+            if ``True``, return ``None`` instead of the default transformation
+            if the transformation for this :py:class:`Dataset` has not been defined.
+
+        Returns
+        -------
+        tuple:
+            a 6-member tuple representing the transformation coefficients
+
+
+
+        """
         return _gdal.Dataset_GetGeoTransform(self, *args, **kwargs)
 
     def SetGeoTransform(self, *args):
-        r"""SetGeoTransform(Dataset self, double [6] argin) -> CPLErr"""
+        r"""
+        SetGeoTransform(Dataset self, double [6] argin) -> CPLErr
+
+
+        Set the affine transformation coefficients.
+
+        See :py:meth:`GetGeoTransform` for details on the meaning of the coefficients.
+
+        Parameters
+        ----------
+        argin : tuple
+
+        Returns
+        -------
+        :py:const:`CE_Failure` if an error occurs, otherwise :py:const:`CE_None`.
+
+
+        """
         return _gdal.Dataset_SetGeoTransform(self, *args)
 
     def BuildOverviews(self, *args, **kwargs):
-        r"""BuildOverviews(Dataset self, char const * resampling="NEAREST", int overviewlist=0, GDALProgressFunc callback=0, void * callback_data=None, char ** options=None) -> int"""
+        r"""
+        BuildOverviews(Dataset self, char const * resampling="NEAREST", int overviewlist=0, GDALProgressFunc callback=0, void * callback_data=None, char ** options=None) -> int
+
+
+        Build raster overview(s) for all bands.
+
+        See :cpp:func:`GDALDataset::BuildOverviews`
+
+        Parameters
+        ----------
+        resampling : str, optional
+                     The resampling method to use. See :cpp:func:`GDALDataset::BuildOveriews`.
+        overviewlist : list
+                     A list of overview levels (decimation factors) to build, or an
+                     empty list to clear existing overviews.
+        callback : function, optional
+                     A progress callback function
+        callback_data: optional
+                     Optional data to be passed to callback function
+        options : dict/list, optional
+                     A dict or list of key=value options
+
+        Returns
+        -------
+        :py:const:`CE_Failure` if an error occurs, otherwise :py:const:`CE_None`.
+
+        Examples
+        --------
+        >>> import numpy as np
+        >>> ds = gdal.GetDriverByName('GTiff').Create('test.tif', 12, 12)
+        >>> ds.GetRasterBand(1).WriteArray(np.arange(12*12).reshape((12, 12)))
+        0
+        >>> ds.BuildOverviews('AVERAGE', [2, 4])
+        0
+        >>> ds.GetRasterBand(1).GetOverviewCount()
+        2
+        >>> ds.BuildOverviews(overviewlist=[])
+        0
+        >>> ds.GetRasterBand(1).GetOverviewCount()
+        0
+
+        """
         return _gdal.Dataset_BuildOverviews(self, *args, **kwargs)
 
     def GetGCPCount(self, *args):
-        r"""GetGCPCount(Dataset self) -> int"""
+        r"""
+        GetGCPCount(Dataset self) -> int
+
+
+        Get number of GCPs. See :cpp:func:`GDALGetGCPCount`.
+
+        Returns
+        --------
+        int
+
+
+        """
         return _gdal.Dataset_GetGCPCount(self, *args)
 
     def GetGCPProjection(self, *args):
-        r"""GetGCPProjection(Dataset self) -> char const *"""
+        r"""
+        GetGCPProjection(Dataset self) -> char const *
+
+
+        Return a WKT representation of the GCP spatial reference.
+
+        Returns
+        --------
+        string
+
+
+        """
         return _gdal.Dataset_GetGCPProjection(self, *args)
 
     def GetGCPSpatialRef(self, *args):
-        r"""GetGCPSpatialRef(Dataset self) -> SpatialReference"""
+        r"""
+        GetGCPSpatialRef(Dataset self) -> SpatialReference
+
+
+        Get output spatial reference system for GCPs.
+
+        See :cpp:func:`GDALGetGCPSpatialRef`
+
+
+        """
         return _gdal.Dataset_GetGCPSpatialRef(self, *args)
 
     def GetGCPs(self, *args):
-        r"""GetGCPs(Dataset self)"""
+        r"""
+        GetGCPs(Dataset self)
+
+
+        Get the GCPs. See :cpp:func:`GDALGetGCPs`.
+
+        Returns
+        --------
+        tuple
+            a tuple of :py:class:`GCP` objects.
+
+
+        """
         return _gdal.Dataset_GetGCPs(self, *args)
 
     def _SetGCPs(self, *args):
-        r"""_SetGCPs(Dataset self, int nGCPs, char const * pszGCPProjection) -> CPLErr"""
+        r"""
+        _SetGCPs(Dataset self, int nGCPs, char const * pszGCPProjection) -> CPLErr
+
+
+        """
         return _gdal.Dataset__SetGCPs(self, *args)
 
     def _SetGCPs2(self, *args):
         r"""_SetGCPs2(Dataset self, int nGCPs, SpatialReference hSRS) -> CPLErr"""
         return _gdal.Dataset__SetGCPs2(self, *args)
 
     def FlushCache(self, *args):
-        r"""FlushCache(Dataset self) -> CPLErr"""
+        r"""
+        FlushCache(Dataset self) -> CPLErr
+
+
+        Flush all write-cached data to disk.
+
+        See :cpp:func:`GDALDataset::FlushCache`.
+
+        Returns
+        -------
+        int
+            `gdal.CE_None` in case of success
+
+        """
         return _gdal.Dataset_FlushCache(self, *args)
 
     def AddBand(self, *args, **kwargs):
-        r"""AddBand(Dataset self, GDALDataType datatype=GDT_Byte, char ** options=None) -> CPLErr"""
+        r"""
+        AddBand(Dataset self, GDALDataType datatype=GDT_Byte, char ** options=None) -> CPLErr
+
+
+        Adds a band to a :py:class:`Dataset`.
+
+        Not supported by all drivers.
+
+        Parameters
+        -----------
+        datatype: int
+            the data type of the pixels in the new band
+        options: dict/list
+            an optional dict or list of format-specific ``NAME=VALUE`` option strings.
+
+        Returns
+        -------
+        int:
+           :py:const:`CE_None` on success or :py:const:`CE_Failure` on failure.
+
+        Examples
+        --------
+        >>> ds=gdal.GetDriverByName('MEM').Create('', 10, 10)
+        >>> ds.RasterCount
+        1
+        >>> ds.AddBand(gdal.GDT_Float32)
+        0
+        >>> ds.RasterCount
+        2
+
+        """
         return _gdal.Dataset_AddBand(self, *args, **kwargs)
 
     def CreateMaskBand(self, *args):
-        r"""CreateMaskBand(Dataset self, int nFlags) -> CPLErr"""
+        r"""
+        CreateMaskBand(Dataset self, int nFlags) -> CPLErr
+
+
+        Adds a mask band to the dataset.
+
+        See :cpp:func:`GDALDataset::CreateMaskBand`.
+
+        Parameters
+        ----------
+        flags : int
+
+        Returns
+        -------
+        int
+            :py:const:`CE_Failure` if an error occurs, otherwise :py:const:`CE_None`.
+
+
+        """
         return _gdal.Dataset_CreateMaskBand(self, *args)
 
     def GetFileList(self, *args):
-        r"""GetFileList(Dataset self) -> char **"""
+        r"""
+        GetFileList(Dataset self) -> char **
+
+
+        Returns a list of files believed to be part of this dataset.
+        See :cpp:func:`GDALGetFileList`.
+
+
+        """
         return _gdal.Dataset_GetFileList(self, *args)
 
     def WriteRaster(self, *args, **kwargs):
         r"""WriteRaster(Dataset self, int xoff, int yoff, int xsize, int ysize, GIntBig buf_len, int * buf_xsize=None, int * buf_ysize=None, GDALDataType * buf_type=None, int band_list=0, GIntBig * buf_pixel_space=None, GIntBig * buf_line_space=None, GIntBig * buf_band_space=None) -> CPLErr"""
         return _gdal.Dataset_WriteRaster(self, *args, **kwargs)
 
     def AdviseRead(self, *args):
-        r"""AdviseRead(Dataset self, int xoff, int yoff, int xsize, int ysize, int * buf_xsize=None, int * buf_ysize=None, GDALDataType * buf_type=None, int band_list=0, char ** options=None) -> CPLErr"""
+        r"""
+        AdviseRead(Dataset self, int xoff, int yoff, int xsize, int ysize, int * buf_xsize=None, int * buf_ysize=None, GDALDataType * buf_type=None, int band_list=0, char ** options=None) -> CPLErr
+
+
+        Advise driver of upcoming read requests.
+
+        See :cpp:func:`GDALDataset::AdviseRead`.
+
+
+        """
         return _gdal.Dataset_AdviseRead(self, *args)
 
     def BeginAsyncReader(self, *args, **kwargs):
         r"""BeginAsyncReader(Dataset self, int xOff, int yOff, int xSize, int ySize, size_t buf_len, int buf_xsize, int buf_ysize, GDALDataType bufType=(GDALDataType) 0, int band_list=0, int nPixelSpace=0, int nLineSpace=0, int nBandSpace=0, char ** options=None) -> AsyncReader"""
         return _gdal.Dataset_BeginAsyncReader(self, *args, **kwargs)
 
     def EndAsyncReader(self, *args):
@@ -3574,71 +4563,182 @@
         return _gdal.Dataset_GetVirtualMem(self, *args, **kwargs)
 
     def GetTiledVirtualMem(self, *args, **kwargs):
         r"""GetTiledVirtualMem(Dataset self, GDALRWFlag eRWFlag, int nXOff, int nYOff, int nXSize, int nYSize, int nTileXSize, int nTileYSize, GDALDataType eBufType, int band_list, GDALTileOrganization eTileOrganization, size_t nCacheSize, char ** options=None) -> VirtualMem"""
         return _gdal.Dataset_GetTiledVirtualMem(self, *args, **kwargs)
 
     def CreateLayer(self, *args, **kwargs):
-        r"""CreateLayer(Dataset self, char const * name, SpatialReference srs=None, OGRwkbGeometryType geom_type=wkbUnknown, char ** options=None) -> Layer"""
-        return _gdal.Dataset_CreateLayer(self, *args, **kwargs)
+        r"""
+        CreateLayer(Dataset self, char const * name, SpatialReference srs=None, OGRwkbGeometryType geom_type=wkbUnknown, char ** options=None) -> Layer
+
+
+        Create a new layer in a vector Dataset.
+
+        Parameters
+        ----------
+        name : string
+               the name for the new layer.  This should ideally not
+               match any existing layer on the datasource.
+        srs : osr.SpatialReference, default=None
+              the coordinate system to use for the new layer, or ``None`` if
+              no coordinate system is available.
+        geom_type : int, default = :py:const:`ogr.wkbUnknown`
+              geometry type for the layer.  Use :py:const:`ogr.wkbUnknown` if there
+              are no constraints on the types geometry to be written.
+        options : dict/list, optional
+              Driver-specific dict or list of name=value options
+
+        Returns
+        -------
+        ogr.Layer or ``None`` on failure.
+
+
+        Examples
+        --------
+        >>> ds = gdal.GetDriverByName('GPKG').Create('test.gpkg', 0, 0)
+        >>> ds.GetLayerCount()
+        0
+        >>> lyr = ds.CreateLayer('poly', geom_type=ogr.wkbPolygon)
+        >>> ds.GetLayerCount()
+        1
+
+
+        """
+        val = _gdal.Dataset_CreateLayer(self, *args, **kwargs)
+
+        self._add_child_ref(val)
+
+
+        return val
+
+
+    def CreateLayerFromGeomFieldDefn(self, *args):
+        r"""CreateLayerFromGeomFieldDefn(Dataset self, char const * name, GeomFieldDefn geom_field, char ** options=None) -> Layer"""
+        return _gdal.Dataset_CreateLayerFromGeomFieldDefn(self, *args)
 
     def CopyLayer(self, *args, **kwargs):
-        r"""CopyLayer(Dataset self, Layer src_layer, char const * new_name, char ** options=None) -> Layer"""
-        return _gdal.Dataset_CopyLayer(self, *args, **kwargs)
+        r"""
+        CopyLayer(Dataset self, Layer src_layer, char const * new_name, char ** options=None) -> Layer
+
+
+        Duplicate an existing :py:class:`ogr.Layer`.
+
+        See :cpp:func:`GDALDAtaset::CopyLayer`.
+
+        Parameters
+        ----------
+        src_layer : ogr.Layer
+                    source layer
+        new_name : str
+                   name of the layer to create
+        options : dict/list
+                  a dict or list of name=value driver-specific creation options
+
+        Returns
+        -------
+        ogr.Layer, or ``None`` if an error occurs
+
+        """
+        val = _gdal.Dataset_CopyLayer(self, *args, **kwargs)
+
+        self._add_child_ref(val)
+
+
+        return val
+
 
     def DeleteLayer(self, *args):
         r"""DeleteLayer(Dataset self, int index) -> OGRErr"""
         return _gdal.Dataset_DeleteLayer(self, *args)
 
-    def GetLayerCount(self, *args):
-        r"""GetLayerCount(Dataset self) -> int"""
-        return _gdal.Dataset_GetLayerCount(self, *args)
-
     def IsLayerPrivate(self, *args):
-        r"""IsLayerPrivate(Dataset self, int index) -> bool"""
+        r"""
+        IsLayerPrivate(Dataset self, int index) -> bool
+
+
+        Parameters
+        ----------
+        index : int
+                Index o layer to check
+
+        Returns
+        -------
+        bool
+             ``True`` if the layer is a private or system table, ``False`` otherwise
+
+
+
+        """
         return _gdal.Dataset_IsLayerPrivate(self, *args)
 
-    def GetLayerByIndex(self, *args):
-        r"""GetLayerByIndex(Dataset self, int index=0) -> Layer"""
-        return _gdal.Dataset_GetLayerByIndex(self, *args)
+    def GetNextFeature(self, *args, **kwargs):
+        r"""
+        GetNextFeature(Dataset self, bool include_layer=True, bool include_pct=False, GDALProgressFunc callback=0, void * callback_data=None) -> Feature
 
-    def GetLayerByName(self, *args):
-        r"""GetLayerByName(Dataset self, char const * layer_name) -> Layer"""
 
-        _WarnIfUserHasNotSpecifiedIfUsingOgrExceptions()
+        Fetch the next available feature from this dataset.
 
+        This method is intended for the few drivers where
+        :py:meth:`OGRLayer.GetNextFeature` is not efficient, but in general
+        :py:meth:`OGRLayer.GetNextFeature` is a more natural API.
 
-        return _gdal.Dataset_GetLayerByName(self, *args)
+        See :cpp:func:`GDALDataset::GetNextFeature`.
 
+        Returns
+        -------
+        ogr.Feature
 
-    def ResetReading(self, *args):
-        r"""ResetReading(Dataset self)"""
-        return _gdal.Dataset_ResetReading(self, *args)
 
-    def GetNextFeature(self, *args, **kwargs):
-        r"""GetNextFeature(Dataset self, bool include_layer=True, bool include_pct=False, GDALProgressFunc callback=0, void * callback_data=None) -> Feature"""
+        """
         return _gdal.Dataset_GetNextFeature(self, *args, **kwargs)
 
     def TestCapability(self, *args):
-        r"""TestCapability(Dataset self, char const * cap) -> bool"""
+        r"""
+        TestCapability(Dataset self, char const * cap) -> bool
+
+
+        Test if a capability is available.
+
+        Parameters
+        ----------
+        cap : str
+           Name of the capability (e.g., :py:const:`ogr.ODsCTransactions`)
+
+        Returns
+        -------
+        bool
+            ``True`` if the capability is available, ``False`` if invalid or unavailable
+
+        Examples
+        --------
+        >>> ds = gdal.GetDriverByName('ESRI Shapefile').Create('test.shp', 0, 0, 0, gdal.GDT_Unknown)
+        >>> ds.TestCapability(ogr.ODsCTransactions)
+        False
+        >>> ds.TestCapability(ogr.ODsCMeasuredGeometries)
+        True
+        >>> ds.TestCapability(gdal.GDsCAddRelationship)
+        False
+
+
+        """
         return _gdal.Dataset_TestCapability(self, *args)
 
     def ExecuteSQL(self, statement, spatialFilter=None, dialect="", keep_ref_on_ds=False):
         """ExecuteSQL(self, statement, spatialFilter: ogr.Geometry = None, dialect: Optional[str] = "", keep_ref_on_ds=False) -> ogr.Layer
 
         Execute a SQL statement against the dataset
 
         The result of a SQL query is:
           - None (or an exception if exceptions are enabled) for statements
             that are in error
           - or None for statements that have no results set,
-          - or a ogr.Layer handle representing a results set from the query.
+          - or a :py:class:`ogr.Layer` handle representing a results set from the query.
 
-        Note that this ogr.Layer is in addition to the layers in the data store
-        and must be released with ReleaseResultSet() before the data source is closed
+        Note that this :py:class:`ogr.Layer` is in addition to the layers in the data store
+        and must be released with :py:meth:`ReleaseResultSet` before the data source is closed
         (destroyed).
 
         Starting with GDAL 3.7, this method can also be used as a context manager,
         as a convenient way of automatically releasing the returned result layer.
 
         For more information on the SQL dialect supported internally by OGR
         review the OGR SQL document (:ref:`ogr_sql_sqlite_dialect`)
@@ -3694,116 +4794,519 @@
         return sql_lyr
 
 
 
     def ReleaseResultSet(self, sql_lyr):
         """ReleaseResultSet(self, sql_lyr: ogr.Layer)
 
-        Release ogr.Layer returned by ExecuteSQL() (when not called as an execution manager)
+        Release :py:class:`ogr.Layer` returned by :py:meth:`ExecuteSQL` (when not called as a context manager)
 
         The sql_lyr object is invalidated after this call.
 
         Parameters
         ----------
         sql_lyr:
-            ogr.Layer got with ExecuteSQL()
+            :py:class:`ogr.Layer` got with :py:meth:`ExecuteSQL`
         """
 
         if sql_lyr and not hasattr(sql_lyr, "_to_release"):
             raise Exception("This layer was not returned by ExecuteSQL() and should not be released with ReleaseResultSet()")
         _gdal.Dataset_ReleaseResultSet(self, sql_lyr)
     # Invalidates the layer
         if sql_lyr:
             sql_lyr.thisown = None
             sql_lyr.this = None
 
 
 
     def GetStyleTable(self, *args):
-        r"""GetStyleTable(Dataset self) -> StyleTable"""
+        r"""
+        GetStyleTable(Dataset self) -> StyleTable
+
+
+        Returns dataset style table.
+
+        Returns
+        -------
+        ogr.StyleTable
+
+
+        """
         return _gdal.Dataset_GetStyleTable(self, *args)
 
     def SetStyleTable(self, *args):
-        r"""SetStyleTable(Dataset self, StyleTable table)"""
+        r"""
+        SetStyleTable(Dataset self, StyleTable table)
+
+
+        Set dataset style table
+
+        Parameters
+        ----------
+        table : ogr.StyleTable
+
+        """
         return _gdal.Dataset_SetStyleTable(self, *args)
 
+    def GetLayerByIndex(self, *args):
+        r"""
+        GetLayerByIndex(Dataset self, int index=0) -> Layer
+
+
+        Fetch a layer by index.
+
+        Parameters
+        ----------
+        index : int
+            A layer number between 0 and ``GetLayerCount() - 1``
+
+        Returns
+        -------
+        ogr.Layer
+
+
+        """
+        val = _gdal.Dataset_GetLayerByIndex(self, *args)
+
+        self._add_child_ref(val)
+
+
+        return val
+
+
+    def GetLayerByName(self, *args):
+        r"""GetLayerByName(Dataset self, char const * layer_name) -> Layer"""
+
+        _WarnIfUserHasNotSpecifiedIfUsingOgrExceptions()
+
+
+        val = _gdal.Dataset_GetLayerByName(self, *args)
+
+        self._add_child_ref(val)
+
+
+        return val
+
+
+    def ResetReading(self, *args):
+        r"""
+        ResetReading(Dataset self)
+
+
+        Reset feature reading to start on the first feature.
+
+        This affects :py:meth:`GetNextFeature`.
+
+        Depending on drivers, this may also have the side effect of calling
+        :py:meth:`OGRLayer.ResetReading` on the layers of this dataset.
+
+
+        """
+        return _gdal.Dataset_ResetReading(self, *args)
+
+    def GetLayerCount(self, *args):
+        r"""
+        GetLayerCount(Dataset self) -> int
+
+
+        Get the number of layers in this dataset.
+
+        Returns
+        -------
+        int
+
+
+        """
+        return _gdal.Dataset_GetLayerCount(self, *args)
+
     def AbortSQL(self, *args):
-        r"""AbortSQL(Dataset self) -> OGRErr"""
+        r"""
+        AbortSQL(Dataset self) -> OGRErr
+
+
+        Abort any SQL statement running in the data store.
+
+        Not implemented by all drivers. See :cpp:func:`GDALDataset::AbortSQL`.
+
+        Returns
+        -------
+        :py:const:`ogr.OGRERR_NONE` on success or :py:const:`ogr.OGRERR_UNSUPPORTED_OPERATION` if AbortSQL is not supported for this dataset.
+
+        """
         return _gdal.Dataset_AbortSQL(self, *args)
 
     def StartTransaction(self, *args, **kwargs):
-        r"""StartTransaction(Dataset self, int force=FALSE) -> OGRErr"""
+        r"""
+        StartTransaction(Dataset self, int force=FALSE) -> OGRErr
+
+
+        Creates a transaction. See :cpp:func:`GDALDataset::StartTransaction`.
+
+        Returns
+        -------
+        int
+            If starting the transaction fails, will return
+            :py:const:`ogr.OGRERR_FAILURE`. Datasources which do not support transactions will
+            always return :py:const:`OGRERR_UNSUPPORTED_OPERATION`.
+
+
+        """
         return _gdal.Dataset_StartTransaction(self, *args, **kwargs)
 
     def CommitTransaction(self, *args):
-        r"""CommitTransaction(Dataset self) -> OGRErr"""
+        r"""
+        CommitTransaction(Dataset self) -> OGRErr
+
+        Commits a transaction, for `Datasets` that support transactions.
+
+        See :cpp:func:`GDALDataset::CommitTransaction`.
+
+        """
         return _gdal.Dataset_CommitTransaction(self, *args)
 
     def RollbackTransaction(self, *args):
-        r"""RollbackTransaction(Dataset self) -> OGRErr"""
+        r"""
+        RollbackTransaction(Dataset self) -> OGRErr
+
+
+        Roll back a Dataset to its state before the start of the current transaction.
+
+        For datasets that support transactions.
+
+        Returns
+        -------
+        int
+            If no transaction is active, or the rollback fails, will return
+            :py:const:`OGRERR_FAILURE`. Datasources which do not support transactions will
+            always return :py:const:`OGRERR_UNSUPPORTED_OPERATION`.
+
+
+        """
         return _gdal.Dataset_RollbackTransaction(self, *args)
 
     def ClearStatistics(self, *args):
-        r"""ClearStatistics(Dataset self)"""
+        r"""
+        ClearStatistics(Dataset self)
+
+
+        Clear statistics
+
+        See :cpp:func:`GDALDatset::ClearStatistics`.
+
+
+        """
         return _gdal.Dataset_ClearStatistics(self, *args)
 
     def GetFieldDomainNames(self, *args):
-        r"""GetFieldDomainNames(Dataset self, char ** options=None) -> char **"""
+        r"""
+        GetFieldDomainNames(Dataset self, char ** options=None) -> char **
+
+
+        Get a list of the names of all field domains stored in the dataset.
+
+        Parameters
+        ----------
+        options: dict/list, optional
+                 Driver-specific options determining how attributes should
+                 be retrieved.
+
+        Returns
+        -------
+        list, or ``None`` if no field domains are stored in the dataset.
+
+        """
         return _gdal.Dataset_GetFieldDomainNames(self, *args)
 
     def GetFieldDomain(self, *args):
-        r"""GetFieldDomain(Dataset self, char const * name) -> FieldDomain"""
+        r"""
+        GetFieldDomain(Dataset self, char const * name) -> FieldDomain
+
+
+        Get a field domain from its name.
+
+        Parameters
+        ----------
+        name: str
+              The name of the field domain
+
+        Returns
+        -------
+        ogr.FieldDomain, or ``None`` if it is not found.
+
+        """
         return _gdal.Dataset_GetFieldDomain(self, *args)
 
     def AddFieldDomain(self, *args):
-        r"""AddFieldDomain(Dataset self, FieldDomain fieldDomain) -> bool"""
+        r"""
+        AddFieldDomain(Dataset self, FieldDomain fieldDomain) -> bool
+
+
+        Add a :py:class:`ogr.FieldDomain` to the dataset.
+
+        Only a few drivers support this operation. See :cpp:func:`GDALDataset::AddFieldDomain`.
+
+        Parameters
+        ----------
+        fieldDomain : ogr.FieldDomain
+                      The field domain to add
+
+        Returns
+        --------
+        bool:
+            ``True`` if the field domain was added, ``False`` in case of error.
+
+
+
+        """
         return _gdal.Dataset_AddFieldDomain(self, *args)
 
     def DeleteFieldDomain(self, *args):
-        r"""DeleteFieldDomain(Dataset self, char const * name) -> bool"""
+        r"""
+        DeleteFieldDomain(Dataset self, char const * name) -> bool
+
+
+        Removes a field domain from the Dataset.
+
+        Parameters
+        ----------
+        name : str
+               Name of the field domain to delete
+
+        Returns
+        -------
+        bool
+             ``True`` if the field domain was removed, otherwise ``False``.
+
+
+        """
         return _gdal.Dataset_DeleteFieldDomain(self, *args)
 
     def UpdateFieldDomain(self, *args):
-        r"""UpdateFieldDomain(Dataset self, FieldDomain fieldDomain) -> bool"""
+        r"""
+        UpdateFieldDomain(Dataset self, FieldDomain fieldDomain) -> bool
+
+
+        Update an existing field domain by replacing its definition.
+
+        The existing field domain with matching name will be replaced.
+
+        Requires the :py:const:`ogr.ODsCUpdateFieldDomain` datasset capability.
+
+        Parameters
+        ----------
+        fieldDomain : ogr.FieldDomain
+            Updated field domain.
+
+        Returns
+        -------
+        bool
+            ``True`` in case of success
+
+
+        """
         return _gdal.Dataset_UpdateFieldDomain(self, *args)
 
     def GetRelationshipNames(self, *args):
-        r"""GetRelationshipNames(Dataset self, char ** options=None) -> char **"""
+        r"""
+        GetRelationshipNames(Dataset self, char ** options=None) -> char **
+
+
+        Get a list of the names of all relationships stored in the dataset.
+
+        Parameters
+        ----------
+        options : dict/list, optional
+            driver-specific options determining how the relationships should be retrieved
+
+
+        """
         return _gdal.Dataset_GetRelationshipNames(self, *args)
 
     def GetRelationship(self, *args):
-        r"""GetRelationship(Dataset self, char const * name) -> Relationship"""
+        r"""
+        GetRelationship(Dataset self, char const * name) -> Relationship
+
+
+        Get a relationship from its name.
+
+        Returns
+        -------
+        Relationship, or ``None`` if not found.
+
+        """
         return _gdal.Dataset_GetRelationship(self, *args)
 
     def AddRelationship(self, *args):
-        r"""AddRelationship(Dataset self, Relationship relationship) -> bool"""
+        r"""
+        AddRelationship(Dataset self, Relationship relationship) -> bool
+
+
+        Add a :py:class:`Relationship` to the dataset.
+
+        See :cpp:func:`GDALDataset::AddRelationship`.
+
+        Parameters
+        ----------
+        relationship : Relationship
+                       The relationship to add
+
+        Returns
+        -------
+        bool:
+            ``True`` if the field domain was added, ``False`` in case of error.
+
+
+        """
         return _gdal.Dataset_AddRelationship(self, *args)
 
     def DeleteRelationship(self, *args):
-        r"""DeleteRelationship(Dataset self, char const * name) -> bool"""
+        r"""
+        DeleteRelationship(Dataset self, char const * name) -> bool
+
+
+        Removes a relationship from the Dataset.
+
+        Parameters
+        ----------
+        name : str
+               Name of the relationship to remove.
+
+        Returns
+        -------
+        bool
+             ``True`` if the relationship  was removed, otherwise ``False``.
+
+
+
+        """
         return _gdal.Dataset_DeleteRelationship(self, *args)
 
     def UpdateRelationship(self, *args):
-        r"""UpdateRelationship(Dataset self, Relationship relationship) -> bool"""
+        r"""
+        UpdateRelationship(Dataset self, Relationship relationship) -> bool
+
+
+        Update an existing relationship by replacing its definition.
+
+        The existing relationship with matching name will be replaced.
+
+        Requires the :py:const:`gdal.GDsCUpdateFieldDomain` dataset capability.
+
+        Parameters
+        ----------
+        relationship : Relationship
+            Updated relationship
+
+        Returns
+        -------
+        bool
+            ``True`` in case of success
+
+
+        """
         return _gdal.Dataset_UpdateRelationship(self, *args)
 
     def ReadRaster1(self, *args, **kwargs):
         r"""ReadRaster1(Dataset self, double xoff, double yoff, double xsize, double ysize, int * buf_xsize=None, int * buf_ysize=None, GDALDataType * buf_type=None, int band_list=0, GIntBig * buf_pixel_space=None, GIntBig * buf_line_space=None, GIntBig * buf_band_space=None, GDALRIOResampleAlg resample_alg=GRIORA_NearestNeighbour, GDALProgressFunc callback=0, void * callback_data=None, void * inputOutputBuf=None) -> CPLErr"""
         return _gdal.Dataset_ReadRaster1(self, *args, **kwargs)
 
 
     def ReadAsArray(self, xoff=0, yoff=0, xsize=None, ysize=None, buf_obj=None,
                     buf_xsize=None, buf_ysize=None, buf_type=None,
                     resample_alg=gdalconst.GRIORA_NearestNeighbour,
                     callback=None,
                     callback_data=None,
                     interleave='band',
                     band_list=None):
-        """ Reading a chunk of a GDAL band into a numpy array. The optional (buf_xsize,buf_ysize,buf_type)
-        parameters should generally not be specified if buf_obj is specified. The array is returned"""
+        """
+        Read a window from raster bands into a NumPy array.
+
+        Parameters
+        ----------
+        xoff : float, default=0
+           The pixel offset to left side of the region of the band to
+           be read. This would be zero to start from the left side.
+        yoff : float, default=0
+           The line offset to top side of the region of the band to
+           be read. This would be zero to start from the top side.
+        xsize : float, optional
+             The number of pixels to read in the x direction. By default,
+             equal to the number of columns in the raster.
+        ysize : float, optional
+             The number of rows to read in the y direction. By default,
+             equal to the number of bands in the raster.
+        buf_xsize : int, optional
+             The number of columns in the returned array. If not equal
+             to ``win_xsize``, the returned values will be determined
+             by ``resample_alg``.
+        buf_ysize : int, optional
+             The number of rows in the returned array. If not equal
+             to ``win_ysize``, the returned values will be determined
+             by ``resample_alg``.
+        buf_type : int, optional
+             The data type of the returned array
+        buf_obj : np.ndarray, optional
+             Optional buffer into which values will be read. If ``buf_obj``
+             is specified, then ``buf_xsize``/``buf_ysize``/``buf_type``
+             should generally not be specified.
+        resample_alg : int, default = :py:const:`gdal.GRIORA_NearestNeighbour`.
+             Specifies the resampling algorithm to use when the size of
+             the read window and the buffer are not equal.
+        callback : function, optional
+            A progress callback function
+        callback_data: optional
+            Optional data to be passed to callback function
+        band_list : list, optional
+            Indexes of bands from which data should be read. By default,
+            data will be read from all bands.
+
+        Returns
+        -------
+        np.ndarray
+
+        Examples
+        --------
+        >>> ds = gdal.GetDriverByName("GTiff").Create("test.tif", 4, 4, bands=2)
+        >>> ds.WriteArray(np.arange(32).reshape(2, 4, 4))
+        0
+        >>> ds.ReadAsArray()
+        array([[[ 0,  1,  2,  3],
+                [ 4,  5,  6,  7],
+                [ 8,  9, 10, 11],
+                [12, 13, 14, 15]],
+               [[16, 17, 18, 19],
+                [20, 21, 22, 23],
+                [24, 25, 26, 27],
+                [28, 29, 30, 31]]], dtype=uint8)
+        >>> ds.ReadAsArray(xoff=2, yoff=2, xsize=2, ysize=2)
+        array([[[10, 11],
+                [14, 15]],
+               [[26, 27],
+                [30, 31]]], dtype=uint8)
+        >>> ds.ReadAsArray(buf_xsize=2, buf_ysize=2, buf_type=gdal.GDT_Float64, resample_alg=gdal.GRIORA_Average)
+        array([[[ 3.,  5.],
+                [11., 13.]],
+               [[19., 21.],
+                [27., 29.]]])
+        >>> buf = np.zeros((2,2,2))
+        >>> ds.ReadAsArray(buf_obj=buf)
+        array([[[ 5.,  7.],
+                [13., 15.]],
+               [[21., 23.],
+                [29., 31.]]])
+        >>> ds.ReadAsArray(band_list=[2,1])
+        array([[[16, 17, 18, 19],
+                [20, 21, 22, 23],
+                [24, 25, 26, 27],
+                [28, 29, 30, 31]],
+               [[ 0,  1,  2,  3],
+                [ 4,  5,  6,  7],
+                [ 8,  9, 10, 11],
+                [12, 13, 14, 15]]], dtype=uint8)
+        """
 
         from osgeo import gdal_array
         return gdal_array.DatasetReadAsArray(self, xoff, yoff, xsize, ysize, buf_obj,
                                               buf_xsize, buf_ysize, buf_type,
                                               resample_alg=resample_alg,
                                               callback=callback,
                                               callback_data=callback_data,
@@ -3812,14 +5315,82 @@
 
     def WriteArray(self, array, xoff=0, yoff=0,
                    band_list=None,
                    interleave='band',
                    resample_alg=gdalconst.GRIORA_NearestNeighbour,
                    callback=None,
                    callback_data=None):
+        """
+        Write the contents of a NumPy array to a Dataset.
+
+        Parameters
+        ----------
+        array : np.ndarray
+            Two- or three-dimensional array containing values to write
+        xoff : int, default=0
+           The pixel offset to left side of the region of the band to
+           be written. This would be zero to start from the left side.
+        yoff : int, default=0
+           The line offset to top side of the region of the band to
+           be written. This would be zero to start from the top side.
+        band_list : list, optional
+            Indexes of bands to which data should be written. By default,
+            it is assumed that the Dataset contains the same number of
+            bands as levels in ``array``.
+        interleave : str, default="band"
+            Interleaving, "band" or "pixel". For band-interleaved writing,
+            ``array`` should have shape ``(nband, ny, nx)``. For pixel-
+            interleaved-writing, ``array`` should have shape
+            ``(ny, nx, nbands)``.
+        resample_alg : int, default = :py:const:`gdal.GRIORA_NearestNeighbour`
+            Resampling algorithm. Placeholder argument, not currently supported.
+        callback : function, optional
+            A progress callback function
+        callback_data: optional
+            Optional data to be passed to callback function
+
+        Returns
+        -------
+        int:
+            Error code, or ``gdal.CE_None`` if no error occurred.
+
+        Examples
+        --------
+
+        >>> import numpy as np
+        >>>
+        >>> nx = 4
+        >>> ny = 3
+        >>> nbands = 2
+        >>> with gdal.GetDriverByName("GTiff").Create("band3_px.tif", nx, ny, bands=nbands) as ds:
+        ...     data = np.arange(nx*ny*nbands).reshape(ny,nx,nbands)
+        ...     ds.WriteArray(data, interleave="pixel")
+        ...     ds.ReadAsArray()
+        ...
+        0
+        array([[[ 0,  2,  4,  6],
+                [ 8, 10, 12, 14],
+                [16, 18, 20, 22]],
+               [[ 1,  3,  5,  7],
+                [ 9, 11, 13, 15],
+                [17, 19, 21, 23]]], dtype=uint8)
+        >>> with gdal.GetDriverByName("GTiff").Create("band3_band.tif", nx, ny, bands=nbands) as ds:
+        ...     data = np.arange(nx*ny*nbands).reshape(nbands, ny, nx)
+        ...     ds.WriteArray(data, interleave="band")
+        ...     ds.ReadAsArray()
+        ...
+        0
+        array([[[ 0,  1,  2,  3],
+                [ 4,  5,  6,  7],
+                [ 8,  9, 10, 11]],
+               [[12, 13, 14, 15],
+                [16, 17, 18, 19],
+                [20, 21, 22, 23]]], dtype=uint8)
+        """
+
         from osgeo import gdal_array
 
         return gdal_array.DatasetWriteArray(self, array, xoff, yoff,
                                             band_list=band_list,
                                             interleave=interleave,
                                             resample_alg=resample_alg,
                                             callback=callback,
@@ -3942,14 +5513,23 @@
         if options is None:
             virtualmem = self.GetTiledVirtualMem(eAccess, xoff, yoff, xsize, ysize, tilexsize, tileysize, datatype, band_list, tile_organization, cache_size)
         else:
             virtualmem = self.GetTiledVirtualMem(eAccess, xoff, yoff, xsize, ysize, tilexsize, tileysize, datatype, band_list, tile_organization, cache_size, options)
         return gdal_array.VirtualMemGetArray( virtualmem )
 
     def GetSubDatasets(self):
+        """
+        Return a list of Subdatasets.
+
+
+        Returns
+        -------
+        list
+
+        """
         sd_list = []
 
         sd = self.GetMetadata('SUBDATASETS')
         if sd is None:
             return sd_list
 
         i = 1
@@ -3983,73 +5563,239 @@
                 exec("buf_obj_ar[0] = b' ' * nRequiredSize")
                 buf_obj = buf_obj_ar[0]
             else:
                 buf_obj = ' ' * nRequiredSize
         return _gdal.Dataset_BeginAsyncReader(self, xoff, yoff, xsize, ysize, buf_obj, buf_xsize, buf_ysize, buf_type, band_list,  0, 0, 0, options)
 
     def GetLayer(self, iLayer=0):
-        """Return the layer given an index or a name"""
+        """
+        Get the indicated layer from the Dataset
+
+        Parameters
+        ----------
+        value : int/str
+                Name or 0-based index of the layer to delete.
+
+        Returns
+        -------
+        ogr.Layer, or ``None`` on error
+        """
 
         _WarnIfUserHasNotSpecifiedIfUsingOgrExceptions()
 
         if isinstance(iLayer, str):
             return self.GetLayerByName(str(iLayer))
         elif isinstance(iLayer, int):
             return self.GetLayerByIndex(iLayer)
         else:
             raise TypeError("Input %s is not of String or Int type" % type(iLayer))
 
     def DeleteLayer(self, value):
-        """Deletes the layer given an index or layer name"""
+        """
+        Delete the indicated layer from the Dataset.
+
+        Parameters
+        ----------
+        value : int/str
+                Name or 0-based index of the layer to delete.
+
+        Returns
+        -------
+        int
+            :py:const:`ogr.OGRERR_NONE` on success or
+            :py:const:`ogr.OGRERR_UNSUPPORTED_OPERATION` if DeleteLayer is not supported
+            for this dataset.
+        """
         if isinstance(value, str):
             for i in range(self.GetLayerCount()):
                 name = self.GetLayer(i).GetName()
                 if name == value:
                     return _gdal.Dataset_DeleteLayer(self, i)
             raise ValueError("Layer %s not found to delete" % value)
         elif isinstance(value, int):
             return _gdal.Dataset_DeleteLayer(self, value)
         else:
             raise TypeError("Input %s is not of String or Int type" % type(value))
 
     def SetGCPs(self, gcps, wkt_or_spatial_ref):
+        """
+        Assign GCPs.
+
+        See :cpp:func:`GDALSetGCPs`.
+
+        Parameters
+        ----------
+        gcps : list
+               a list of :py:class:`GCP` objects
+        wkt_or_spatial_ref : str/osr.SpatialReference
+               spatial reference of the GCPs
+        """
+
         if isinstance(wkt_or_spatial_ref, str):
             return self._SetGCPs(gcps, wkt_or_spatial_ref)
         else:
             return self._SetGCPs2(gcps, wkt_or_spatial_ref)
 
-    def _add_band_ref(self, band):
-        if band is None:
+    def _add_child_ref(self, child):
+        if child is None:
             return
 
         import weakref
 
-        if not hasattr(self, '_band_references'):
-            self._band_references = weakref.WeakSet()
+        if not hasattr(self, '_child_references'):
+            self._child_references = weakref.WeakSet()
 
-        self._band_references.add(band)
-        band._parent_ds = weakref.ref(self)
+        self._child_references.add(child)
+        child._parent_ds = weakref.ref(self)
 
-    def _invalidate_bands(self):
-        if hasattr(self, '_band_references'):
-            for band in self._band_references:
-                band.this = None
+    def _invalidate_children(self):
+        if hasattr(self, '_child_references'):
+            for child in self._child_references:
+                child.this = None
 
     def __del__(self):
-        self._invalidate_bands()
+        self._invalidate_children()
 
     def __enter__(self):
         return self
 
     def __exit__(self, *args):
         self.Close()
 
 
 # Register Dataset in _gdal:
 _gdal.Dataset_swigregister(Dataset)
+class RasterAttributeTable(object):
+    r"""Proxy of C++ GDALRasterAttributeTableShadow class."""
+
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, *args):
+        r"""__init__(RasterAttributeTable self) -> RasterAttributeTable"""
+        _gdal.RasterAttributeTable_swiginit(self, _gdal.new_RasterAttributeTable(*args))
+    __swig_destroy__ = _gdal.delete_RasterAttributeTable
+
+    def Clone(self, *args):
+        r"""Clone(RasterAttributeTable self) -> RasterAttributeTable"""
+        return _gdal.RasterAttributeTable_Clone(self, *args)
+
+    def GetColumnCount(self, *args):
+        r"""GetColumnCount(RasterAttributeTable self) -> int"""
+        return _gdal.RasterAttributeTable_GetColumnCount(self, *args)
+
+    def GetNameOfCol(self, *args):
+        r"""GetNameOfCol(RasterAttributeTable self, int iCol) -> char const *"""
+        return _gdal.RasterAttributeTable_GetNameOfCol(self, *args)
+
+    def GetUsageOfCol(self, *args):
+        r"""GetUsageOfCol(RasterAttributeTable self, int iCol) -> GDALRATFieldUsage"""
+        return _gdal.RasterAttributeTable_GetUsageOfCol(self, *args)
+
+    def GetTypeOfCol(self, *args):
+        r"""GetTypeOfCol(RasterAttributeTable self, int iCol) -> GDALRATFieldType"""
+        return _gdal.RasterAttributeTable_GetTypeOfCol(self, *args)
+
+    def GetColOfUsage(self, *args):
+        r"""GetColOfUsage(RasterAttributeTable self, GDALRATFieldUsage eUsage) -> int"""
+        return _gdal.RasterAttributeTable_GetColOfUsage(self, *args)
+
+    def GetRowCount(self, *args):
+        r"""GetRowCount(RasterAttributeTable self) -> int"""
+        return _gdal.RasterAttributeTable_GetRowCount(self, *args)
+
+    def GetValueAsString(self, *args):
+        r"""GetValueAsString(RasterAttributeTable self, int iRow, int iCol) -> char const *"""
+        return _gdal.RasterAttributeTable_GetValueAsString(self, *args)
+
+    def GetValueAsInt(self, *args):
+        r"""GetValueAsInt(RasterAttributeTable self, int iRow, int iCol) -> int"""
+        return _gdal.RasterAttributeTable_GetValueAsInt(self, *args)
+
+    def GetValueAsDouble(self, *args):
+        r"""GetValueAsDouble(RasterAttributeTable self, int iRow, int iCol) -> double"""
+        return _gdal.RasterAttributeTable_GetValueAsDouble(self, *args)
+
+    def ReadValuesIOAsString(self, *args):
+        r"""ReadValuesIOAsString(RasterAttributeTable self, int iField, int iStartRow, int iLength) -> CPLErr"""
+        return _gdal.RasterAttributeTable_ReadValuesIOAsString(self, *args)
+
+    def ReadValuesIOAsInteger(self, *args):
+        r"""ReadValuesIOAsInteger(RasterAttributeTable self, int iField, int iStartRow, int iLength) -> CPLErr"""
+        return _gdal.RasterAttributeTable_ReadValuesIOAsInteger(self, *args)
+
+    def ReadValuesIOAsDouble(self, *args):
+        r"""ReadValuesIOAsDouble(RasterAttributeTable self, int iField, int iStartRow, int iLength) -> CPLErr"""
+        return _gdal.RasterAttributeTable_ReadValuesIOAsDouble(self, *args)
+
+    def SetValueAsString(self, *args):
+        r"""SetValueAsString(RasterAttributeTable self, int iRow, int iCol, char const * pszValue)"""
+        return _gdal.RasterAttributeTable_SetValueAsString(self, *args)
+
+    def SetValueAsInt(self, *args):
+        r"""SetValueAsInt(RasterAttributeTable self, int iRow, int iCol, int nValue)"""
+        return _gdal.RasterAttributeTable_SetValueAsInt(self, *args)
+
+    def SetValueAsDouble(self, *args):
+        r"""SetValueAsDouble(RasterAttributeTable self, int iRow, int iCol, double dfValue)"""
+        return _gdal.RasterAttributeTable_SetValueAsDouble(self, *args)
+
+    def SetRowCount(self, *args):
+        r"""SetRowCount(RasterAttributeTable self, int nCount)"""
+        return _gdal.RasterAttributeTable_SetRowCount(self, *args)
+
+    def CreateColumn(self, *args):
+        r"""CreateColumn(RasterAttributeTable self, char const * pszName, GDALRATFieldType eType, GDALRATFieldUsage eUsage) -> int"""
+        return _gdal.RasterAttributeTable_CreateColumn(self, *args)
+
+    def GetLinearBinning(self, *args):
+        r"""GetLinearBinning(RasterAttributeTable self) -> bool"""
+        return _gdal.RasterAttributeTable_GetLinearBinning(self, *args)
+
+    def SetLinearBinning(self, *args):
+        r"""SetLinearBinning(RasterAttributeTable self, double dfRow0Min, double dfBinSize) -> int"""
+        return _gdal.RasterAttributeTable_SetLinearBinning(self, *args)
+
+    def GetRowOfValue(self, *args):
+        r"""GetRowOfValue(RasterAttributeTable self, double dfValue) -> int"""
+        return _gdal.RasterAttributeTable_GetRowOfValue(self, *args)
+
+    def ChangesAreWrittenToFile(self, *args):
+        r"""ChangesAreWrittenToFile(RasterAttributeTable self) -> int"""
+        return _gdal.RasterAttributeTable_ChangesAreWrittenToFile(self, *args)
+
+    def DumpReadable(self, *args):
+        r"""DumpReadable(RasterAttributeTable self)"""
+        return _gdal.RasterAttributeTable_DumpReadable(self, *args)
+
+    def SetTableType(self, *args):
+        r"""SetTableType(RasterAttributeTable self, GDALRATTableType eTableType)"""
+        return _gdal.RasterAttributeTable_SetTableType(self, *args)
+
+    def GetTableType(self, *args):
+        r"""GetTableType(RasterAttributeTable self) -> GDALRATTableType"""
+        return _gdal.RasterAttributeTable_GetTableType(self, *args)
+
+    def RemoveStatistics(self, *args):
+        r"""RemoveStatistics(RasterAttributeTable self)"""
+        return _gdal.RasterAttributeTable_RemoveStatistics(self, *args)
+
+    def WriteArray(self, array, field, start=0):
+        from osgeo import gdal_array
+
+        return gdal_array.RATWriteArray(self, array, field, start)
+
+    def ReadAsArray(self, field, start=0, length=None):
+        from osgeo import gdal_array
+
+        return gdal_array.RATReadArray(self, field, start, length)
+
+
+# Register RasterAttributeTable in _gdal:
+_gdal.RasterAttributeTable_swigregister(RasterAttributeTable)
 GEDTST_NONE = _gdal.GEDTST_NONE
 
 GEDTST_JSON = _gdal.GEDTST_JSON
 
 class Group(object):
     r"""Proxy of C++ GDALGroupHS class."""
 
@@ -4911,81 +6657,244 @@
 
     def GetType(self, *args):
         r"""GetType(EDTComponent self) -> ExtendedDataType"""
         return _gdal.EDTComponent_GetType(self, *args)
 
 # Register EDTComponent in _gdal:
 _gdal.EDTComponent_swigregister(EDTComponent)
+
+def CreateRasterAttributeTableFromMDArrays(*args):
+    r"""CreateRasterAttributeTableFromMDArrays(GDALRATTableType eTableType, int nArrays, int nUsages=0) -> RasterAttributeTable"""
+    return _gdal.CreateRasterAttributeTableFromMDArrays(*args)
 class Band(MajorObject):
-    r"""Proxy of C++ GDALRasterBandShadow class."""
+    r"""
+
+
+    Python proxy of a :cpp:class:`GDALRasterBand`.
+
+
+    """
 
     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
 
     def __init__(self, *args, **kwargs):
         raise AttributeError("No constructor defined")
     __repr__ = _swig_repr
     XSize = property(_gdal.Band_XSize_get, doc=r"""XSize : int""")
     YSize = property(_gdal.Band_YSize_get, doc=r"""YSize : int""")
     DataType = property(_gdal.Band_DataType_get, doc=r"""DataType : GDALDataType""")
 
     def GetDataset(self, *args):
-        r"""GetDataset(Band self) -> Dataset"""
+        r"""
+        GetDataset(Band self) -> Dataset
+
+
+        Fetch the :py:class:`Dataset` associated with this Band.
+        See :cpp:func:`GDALRasterBand::GetDataset`.
+
+        """
         return _gdal.Band_GetDataset(self, *args)
 
     def GetBand(self, *args):
-        r"""GetBand(Band self) -> int"""
+        r"""
+        GetBand(Band self) -> int
+
+
+        Return the index of this band.
+        See :cpp:func:`GDALRasterBand::GetBand`.
+
+        Returns
+        -------
+        int
+            the (1-based) index of this band
+
+        """
         return _gdal.Band_GetBand(self, *args)
 
     def GetBlockSize(self, *args):
-        r"""GetBlockSize(Band self)"""
+        r"""
+        GetBlockSize(Band self)
+
+
+        Fetch the natural block size of this band.
+        See :cpp:func:`GDALRasterBand::GetBlockSize`.
+
+        Returns
+        -------
+        list
+            list with the x and y dimensions of a block
+
+        """
         return _gdal.Band_GetBlockSize(self, *args)
 
     def GetActualBlockSize(self, *args):
-        r"""GetActualBlockSize(Band self, int nXBlockOff, int nYBlockOff)"""
+        r"""
+        GetActualBlockSize(Band self, int nXBlockOff, int nYBlockOff)
+
+
+        Fetch the actual block size for a given block offset.
+        See :cpp:func:`GDALRasterBand::GetActualBlockSize`.
+
+        Parameters
+        ----------
+        nXBlockOff : int
+            the horizontal block offset for which to calculate the
+            number of valid pixels, with zero indicating the left most block, 1 the next
+            block and so forth.
+        nYBlockOff : int
+            the vertical block offset, with zero indicating
+            the top most block, 1 the next block and so forth.
+
+        Returns
+        -------
+        tuple
+            tuple with the x and y dimensions of the block
+
+        """
         return _gdal.Band_GetActualBlockSize(self, *args)
 
     def GetColorInterpretation(self, *args):
-        r"""GetColorInterpretation(Band self) -> GDALColorInterp"""
+        r"""
+        GetColorInterpretation(Band self) -> GDALColorInterp
+
+
+        Get the :cpp:enum:`GDALColorInterp` value for this band.
+        See :cpp:func:`GDALRasterBand::GetColorInterpretation`.
+
+        Returns
+        -------
+        int
+
+        """
         return _gdal.Band_GetColorInterpretation(self, *args)
 
     def GetRasterColorInterpretation(self, *args):
-        r"""GetRasterColorInterpretation(Band self) -> GDALColorInterp"""
+        r"""
+        GetRasterColorInterpretation(Band self) -> GDALColorInterp
+
+
+        Return the color interpretation code for this band.
+        See :cpp:func:`GDALRasterBand::GetColorInterpretation`.
+
+        Returns
+        -------
+        int
+            The color interpretation code (default :py:const:`gdal.GCI_Undefined`)
+
+
+        """
         return _gdal.Band_GetRasterColorInterpretation(self, *args)
 
     def SetColorInterpretation(self, *args):
-        r"""SetColorInterpretation(Band self, GDALColorInterp val) -> CPLErr"""
+        r"""
+        SetColorInterpretation(Band self, GDALColorInterp val) -> CPLErr
+
+
+        Set color interpretation of the band
+        See :cpp:func:`GDALRasterBand::SetColorInterpretation`.
+
+        Parameters
+        ----------
+        val : int
+            A color interpretation code such as :py:const:`gdal.GCI_RedBand`
+
+        Returns
+        -------
+        int:
+           :py:const:`CE_None` on success or :py:const:`CE_Failure` on failure.
+
+        """
         return _gdal.Band_SetColorInterpretation(self, *args)
 
     def SetRasterColorInterpretation(self, *args):
-        r"""SetRasterColorInterpretation(Band self, GDALColorInterp val) -> CPLErr"""
+        r"""
+        SetRasterColorInterpretation(Band self, GDALColorInterp val) -> CPLErr
+
+        Deprecated.  Alternate name for :py:meth:`SetColorInterpretation`.
+
+        """
         return _gdal.Band_SetRasterColorInterpretation(self, *args)
 
     def GetNoDataValue(self):
-        """GetNoDataValue(Band self) -> value """
+        """GetNoDataValue(Band self) -> value
+
+        Fetch the nodata value for this band.
+        Unlike :cpp:func:`GDALRasterBand::GetNoDataValue`, this
+        method handles 64-bit integer data types.
+
+        Returns
+        -------
+        float/int
+            The nodata value, or ``None`` if it has not been set.
+        """
 
         if self.DataType == gdalconst.GDT_Int64:
             return _gdal.Band_GetNoDataValueAsInt64(self)
 
         if self.DataType == gdalconst.GDT_UInt64:
             return _gdal.Band_GetNoDataValueAsUInt64(self)
 
         return _gdal.Band_GetNoDataValue(self)
 
 
 
     def GetNoDataValueAsInt64(self, *args):
-        r"""GetNoDataValueAsInt64(Band self)"""
+        r"""
+        GetNoDataValueAsInt64(Band self)
+
+
+        Fetch the nodata value for this band.
+        See :cpp:func:`GDALRasterBand::GetNoDataValueAsInt64`.
+
+        Returns
+        -------
+        int
+            The nodata value, or ``None`` if it has not been set or
+            the data type of this band is not :py:const:`gdal.GDT_Int64`.
+
+
+        """
         return _gdal.Band_GetNoDataValueAsInt64(self, *args)
 
     def GetNoDataValueAsUInt64(self, *args):
-        r"""GetNoDataValueAsUInt64(Band self)"""
+        r"""
+        GetNoDataValueAsUInt64(Band self)
+
+
+        Fetch the nodata value for this band.
+        See :cpp:func:`GDALRasterBand::GetNoDataValueAsUInt64`.
+
+        Returns
+        -------
+        int
+            The nodata value, or ``None`` if it has not been set or
+            the data type of this band is not :py:const:`gdal.GDT_UInt64`.
+
+
+        """
         return _gdal.Band_GetNoDataValueAsUInt64(self, *args)
 
     def SetNoDataValue(self, value) -> "CPLErr":
-        """SetNoDataValue(Band self, value) -> CPLErr"""
+        """SetNoDataValue(Band self, value) -> CPLErr
+
+        Set the nodata value for this band.
+        Unlike :cpp:func:`GDALRasterBand::SetNoDataValue`, this
+        method handles 64-bit integer types.
+
+        Parameters
+        ----------
+        value : float/int
+            The nodata value to set
+
+        Returns
+        -------
+        int:
+           :py:const:`CE_None` on success or :py:const:`CE_Failure` on failure.
+
+        """
 
         if self.DataType == gdalconst.GDT_Int64:
             return _gdal.Band_SetNoDataValueAsInt64(self, value)
 
         if self.DataType == gdalconst.GDT_UInt64:
             return _gdal.Band_SetNoDataValueAsUInt64(self, value)
 
@@ -4998,63 +6907,280 @@
         return _gdal.Band_SetNoDataValueAsInt64(self, *args)
 
     def SetNoDataValueAsUInt64(self, *args):
         r"""SetNoDataValueAsUInt64(Band self, GUIntBig v) -> CPLErr"""
         return _gdal.Band_SetNoDataValueAsUInt64(self, *args)
 
     def DeleteNoDataValue(self, *args):
-        r"""DeleteNoDataValue(Band self) -> CPLErr"""
+        r"""
+        DeleteNoDataValue(Band self) -> CPLErr
+
+
+        Remove the nodata value for this band.
+
+        Returns
+        -------
+        int:
+           :py:const:`CE_None` on success or :py:const:`CE_Failure` on failure.
+
+
+        """
         return _gdal.Band_DeleteNoDataValue(self, *args)
 
     def GetUnitType(self, *args):
-        r"""GetUnitType(Band self) -> char const *"""
+        r"""
+        GetUnitType(Band self) -> char const *
+
+
+        Return a name for the units of this raster's values.
+        See :cpp:func:`GDALRasterBand::GetUnitType`.
+
+        Returns
+        -------
+        str
+
+        Examples
+        --------
+        >>> ds = gdal.GetDriverByName('MEM').Create('', 10, 10)
+        >>> ds.GetRasterBand(1).SetUnitType('ft')
+        0
+        >>> ds.GetRasterBand(1).GetUnitType()
+        'ft'
+
+        """
         return _gdal.Band_GetUnitType(self, *args)
 
     def SetUnitType(self, *args):
-        r"""SetUnitType(Band self, char const * val) -> CPLErr"""
+        r"""
+        SetUnitType(Band self, char const * val) -> CPLErr
+
+
+        Set unit type.
+        See :cpp:func:`GDALRasterBand::SetUnitType`.
+
+        Parameters
+        ----------
+        val : str
+
+        Returns
+        -------
+        int:
+           :py:const:`CE_None` on success or :py:const:`CE_Failure` on failure.
+
+        """
         return _gdal.Band_SetUnitType(self, *args)
 
     def GetRasterCategoryNames(self, *args):
-        r"""GetRasterCategoryNames(Band self) -> char **"""
+        r"""
+        GetRasterCategoryNames(Band self) -> char **
+
+
+        Fetch the list of category names for this band.
+        See :cpp:func:`GDALRasterBand::GetCategoryNames`.
+
+        Returns
+        -------
+        list
+            The list of names, or ``None`` if no names exist.
+
+
+        """
         return _gdal.Band_GetRasterCategoryNames(self, *args)
 
     def SetRasterCategoryNames(self, *args):
-        r"""SetRasterCategoryNames(Band self, char ** names) -> CPLErr"""
+        r"""
+        SetRasterCategoryNames(Band self, char ** names) -> CPLErr
+
+        Deprecated.  Alternate name for :py:meth:`SetCategoryNames`.
+
+        """
         return _gdal.Band_SetRasterCategoryNames(self, *args)
 
     def GetMinimum(self, *args):
-        r"""GetMinimum(Band self)"""
+        r"""
+        GetMinimum(Band self)
+
+
+        Fetch a previously stored maximum value for this band.
+        See :cpp:func:`GDALRasterBand::GetMinimum`.
+
+        Returns
+        -------
+        float
+            The stored minimum value, or ``None`` if no value
+            has been stored.
+
+
+        """
         return _gdal.Band_GetMinimum(self, *args)
 
     def GetMaximum(self, *args):
-        r"""GetMaximum(Band self)"""
+        r"""
+        GetMaximum(Band self)
+
+
+        Fetch a previously stored maximum value for this band.
+        See :cpp:func:`GDALRasterBand::GetMaximum`.
+
+        Returns
+        -------
+        float
+            The stored maximum value, or ``None`` if no value
+            has been stored.
+
+
+        """
         return _gdal.Band_GetMaximum(self, *args)
 
     def GetOffset(self, *args):
-        r"""GetOffset(Band self)"""
+        r"""
+        GetOffset(Band self)
+
+
+        Fetch the raster value offset.
+        See :cpp:func:`GDALRasterBand::GetOffset`.
+
+        Returns
+        -------
+        double
+            The offset value, or ``0.0``.
+
+
+        """
         return _gdal.Band_GetOffset(self, *args)
 
     def GetScale(self, *args):
-        r"""GetScale(Band self)"""
+        r"""
+        GetScale(Band self)
+
+
+        Fetch the band scale value.
+        See :cpp:func:`GDALRasterBand::GetScale`.
+
+        Returns
+        -------
+        double
+            The scale value, or ``1.0``.
+
+        """
         return _gdal.Band_GetScale(self, *args)
 
     def SetOffset(self, *args):
-        r"""SetOffset(Band self, double val) -> CPLErr"""
+        r"""
+        SetOffset(Band self, double val) -> CPLErr
+
+
+        Set scaling offset.
+        See :cpp:func:`GDALRasterBand::SetOffset`.
+
+        Parameters
+        ----------
+        val : float
+
+        Returns
+        -------
+        int:
+           :py:const:`CE_None` on success or :py:const:`CE_Failure` on failure.
+
+        See Also
+        --------
+        :py:meth:`SetScale`
+
+        """
         return _gdal.Band_SetOffset(self, *args)
 
     def SetScale(self, *args):
-        r"""SetScale(Band self, double val) -> CPLErr"""
+        r"""
+        SetScale(Band self, double val) -> CPLErr
+
+        Set scaling ratio.
+        See :cpp:func:`GDALRasterBand::SetScale`.
+
+        Parameters
+        ----------
+        val : float
+
+        Returns
+        -------
+        int:
+           :py:const:`CE_None` on success or :py:const:`CE_Failure` on failure.
+
+        See Also
+        --------
+        :py:meth:`SetOffset`
+
+        """
         return _gdal.Band_SetScale(self, *args)
 
     def GetStatistics(self, *args):
-        r"""GetStatistics(Band self, int approx_ok, int force) -> CPLErr"""
+        r"""
+        GetStatistics(Band self, int approx_ok, int force) -> CPLErr
+
+
+        Return the minimum, maximum, mean, and standard deviation of all pixel values
+        in this band.
+        See :cpp:func:`GDALRasterBand::GetStatistics`
+
+        Parameters
+        ----------
+        approx_ok : bool
+            If ``True``, allow overviews or a subset of image tiles to be used in
+            computing the statistics.
+        force : bool
+            If ``False``, only return a result if it can be obtained without scanning
+            the image, i.e. from pre-existing metadata.
+
+        Returns
+        -------
+        list
+           a list with the min, max, mean, and standard deviation of values
+           in the Band.
+
+        See Also
+        --------
+        :py:meth:`ComputeBandStats`
+        :py:meth:`ComputeRasterMinMax`
+        :py:meth:`GetMaximum`
+        :py:meth:`GetMinimum`
+        :py:meth:`GetStatistics`
+
+        """
         return _gdal.Band_GetStatistics(self, *args)
 
     def ComputeStatistics(self, *args, **kwargs) -> "CPLErr":
-        """ComputeStatistics(Band self, bool approx_ok, callback=None, callback_data=None) -> CPLErr"""
+        """ComputeStatistics(Band self, bool approx_ok, callback=None, callback_data=None) -> CPLErr
+
+        Compute image statistics.
+        See :cpp:func:`GDALRasterBand::ComputeStatistics`.
+
+        Parameters
+        ----------
+        approx_ok : bool
+                     If ``True``, compute statistics based on overviews or a
+                     subset of tiles.
+        callback : function, optional
+                     A progress callback function
+        callback_data: optional
+                     Optional data to be passed to callback function
+
+        Returns
+        -------
+        list
+           a list with the min, max, mean, and standard deviation of values
+           in the Band.
+
+        See Also
+        --------
+        :py:meth:`ComputeBandStats`
+        :py:meth:`ComputeRasterMinMax`
+        :py:meth:`GetMaximum`
+        :py:meth:`GetMinimum`
+        :py:meth:`GetStatistics`
+        :py:meth:`SetStatistics`
+        """
 
         if len(args) == 1:
             kwargs["approx_ok"] = args[0]
             args = ()
 
         if "approx_ok" in kwargs:
     # Compatibility with older signature that used int for approx_ok
@@ -5066,38 +7192,152 @@
                 raise Exception("approx_ok value should be 0/1/False/True")
 
         return _gdal.Band_ComputeStatistics(self, *args, **kwargs)
 
 
 
     def SetStatistics(self, *args):
-        r"""SetStatistics(Band self, double min, double max, double mean, double stddev) -> CPLErr"""
+        r"""
+        SetStatistics(Band self, double min, double max, double mean, double stddev) -> CPLErr
+
+
+        Set statistics on band.
+        See :cpp:func:`GDALRasterBand::SetStatistics`.
+
+        Parameters
+        ----------
+        min : float
+        max : float
+        mean : float
+        stdev : float
+
+        Returns
+        -------
+        int:
+           :py:const:`CE_None` on apparent success or :py:const:`CE_Failure` on
+           failure.  This method cannot detect whether metadata will be properly saved and
+           so may return :py:const:`gdal.`CE_None` even if the statistics will never be
+           saved.
+
+        See Also
+        --------
+        :py:meth:`ComputeBandStats`
+        :py:meth:`ComputeRasterMinMax`
+        :py:meth:`ComputeStatistics`
+        :py:meth:`GetMaximum`
+        :py:meth:`GetMinimum`
+        :py:meth:`GetStatistics`
+
+        """
         return _gdal.Band_SetStatistics(self, *args)
 
     def GetOverviewCount(self, *args):
-        r"""GetOverviewCount(Band self) -> int"""
+        r"""
+        GetOverviewCount(Band self) -> int
+
+
+        Return the number of overview layers available.
+        See :cpp:func:`GDALRasterBand::GetOverviewCount`.
+
+        Returns
+        -------
+        int
+
+
+        """
         return _gdal.Band_GetOverviewCount(self, *args)
 
     def GetOverview(self, *args):
-        r"""GetOverview(Band self, int i) -> Band"""
+        r"""
+        GetOverview(Band self, int i) -> Band
+
+
+        Fetch a raster overview.
+        See :cpp:func:`GDALRasterBand::GetOverview`.
+
+        Parameters
+        ----------
+        i : int
+            Overview index between 0 and ``GetOverviewCount() - 1``.
+
+        Returns
+        -------
+        Band
+
+
+        """
         val = _gdal.Band_GetOverview(self, *args)
 
         if hasattr(self, '_parent_ds') and self._parent_ds():
-            self._parent_ds()._add_band_ref(val)
+            self._parent_ds()._add_child_ref(val)
 
 
         return val
 
 
     def Checksum(self, *args, **kwargs):
-        r"""Checksum(Band self, int xoff=0, int yoff=0, int * xsize=None, int * ysize=None) -> int"""
+        r"""
+        Checksum(Band self, int xoff=0, int yoff=0, int * xsize=None, int * ysize=None) -> int
+
+
+        Computes a checksum from a region of a RasterBand.
+        See :cpp:func:`GDALChecksumImage`.
+
+        Parameters
+        ----------
+        xoff : int, default=0
+           The pixel offset to left side of the region of the band to
+           be read. This would be zero to start from the left side.
+        yoff : int, default=0
+           The line offset to top side of the region of the band to
+           be read. This would be zero to start from the top side.
+        xsize : int, optional
+             The number of pixels to read in the x direction. By default,
+             equal to the number of columns in the raster.
+        ysize : int, optional
+             The number of rows to read in the y direction. By default,
+             equal to the number of bands in the raster.
+
+        Returns
+        -------
+        int
+            checksum value, or -1 in case of error
+
+
+        """
         return _gdal.Band_Checksum(self, *args, **kwargs)
 
     def ComputeRasterMinMax(self, *args, **kwargs):
-        """ComputeRasterMinMax(Band self, bool approx_ok=False, bool can_return_none=False) -> (min, max) or None"""
+        """ComputeRasterMinMax(Band self, bool approx_ok=False, bool can_return_none=False) -> (min, max) or None
+
+        Computes the minimum and maximum values for this Band.
+        See :cpp:func:`GDALComputeRasterMinMax`.
+
+        Parameters
+        ----------
+        approx_ok : bool, default=False
+            If ``False``, read all pixels in the band. If ``True``, check
+            :py:meth:`GetMinimum`/:py:meth:`GetMaximum` or read a subsample.
+        can_return_none : bool, default=False
+            If ``True``, return ``None`` on error. Otherwise, return a tuple
+            with NaN values.
+
+        Returns
+        -------
+        tuple
+
+        See Also
+        --------
+        :py:meth:`ComputeBandStats`
+        :py:meth:`ComputeStatistics`
+        :py:meth:`GetMaximum`
+        :py:meth:`GetMinimum`
+        :py:meth:`GetStatistics`
+        :py:meth:`SetStatistics`
+        """
 
         if len(args) == 1:
             kwargs["approx_ok"] = args[0]
             args = ()
 
         if "approx_ok" in kwargs:
     # Compatibility with older signature that used int for approx_ok
@@ -5114,98 +7354,383 @@
             del kwargs["can_return_null"]
 
         return _gdal.Band_ComputeRasterMinMax(self, *args, **kwargs)
 
 
 
     def ComputeBandStats(self, *args):
-        r"""ComputeBandStats(Band self, int samplestep=1)"""
+        r"""
+        ComputeBandStats(Band self, int samplestep=1)
+
+
+        Computes the mean and standard deviation of values in this Band.
+        See :cpp:func:`GDALComputeBandStats`.
+
+        Parameters
+        ----------
+        samplestep : int, default=1
+            Step between scanlines used to compute statistics.
+
+        Returns
+        -------
+        tuple
+            tuple of length 2 with value of mean and standard deviation
+
+        See Also
+        --------
+        :py:meth:`ComputeRasterMinMax`
+        :py:meth:`ComputeStatistics`
+        :py:meth:`GetMaximum`
+        :py:meth:`GetMinimum`
+        :py:meth:`GetStatistics`
+        :py:meth:`SetStatistics`
+
+        """
         return _gdal.Band_ComputeBandStats(self, *args)
 
     def Fill(self, *args):
-        r"""Fill(Band self, double real_fill, double imag_fill=0.0) -> CPLErr"""
+        r"""
+        Fill(Band self, double real_fill, double imag_fill=0.0) -> CPLErr
+
+
+        Fill this band with a constant value.
+        See :cpp:func:`GDALRasterBand::Fill`.
+
+        Parameters
+        ----------
+        real_fill : float
+            real component of the fill value
+        imag_fill : float, default = 0.0
+            imaginary component of the fill value
+
+        Returns
+        -------
+        int:
+           :py:const:`CE_None` on success or :py:const:`CE_Failure` on failure.
+
+
+        """
         return _gdal.Band_Fill(self, *args)
 
     def WriteRaster(self, *args, **kwargs):
         r"""WriteRaster(Band self, int xoff, int yoff, int xsize, int ysize, GIntBig buf_len, int * buf_xsize=None, int * buf_ysize=None, GDALDataType * buf_type=None, GIntBig * buf_pixel_space=None, GIntBig * buf_line_space=None) -> CPLErr"""
         return _gdal.Band_WriteRaster(self, *args, **kwargs)
 
     def FlushCache(self, *args):
-        r"""FlushCache(Band self)"""
+        r"""
+        FlushCache(Band self)
+
+
+        Flush raster data cache.
+        See :cpp:func:`GDALRasterBand::FlushCache`.
+
+        """
         return _gdal.Band_FlushCache(self, *args)
 
     def GetRasterColorTable(self, *args):
-        r"""GetRasterColorTable(Band self) -> ColorTable"""
+        r"""
+        GetRasterColorTable(Band self) -> ColorTable
+
+
+        Fetch the color table associated with this band.
+        See :cpp:func:`GDALRasterBand::GetColorTable`.
+
+        Returns
+        -------
+        ColorTable
+            The :py:class:`ColorTable`, or ``None`` if it has not been defined.
+
+        """
         return _gdal.Band_GetRasterColorTable(self, *args)
 
     def GetColorTable(self, *args):
-        r"""GetColorTable(Band self) -> ColorTable"""
+        r"""
+        GetColorTable(Band self) -> ColorTable
+
+
+        Get the color table associated with this band.
+        See :cpp:func:`GDALRasterBand::GetColorTable`.
+
+        Returns
+        -------
+        ColorTable or ``None``
+
+        """
         return _gdal.Band_GetColorTable(self, *args)
 
     def SetRasterColorTable(self, *args):
-        r"""SetRasterColorTable(Band self, ColorTable arg) -> int"""
+        r"""
+        SetRasterColorTable(Band self, ColorTable arg) -> int
+
+        Deprecated. Alternate name for :py:meth:`SetColorTable`.
+
+        """
         return _gdal.Band_SetRasterColorTable(self, *args)
 
     def SetColorTable(self, *args):
-        r"""SetColorTable(Band self, ColorTable arg) -> int"""
+        r"""
+        SetColorTable(Band self, ColorTable arg) -> int
+
+
+        Set the raster color table.
+        See :cpp:func:`GDALRasterBand::SetColorTable`.
+
+        Parameters
+        ----------
+        arg : ColorTable
+
+        Returns
+        -------
+        int:
+           :py:const:`CE_None` on success or :py:const:`CE_Failure` on failure.
+
+        """
         return _gdal.Band_SetColorTable(self, *args)
 
     def GetDefaultRAT(self, *args):
         r"""GetDefaultRAT(Band self) -> RasterAttributeTable"""
         return _gdal.Band_GetDefaultRAT(self, *args)
 
     def SetDefaultRAT(self, *args):
         r"""SetDefaultRAT(Band self, RasterAttributeTable table) -> int"""
         return _gdal.Band_SetDefaultRAT(self, *args)
 
     def GetMaskBand(self, *args):
-        r"""GetMaskBand(Band self) -> Band"""
+        r"""
+        GetMaskBand(Band self) -> Band
+
+
+        Return the mask band associated with this band.
+        See :cpp:func:`GDALRasterBand::GetMaskBand`.
+
+        Returns
+        -------
+        Band
+
+
+        """
         val = _gdal.Band_GetMaskBand(self, *args)
 
         if hasattr(self, '_parent_ds') and self._parent_ds():
-            self._parent_ds()._add_band_ref(val)
+            self._parent_ds()._add_child_ref(val)
 
 
         return val
 
 
     def GetMaskFlags(self, *args):
-        r"""GetMaskFlags(Band self) -> int"""
+        r"""
+        GetMaskFlags(Band self) -> int
+
+
+        Return the status flags of the mask band.
+        See :cpp:func:`GDALRasterBand::GetMaskFlags`.
+
+        Returns
+        -------
+        int
+
+        Examples
+        --------
+        >>> import numpy as np
+        >>> ds = gdal.GetDriverByName('MEM').Create('', 10, 10)
+        >>> band = ds.GetRasterBand(1)
+        >>> band.GetMaskFlags() == gdal.GMF_ALL_VALID
+        True
+        >>> band.SetNoDataValue(22)
+        0
+        >>> band.WriteArray(np.array([[22]]))
+        0
+        >>> band.GetMaskBand().ReadAsArray(win_xsize=2,win_ysize=2)
+        array([[  0, 255],
+               [255, 255]], dtype=uint8)
+        >>> band.GetMaskFlags() == gdal.GMF_NODATA
+        True
+
+
+        """
         return _gdal.Band_GetMaskFlags(self, *args)
 
     def CreateMaskBand(self, *args):
-        r"""CreateMaskBand(Band self, int nFlags) -> CPLErr"""
+        r"""
+        CreateMaskBand(Band self, int nFlags) -> CPLErr
+
+
+        Add a mask band to the current band.
+        See :cpp:func:`GDALRasterBand::CreateMaskBand`.
+
+        Parameters
+        ----------
+        nFlags : int
+
+        Returns
+        -------
+        int:
+           :py:const:`CE_None` on success or :py:const:`CE_Failure` on failure.
+
+
+        """
         return _gdal.Band_CreateMaskBand(self, *args)
 
     def IsMaskBand(self, *args):
-        r"""IsMaskBand(Band self) -> bool"""
+        r"""
+        IsMaskBand(Band self) -> bool
+
+
+        Returns whether the band is a mask band.
+        See :cpp:func:`GDALRasterBand::IsMaskBand`.
+
+        Returns
+        -------
+        bool
+
+        """
         return _gdal.Band_IsMaskBand(self, *args)
 
     def GetHistogram(self, *args, **kwargs):
-        r"""GetHistogram(Band self, double min=-0.5, double max=255.5, int buckets=256, int include_out_of_range=0, int approx_ok=1, GDALProgressFunc callback=0, void * callback_data=None) -> CPLErr"""
+        r"""
+        GetHistogram(Band self, double min=-0.5, double max=255.5, int buckets=256, int include_out_of_range=0, int approx_ok=1, GDALProgressFunc callback=0, void * callback_data=None) -> CPLErr
+
+
+        Compute raster histogram.
+        See :cpp:func:`GDALRasterBand::GetHistogram`.
+
+        Parameters
+        ----------
+        min : float, default=-0.05
+            the lower bound of the histogram
+        max : float, default=255.5
+            the upper bound of the histogram
+        buckets : int, default=256
+            the number of buckets int he histogram
+        include_out_of_range : bool, default=False
+            if ``True``, add out-of-range values into the first and last buckets
+        approx_ok : bool, default=True
+            if ``True``, compute an approximate histogram by using subsampling or overviews
+        callback : function, optional
+                     A progress callback function
+        callback_data: optional
+                     Optional data to be passed to callback function
+
+        Returns
+        -------
+        list
+            list with length equal to ``buckets``. If ``approx_ok`` is ``False``, each
+            the value of each list item will equal the number of pixels in that bucket.
+
+        Examples
+        --------
+        >>> import numpy as np
+        >>> ds = gdal.GetDriverByName('MEM').Create('', 10, 10, eType=gdal.GDT_Float32)
+        >>> ds.WriteArray(np.random.normal(size=100).reshape(10, 10))
+        0
+        >>> ds.GetRasterBand(1).GetHistogram(min=-3.5, max=3.5, buckets=13, approx_ok=False)
+        [0, 0, 3, 9, 13, 12, 25, 22, 9, 6, 0, 1, 0]  # random
+
+        """
         return _gdal.Band_GetHistogram(self, *args, **kwargs)
 
     def GetDefaultHistogram(self, *args, **kwargs):
-        r"""GetDefaultHistogram(Band self, double * min_ret=None, double * max_ret=None, int * buckets_ret=None, GUIntBig ** ppanHistogram=None, int force=1, GDALProgressFunc callback=0, void * callback_data=None) -> CPLErr"""
+        r"""
+        GetDefaultHistogram(Band self, double * min_ret=None, double * max_ret=None, int * buckets_ret=None, GUIntBig ** ppanHistogram=None, int force=1, GDALProgressFunc callback=0, void * callback_data=None) -> CPLErr
+
+
+        Fetch the default histogram for this band.
+        See :cpp:func:`GDALRasterBand::GetDefaultHistogram`.
+
+        Returns
+        -------
+        list
+            List with the following four elements:
+            - lower bound of histogram
+            - upper bound of histogram
+            - number of buckets in histogram
+            - tuple with counts for each bucket
+
+        """
         return _gdal.Band_GetDefaultHistogram(self, *args, **kwargs)
 
     def SetDefaultHistogram(self, *args):
-        r"""SetDefaultHistogram(Band self, double min, double max, int buckets_in) -> CPLErr"""
+        r"""
+        SetDefaultHistogram(Band self, double min, double max, int buckets_in) -> CPLErr
+
+
+        Set default histogram.
+        See :cpp:func:`GDALRasterBand::SetDefaultHistogram`.
+
+        Parameters
+        ----------
+        min : float
+            minimum value
+        max : float
+            maximum value
+        buckets_in : list
+            list of pixel counts for each bucket
+
+        Returns
+        -------
+        int:
+           :py:const:`CE_None` on success or :py:const:`CE_Failure` on failure.
+
+        See Also
+        --------
+        :py:meth:`SetHistogram`
+
+        """
         return _gdal.Band_SetDefaultHistogram(self, *args)
 
     def HasArbitraryOverviews(self, *args):
-        r"""HasArbitraryOverviews(Band self) -> bool"""
+        r"""
+        HasArbitraryOverviews(Band self) -> bool
+
+
+        Check for arbitrary overviews.
+        See :cpp:func:`GDALRasterBand::HasArbitraryOverviews`.
+
+        Returns
+        -------
+        bool
+
+        """
         return _gdal.Band_HasArbitraryOverviews(self, *args)
 
     def GetCategoryNames(self, *args):
-        r"""GetCategoryNames(Band self) -> char **"""
+        r"""
+        GetCategoryNames(Band self) -> char **
+
+
+        Fetch the list of category names for this raster.
+        See :cpp:func:`GDALRasterBand::GetCategoryNames`.
+
+        Returns
+        -------
+        list
+            A list of category names, or ``None``
+
+        """
         return _gdal.Band_GetCategoryNames(self, *args)
 
     def SetCategoryNames(self, *args):
-        r"""SetCategoryNames(Band self, char ** papszCategoryNames) -> CPLErr"""
+        r"""
+        SetCategoryNames(Band self, char ** papszCategoryNames) -> CPLErr
+
+
+        Set the category names for this band.
+        See :cpp:func:`GDALRasterBand::SetCategoryNames`.
+
+        Parameters
+        ----------
+        papszCategoryNames : list
+
+        Returns
+        -------
+        int:
+           :py:const:`CE_None` on success or :py:const:`CE_Failure` on failure.
+
+        """
         return _gdal.Band_SetCategoryNames(self, *args)
 
     def GetVirtualMem(self, *args, **kwargs):
         r"""GetVirtualMem(Band self, GDALRWFlag eRWFlag, int nXOff, int nYOff, int nXSize, int nYSize, int nBufXSize, int nBufYSize, GDALDataType eBufType, size_t nCacheSize, size_t nPageSizeHint, char ** options=None) -> VirtualMem"""
         return _gdal.Band_GetVirtualMem(self, *args, **kwargs)
 
     def GetVirtualMemAuto(self, *args, **kwargs):
@@ -5213,15 +7738,67 @@
         return _gdal.Band_GetVirtualMemAuto(self, *args, **kwargs)
 
     def GetTiledVirtualMem(self, *args, **kwargs):
         r"""GetTiledVirtualMem(Band self, GDALRWFlag eRWFlag, int nXOff, int nYOff, int nXSize, int nYSize, int nTileXSize, int nTileYSize, GDALDataType eBufType, size_t nCacheSize, char ** options=None) -> VirtualMem"""
         return _gdal.Band_GetTiledVirtualMem(self, *args, **kwargs)
 
     def GetDataCoverageStatus(self, *args):
-        r"""GetDataCoverageStatus(Band self, int nXOff, int nYOff, int nXSize, int nYSize, int nMaskFlagStop=0) -> int"""
+        r"""
+        GetDataCoverageStatus(Band self, int nXOff, int nYOff, int nXSize, int nYSize, int nMaskFlagStop=0) -> int
+
+
+        Determine whether a sub-window of the Band contains only data, only empty blocks, or a mix of both.
+        See :cpp:func:`GDALRasterBand::GetDataCoverageStatus`.
+
+        Parameters
+        ----------
+        nXOff : int
+        nYOff : int
+        nXSize : int
+        nYSize : int
+        nMaskFlagStop : int, default=0
+
+        Returns
+        -------
+        list
+            First value represents a bitwise-or value of the following constants
+            - :py:const:`gdalconst.GDAL_DATA_COVERAGE_STATUS_DATA`
+            - :py:const:`gdalconst.GDAL_DATA_COVERAGE_STATUS_EMPTY`
+            - :py:const:`gdalconst.GDAL_DATA_COVERAGE_STATUS_UNIMPLEMENTED`
+            Second value represents the approximate percentage in [0, 100] of pixels in the window that have valid values
+
+        Examples
+        --------
+        >>> import numpy as np
+        >>> # Create a raster with four blocks
+        >>> ds = gdal.GetDriverByName('GTiff').Create('test.tif', 64, 64, options = {'SPARSE_OK':True, 'TILED':True, 'BLOCKXSIZE':32, 'BLOCKYSIZE':32})
+        >>> band = ds.GetRasterBand(1)
+        >>> # Write some data to upper-left block
+        >>> band.WriteArray(np.array([[1, 2], [3, 4]]))
+        0
+        >>> # Check status of upper-left block
+        >>> flags, pct = band.GetDataCoverageStatus(0, 0, 32, 32)
+        >>> flags == gdal.GDAL_DATA_COVERAGE_STATUS_DATA
+        True
+        >>> pct
+        100.0
+        >>> # Check status of upper-right block
+        >>> flags, pct = band.GetDataCoverageStatus(32, 0, 32, 32)
+        >>> flags == gdal.GDAL_DATA_COVERAGE_STATUS_EMPTY
+        True
+        >>> pct
+        0.0
+        >>> # Check status of window touching all four blocks
+        >>> flags, pct = band.GetDataCoverageStatus(16, 16, 32, 32)
+        >>> flags == gdal.GDAL_DATA_COVERAGE_STATUS_DATA | gdal.GDAL_DATA_COVERAGE_STATUS_EMPTY
+        True
+        >>> pct
+        25.0
+
+        """
         return _gdal.Band_GetDataCoverageStatus(self, *args)
 
     def AdviseRead(self, *args):
         r"""AdviseRead(Band self, int xoff, int yoff, int xsize, int ysize, int * buf_xsize=None, int * buf_ysize=None, GDALDataType * buf_type=None, char ** options=None) -> CPLErr"""
         return _gdal.Band_AdviseRead(self, *args)
 
     def AsMDArray(self, *args):
@@ -5260,14 +7837,18 @@
                                       resample_alg, callback, callback_data,
                                       buf_obj)
 
     def WriteRaster(self, xoff, yoff, xsize, ysize,
                     buf_string,
                     buf_xsize=None, buf_ysize=None, buf_type=None,
                     buf_pixel_space=None, buf_line_space=None ):
+        """
+        Write the contents of a buffer to a dataset.
+
+        """
 
         if buf_xsize is None:
             buf_xsize = xsize
         if buf_ysize is None:
             buf_ysize = ysize
 
     # Redirect to numpy-friendly WriteArray() if buf_string is a numpy array
@@ -5281,35 +7862,168 @@
             buf_type = self.DataType
 
         return _gdal.Band_WriteRaster(self,
                  xoff, yoff, xsize, ysize,
                 buf_string, buf_xsize, buf_ysize, buf_type,
                 buf_pixel_space, buf_line_space )
 
+    def ReadAsMaskedArray(self, xoff=0, yoff=0, win_xsize=None, win_ysize=None,
+                    buf_xsize=None, buf_ysize=None, buf_type=None,
+                    resample_alg=gdalconst.GRIORA_NearestNeighbour,
+                    callback=None,
+                    callback_data=None):
+        """
+        Read a window of this raster band into a NumPy masked array.
+
+        Values of the mask will be ``True`` where pixels are invalid.
+
+        See :py:meth:`ReadAsArray` for a description of arguments.
+
+        """
+        import numpy
+        array = self.ReadAsArray(xoff=xoff, yoff=yoff,
+                                 win_xsize=win_xsize, win_ysize=win_ysize,
+                                 buf_xsize=buf_xsize, buf_ysize=buf_ysize,
+                                 buf_type=buf_type,
+                                 resample_alg=resample_alg,
+                                 callback=callback, callback_data=callback_data)
+
+        if self.GetMaskFlags() != GMF_ALL_VALID:
+            mask = self.GetMaskBand()
+            mask_array = ~mask.ReadAsArray(xoff=xoff,
+                                           yoff=yoff,
+                                           win_xsize=win_xsize,
+                                           win_ysize=win_ysize,
+                                           buf_xsize=buf_xsize,
+                                           buf_ysize=buf_ysize,
+                                           resample_alg=resample_alg).astype(bool)
+        else:
+            mask_array = None
+        return numpy.ma.array(array, mask=mask_array)
+
+
     def ReadAsArray(self, xoff=0, yoff=0, win_xsize=None, win_ysize=None,
                     buf_xsize=None, buf_ysize=None, buf_type=None, buf_obj=None,
                     resample_alg=gdalconst.GRIORA_NearestNeighbour,
                     callback=None,
                     callback_data=None):
-        """ Reading a chunk of a GDAL band into a numpy array. The optional (buf_xsize,buf_ysize,buf_type)
-        parameters should generally not be specified if buf_obj is specified. The array is returned"""
+        """
+        Read a window of this raster band into a NumPy array.
 
+        Parameters
+        ----------
+        xoff : float, default=0
+           The pixel offset to left side of the region of the band to
+           be read. This would be zero to start from the left side.
+        yoff : float, default=0
+           The line offset to top side of the region of the band to
+           be read. This would be zero to start from the top side.
+        win_xsize : float, optional
+             The number of pixels to read in the x direction. By default,
+             equal to the number of columns in the raster.
+        win_ysize : float, optional
+             The number of rows to read in the y direction. By default,
+             equal to the number of bands in the raster.
+        buf_xsize : int, optional
+             The number of columns in the returned array. If not equal
+             to ``win_xsize``, the returned values will be determined
+             by ``resample_alg``.
+        buf_ysize : int, optional
+             The number of rows in the returned array. If not equal
+             to ``win_ysize``, the returned values will be determined
+             by ``resample_alg``.
+        buf_type : int, optional
+             The data type of the returned array
+        buf_obj : np.ndarray, optional
+             Optional buffer into which values will be read. If ``buf_obj``
+             is specified, then ``buf_xsize``/``buf_ysize``/``buf_type``
+             should generally not be specified.
+        resample_alg : int, default = :py:const:`gdal.GRIORA_NearestNeighbour`.
+             Specifies the resampling algorithm to use when the size of
+             the read window and the buffer are not equal.
+        callback : function, optional
+            A progress callback function
+        callback_data: optional
+            Optional data to be passed to callback function
+
+        Returns
+        -------
+        np.ndarray
+
+        Examples
+        --------
+        >>> import numpy as np
+        >>> ds = gdal.GetDriverByName("GTiff").Create("test.tif", 4, 4, eType=gdal.GDT_Float32)
+        >>> ds.WriteArray(np.arange(16).reshape(4, 4))
+        0
+        >>> band = ds.GetRasterBand(1)
+        >>> # Reading an entire band
+        >>> band.ReadAsArray()
+        array([[ 0.,  1.,  2.,  3.],
+               [ 4.,  5.,  6.,  7.],
+               [ 8.,  9., 10., 11.],
+               [12., 13., 14., 15.]], dtype=float32)
+        >>> # Reading a window of a band
+        >>> band.ReadAsArray(xoff=2, yoff=2, win_xsize=2, win_ysize=2)
+        array([[10., 11.],
+               [14., 15.]], dtype=float32)
+        >>> # Reading a band into a new buffer at higher resolution
+        >>> band.ReadAsArray(xoff=0.5, yoff=0.5, win_xsize=2.5, win_ysize=2.5, buf_xsize=5, buf_ysize=5)
+        array([[ 0.,  1.,  1.,  2.,  2.],
+               [ 4.,  5.,  5.,  6.,  6.],
+               [ 4.,  5.,  5.,  6.,  6.],
+               [ 8.,  9.,  9., 10., 10.],
+               [ 8.,  9.,  9., 10., 10.]], dtype=float32)
+        >>> # Reading a band into an existing buffer at lower resolution
+        >>> band.ReadAsArray(buf_xsize=2, buf_ysize=2, buf_type=gdal.GDT_Float64, resample_alg=gdal.GRIORA_Average)
+        array([[ 2.5,  4.5],
+               [10.5, 12.5]])
+        >>> buf = np.zeros((2,2))
+        >>> band.ReadAsArray(buf_obj=buf)
+        array([[ 5.,  7.],
+               [13., 15.]])
+        """
         from osgeo import gdal_array
 
         return gdal_array.BandReadAsArray(self, xoff, yoff,
                                            win_xsize, win_ysize,
                                            buf_xsize, buf_ysize, buf_type, buf_obj,
                                            resample_alg=resample_alg,
                                            callback=callback,
                                            callback_data=callback_data)
 
     def WriteArray(self, array, xoff=0, yoff=0,
                    resample_alg=gdalconst.GRIORA_NearestNeighbour,
                    callback=None,
                    callback_data=None):
+        """
+        Write the contents of a NumPy array to a Band.
+
+        Parameters
+        ----------
+        array : np.ndarray
+            Two-dimensional array containing values to write
+        xoff : int, default=0
+           The pixel offset to left side of the region of the band to
+           be written. This would be zero to start from the left side.
+        yoff : int, default=0
+           The line offset to top side of the region of the band to
+           be written. This would be zero to start from the top side.
+        resample_alg : int, default = :py:const:`gdal.GRIORA_NearestNeighbour`
+           Resampling algorithm. Placeholder argument, not currently supported.
+        callback : function, optional
+            A progress callback function
+        callback_data: optional
+            Optional data to be passed to callback function
+
+        Returns
+        -------
+        int:
+            Error code, or ``gdal.CE_None`` if no error occurred.
+        """
         from osgeo import gdal_array
 
         return gdal_array.BandWriteArray(self, array, xoff, yoff,
                                           resample_alg=resample_alg,
                                           callback=callback,
                                           callback_data=callback_data)
 
@@ -5417,126 +8131,14 @@
 
     def CreateColorRamp(self, *args):
         r"""CreateColorRamp(ColorTable self, int nStartIndex, ColorEntry startcolor, int nEndIndex, ColorEntry endcolor)"""
         return _gdal.ColorTable_CreateColorRamp(self, *args)
 
 # Register ColorTable in _gdal:
 _gdal.ColorTable_swigregister(ColorTable)
-class RasterAttributeTable(object):
-    r"""Proxy of C++ GDALRasterAttributeTableShadow class."""
-
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, *args):
-        r"""__init__(RasterAttributeTable self) -> RasterAttributeTable"""
-        _gdal.RasterAttributeTable_swiginit(self, _gdal.new_RasterAttributeTable(*args))
-    __swig_destroy__ = _gdal.delete_RasterAttributeTable
-
-    def Clone(self, *args):
-        r"""Clone(RasterAttributeTable self) -> RasterAttributeTable"""
-        return _gdal.RasterAttributeTable_Clone(self, *args)
-
-    def GetColumnCount(self, *args):
-        r"""GetColumnCount(RasterAttributeTable self) -> int"""
-        return _gdal.RasterAttributeTable_GetColumnCount(self, *args)
-
-    def GetNameOfCol(self, *args):
-        r"""GetNameOfCol(RasterAttributeTable self, int iCol) -> char const *"""
-        return _gdal.RasterAttributeTable_GetNameOfCol(self, *args)
-
-    def GetUsageOfCol(self, *args):
-        r"""GetUsageOfCol(RasterAttributeTable self, int iCol) -> GDALRATFieldUsage"""
-        return _gdal.RasterAttributeTable_GetUsageOfCol(self, *args)
-
-    def GetTypeOfCol(self, *args):
-        r"""GetTypeOfCol(RasterAttributeTable self, int iCol) -> GDALRATFieldType"""
-        return _gdal.RasterAttributeTable_GetTypeOfCol(self, *args)
-
-    def GetColOfUsage(self, *args):
-        r"""GetColOfUsage(RasterAttributeTable self, GDALRATFieldUsage eUsage) -> int"""
-        return _gdal.RasterAttributeTable_GetColOfUsage(self, *args)
-
-    def GetRowCount(self, *args):
-        r"""GetRowCount(RasterAttributeTable self) -> int"""
-        return _gdal.RasterAttributeTable_GetRowCount(self, *args)
-
-    def GetValueAsString(self, *args):
-        r"""GetValueAsString(RasterAttributeTable self, int iRow, int iCol) -> char const *"""
-        return _gdal.RasterAttributeTable_GetValueAsString(self, *args)
-
-    def GetValueAsInt(self, *args):
-        r"""GetValueAsInt(RasterAttributeTable self, int iRow, int iCol) -> int"""
-        return _gdal.RasterAttributeTable_GetValueAsInt(self, *args)
-
-    def GetValueAsDouble(self, *args):
-        r"""GetValueAsDouble(RasterAttributeTable self, int iRow, int iCol) -> double"""
-        return _gdal.RasterAttributeTable_GetValueAsDouble(self, *args)
-
-    def SetValueAsString(self, *args):
-        r"""SetValueAsString(RasterAttributeTable self, int iRow, int iCol, char const * pszValue)"""
-        return _gdal.RasterAttributeTable_SetValueAsString(self, *args)
-
-    def SetValueAsInt(self, *args):
-        r"""SetValueAsInt(RasterAttributeTable self, int iRow, int iCol, int nValue)"""
-        return _gdal.RasterAttributeTable_SetValueAsInt(self, *args)
-
-    def SetValueAsDouble(self, *args):
-        r"""SetValueAsDouble(RasterAttributeTable self, int iRow, int iCol, double dfValue)"""
-        return _gdal.RasterAttributeTable_SetValueAsDouble(self, *args)
-
-    def SetRowCount(self, *args):
-        r"""SetRowCount(RasterAttributeTable self, int nCount)"""
-        return _gdal.RasterAttributeTable_SetRowCount(self, *args)
-
-    def CreateColumn(self, *args):
-        r"""CreateColumn(RasterAttributeTable self, char const * pszName, GDALRATFieldType eType, GDALRATFieldUsage eUsage) -> int"""
-        return _gdal.RasterAttributeTable_CreateColumn(self, *args)
-
-    def GetLinearBinning(self, *args):
-        r"""GetLinearBinning(RasterAttributeTable self) -> bool"""
-        return _gdal.RasterAttributeTable_GetLinearBinning(self, *args)
-
-    def SetLinearBinning(self, *args):
-        r"""SetLinearBinning(RasterAttributeTable self, double dfRow0Min, double dfBinSize) -> int"""
-        return _gdal.RasterAttributeTable_SetLinearBinning(self, *args)
-
-    def GetRowOfValue(self, *args):
-        r"""GetRowOfValue(RasterAttributeTable self, double dfValue) -> int"""
-        return _gdal.RasterAttributeTable_GetRowOfValue(self, *args)
-
-    def ChangesAreWrittenToFile(self, *args):
-        r"""ChangesAreWrittenToFile(RasterAttributeTable self) -> int"""
-        return _gdal.RasterAttributeTable_ChangesAreWrittenToFile(self, *args)
-
-    def DumpReadable(self, *args):
-        r"""DumpReadable(RasterAttributeTable self)"""
-        return _gdal.RasterAttributeTable_DumpReadable(self, *args)
-
-    def SetTableType(self, *args):
-        r"""SetTableType(RasterAttributeTable self, GDALRATTableType eTableType)"""
-        return _gdal.RasterAttributeTable_SetTableType(self, *args)
-
-    def GetTableType(self, *args):
-        r"""GetTableType(RasterAttributeTable self) -> GDALRATTableType"""
-        return _gdal.RasterAttributeTable_GetTableType(self, *args)
-
-    def WriteArray(self, array, field, start=0):
-        from osgeo import gdal_array
-
-        return gdal_array.RATWriteArray(self, array, field, start)
-
-    def ReadAsArray(self, field, start=0, length=None):
-        from osgeo import gdal_array
-
-        return gdal_array.RATReadArray(self, field, start, length)
-
-
-# Register RasterAttributeTable in _gdal:
-_gdal.RasterAttributeTable_swigregister(RasterAttributeTable)
 class SubdatasetInfo(object):
     r"""Proxy of C++ GDALSubdatasetInfoShadow class."""
 
     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
 
     def __init__(self, *args, **kwargs):
         raise AttributeError("No constructor defined")
@@ -5735,14 +8337,66 @@
 GVOT_MIN_TARGET_HEIGHT_FROM_GROUND = _gdal.GVOT_MIN_TARGET_HEIGHT_FROM_GROUND
 
 
 def ViewshedGenerate(*args, **kwargs):
     r"""ViewshedGenerate(Band srcBand, char const * driverName, char const * targetRasterName, char ** creationOptions, double observerX, double observerY, double observerHeight, double targetHeight, double visibleVal, double invisibleVal, double outOfRangeVal, double noDataVal, double dfCurvCoeff, GDALViewshedMode mode, double maxDistance, GDALProgressFunc callback=0, void * callback_data=None, GDALViewshedOutputType heightMode=GVOT_NORMAL, char ** options=None) -> Dataset"""
     return _gdal.ViewshedGenerate(*args, **kwargs)
 
+def IsLineOfSightVisible(*args, **kwargs):
+    r"""
+    IsLineOfSightVisible(Band band, int xA, int yA, double zA, int xB, int yB, double zB, char ** options=None)
+
+
+    Check Line of Sight between two points.
+    Both input coordinates must be within the raster coordinate bounds.
+
+     See :cpp:func:`GDALIsLineOfSightVisible`.
+
+    .. versionadded:: 3.9
+
+    Parameters
+    ----------
+    band : gdal.RasterBand
+        The band to read the DEM data from. This must NOT be null.
+    xA : int
+        The X location (raster column) of the first point to check on the raster.
+    yA : int
+        The Y location (raster row) of the first point to check on the raster.
+    zA : float
+        The Z location (height) of the first point to check.
+    xB : int
+        The X location (raster column) of the second point to check on the raster.
+    yB : int
+        The Y location (raster row) of the second point to check on the raster.
+    zB : float
+        The Z location (height) of the second point to check.
+    options : dict/list, optional
+        A dict or list of name=value of options for the line of sight algorithm (currently ignored).
+
+    Returns
+    -------
+    collections.namedtuple(is_visible: bool, col_intersection: int, row_intersection: int)
+        is_visible is True if the two points are within Line of Sight.
+        col_intersection is the raster column index where the LOS line intersects with terrain (will be set in the future, currently set to -1).
+        row_intersection is the raster row index where the LOS line intersects with terrain (will be set in the future, currently set to -1).
+
+    """
+    val = _gdal.IsLineOfSightVisible(*args, **kwargs)
+
+    is_visible, col_intersection, row_intersection = val
+    import collections
+    tuple = collections.namedtuple('IsLineOfSightVisibleResult', ['is_visible', 'col_intersection', 'row_intersection'])
+    tuple.is_visible = is_visible
+    tuple.col_intersection = col_intersection
+    tuple.row_intersection = row_intersection
+    val = tuple
+
+
+    return val
+
 def AutoCreateWarpedVRT(*args):
     r"""AutoCreateWarpedVRT(Dataset src_ds, char const * src_wkt=None, char const * dst_wkt=None, GDALResampleAlg eResampleAlg=GRA_NearestNeighbour, double maxerror=0.0) -> Dataset"""
     return _gdal.AutoCreateWarpedVRT(*args)
 
 def CreatePansharpenedVRT(*args):
     r"""CreatePansharpenedVRT(char const * pszXML, Band panchroBand, int nInputSpectralBands) -> Dataset"""
     return _gdal.CreatePansharpenedVRT(*args)
@@ -5899,47 +8553,167 @@
     return _gdal.InvGeoTransform(*args)
 
 def VersionInfo(*args):
     r"""VersionInfo(char const * request="VERSION_NUM") -> char const *"""
     return _gdal.VersionInfo(*args)
 
 def AllRegister(*args):
-    r"""AllRegister()"""
+    r"""
+    AllRegister()
+
+
+    Register all known configured GDAL drivers.
+    Automatically called when the :py:mod:`gdal` module is loaded.
+    Does not need to be called in user code unless a driver was
+    deregistered and needs to be re-registered.
+    See :cpp:func:`GDALAllRegister`.
+
+    See Also
+    --------
+    :py:func:`Driver.Register`
+
+    """
     return _gdal.AllRegister(*args)
 
 def GDALDestroyDriverManager(*args):
     r"""GDALDestroyDriverManager()"""
     return _gdal.GDALDestroyDriverManager(*args)
 
 def GetCacheMax(*args):
-    r"""GetCacheMax() -> GIntBig"""
+    r"""
+    GetCacheMax() -> GIntBig
+
+
+    Get the maximum size of the block cache.
+    See :cpp:func:`GDALGetCacheMax`.
+
+    Returns
+    -------
+    int
+        maximum cache size in bytes
+
+    """
     return _gdal.GetCacheMax(*args)
 
 def GetCacheUsed(*args):
-    r"""GetCacheUsed() -> GIntBig"""
+    r"""
+    GetCacheUsed() -> GIntBig
+
+
+    Get the number of bytes in used by the block cache.
+    See :cpp:func:`GDALGetCacheUsed`.
+
+    Returns
+    -------
+    int
+        cache size in bytes
+
+    """
     return _gdal.GetCacheUsed(*args)
 
 def SetCacheMax(*args):
-    r"""SetCacheMax(GIntBig nBytes)"""
+    r"""
+    SetCacheMax(GIntBig nBytes)
+
+
+    Set the maximum size of the block cache.
+    See :cpp:func:`GDALSetCacheMax`.
+
+    Parameters
+    ----------
+    nBytes: int
+        Cache size in bytes
+
+    See Also
+    --------
+    :config:`GDAL_CACHEMAX`
+
+    """
     return _gdal.SetCacheMax(*args)
 
 def GetDataTypeSize(*args):
-    r"""GetDataTypeSize(GDALDataType eDataType) -> int"""
+    r"""
+    GetDataTypeSize(GDALDataType eDataType) -> int
+
+
+    Return the size of the data type in bits.
+
+    Parameters
+    ----------
+    eDataType : int
+        data type code
+
+    Returns
+    -------
+    int
+
+    Examples
+    --------
+    >>> gdal.GetDataTypeSize(gdal.GDT_Byte)
+    8
+    >>> gdal.GetDataTypeSize(gdal.GDT_Int32)
+    32
+
+    """
     return _gdal.GetDataTypeSize(*args)
 
 def DataTypeIsComplex(*args):
     r"""DataTypeIsComplex(GDALDataType eDataType) -> int"""
     return _gdal.DataTypeIsComplex(*args)
 
 def GetDataTypeName(*args):
-    r"""GetDataTypeName(GDALDataType eDataType) -> char const *"""
+    r"""
+    GetDataTypeName(GDALDataType eDataType) -> char const *
+
+
+    Return the name of the data type.
+
+    Parameters
+    ----------
+    eDataType : int
+        data type code
+
+    Returns
+    -------
+    str
+
+    Examples
+    --------
+    >>> gdal.GetDataTypeName(gdal.GDT_Int16)
+    'Int16'
+    >>> gdal.GetDataTypeName(gdal.GDT_Float64)
+    'Float64'
+
+    """
     return _gdal.GetDataTypeName(*args)
 
 def GetDataTypeByName(*args):
-    r"""GetDataTypeByName(char const * pszDataTypeName) -> GDALDataType"""
+    r"""
+    GetDataTypeByName(char const * pszDataTypeName) -> GDALDataType
+
+
+    Return the data type for a given name.
+
+    Parameters
+    ----------
+    pszDataTypeName : str
+        data type name
+
+    Returns
+    -------
+    int
+        data type code
+
+    Examples
+    --------
+    >>> gdal.GetDataTypeByName('Int16') == gdal.GDT_Int16
+    True
+
+
+    """
     return _gdal.GetDataTypeByName(*args)
 
 def DataTypeUnion(*args):
     r"""DataTypeUnion(GDALDataType a, GDALDataType b) -> GDALDataType"""
     return _gdal.DataTypeUnion(*args)
 
 def GetColorInterpretationName(*args):
@@ -5979,43 +8753,138 @@
     return _gdal.GetJPEG2000StructureAsString(*args)
 
 def HasTriangulation(*args):
     r"""HasTriangulation() -> int"""
     return _gdal.HasTriangulation(*args)
 
 def GetDriverCount(*args):
-    r"""GetDriverCount() -> int"""
+    r"""
+    GetDriverCount() -> int
+
+
+    Return the number of registered drivers.
+    See :cpp:func:`GDALGetDriverCount`.
+
+    Examples
+    --------
+    >>> gdal.GetDriverCount()
+    227
+    >>> gdal.GetDriverByName('ESRI Shapefile').Deregister()
+    >>> gdal.GetDriverCount()
+    226
+
+
+    """
     return _gdal.GetDriverCount(*args)
 
 def GetDriverByName(*args):
     r"""GetDriverByName(char const * name) -> Driver"""
     return _gdal.GetDriverByName(*args)
 
 def GetDriver(*args):
     r"""GetDriver(int i) -> Driver"""
     return _gdal.GetDriver(*args)
 
 def Open(*args):
-    r"""Open(char const * utf8_path, GDALAccess eAccess=GA_ReadOnly) -> Dataset"""
+    r"""
+    Open(char const * utf8_path, GDALAccess eAccess=GA_ReadOnly) -> Dataset
+
+
+    Opens a raster file as a :py:class:`Dataset` using default options.
+    See :cpp:func:`GDALOpen`.
+    For more control over how the file is opened, use :py:func:`OpenEx`.
+
+    Parameters
+    ----------
+    utf8_path : str
+        name of the file to open
+    eAccess : int, default = :py:const:`gdal.GA_ReadOnly`
+
+    Returns
+    -------
+    Dataset, or ``None`` on failure
+
+    See Also
+    --------
+    :py:func:`OpenEx`
+    :py:func:`OpenShared`
+
+
+    """
 
     _WarnIfUserHasNotSpecifiedIfUsingExceptions()
 
 
     return _gdal.Open(*args)
 
 def OpenEx(*args, **kwargs):
-    r"""OpenEx(char const * utf8_path, unsigned int nOpenFlags=0, char ** allowed_drivers=None, char ** open_options=None, char ** sibling_files=None) -> Dataset"""
+    r"""
+    OpenEx(char const * utf8_path, unsigned int nOpenFlags=0, char ** allowed_drivers=None, char ** open_options=None, char ** sibling_files=None) -> Dataset
+
+
+    Open a raster or vector file as a :py:class:`Dataset`.
+    See :cpp:func:`GDALOpenEx`.
+
+    Parameters
+    ----------
+    utf8_path : str
+        name of the file to open
+    flags : int
+            Flags controlling how the Dataset is opened. Multiple ``gdal.OF_XXX`` flags
+            may be combined using the ``|`` operator. See :cpp:func:`GDALOpenEx`.
+    allowed_drivers : list, optional
+            A list of the names of drivers that may attempt to open the dataset.
+    open_options : dict/list, optional
+            A dict or list of name=value driver-specific opening options.
+    sibling_files: list, optional
+            A list of filenames that are auxiliary to the main filename
+
+    Returns
+    -------
+    Dataset, or ``None`` on failure.
+
+    See Also
+    --------
+    :py:func:`Open`
+    :py:func:`OpenShared`
+
+
+    """
 
     _WarnIfUserHasNotSpecifiedIfUsingExceptions()
 
 
     return _gdal.OpenEx(*args, **kwargs)
 
 def OpenShared(*args):
-    r"""OpenShared(char const * utf8_path, GDALAccess eAccess=GA_ReadOnly) -> Dataset"""
+    r"""
+    OpenShared(char const * utf8_path, GDALAccess eAccess=GA_ReadOnly) -> Dataset
+
+
+    Open a raster file as a :py:class:`Dataset`. If the file has already been
+    opened in the current thread, return a reference to the already-opened
+    :py:class:`Dataset`.  See :cpp:func:`GDALOpenShared`.
+
+    Parameters
+    ----------
+    utf8_path : str
+        name of the file to open
+    eAccess : int, default = :py:const:`gdal.GA_ReadOnly`
+
+    Returns
+    -------
+    Dataset, or ``None`` on failure
+
+    See Also
+    --------
+    :py:func:`Open`
+    :py:func:`OpenEx`
+
+
+    """
 
     _WarnIfUserHasNotSpecifiedIfUsingExceptions()
 
 
     return _gdal.OpenShared(*args)
 
 def IdentifyDriver(*args):
@@ -6024,14 +8893,21 @@
 
 def IdentifyDriverEx(*args, **kwargs):
     r"""IdentifyDriverEx(char const * utf8_path, unsigned int nIdentifyFlags=0, char ** allowed_drivers=None, char ** sibling_files=None) -> Driver"""
     return _gdal.IdentifyDriverEx(*args, **kwargs)
 
 def GeneralCmdLineProcessor(*args):
     r"""GeneralCmdLineProcessor(char ** papszArgv, int nOptions=0) -> char **"""
+
+    import os
+    for i in range(len(args[0])):
+        if isinstance(args[0][i], (os.PathLike, int)):
+            args[0][i] = str(args[0][i])
+
+
     return _gdal.GeneralCmdLineProcessor(*args)
 
 __version__ = _gdal.VersionInfo("RELEASE_NAME")
 
 class GDALInfoOptions(object):
     r"""Proxy of C++ GDALInfoOptions class."""
 
@@ -6256,14 +9132,31 @@
 def BuildVRTInternalObjects(*args):
     r"""BuildVRTInternalObjects(char const * dest, int object_list_count, GDALBuildVRTOptions options, GDALProgressFunc callback=0, void * callback_data=None) -> Dataset"""
     return _gdal.BuildVRTInternalObjects(*args)
 
 def BuildVRTInternalNames(*args):
     r"""BuildVRTInternalNames(char const * dest, char ** source_filenames, GDALBuildVRTOptions options, GDALProgressFunc callback=0, void * callback_data=None) -> Dataset"""
     return _gdal.BuildVRTInternalNames(*args)
+class GDALTileIndexOptions(object):
+    r"""Proxy of C++ GDALTileIndexOptions class."""
+
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, *args):
+        r"""__init__(GDALTileIndexOptions self, char ** options) -> GDALTileIndexOptions"""
+        _gdal.GDALTileIndexOptions_swiginit(self, _gdal.new_GDALTileIndexOptions(*args))
+    __swig_destroy__ = _gdal.delete_GDALTileIndexOptions
+
+# Register GDALTileIndexOptions in _gdal:
+_gdal.GDALTileIndexOptions_swigregister(GDALTileIndexOptions)
+
+def TileIndexInternalNames(*args):
+    r"""TileIndexInternalNames(char const * dest, char ** source_filenames, GDALTileIndexOptions options, GDALProgressFunc callback=0, void * callback_data=None) -> Dataset"""
+    return _gdal.TileIndexInternalNames(*args)
 class GDALMultiDimTranslateOptions(object):
     r"""Proxy of C++ GDALMultiDimTranslateOptions class."""
 
     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
     __repr__ = _swig_repr
 
     def __init__(self, *args):
```

### Comparing `GDAL-3.8.5/osgeo/gdal_array.py` & `GDAL-3.9.0/osgeo/gdal_array.py`

 * *Files identical despite different names*

### Comparing `GDAL-3.8.5/osgeo/gdalconst.py` & `GDAL-3.9.0/osgeo/gdalconst.py`

 * *Files identical despite different names*

### Comparing `GDAL-3.8.5/osgeo/gnm.py` & `GDAL-3.9.0/osgeo/gnm.py`

 * *Files identical despite different names*

### Comparing `GDAL-3.8.5/osgeo/ogr.py` & `GDAL-3.9.0/osgeo/ogr.py`

 * *Files 6% similar despite different names*

```diff
@@ -340,14 +340,16 @@
 
 OLCFastSpatialFilter = _ogr.OLCFastSpatialFilter
 
 OLCFastFeatureCount = _ogr.OLCFastFeatureCount
 
 OLCFastGetExtent = _ogr.OLCFastGetExtent
 
+OLCFastGetExtent3D = _ogr.OLCFastGetExtent3D
+
 OLCCreateField = _ogr.OLCCreateField
 
 OLCDeleteField = _ogr.OLCDeleteField
 
 OLCReorderFields = _ogr.OLCReorderFields
 
 OLCAlterFieldDefn = _ogr.OLCAlterFieldDefn
@@ -376,14 +378,16 @@
 
 OLCZGeometries = _ogr.OLCZGeometries
 
 OLCRename = _ogr.OLCRename
 
 OLCFastGetArrowStream = _ogr.OLCFastGetArrowStream
 
+OLCFastWriteArrowBatch = _ogr.OLCFastWriteArrowBatch
+
 ODsCCreateLayer = _ogr.ODsCCreateLayer
 
 ODsCDeleteLayer = _ogr.ODsCDeleteLayer
 
 ODsCCreateGeomFieldAfterCreateLayer = _ogr.ODsCCreateGeomFieldAfterCreateLayer
 
 ODsCCurveGeometries = _ogr.ODsCCurveGeometries
@@ -408,14 +412,18 @@
 
 ODrCCreateDataSource = _ogr.ODrCCreateDataSource
 
 ODrCDeleteDataSource = _ogr.ODrCDeleteDataSource
 
 OLMD_FID64 = _ogr.OLMD_FID64
 
+GEOS_PREC_NO_TOPO = _ogr.GEOS_PREC_NO_TOPO
+
+GEOS_PREC_KEEP_COLLAPSED = _ogr.GEOS_PREC_KEEP_COLLAPSED
+
 OGRERR_NONE = _ogr.OGRERR_NONE
 
 OGRERR_NOT_ENOUGH_DATA = _ogr.OGRERR_NOT_ENOUGH_DATA
 
 OGRERR_NOT_ENOUGH_MEMORY = _ogr.OGRERR_NOT_ENOUGH_MEMORY
 
 OGRERR_UNSUPPORTED_GEOMETRY_TYPE = _ogr.OGRERR_UNSUPPORTED_GEOMETRY_TYPE
@@ -781,15 +789,14 @@
 
         """
         val = _ogr.DataSource_Close(self, *args)
 
         self.thisown = 0
         self.this = None
         self._invalidate_layers()
-        return val
 
 
         return val
 
 
     def GetRefCount(self, *args):
         r"""
@@ -1423,14 +1430,30 @@
 
     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
 
     def __init__(self, *args, **kwargs):
         raise AttributeError("No constructor defined")
     __repr__ = _swig_repr
 
+    def GetDataset(self, *args):
+        r"""
+        GetDataset(Layer self) -> GDALDatasetShadow *
+
+        Return the dataset associated with this layer.
+
+        For more details: :cpp:func:`OGR_L_GetDataset`
+
+        Returns
+        -------
+        Dataset:
+            Dataset or None
+
+        """
+        return _ogr.Layer_GetDataset(self, *args)
+
     def Rename(self, *args):
         r"""Rename(Layer self, char const * new_name) -> OGRErr"""
         return _ogr.Layer_Rename(self, *args)
 
     def GetRefCount(self, *args):
         r"""
         GetRefCount(Layer self) -> int
@@ -1859,14 +1882,18 @@
         maxx: float
         miny: float
         maxy: float
 
         """
         return _ogr.Layer_GetExtent(self, *args, **kwargs)
 
+    def GetExtent3D(self, *args, **kwargs):
+        r"""GetExtent3D(Layer self, int force=1, int can_return_null=0, int geom_field=0)"""
+        return _ogr.Layer_GetExtent3D(self, *args, **kwargs)
+
     def TestCapability(self, *args):
         r"""
         TestCapability(Layer self, char const * cap) -> bool
 
         Test if this layer supported the named capability.
 
         For more details: :cpp:func:`OGR_L_TestCapability`
@@ -2398,14 +2425,18 @@
         Set style table.
 
         For more details: :cpp:func:`OGR_L_SetStyleTable`
 
         """
         return _ogr.Layer_SetStyleTable(self, *args)
 
+    def ExportArrowArrayStreamPyCapsule(self, *args):
+        r"""ExportArrowArrayStreamPyCapsule(Layer self, char ** options=None) -> PyObject *"""
+        return _ogr.Layer_ExportArrowArrayStreamPyCapsule(self, *args)
+
     def GetArrowStream(self, *args):
         r"""GetArrowStream(Layer self, char ** options=None) -> ArrowArrayStream"""
         return _ogr.Layer_GetArrowStream(self, *args)
 
     def IsArrowSchemaSupported(self, *args):
         r"""IsArrowSchemaSupported(Layer self, ArrowSchema schema, char ** options=None)"""
         return _ogr.Layer_IsArrowSchemaSupported(self, *args)
@@ -2414,14 +2445,22 @@
         r"""CreateFieldFromArrowSchema(Layer self, ArrowSchema schema, char ** options=None) -> OGRErr"""
         return _ogr.Layer_CreateFieldFromArrowSchema(self, *args)
 
     def WriteArrowBatch(self, *args):
         r"""WriteArrowBatch(Layer self, ArrowSchema schema, ArrowArray array, char ** options=None) -> OGRErr"""
         return _ogr.Layer_WriteArrowBatch(self, *args)
 
+    def WriteArrowStreamCapsule(self, *args):
+        r"""WriteArrowStreamCapsule(Layer self, PyObject * capsule, int createFieldsFromSchema, char ** options=None) -> OGRErr"""
+        return _ogr.Layer_WriteArrowStreamCapsule(self, *args)
+
+    def WriteArrowSchemaAndArrowArrayCapsule(self, *args):
+        r"""WriteArrowSchemaAndArrowArrayCapsule(Layer self, PyObject * schemaCapsule, PyObject * arrayCapsule, int createFieldsFromSchema, char ** options=None) -> OGRErr"""
+        return _ogr.Layer_WriteArrowSchemaAndArrowArrayCapsule(self, *args)
+
     def GetGeometryTypes(self, *args, **kwargs):
         r"""
         GetGeometryTypes(Layer self, int geom_field=0, int flags=0, GDALProgressFunc callback=0, void * callback_data=None)
 
         Get actual geometry types found in features.
 
         For more details: :cpp:func:`OGR_L_GetGeometryTypes`
@@ -2538,14 +2577,98 @@
         defn = self.GetLayerDefn()
         for n in range(defn.GetFieldCount()):
             output.append(defn.GetFieldDefn(n))
         return output
     schema = property(schema)
 
 
+    def __arrow_c_stream__(self, requested_schema=None):
+        """
+        Export to a C ArrowArrayStream PyCapsule, according to
+        https://arrow.apache.org/docs/format/CDataInterface/PyCapsuleInterface.html
+
+        Also note that only one active stream can be queried at a time for a
+        given layer.
+
+        To specify options how the ArrowStream should be generated, use
+        the GetArrowArrayStreamInterface(self, options) method
+
+        Parameters
+        ----------
+        requested_schema : PyCapsule, default None
+            The schema to which the stream should be casted, passed as a
+            PyCapsule containing a C ArrowSchema representation of the
+            requested schema.
+            Currently, this is not supported and will raise a
+            NotImplementedError if the schema is not None
+
+        Returns
+        -------
+        PyCapsule
+            A capsule containing a C ArrowArrayStream struct.
+        """
+
+        if requested_schema is not None:
+            raise NotImplementedError("requested_schema != None not implemented")
+
+        return self.ExportArrowArrayStreamPyCapsule()
+
+
+    def GetArrowArrayStreamInterface(self, options = []):
+        """
+        Return a proxy object that implements the __arrow_c_stream__() method,
+        but allows the user to pass options.
+
+        Parameters
+        ----------
+        options : List of strings or dict with options such as INCLUDE_FID=NO, MAX_FEATURES_IN_BATCH=<number>, etc.
+
+        Returns
+        -------
+        a proxy object which implements the __arrow_c_stream__() method
+        """
+
+        class ArrowArrayStreamInterface:
+            def __init__(self, lyr, options):
+                self.lyr = lyr
+                self.options = options
+
+            def __arrow_c_stream__(self, requested_schema=None):
+                """
+                Export to a C ArrowArrayStream PyCapsule, according to
+                https://arrow.apache.org/docs/format/CDataInterface/PyCapsuleInterface.html
+
+                Also note that only one active stream can be queried at a time for a
+                given layer.
+
+                To specify options how the ArrowStream should be generated, use
+                the GetArrowArrayStreamInterface(self, options) method
+
+                Parameters
+                ----------
+                requested_schema : PyCapsule, default None
+                    The schema to which the stream should be casted, passed as a
+                    PyCapsule containing a C ArrowSchema representation of the
+                    requested schema.
+                    Currently, this is not supported and will raise a
+                    NotImplementedError if the schema is not None
+
+                Returns
+                -------
+                PyCapsule
+                    A capsule containing a C ArrowArrayStream struct.
+                """
+                if requested_schema is not None:
+                    raise NotImplementedError("requested_schema != None not implemented")
+
+                return self.lyr.ExportArrowArrayStreamPyCapsule(self.options)
+
+        return ArrowArrayStreamInterface(self, options)
+
+
     def GetArrowStreamAsPyArrow(self, options = []):
         """ Return an ArrowStream as PyArrow Schema and Array objects """
 
         import pyarrow as pa
 
         class Stream:
             def __init__(self, stream):
@@ -2686,16 +2809,63 @@
 
         import pyarrow as pa
         schema = ArrowSchema()
         pa_schema._export_to_c(schema._getPtr())
         return self.CreateFieldFromArrowSchema(schema, options)
 
 
+    def WriteArrow(self, obj, requested_schema=None, createFieldsFromSchema=None, options=[]):
+        """Write the content of the passed object, which must implement the
+           __arrow_c_stream__ or __arrow_c_array__ interface, into the layer.
+
+           Parameters
+           ----------
+           obj:
+               Object implementing the __arrow_c_stream__ or __arrow_c_array__ interface
+
+           requested_schema: PyCapsule, object implementing __arrow_c_schema__ or None. Default None
+               The schema to which the stream should be casted, passed as a
+               PyCapsule containing a C ArrowSchema representation of the
+               requested schema, or an object implementing the __arrow_c_schema__ interface.
+
+           createFieldsFromSchema: boolean or None. Default to None
+               Whether OGRLayer::CreateFieldFromArrowSchema() should be called. If None
+               specified, it is called if no fields have been created yet
+
+           options: list of strings
+               Options to pass to OGRLayer::CreateFieldFromArrowSchema() and OGRLayer::WriteArrowBatch()
+
+        """
+
+        if createFieldsFromSchema is None:
+            createFieldsFromSchema = -1
+        elif createFieldsFromSchema is True:
+            createFieldsFromSchema = 1
+        else:
+            createFieldsFromSchema = 0
+
+        if requested_schema is not None and hasattr(requested_schema, "__arrow_c_schema__"):
+            requested_schema = requested_schema.__arrow_c_schema__()
+
+        if hasattr(obj, "__arrow_c_stream__"):
+            stream_capsule = obj.__arrow_c_stream__(requested_schema=requested_schema)
+            return self.WriteArrowStreamCapsule(stream_capsule, createFieldsFromSchema, options)
+
+        if hasattr(obj, "__arrow_c_array__"):
+            schema_capsule, array_capsule = obj.__arrow_c_array__(requested_schema=requested_schema)
+            return self.WriteArrowSchemaAndArrowArrayCapsule(schema_capsule, array_capsule, createFieldsFromSchema, options)
+
+        raise Exception("Passed object does not implement the __arrow_c_stream__ or __arrow_c_array__ interface.")
+
+
     def WritePyArrow(self, pa_batch, options=[]):
-        """Write the content of the passed PyArrow batch (either a pyarrow.Table, a pyarrow.RecordBatch or a pyarrow.StructArray) into the layer."""
+        """Write the content of the passed PyArrow batch (either a pyarrow.Table, a pyarrow.RecordBatch or a pyarrow.StructArray) into the layer.
+
+           See also the WriteArrow() method to be independent of PyArrow
+        """
 
         import pyarrow as pa
 
     # Is it a pyarrow.Table ?
         if hasattr(pa_batch, "to_batches"):
             for batch in pa_batch.to_batches():
                 if self.WritePyArrow(batch, options=options) != OGRERR_NONE:
@@ -2714,85 +2884,115 @@
         return self.WriteArrowBatch(schema, array, options)
 
 
 
 # Register Layer in _ogr:
 _ogr.Layer_swigregister(Layer)
 class Feature(object):
-    r"""Proxy of C++ OGRFeatureShadow class."""
+    r"""
+
+    Python proxy of an :cpp:class:`OGRFeature`.
+
+    """
 
     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
     __repr__ = _swig_repr
     __swig_destroy__ = _ogr.delete_Feature
 
     def __init__(self, *args, **kwargs):
-        r"""__init__(Feature self, FeatureDefn feature_def) -> Feature"""
+        r"""
+        __init__(Feature self, FeatureDefn feature_def) -> Feature
+
+
+        Parameters
+        -----------
+        feature_def:
+            :py:class:`FeatureDefn` to which the feature will adhere.
+
+        """
         _ogr.Feature_swiginit(self, _ogr.new_Feature(*args, **kwargs))
 
     def GetDefnRef(self, *args):
         r"""
         GetDefnRef(Feature self) -> FeatureDefn
 
-        OGRFeatureDefnH OGR_F_GetDefnRef(OGRFeatureH hFeat)
 
-        Fetch feature definition.
+        Fetch the :py:class:`FeatureDefn` associated with this Feature.
 
-        This function is the same as the C++ method OGRFeature::GetDefnRef().
-
-        Parameters
-        -----------
-        hFeat:
-            handle to the feature to get the feature definition from.
+        See :cpp:func:`OGRFeature::GetDefnRef()`.
 
         Returns
         --------
-        OGRFeatureDefnH:
-            a handle to the feature definition object on which feature depends.
+        FeatureDefn
 
         """
         return _ogr.Feature_GetDefnRef(self, *args)
 
     def SetGeometry(self, *args):
         r"""
         SetGeometry(Feature self, Geometry geom) -> OGRErr
 
-        OGRErr OGR_F_SetGeometry(OGRFeatureH hFeat, OGRGeometryH hGeom)
 
         Set feature geometry.
 
-        This function updates the features geometry, and operate exactly as
-        SetGeometryDirectly(), except that this function does not assume
+        This function updates the features geometry, and operates exactly as
+        :py:meth:`SetGeometryDirectly`, except that this function does not assume
         ownership of the passed geometry, but instead makes a copy of it.
 
-        This function is the same as the C++ OGRFeature::SetGeometry().
+        See :cpp:func:`OGRFeature::SetGeometry`.
 
         This method has only an effect on the in-memory feature object. If
         this object comes from a layer and the modifications must be
-        serialized back to the datasource, OGR_L_SetFeature() must be used
-        afterwards. Or if this is a new feature, OGR_L_CreateFeature() must be
+        serialized back to the datasource, :py:meth:`Layer.SetFeature` must be used
+        afterwards. Or if this is a new feature, :py:meth:`Layer.CreateFeature` must be
         used afterwards.
 
         Parameters
         -----------
-        hFeat:
-            handle to the feature on which new geometry is applied to.
-        hGeom:
-            handle to the new geometry to apply to feature.
+        geom : Geometry
+            new geometry to apply to feature.
 
         Returns
         --------
-        OGRErr:
-            OGRERR_NONE if successful, or OGR_UNSUPPORTED_GEOMETRY_TYPE if the
-            geometry type is illegal for the OGRFeatureDefn (checking not yet
-            implemented).
+        int:
+            :py:const:`OGRERR_NONE` if successful, or
+            :py:const:`OGR_UNSUPPORTED_GEOMETRY_TYPE` if the geometry type is illegal for
+            the :py:class:`FeatureDefn` (checking not yet implemented).
 
         """
         return _ogr.Feature_SetGeometry(self, *args)
 
     def SetGeometryDirectly(self, geom):
+        """
+        Set feature geometry.
+
+        This function updates the features geometry, and operates exactly as
+        :py:meth:`SetGeometry`, except that this function assumes ownership of the
+        passed geometry (even in case of failure of that function).
+
+        See :cpp:func:`OGRFeature::SetGeometryDirectly`.
+
+        This method has only an effect on the in-memory feature object. If
+        this object comes from a layer and the modifications must be
+        serialized back to the datasource, :py:meth:`Layer.SetFeature` must be used
+        afterwards. Or if this is a new feature, :py:meth:`Layer.CreateFeature` must be
+        used afterwards.
+
+        Parameters
+        -----------
+        geom : Geometry
+            geometry to apply to feature.
+
+        Returns
+        --------
+        int:
+            :py:const:`OGRERR_NONE` if successful, or
+            :py:const:`OGR_UNSUPPORTED_GEOMETRY_TYPE` if the geometry type is illegal for
+            the :py:class:`FeatureDefn` (checking not yet implemented).
+        """
         ret = _ogr.Feature_SetGeometryDirectly(self, geom)
         if ret == OGRERR_NONE:
             self._add_geom_ref(geom)
         return ret
 
 
 
@@ -2801,17 +3001,17 @@
         GetGeometryRef(Feature self) -> Geometry
 
         Return the feature geometry
 
         The lifetime of the returned geometry is bound to the one of its belonging
         feature.
 
-        For more details: :cpp:func:`OGR_F_GetGeometryRef`
+        See :cpp:func:`OGRFeature::GetGeometryRef`
 
-        The geometry() method is also available as an alias of GetGeometryRef()
+        The :py:func:`Feature.geometry` method is also available as an alias of :py:func:`Feature.GetGeometryRef`.
 
         Returns
         --------
         Geometry:
             the geometry, or None.
 
         """
@@ -2823,908 +3023,830 @@
         return val
 
 
     def SetGeomField(self, *args):
         r"""
         SetGeomField(Feature self, int iField, Geometry geom) -> OGRErr
         SetGeomField(Feature self, char const * field_name, Geometry geom) -> OGRErr
-        OGRErr
-        OGR_F_SetGeomField(OGRFeatureH hFeat, int iField, OGRGeometryH hGeom)
+
 
         Set feature geometry of a specified geometry field.
 
-        This function updates the features geometry, and operate exactly as
-        SetGeometryDirectly(), except that this function does not assume
+        This function updates the features geometry, and operates exactly as
+        :py:meth:`SetGeomFieldDirectly`, except that this function does not assume
         ownership of the passed geometry, but instead makes a copy of it.
 
-        This function is the same as the C++ OGRFeature::SetGeomField().
+        See :cpp:func:`OGRFeature::SetGeomField`.
 
         Parameters
         -----------
-        hFeat:
-            handle to the feature on which new geometry is applied to.
-        iField:
-            geometry field to set.
-        hGeom:
+        fld_index : int / str
+            Geometry field name or 0-based numeric index. For repeated
+            access, use of the numeric index avoids a lookup
+            step.
+        geom : Geometry
             handle to the new geometry to apply to feature.
 
         Returns
         --------
-        OGRErr:
-            OGRERR_NONE if successful, or OGR_UNSUPPORTED_GEOMETRY_TYPE if the
-            geometry type is illegal for the OGRFeatureDefn (checking not yet
-            implemented).
+        int:
+            :py:const:`OGRERR_NONE` if successful, or
+            :py:const:`OGR_UNSUPPORTED_GEOMETRY_TYPE` if the geometry type is illegal for
+            the :py:class:`FeatureDefn` (checking not yet implemented).
 
         """
         return _ogr.Feature_SetGeomField(self, *args)
 
     def SetGeomFieldDirectly(self, field, geom):
+        """
+        Set feature geometry of a specified geometry field.
+
+        This function updates the features geometry, and operates exactly as
+        :py:meth:`SetGeomField`, except that this function assumes ownership of the
+        passed geometry (even in case of failure of that function).
+
+        See :cpp:func:`OGRFeature::SetGeomFieldDirectly`.
+
+        Parameters
+        -----------
+        fld_index : int / str
+            Geometry field name or 0-based numeric index. For repeated
+            access, use of the numeric index avoids a lookup
+            step.
+        geom : Geometry
+            handle to the new geometry to apply to feature.
+
+        Returns
+        --------
+        int:
+            :py:const:`OGRERR_NONE` if successful, or
+            :py:const:`OGR_UNSUPPORTED_GEOMETRY_TYPE` if the geometry type is illegal for
+            the :py:class:`FeatureDefn` (checking not yet implemented).
+        """
         ret = _ogr.Feature_SetGeomFieldDirectly(self, field, geom)
         if ret == OGRERR_NONE:
             self._add_geom_ref(geom)
         return ret
 
 
 
     def GetGeomFieldRef(self, *args):
         r"""
         GetGeomFieldRef(Feature self, int iField) -> Geometry
         GetGeomFieldRef(Feature self, char const * field_name) -> Geometry
-        OGRGeometryH
-        OGR_F_GetGeomFieldRef(OGRFeatureH hFeat, int iField)
 
-        Fetch a handle to feature geometry.
 
-        This function is the same as the C++ method
-        OGRFeature::GetGeomFieldRef().
+        Fetch a feature :py:class:`Geometry`.
+
+        See :cpp:func:`OGRFeature::GetGeomFieldRef`.
 
         Parameters
         -----------
-        hFeat:
-            handle to the feature to get geometry from.
-        iField:
-            geometry field to get.
+        fld_index : int / str
+            Field name or 0-based numeric index. For repeated
+            access, use of the numeric index avoids a lookup
+            step.
+
+        Returns
+        -------
+        Geometry
 
-        a handle to internal feature geometry. This object should not be
-        modified.
 
-        GDAL 1.11 
         """
         val = _ogr.Feature_GetGeomFieldRef(self, *args)
 
         self._add_geom_ref(val)
 
 
         return val
 
 
     def Clone(self, *args):
         r"""
         Clone(Feature self) -> Feature
 
-        OGRFeatureH OGR_F_Clone(OGRFeatureH hFeat)
-
-        Duplicate feature.
-
-        The newly created feature is owned by the caller, and will have its
-        own reference to the OGRFeatureDefn.
-
-        This function is the same as the C++ method OGRFeature::Clone().
-
-        Parameters
-        -----------
-        hFeat:
-            handle to the feature to clone.
+        Duplicate a Feature.
+        See :cpp:func:`OGRFeature::Clone`.
 
         Returns
         --------
-        OGRFeatureH:
-            a handle to the new feature, exactly matching this feature.
+        Feature
 
         """
         return _ogr.Feature_Clone(self, *args)
 
     def Equal(self, *args):
         r"""
         Equal(Feature self, Feature feature) -> bool
-        int OGR_F_Equal(OGRFeatureH hFeat,
-        OGRFeatureH hOtherFeat)
+
 
         Test if two features are the same.
 
-        Two features are considered equal if the share them (handle equality)
-        same OGRFeatureDefn, have the same field values, and the same geometry
-        (as tested by OGR_G_Equal()) as well as the same feature id.
+        Two features are considered equal if they reference the
+        same :py:class:`FeatureDefn`, have the same field values, and the same geometry
+        (as tested by :py:func:`Geometry.Equal`) as well as the same feature id.
 
-        This function is the same as the C++ method OGRFeature::Equal().
+        See :cpp:func:`OGRFeature::Equal`.
 
         Parameters
         -----------
-        hFeat:
-            handle to one of the feature.
-        hOtherFeat:
-            handle to the other feature to test this one against.
+        feature : Feature
+            feature to test this one against
 
         Returns
         --------
-        int:
-            TRUE if they are equal, otherwise FALSE.
+        bool
 
         """
         return _ogr.Feature_Equal(self, *args)
 
     def GetFieldCount(self, *args):
         r"""
         GetFieldCount(Feature self) -> int
 
-        int OGR_F_GetFieldCount(OGRFeatureH hFeat)
 
         Fetch number of fields on this feature This will always be the same as
-        the field count for the OGRFeatureDefn.
+        the field count for the :py:class:`FeatureDefn`.
 
-        This function is the same as the C++ method
-        OGRFeature::GetFieldCount().
-
-        Parameters
-        -----------
-        hFeat:
-            handle to the feature to get the fields count from.
+        See :cpp:func:`OGRFeature::GetFieldCount`.
 
         Returns
         --------
         int:
             count of fields.
 
         """
         return _ogr.Feature_GetFieldCount(self, *args)
 
     def GetFieldDefnRef(self, *args):
         r"""
         GetFieldDefnRef(Feature self, int id) -> FieldDefn
         GetFieldDefnRef(Feature self, char const * field_name) -> FieldDefn
 
-        OGRFieldDefnH OGR_F_GetFieldDefnRef(OGRFeatureH hFeat, int i)
 
         Fetch definition for this field.
 
-        This function is the same as the C++ method
-        OGRFeature::GetFieldDefnRef().
+        See :cpp:func:`OGRFeature::GetFieldDefnRef`.
 
         Parameters
         -----------
-        hFeat:
-            handle to the feature on which the field is found.
-        i:
-            the field to fetch, from 0 to GetFieldCount()-1.
+        fld_index : int / str
+            Field name or 0-based numeric index. For repeated
+            access, use of the numeric index avoids a lookup
+            step.
 
         Returns
         --------
-        OGRFieldDefnH:
-            a handle to the field definition (from the OGRFeatureDefn). This is an
-            internal reference, and should not be deleted or modified.
+        FieldDefn
+            a reference to the field definition. This reference should
+            not be modified.
 
         """
         return _ogr.Feature_GetFieldDefnRef(self, *args)
 
     def GetGeomFieldCount(self, *args):
         r"""
         GetGeomFieldCount(Feature self) -> int
 
-        int OGR_F_GetGeomFieldCount(OGRFeatureH hFeat)
 
         Fetch number of geometry fields on this feature This will always be
-        the same as the geometry field count for the OGRFeatureDefn.
-
-        This function is the same as the C++ method
-        OGRFeature::GetGeomFieldCount().
-
-        .. versionadded:: 1.11
-
-        Parameters
-        -----------
-        hFeat:
-            handle to the feature to get the geometry fields count from.
+        the same as the geometry field count for the :py:class:`FeatureDefn`.
 
+        See :cpp:func:`OGRFeature::GetGeomFieldCount`.
 
         Returns
         --------
         int:
             count of geometry fields.
 
         """
         return _ogr.Feature_GetGeomFieldCount(self, *args)
 
     def GetGeomFieldDefnRef(self, *args):
         r"""
         GetGeomFieldDefnRef(Feature self, int id) -> GeomFieldDefn
         GetGeomFieldDefnRef(Feature self, char const * field_name) -> GeomFieldDefn
 
-        OGRGeomFieldDefnH OGR_F_GetGeomFieldDefnRef(OGRFeatureH hFeat, int i)
 
         Fetch definition for this geometry field.
 
-        This function is the same as the C++ method
-        OGRFeature::GetGeomFieldDefnRef().
-
-        .. versionadded:: 1.11
+        See :cpp:func:`OGRFeature::GetGeomFieldDefnRef`.
 
         Parameters
         -----------
-        hFeat:
-            handle to the feature on which the field is found.
-        i:
-            the field to fetch, from 0 to GetGeomFieldCount()-1.
-
+        fld_index : int / str
+            Field name or 0-based numeric index. For repeated
+            access, use of the numeric index avoids a lookup
+            step.
 
         Returns
         --------
-        OGRGeomFieldDefnH:
-            a handle to the field definition (from the OGRFeatureDefn). This is an
-            internal reference, and should not be deleted or modified.
+        GeomFieldDefn:
+            a reference to the field definition.
+            Should not be deleted or modified.
 
         """
         return _ogr.Feature_GetGeomFieldDefnRef(self, *args)
 
     def GetFieldAsString(self, *args):
         r"""
         GetFieldAsString(Feature self, int id) -> char const
         GetFieldAsString(Feature self, char const * field_name) -> char const *
 
-        const char\* OGR_F_GetFieldAsString(OGRFeatureH hFeat, int iField)
-
-        Fetch field value as a string.
 
-        OFTReal and OFTInteger fields will be translated to string using
+        :py:const:`OFTReal` and :py:const:`OFTInteger` fields will be translated to string using
         sprintf(), but not necessarily using the established formatting rules.
         Other field types, or errors will result in a return value of zero.
 
-        This function is the same as the C++ method
-        OGRFeature::GetFieldAsString().
+        See :cpp:func:`OGRFeature::GetFieldAsString`.
 
         Parameters
         -----------
-        hFeat:
-            handle to the feature that owned the field.
-        iField:
-            the field to fetch, from 0 to GetFieldCount()-1.
+        fld_index : int / str
+            Field name or 0-based numeric index. For repeated
+            access, use of the numeric index avoids a lookup
+            step.
 
         Returns
         --------
         str:
-            the field value. This string is internal, and should not be modified,
-            or freed. Its lifetime may be very brief.
+            the field value.
 
         """
         return _ogr.Feature_GetFieldAsString(self, *args)
 
     def GetFieldAsISO8601DateTime(self, *args):
         r"""
         GetFieldAsISO8601DateTime(Feature self, int id, char ** options=None) -> char const
         GetFieldAsISO8601DateTime(Feature self, char const * field_name, char ** options=None) -> char const *
+
+
+        Fetch :py:const:`OFTDateTime` field value as a ISO8601 representation.
+
+        Return a string like 'YYYY-MM-DDTHH:MM:SS(.sss)?(Z|([+|-]HH:MM))?'
+        Milliseconds are omitted if equal to zero.
+        Other field types, or errors will result in a return of an empty string.
+
+        See :cpp:func:`OGRFeature::GetFieldAsISO8601DateTime`.
+
+        .. versionadded:: 3.7
+
+        Parameters
+        -----------
+        fld_index : int / str
+            Field name or 0-based numeric index. For repeated
+            access, use of the numeric index avoids a lookup
+            step.
+        options : dict / str
+            Not currently used.
+
         """
         return _ogr.Feature_GetFieldAsISO8601DateTime(self, *args)
 
     def GetFieldAsInteger(self, *args):
         r"""
         GetFieldAsInteger(Feature self, int id) -> int
         GetFieldAsInteger(Feature self, char const * field_name) -> int
 
-        int OGR_F_GetFieldAsInteger(OGRFeatureH hFeat, int iField)
 
-        Fetch field value as integer.
+        Fetch field value as a 32-bit integer.
 
-        OFTString features will be translated using atoi(). OFTReal fields
-        will be cast to integer. Other field types, or errors will result in a
-        return value of zero.
+        :py:const:`OFTString` features will be translated using atoi().
+        :py:const:`OFTReal` fields will be cast to integer. Other field types, or
+        errors will result in a return value of zero.
 
-        This function is the same as the C++ method
-        OGRFeature::GetFieldAsInteger().
+        See :cpp:func:`GetFieldAsInteger`.
 
         Parameters
         -----------
-        hFeat:
-            handle to the feature that owned the field.
-        iField:
-            the field to fetch, from 0 to GetFieldCount()-1.
+        fld_index : int / str
+            Field name or 0-based numeric index. For repeated
+            access, use of the numeric index avoids a lookup
+            step.
 
         Returns
         --------
         int:
             the field value.
 
+        Examples
+        --------
+        >>> defn = ogr.FeatureDefn()
+        >>> defn.AddFieldDefn(ogr.FieldDefn('my_int', ogr.OFTInteger64))
+        >>> feature = ogr.Feature(defn)
+        >>> feature['my_int'] = 2**32 + 1
+        >>> feature.GetFieldAsInteger('my_int')
+        Warning 1: Integer overflow occurred when trying to return 64bit integer. Use GetFieldAsInteger64() instead
+        2147483647
+        >>> feature.GetFieldAsInteger64('my_int')
+        4294967297
+        >>> feature.GetField('my_int')
+        4294967297
+
         """
         return _ogr.Feature_GetFieldAsInteger(self, *args)
 
     def GetFieldAsInteger64(self, *args):
         r"""
         GetFieldAsInteger64(Feature self, int id) -> GIntBig
         GetFieldAsInteger64(Feature self, char const * field_name) -> GIntBig
 
-        GIntBig OGR_F_GetFieldAsInteger64(OGRFeatureH hFeat, int iField)
 
         Fetch field value as integer 64 bit.
 
-        OFTInteger are promoted to 64 bit. OFTString features will be
-        translated using CPLAtoGIntBig(). OFTReal fields will be cast to
-        integer. Other field types, or errors will result in a return value of
-        zero.
+        :py:const:`OFTInteger` are promoted to 64 bit. :py:const:`OFTString` features
+        will be translated using :cpp:func:`CPLAtoGIntBig`. :py:const:`OFTReal` fields
+        will be cast to integer. Other field types, or errors will result in a return
+        value of zero.
 
-        This function is the same as the C++ method
-        OGRFeature::GetFieldAsInteger64().
-
-        .. versionadded:: 2.0
+        See :cpp:func:`OGRFeature::GetFieldAsInteger64`.
 
         Parameters
         -----------
-        hFeat:
-            handle to the feature that owned the field.
-        iField:
-            the field to fetch, from 0 to GetFieldCount()-1.
+        fld_index : int / str
+            Field name or 0-based numeric index. For repeated
+            access, use of the numeric index avoids a lookup
+            step.
 
         Returns
         --------
         int:
             the field value.
 
         """
         return _ogr.Feature_GetFieldAsInteger64(self, *args)
 
     def GetFieldAsDouble(self, *args):
         r"""
         GetFieldAsDouble(Feature self, int id) -> double
         GetFieldAsDouble(Feature self, char const * field_name) -> double
 
-        double OGR_F_GetFieldAsDouble(OGRFeatureH hFeat, int iField)
-
         Fetch field value as a double.
 
-        OFTString features will be translated using CPLAtof(). OFTInteger
+        :py:const:`OFTString` features will be translated using :cpp:func:`CPLAtof`. :py:const:`OFTInteger`
         fields will be cast to double. Other field types, or errors will
         result in a return value of zero.
 
-        This function is the same as the C++ method
-        OGRFeature::GetFieldAsDouble().
+        See :cpp:func:`OGRFeature::GetFieldAsDouble`.
 
         Parameters
         -----------
-        hFeat:
-            handle to the feature that owned the field.
-        iField:
-            the field to fetch, from 0 to GetFieldCount()-1.
+        fld_index : int / str
+            Field name or 0-based numeric index. For repeated
+            access, use of the numeric index avoids a lookup
+            step.
 
         Returns
         --------
         float:
             the field value.
 
         """
         return _ogr.Feature_GetFieldAsDouble(self, *args)
 
     def GetFieldAsDateTime(self, *args):
         r"""
         GetFieldAsDateTime(Feature self, int id)
         GetFieldAsDateTime(Feature self, char const * field_name)
-        int
-        OGR_F_GetFieldAsDateTime(OGRFeatureH hFeat, int iField, int \*pnYear,
-        int \*pnMonth, int \*pnDay, int \*pnHour, int \*pnMinute, int \*pnSecond,
-        int \*pnTZFlag)
 
-        Fetch field value as date and time.
 
-        Currently this method only works for OFTDate, OFTTime and OFTDateTime
-        fields.
+        Fetch field value as date and time.
 
-        This function is the same as the C++ method
-        OGRFeature::GetFieldAsDateTime().
+        Currently this method only works for :py:const:`OFTDate`, :py:const:`OFTTime`
+        and :py:const:`OFTDateTime` fields.
 
-        .. note:: Use OGR_F_GetFieldAsDateTimeEx() for second with millisecond accuracy.
+        See :cpp:func:`OGRFeature::GetFieldAsDateTime`.
 
         Parameters
         -----------
-        hFeat:
-            handle to the feature that owned the field.
-        iField:
-            the field to fetch, from 0 to GetFieldCount()-1.
-        pnYear:
-            (including century)
-        pnMonth:
-            (1-12)
-        pnDay:
-            (1-31)
-        pnHour:
-            (0-23)
-        pnMinute:
-            (0-59)
-        pnSecond:
-            (0-59)
-        pnTZFlag:
-            (0=unknown, 1=localtime, 100=GMT, see data model for
-        details)
+        fld_index : int / str
+            Field name or 0-based numeric index. For repeated
+            access, use of the numeric index avoids a lookup
+            step.
 
         Returns
         --------
-        int:
-            TRUE on success or FALSE on failure.
+        list
+            list containing [ year, month, day, hour, minute, second, timezone flag ]
+
+        Examples
+        --------
+        >>> from datetime import datetime
+        >>> from zoneinfo import ZoneInfo
+        >>> defn = ogr.FeatureDefn()
+        >>> defn.AddFieldDefn(ogr.FieldDefn('unknown', ogr.OFTDateTime))
+        >>> defn.AddFieldDefn(ogr.FieldDefn('local', ogr.OFTDateTime))
+        >>> defn.AddFieldDefn(ogr.FieldDefn('utc', ogr.OFTDateTime))
+        >>> feature = ogr.Feature(defn)
+        >>> feature['unknown'] = datetime.now()
+        >>> feature['local'] = datetime.now(ZoneInfo('Canada/Eastern'))
+        >>> feature['utc'] = datetime.now(ZoneInfo('UTC'))
+        >>> feature.GetFieldAsDateTime('unknown')
+        [2024, 3, 15, 20, 34, 52.594173431396484, 0]
+        >>> feature.GetFieldAsDateTime('local')
+        [2024, 3, 15, 20, 34, 52.59502410888672, 84]
+        >>> feature.GetFieldAsDateTime('utc')
+        [2024, 3, 16, 0, 34, 52.59580993652344, 100]
+
+        See Also
+        --------
+        :py:func:`Feature.GetFieldAsISO8601DateTime`
 
         """
         return _ogr.Feature_GetFieldAsDateTime(self, *args)
 
     def GetFieldAsIntegerList(self, *args):
         r"""
         GetFieldAsIntegerList(Feature self, int id)
         GetFieldAsIntegerList(Feature self, char const * field_name)
 
-        const int\* OGR_F_GetFieldAsIntegerList(OGRFeatureH hFeat, int iField, int
-        \*pnCount)
 
         Fetch field value as a list of integers.
 
-        Currently this function only works for OFTIntegerList fields.
+        Currently this function only works for :py:const:`OFTIntegerList` fields.
 
         This function is the same as the C++ method
-        OGRFeature::GetFieldAsIntegerList().
+        :cpp:func:`OGRFeature::GetFieldAsIntegerList`.
 
         Parameters
         -----------
-        hFeat:
-            handle to the feature that owned the field.
-        iField:
-            the field to fetch, from 0 to GetFieldCount()-1.
-        pnCount:
-            an integer to put the list count (number of integers) into.
+        fld_index : int / str
+            Field name or 0-based numeric index. For repeated
+            access, use of the numeric index avoids a lookup
+            step.
 
         Returns
         --------
-        list[int]:
-            the field value. This list is internal, and should not be modified, or
-            freed. Its lifetime may be very brief. If \*pnCount is zero on return
-            the returned pointer may be NULL or non-NULL.
+        list:
+            the field value.
 
         """
         return _ogr.Feature_GetFieldAsIntegerList(self, *args)
 
     def GetFieldAsInteger64List(self, *args):
         r"""
         GetFieldAsInteger64List(Feature self, int id)
-        const GIntBig\*
-        OGR_F_GetFieldAsInteger64List(OGRFeatureH hFeat, int iField, int
-        \*pnCount)
 
         Fetch field value as a list of 64 bit integers.
 
-        Currently this function only works for OFTInteger64List fields.
+        Currently this function only works for :py:const:`OFTInteger64List` fields.
 
-        This function is the same as the C++ method
-        OGRFeature::GetFieldAsInteger64List().
-
-        .. versionadded:: 2.0
+        See :cpp:func:`OGRFeature::GetFieldAsInteger64List`.
 
         Parameters
         -----------
-        hFeat:
-            handle to the feature that owned the field.
-        iField:
-            the field to fetch, from 0 to GetFieldCount()-1.
-        pnCount:
-            an integer to put the list count (number of integers) into.
+        fld_index : int / str
+            Field name or 0-based numeric index. For repeated
+            access, use of the numeric index avoids a lookup
+            step.
 
         Returns
         --------
-        list[int]:
-            the field value. This list is internal, and should not be modified, or
-            freed. Its lifetime may be very brief. If \*pnCount is zero on return
-            the returned pointer may be NULL or non-NULL.
+        list:
+            the field value.
 
         """
         return _ogr.Feature_GetFieldAsInteger64List(self, *args)
 
     def GetFieldAsDoubleList(self, *args):
         r"""
         GetFieldAsDoubleList(Feature self, int id)
         GetFieldAsDoubleList(Feature self, char const * field_name)
-        const double\*
-        OGR_F_GetFieldAsDoubleList(OGRFeatureH hFeat, int iField, int
-        \*pnCount)
+
 
         Fetch field value as a list of doubles.
 
-        Currently this function only works for OFTRealList fields.
+        Currently this function only works for :py:const:`OFTRealList` fields.
 
-        This function is the same as the C++ method
-        OGRFeature::GetFieldAsDoubleList().
+        See :cpp:func:`OGRFeature::GetFieldAsDoubleList`.
 
         Parameters
         -----------
-        hFeat:
-            handle to the feature that owned the field.
-        iField:
-            the field to fetch, from 0 to GetFieldCount()-1.
-        pnCount:
-            an integer to put the list count (number of doubles) into.
+        fld_index : int / str
+            Field name or 0-based numeric index. For repeated
+            access, use of the numeric index avoids a lookup
+            step.
 
         Returns
+        -------
+        list
+
+        Examples
         --------
-        list[float]:
-            the field value. This list is internal, and should not be modified, or
-            freed. Its lifetime may be very brief. If \*pnCount is zero on return
-            the returned pointer may be NULL or non-NULL.
+        >>> defn = ogr.FeatureDefn()
+        >>> defn.AddFieldDefn(ogr.FieldDefn('list', ogr.OFTRealList))
+        >>> feature = ogr.Feature(defn)
+        >>> feature['list'] = [1.1, 2.2, 3.3]
+        >>> feature.GetFieldAsDoubleList('list')
+        [1.1, 2.2, 3.3]
 
         """
         return _ogr.Feature_GetFieldAsDoubleList(self, *args)
 
     def GetFieldAsStringList(self, *args):
         r"""
         GetFieldAsStringList(Feature self, int id) -> char **
-        char\*\*
-        OGR_F_GetFieldAsStringList(OGRFeatureH hFeat, int iField)
 
-        Fetch field value as a list of strings.
 
-        Currently this method only works for OFTStringList fields.
+        Fetch field value as a list of strings.
 
-        The returned list is terminated by a NULL pointer. The number of
-        elements can also be calculated using CSLCount().
+        Currently this method only works for :py:const:`OFTStringList` fields.
 
-        This function is the same as the C++ method
-        OGRFeature::GetFieldAsStringList().
+        See :cpp:func:`OGRFeature::GetFieldAsStringList`.
 
         Parameters
         -----------
-        hFeat:
-            handle to the feature that owned the field.
-        iField:
-            the field to fetch, from 0 to GetFieldCount()-1.
+        fld_index : int / str
+            Field name or 0-based numeric index. For repeated
+            access, use of the numeric index avoids a lookup
+            step.
 
         Returns
         --------
-        list[str]:
-            the field value. This list is internal, and should not be modified, or
-            freed. Its lifetime may be very brief.
+        list:
+            the field value.
 
         """
         return _ogr.Feature_GetFieldAsStringList(self, *args)
 
     def GetFieldAsBinary(self, *args):
         r"""
         GetFieldAsBinary(Feature self, int id) -> OGRErr
         GetFieldAsBinary(Feature self, char const * field_name) -> OGRErr
-        GByte\*
-        OGR_F_GetFieldAsBinary(OGRFeatureH hFeat, int iField, int \*pnBytes)
+
 
         Fetch field value as binary.
 
-        This method only works for OFTBinary and OFTString fields.
+        This method only works for :py:const:`OFTBinary` and :py:const:`OFTString` fields.
 
-        This function is the same as the C++ method
-        OGRFeature::GetFieldAsBinary().
+        See :cpp:func:`OGRFeature::GetFieldAsBinary`.
 
         Parameters
         -----------
-        hFeat:
-            handle to the feature that owned the field.
-        iField:
-            the field to fetch, from 0 to GetFieldCount()-1.
-        pnBytes:
-            location to place count of bytes returned.
-
+        fld_index : int / str
+            Field name or 0-based numeric index. For repeated
+            access, use of the numeric index avoids a lookup
+            step.
 
         Returns
         --------
-        list:
-            the field value. This list is internal, and should not be modified, or
-            freed. Its lifetime may be very brief.
+        bytearray
 
         """
         return _ogr.Feature_GetFieldAsBinary(self, *args)
 
     def IsFieldSet(self, *args):
         r"""
         IsFieldSet(Feature self, int id) -> bool
         IsFieldSet(Feature self, char const * field_name) -> bool
 
-        int OGR_F_IsFieldSet(OGRFeatureH hFeat, int iField)
 
         Test if a field has ever been assigned a value or not.
 
-        This function is the same as the C++ method OGRFeature::IsFieldSet().
+        See :cpp:func:`OGRFeature::IsFieldSet`.
 
         Parameters
         -----------
-        hFeat:
-            handle to the feature on which the field is.
-        iField:
-            the field to test.
+        fld_index : int / str
+            Field name or 0-based numeric index. For repeated
+            access, use of the numeric index avoids a lookup
+            step.
 
         Returns
         --------
-        int:
-            TRUE if the field has been set, otherwise false.
+        bool:
+            ``True`` if the field has been set, otherwise ``False``.
 
         """
         return _ogr.Feature_IsFieldSet(self, *args)
 
     def IsFieldNull(self, *args):
         r"""
         IsFieldNull(Feature self, int id) -> bool
         IsFieldNull(Feature self, char const * field_name) -> bool
 
-        int OGR_F_IsFieldNull(OGRFeatureH hFeat, int iField)
 
         Test if a field is null.
 
-        This function is the same as the C++ method OGRFeature::IsFieldNull().
-
-        .. versionadded:: 2.2
+        See :cpp:func:OGRFeature::`IsFieldNull`.
 
         Parameters
         -----------
-        hFeat:
-            handle to the feature on which the field is.
-        iField:
-            the field to test.
+        fld_index : int / str
+            Field name or 0-based numeric index. For repeated
+            access, use of the numeric index avoids a lookup
+            step.
 
         Returns
         --------
-        int:
-            TRUE if the field is null, otherwise false.
+        bool:
+            ``True`` if the field is null, otherwise ``False``
 
         """
         return _ogr.Feature_IsFieldNull(self, *args)
 
     def IsFieldSetAndNotNull(self, *args):
         r"""
         IsFieldSetAndNotNull(Feature self, int id) -> bool
         IsFieldSetAndNotNull(Feature self, char const * field_name) -> bool
 
-        int OGR_F_IsFieldSetAndNotNull(OGRFeatureH hFeat, int iField)
 
         Test if a field is set and not null.
 
-        This function is the same as the C++ method
-        OGRFeature::IsFieldSetAndNotNull().
-
-        .. versionadded:: 2.2
+        See :cpp:func:`OGRFeature::IsFieldSetAndNotNull`.
 
         Parameters
         -----------
-        hFeat:
-            handle to the feature on which the field is.
-        iField:
-            the field to test.
+        fld_index : int / str
+            Field name or 0-based numeric index. For repeated
+            access, use of the numeric index avoids a lookup
+            step.
 
         Returns
         --------
-        int:
-            TRUE if the field is set and not null, otherwise false.
+        bool:
+            ``True`` if the field is set and not null, otherwise ``False``.
 
         """
         return _ogr.Feature_IsFieldSetAndNotNull(self, *args)
 
     def GetFieldIndex(self, *args):
         r"""
         GetFieldIndex(Feature self, char const * field_name) -> int
 
-        int OGR_F_GetFieldIndex(OGRFeatureH hFeat, const char \*pszName)
 
         Fetch the field index given field name.
 
-        This is a cover for the OGRFeatureDefn::GetFieldIndex() method.
-
-        This function is the same as the C++ method
-        OGRFeature::GetFieldIndex().
+        See :cpp:func:`OGRFeature::GetFieldIndex`.
 
         Parameters
         -----------
-        hFeat:
-            handle to the feature on which the field is found.
-        pszName:
+        field_name:
             the name of the field to search for.
 
         Returns
         --------
         int:
             the field index, or -1 if no matching field is found.
 
         """
         return _ogr.Feature_GetFieldIndex(self, *args)
 
     def GetGeomFieldIndex(self, *args):
         r"""
         GetGeomFieldIndex(Feature self, char const * field_name) -> int
 
-        int OGR_F_GetGeomFieldIndex(OGRFeatureH hFeat, const char \*pszName)
 
         Fetch the geometry field index given geometry field name.
 
-        This is a cover for the OGRFeatureDefn::GetGeomFieldIndex() method.
-
-        This function is the same as the C++ method
-        OGRFeature::GetGeomFieldIndex().
-
-        .. versionadded:: 1.11
+        See :cpp:func:`OGRFeature::GetGeomFieldIndex`.
 
         Parameters
         -----------
-        hFeat:
-            handle to the feature on which the geometry field is found.
-        pszName:
+        field_name:
             the name of the geometry field to search for.
 
-
         Returns
         --------
         int:
             the geometry field index, or -1 if no matching geometry field is found.
 
         """
         return _ogr.Feature_GetGeomFieldIndex(self, *args)
 
     def GetFID(self, *args):
         r"""
         GetFID(Feature self) -> GIntBig
-        GIntBig OGR_F_GetFID(OGRFeatureH
-        hFeat)
 
-        Get feature identifier.
-
-        This function is the same as the C++ method OGRFeature::GetFID().
-        Note: since GDAL 2.0, this method returns a GIntBig (previously a
-        long)
 
-        Parameters
-        -----------
-        hFeat:
-            handle to the feature from which to get the feature
-        identifier.
+        Get feature identifier.
+        See :cpp:func:`OGRFeature::GetFID`
 
         Returns
         -------
         int:
-            feature id or OGRNullFID if none has been assigned.
+            feature id or :py:const:`NullFID` if none has been assigned.
 
         """
         return _ogr.Feature_GetFID(self, *args)
 
     def SetFID(self, *args):
         r"""
         SetFID(Feature self, GIntBig fid) -> OGRErr
-        OGRErr OGR_F_SetFID(OGRFeatureH hFeat,
-        GIntBig nFID)
+
 
         Set the feature identifier.
 
         For specific types of features this operation may fail on illegal
         features ids. Generally it always succeeds. Feature ids should be
-        greater than or equal to zero, with the exception of OGRNullFID (-1)
+        greater than or equal to zero, with the exception of :py:const:NullFID` (-1)
         indicating that the feature id is unknown.
 
-        This function is the same as the C++ method OGRFeature::SetFID().
+        See :cpp:func:`OGRFeature::SetFID`.
 
         Parameters
         -----------
-        hFeat:
-            handle to the feature to set the feature id to.
-        nFID:
+        fid:
             the new feature identifier value to assign.
 
         Returns
         --------
-        OGRErr:
-            On success OGRERR_NONE, or on failure some other value.
+        int:
+            :py:const:`OGRERR_NONE` on success, or some other value on failure.
 
         """
         return _ogr.Feature_SetFID(self, *args)
 
     def DumpReadable(self, *args):
         r"""
         DumpReadable(Feature self)
-        void
-        OGR_F_DumpReadable(OGRFeatureH hFeat, FILE \*fpOut)
 
-        Dump this feature in a human readable form.
 
-        This dumps the attributes, and geometry; however, it doesn't
-        definition information (other than field types and names), nor does it
+        Print this feature in a human readable form.
+
+        This dumps the attributes and geometry. It doesn't include
+        definition information other than field types and names nor does it
         report the geometry spatial reference system.
 
-        This function is the same as the C++ method
-        OGRFeature::DumpReadable().
+        See :cpp:func:`OGRFeature::DumpReadable`.
 
-        Parameters
-        -----------
-        hFeat:
-            handle to the feature to dump.
-        fpOut:
-            the stream to write to, such as strout.
+        Examples
+        --------
+        >>> with gdal.OpenEx('data/poly.shp') as ds:
+        ...     lyr = ds.GetLayer(0)
+        ...     feature = lyr.GetNextFeature()
+        ...     feature.DumpReadable()
+        ...
+        OGRFeature(poly):0
+          AREA (Real) = 215229.266
+          EAS_ID (Integer64) = 168
+          PRFEDEA (String) = 35043411
+          POLYGON ((479819.84375 4765180.5,479690.1875 4765259.5,479647.0 4765369.5,479730.375 4765400.5,480039.03125 4765539.5,480035.34375 4765558.5,480159.78125 4765610.5,480202.28125 4765482.0,480365.0 4765015.5,480389.6875 4764950.0,480133.96875 4764856.5,480080.28125 4764979.5,480082.96875 4765049.5,480088.8125 4765139.5,480059.90625 4765239.5,480019.71875 4765319.5,479980.21875 4765409.5,479909.875 4765370.0,479859.875 4765270.0,479819.84375 4765180.5))
 
         """
         return _ogr.Feature_DumpReadable(self, *args)
 
     def DumpReadableAsString(self, *args):
-        r"""DumpReadableAsString(Feature self, char ** options=None) -> retStringAndCPLFree *"""
+        r"""
+        DumpReadableAsString(Feature self, char ** options=None) -> retStringAndCPLFree *
+
+
+        Return feature information in a human-readable form.
+        Returns the text printed by :py:func:`Feature.DumpReadable`.
+
+        Returns
+        -------
+        str
+
+        """
         return _ogr.Feature_DumpReadableAsString(self, *args)
 
     def UnsetField(self, *args):
         r"""
         UnsetField(Feature self, int id)
         UnsetField(Feature self, char const * field_name)
 
-        void OGR_F_UnsetField(OGRFeatureH hFeat, int iField)
 
         Clear a field, marking it as unset.
 
-        This function is the same as the C++ method OGRFeature::UnsetField().
+        See :cpp:func:`OGRFeature::UnsetField`.
 
         Parameters
         -----------
-        hFeat:
-            handle to the feature on which the field is.
-        iField:
-            the field to unset.
+        fld_index : int / str
+            Field name or 0-based numeric index. For repeated
+            access, use of the numeric index avoids a lookup
+            step.
 
         """
         return _ogr.Feature_UnsetField(self, *args)
 
     def SetFieldNull(self, *args):
         r"""
         SetFieldNull(Feature self, int id)
         SetFieldNull(Feature self, char const * field_name)
 
-        void OGR_F_SetFieldNull(OGRFeatureH hFeat, int iField)
 
         Clear a field, marking it as null.
 
-        This function is the same as the C++ method
-        OGRFeature::SetFieldNull().
-
-        .. versionadded:: 2.2
+        See :cpp:func:`OGRFeature::SetFieldNull`.
 
         Parameters
         -----------
-        hFeat:
-            handle to the feature on which the field is.
-        iField:
-            the field to set to null.
+        fld_index : int / str
+            Field name or 0-based numeric index. For repeated
+            access, use of the numeric index avoids a lookup
+            step.
+
 
         """
         return _ogr.Feature_SetFieldNull(self, *args)
 
     def SetFieldInteger64(self, *args):
-        r"""
-        SetFieldInteger64(Feature self, int id, GIntBig value)
-        void
-        OGR_F_SetFieldInteger64(OGRFeatureH hFeat, int iField, GIntBig nValue)
-
-        Set field to 64 bit integer value.
-
-        OFTInteger, OFTInteger64 and OFTReal fields will be set directly.
-        OFTString fields will be assigned a string representation of the
-        value, but not necessarily taking into account formatting constraints
-        on this field. Other field types may be unaffected.
-
-        This function is the same as the C++ method OGRFeature::SetField().
-
-        This method has only an effect on the in-memory feature object. If
-        this object comes from a layer and the modifications must be
-        serialized back to the datasource, OGR_L_SetFeature() must be used
-        afterwards. Or if this is a new feature, OGR_L_CreateFeature() must be
-        used afterwards.
-
-        .. versionadded:: 2.0
-
-        Parameters
-        -----------
-        hFeat:
-            handle to the feature that owned the field.
-        iField:
-            the field to fetch, from 0 to GetFieldCount()-1.
-        nValue:
-            the value to assign.
-
-        """
+        r"""SetFieldInteger64(Feature self, int id, GIntBig value)"""
         return _ogr.Feature_SetFieldInteger64(self, *args)
 
         # With several override, SWIG cannot dispatch automatically unicode strings
         # to the right implementation, so we have to do it at hand
     def SetField(self, *args) -> "OGRErr":
         """
         SetField(self, fld_index, value: str)
@@ -3765,142 +3887,119 @@
 
 
 
     def SetFieldIntegerList(self, *args):
         r"""
         SetFieldIntegerList(Feature self, int id, int nList)
         void
-        OGR_F_SetFieldIntegerList(OGRFeatureH hFeat, int iField, int nCount,
-        const int \*panValues)
 
-        Set field to list of integers value.
+        Set field to list of integer values.
 
-        This function currently on has an effect of OFTIntegerList,
-        OFTInteger64List and OFTRealList fields.
+        This function currently on has an effect of :py:const:`OFTIntegerList`,
+        :py:const:`OFTInteger64List`, :py:const:`OFTRealList` fields.
 
-        This function is the same as the C++ method OGRFeature::SetField().
+        See :cpp:func:`OGRFeature::SetField`.
 
         This method has only an effect on the in-memory feature object. If
         this object comes from a layer and the modifications must be
-        serialized back to the datasource, OGR_L_SetFeature() must be used
-        afterwards. Or if this is a new feature, OGR_L_CreateFeature() must be
+        serialized back to the datasource, :py:meth:`Layer.SetFeature` must be used
+        afterwards. Or if this is a new feature, :py:meth:`Layer.CreateFeature` must be
         used afterwards.
 
         Parameters
         -----------
-        hFeat:
-            handle to the feature that owned the field.
-        iField:
-            the field to set, from 0 to GetFieldCount()-1.
-        nCount:
-            the number of values in the list being assigned.
-        panValues:
+        id : int
+            the field to set, from 0 to :py:meth:`GetFieldCount`-1.
+        nList : list
             the values to assign.
 
         """
         return _ogr.Feature_SetFieldIntegerList(self, *args)
 
     def SetFieldInteger64List(self, *args):
         r"""
         SetFieldInteger64List(Feature self, int id, int nList)
         void
-        OGR_F_SetFieldInteger64List(OGRFeatureH hFeat, int iField, int nCount,
-        const GIntBig \*panValues)
 
-        Set field to list of 64 bit integers value.
+        Set field to list of 64 bit integer values.
 
-        This function currently on has an effect of OFTIntegerList,
-        OFTInteger64List and OFTRealList fields.
+        This function currently on has an effect of :py:const:`OFTIntegerList`,
+        :py:const:`OFTInteger64List`, :py:const:`OFTRealList` fields.
 
-        This function is the same as the C++ method OGRFeature::SetField().
+        See :cpp:func:`OGRFeature::SetField`.
 
         This method has only an effect on the in-memory feature object. If
         this object comes from a layer and the modifications must be
-        serialized back to the datasource, OGR_L_SetFeature() must be used
-        afterwards. Or if this is a new feature, OGR_L_CreateFeature() must be
+        serialized back to the datasource, :py:meth:`Layer.SetFeature` must be used
+        afterwards. Or if this is a new feature, :py:meth:`Layer.CreateFeature` must be
         used afterwards.
 
-        .. versionadded:: 2.0
-
         Parameters
         -----------
-        hFeat:
-            handle to the feature that owned the field.
-        iField:
-            the field to set, from 0 to GetFieldCount()-1.
-        nCount:
-            the number of values in the list being assigned.
-        panValues:
+        id : int
+            the field to set, from 0 to :py:meth:`GetFieldCount`-1.
+        nList : list
             the values to assign.
 
         """
         return _ogr.Feature_SetFieldInteger64List(self, *args)
 
     def SetFieldDoubleList(self, *args):
         r"""
         SetFieldDoubleList(Feature self, int id, int nList)
-        void
-        OGR_F_SetFieldDoubleList(OGRFeatureH hFeat, int iField, int nCount,
-        const double \*padfValues)
 
-        Set field to list of doubles value.
 
-        This function currently on has an effect of OFTIntegerList,
-        OFTInteger64List, OFTRealList fields.
+        Set field to list of double values.
 
-        This function is the same as the C++ method OGRFeature::SetField().
+        This function currently on has an effect of :py:const:`OFTIntegerList`,
+        :py:const:`OFTInteger64List`, :py:const:`OFTRealList` fields.
+
+        See :cpp:func:`OGRFeature::SetField`.
 
         This method has only an effect on the in-memory feature object. If
         this object comes from a layer and the modifications must be
-        serialized back to the datasource, OGR_L_SetFeature() must be used
-        afterwards. Or if this is a new feature, OGR_L_CreateFeature() must be
+        serialized back to the datasource, :py:meth:`Layer.SetFeature` must be used
+        afterwards. Or if this is a new feature, :py:meth:`Layer.CreateFeature` must be
         used afterwards.
 
         Parameters
         -----------
-        hFeat:
-            handle to the feature that owned the field.
-        iField:
-            the field to set, from 0 to GetFieldCount()-1.
-        nCount:
-            the number of values in the list being assigned.
-        padfValues:
+        id : int
+            the field to set, from 0 to :py:meth:`GetFieldCount`-1.
+        nList : list
             the values to assign.
 
         """
         return _ogr.Feature_SetFieldDoubleList(self, *args)
 
     def SetFieldStringList(self, *args):
         r"""
         SetFieldStringList(Feature self, int id, char ** pList)
-        void
-        OGR_F_SetFieldStringList(OGRFeatureH hFeat, int iField, CSLConstList
-        papszValues)
+
 
         Set field to list of strings value.
 
-        This function currently on has an effect of OFTStringList fields.
+        This function currently only has an effect of :py:const:`OFTStringList` fields.
 
-        This function is the same as the C++ method OGRFeature::SetField().
+        See :cpp:func:`OGRFeature::SetField`.
 
         This method has only an effect on the in-memory feature object. If
         this object comes from a layer and the modifications must be
-        serialized back to the datasource, OGR_L_SetFeature() must be used
-        afterwards. Or if this is a new feature, OGR_L_CreateFeature() must be
+        serialized back to the datasource, :py:meth:`Layer.SetFeature` must be used
+        afterwards. Or if this is a new feature, :py:meth:`Layer.CreateFeature` must be
         used afterwards.
 
         Parameters
         -----------
-        hFeat:
-            handle to the feature that owned the field.
-        iField:
-            the field to set, from 0 to GetFieldCount()-1.
-        papszValues:
-            the values to assign. List of NUL-terminated string,
-        ending with a NULL pointer.
+        fld_index : int / str
+            Field name or 0-based numeric index. For repeated
+            access, use of the numeric index avoids a lookup
+            step.
+        value:
+            the value to assign.
 
         """
         return _ogr.Feature_SetFieldStringList(self, *args)
 
     def _SetFieldBinary(self, *args):
         r"""_SetFieldBinary(Feature self, int id, int nLen)"""
         return _ogr.Feature__SetFieldBinary(self, *args)
@@ -3911,389 +4010,324 @@
         SetFieldBinaryFromHexString(Feature self, char const * field_name, char const * pszValue)
         """
         return _ogr.Feature_SetFieldBinaryFromHexString(self, *args)
 
     def SetFrom(self, *args, **kwargs):
         r"""
         SetFrom(Feature self, Feature other, int forgiving=1) -> OGRErr
-        OGRErr OGR_F_SetFrom(OGRFeatureH
-        hFeat, OGRFeatureH hOtherFeat, int bForgiving)
 
         Set one feature from another.
 
         Overwrite the contents of this feature from the geometry and
-        attributes of another. The hOtherFeature does not need to have the
-        same OGRFeatureDefn. Field values are copied by corresponding field
+        attributes of another. The other feature does not need to have the
+        same :py:class:`FeatureDefn`. Field values are copied by corresponding field
         names. Field types do not have to exactly match. OGR_F_SetField\*()
         function conversion rules will be applied as needed.
 
-        This function is the same as the C++ method OGRFeature::SetFrom().
+        See :cpp:func:`OGRFeature::SetFrom`.
 
         Parameters
         -----------
-        hFeat:
-            handle to the feature to set to.
-        hOtherFeat:
-            handle to the feature from which geometry, and field
-            values will be copied.
-        bForgiving:
-            TRUE if the operation should continue despite lacking
+        other : Feature
+            feature from which geometry and field values will be copied.
+        forgiving : bool, default = True
+            ``True`` if the operation should continue despite lacking
             output fields matching some of the source fields.
 
         Returns
         --------
-        OGRErr:
-            OGRERR_NONE if the operation succeeds, even if some values are not
+        int:
+            :py:const:`OGRERR_NONE` if the operation succeeds, even if some values are not
             transferred, otherwise an error code.
 
         """
         return _ogr.Feature_SetFrom(self, *args, **kwargs)
 
     def SetFromWithMap(self, *args):
         r"""
         SetFromWithMap(Feature self, Feature other, int forgiving, int nList) -> OGRErr
-        OGRErr
-        OGR_F_SetFromWithMap(OGRFeatureH hFeat, OGRFeatureH hOtherFeat, int
-        bForgiving, const int \*panMap)
+
 
         Set one feature from another.
 
         Overwrite the contents of this feature from the geometry and
-        attributes of another. The hOtherFeature does not need to have the
-        same OGRFeatureDefn. Field values are copied according to the provided
+        attributes of another. The other feature does not need to have the
+        same :py:class:`FeatureDefn`. Field values are copied according to the provided
         indices map. Field types do not have to exactly match.
         OGR_F_SetField\*() function conversion rules will be applied as needed.
-        This is more efficient than OGR_F_SetFrom() in that this doesn't
+        This is more efficient than :py:meth:SetFrom` in that this doesn't
         lookup the fields by their names. Particularly useful when the field
         names don't match.
 
-        This function is the same as the C++ method OGRFeature::SetFrom().
+        See :cpp:func:`OGRFeature::SetFrom`.
 
         Parameters
         -----------
-        hFeat:
-            handle to the feature to set to.
-        hOtherFeat:
+        other : Feature
             handle to the feature from which geometry, and field
             values will be copied.
-        panMap:
+        forgiving : bool
+            ``True`` if the operation should continue despite lacking
+            output fields matching some of the source fields.
+        nList : list
             Array of the indices of the destination feature's fields
             stored at the corresponding index of the source feature's fields. A
             value of -1 should be used to ignore the source's field. The array
             should not be NULL and be as long as the number of fields in the
             source feature.
-        bForgiving:
-            TRUE if the operation should continue despite lacking
-            output fields matching some of the source fields.
 
         Returns
         --------
         OGRErr:
-            OGRERR_NONE if the operation succeeds, even if some values are not
+            :py:const:`OGRERR_NONE` if the operation succeeds, even if some values are not
             transferred, otherwise an error code.
 
         """
         return _ogr.Feature_SetFromWithMap(self, *args)
 
     def GetStyleString(self, *args):
         r"""
         GetStyleString(Feature self) -> char const *
-        const char\*
-        OGR_F_GetStyleString(OGRFeatureH hFeat)
+
 
         Fetch style string for this feature.
 
         Set the OGR Feature Style Specification for details on the format of
-        this string, and ogr_featurestyle.h for services available to parse
+        this string, and :source_file:`ogr/ogr_featurestyle.h` for services available to parse
         it.
 
-        This function is the same as the C++ method
-        OGRFeature::GetStyleString().
-
-        Parameters
-        -----------
-        hFeat:
-            handle to the feature to get the style from.
+        See :cpp:func:`OGRFeature::GetStyleString`.
 
         Returns
         --------
-        str:
-            a reference to a representation in string format, or NULL if there
-            isn't one.
+        str or None
 
         """
         return _ogr.Feature_GetStyleString(self, *args)
 
     def SetStyleString(self, *args):
         r"""
         SetStyleString(Feature self, char const * the_string)
-        void
-        OGR_F_SetStyleString(OGRFeatureH hFeat, const char \*pszStyle)
 
-        Set feature style string.
 
-        This method operate exactly as OGR_F_SetStyleStringDirectly() except
-        that it does not assume ownership of the passed string, but instead
-        makes a copy of it.
+        Set feature style string.
 
-        This function is the same as the C++ method
-        OGRFeature::SetStyleString().
+        See :cpp:func:`OGRFeature::SetStyleString`.
 
         Parameters
         -----------
-        hFeat:
-            handle to the feature to set style to.
-        pszStyle:
-            the style string to apply to this feature, cannot be NULL.
+        the_string : str
+            the style string to apply to this feature
 
         """
         return _ogr.Feature_SetStyleString(self, *args)
 
     def GetFieldType(self, *args):
         r"""
         GetFieldType(Feature self, int id) -> OGRFieldType
         GetFieldType(Feature self, char const * field_name) -> OGRFieldType
+
+
+        Return the type of the given field.
+
+        Parameters
+        -----------
+        fld_index : int / str
+            Field name or 0-based numeric index. For repeated
+            access, use of the numeric index avoids a lookup
+            step.
+
+        Returns
+        --------
+        int
+            field type code (e.g., :py:const:`OFTInteger`)
+
         """
         return _ogr.Feature_GetFieldType(self, *args)
 
     def Validate(self, *args):
         r"""
         Validate(Feature self, int flags=OGR_F_VAL_ALL, int bEmitError=TRUE) -> int
-        int OGR_F_Validate(OGRFeatureH
-        hFeat, int nValidateFlags, int bEmitError)
 
-        Validate that a feature meets constraints of its schema.
 
-        The scope of test is specified with the nValidateFlags parameter.
+        Validate that a feature meets constraints of its schema.
 
-        Regarding OGR_F_VAL_WIDTH, the test is done assuming the string width
-        must be interpreted as the number of UTF-8 characters. Some drivers
-        might interpret the width as the number of bytes instead. So this test
-        is rather conservative (if it fails, then it will fail for all
-        interpretations).
+        The scope of test is specified with the ``flags`` parameter.
 
-        This function is the same as the C++ method OGRFeature::Validate().
+        Regarding :py:const:`OGR_F_VAL_WIDTH`, the test is done assuming the string
+        width must be interpreted as the number of UTF-8 characters. Some drivers might
+        interpret the width as the number of bytes instead. So this test is rather
+        conservative (if it fails, then it will fail for all interpretations).
 
-        .. versionadded:: 2.0
+        See :cpp:func:`OGRFeature::Validate`.
 
         Parameters
         -----------
-        hFeat:
-            handle to the feature to validate.
-        nValidateFlags:
-            OGR_F_VAL_ALL or combination of OGR_F_VAL_NULL,
-            OGR_F_VAL_GEOM_TYPE, OGR_F_VAL_WIDTH and
-            OGR_F_VAL_ALLOW_NULL_WHEN_DEFAULT with '|' operator
-        bEmitError:
+        flags : int, default = :py:const:`F_VAL_ALL`
+            One ore more of :py:const:`OGR_F_VAL_NULL`,
+            :py:const:`OGR_F_VAL_GEOM_TYPE`, py:const:`OGR_F_VAL_WIDTH` and
+            :py:const:`OGR_F_VAL_ALLOW_NULL_WHEN_DEFAULT` combined with
+            the with ``|`` operator
+        bEmitError : bool, default = True
             TRUE if a CPLError() must be emitted when a check fails
 
         Returns
         -------
         int:
             TRUE if all enabled validation tests pass.
 
         """
         return _ogr.Feature_Validate(self, *args)
 
     def FillUnsetWithDefault(self, *args):
         r"""
         FillUnsetWithDefault(Feature self, int bNotNullableOnly=FALSE, char ** options=None)
-        void
-        OGR_F_FillUnsetWithDefault(OGRFeatureH hFeat, int bNotNullableOnly,
-        char \*\*papszOptions)
 
-        Fill unset fields with default values that might be defined.
 
-        This function is the same as the C++ method
-        OGRFeature::FillUnsetWithDefault().
+        Fill unset fields with default values that might be defined.
 
-        .. versionadded:: 2.0
+        See :cpp:func:`OGRFeature::FillUnsetWithDefault`.
 
         Parameters
         -----------
-        hFeat:
-            handle to the feature.
-        bNotNullableOnly:
+        bNotNullableOnly : bool
             if we should fill only unset fields with a not-null
             constraint.
-        papszOptions:
-            unused currently. Must be set to NULL.
+        options : dict
+            unused currently.
 
         """
         return _ogr.Feature_FillUnsetWithDefault(self, *args)
 
     def GetNativeData(self, *args):
         r"""
         GetNativeData(Feature self) -> char const *
-        const char\*
-        OGR_F_GetNativeData(OGRFeatureH hFeat)
+
 
         Returns the native data for the feature.
 
         The native data is the representation in a "natural" form that comes
         from the driver that created this feature, or that is aimed at an
         output driver. The native data may be in different format, which is
-        indicated by OGR_F_GetNativeMediaType().
+        indicated by :py:func:`GetNativeMediaType`.
 
         Note that most drivers do not support storing the native data in the
-        feature object, and if they do, generally the NATIVE_DATA open option
+        feature object, and if they do, generally the ``NATIVE_DATA`` open option
         must be passed at dataset opening.
 
         The "native data" does not imply it is something more performant or
         powerful than what can be obtained with the rest of the API, but it
         may be useful in round-tripping scenarios where some characteristics
         of the underlying format are not captured otherwise by the OGR
         abstraction.
 
-        This function is the same as the C++ method
-        OGRFeature::GetNativeData().
-
-        .. note:: See https://trac.osgeo.org/gdal/wiki/rfc60_improved_roundtripping_in_ogr
-
-        .. versionadded:: 2.1
-
-        Parameters
-        -----------
-        hFeat:
-            handle to the feature.
+        See :cpp:func:`OGRFeature::GetNativeData` and :ref:`rfc-60`.
 
         Returns
         -------
         str:
-            a string with the native data, or NULL if there is none.
+            a string with the native data, or ``None``.
 
         """
         return _ogr.Feature_GetNativeData(self, *args)
 
     def GetNativeMediaType(self, *args):
         r"""
         GetNativeMediaType(Feature self) -> char const *
-        const char\*
-        OGR_F_GetNativeMediaType(OGRFeatureH hFeat)
+
 
         Returns the native media type for the feature.
 
         The native media type is the identifier for the format of the native
         data. It follows the IANA RFC 2045
         (seehttps://en.wikipedia.org/wiki/Media_type), e.g.
         "application/vnd.geo+json" for JSon.
 
-        This function is the same as the C function
-        OGR_F_GetNativeMediaType().
-
-        .. note:: See https://trac.osgeo.org/gdal/wiki/rfc60_improved_roundtripping_in_ogr
-
-        .. versionadded:: 2.1
-
-        Parameters
-        -----------
-        hFeat:
-            handle to the feature.
-
+        See :cpp:func:`OGRFeature::GetNativeMediaType` and :ref:`rfc-60`.
 
         Returns
         --------
         str:
-            a string with the native media type, or NULL if there is none.
+            a string with the native media type, or ``None``.
 
         """
         return _ogr.Feature_GetNativeMediaType(self, *args)
 
     def SetNativeData(self, *args):
         r"""
         SetNativeData(Feature self, char const * nativeData)
-        void
-        OGR_F_SetNativeData(OGRFeatureH hFeat, const char \*pszNativeData)
+
 
         Sets the native data for the feature.
 
         The native data is the representation in a "natural" form that comes
         from the driver that created this feature, or that is aimed at an
         output driver. The native data may be in different format, which is
-        indicated by OGR_F_GetNativeMediaType().
+        indicated by :py:meth:`GetNativeMediaType`.
 
-        This function is the same as the C++ method
-        OGRFeature::SetNativeData().
-
-        .. note:: See https://trac.osgeo.org/gdal/wiki/rfc60_improved_roundtripping_in_ogr
-
-        .. versionadded:: 2.1
+        See :cpp:func:`OGRFeature::SetNativeData` and :ref:`rfc-60`.
 
         Parameters
         -----------
-        hFeat:
-            handle to the feature.
-        pszNativeData:
-            a string with the native data, or NULL if there is none.
+        nativeData : str
+            a string with the native data, or ``None``
 
         """
         return _ogr.Feature_SetNativeData(self, *args)
 
     def SetNativeMediaType(self, *args):
         r"""
         SetNativeMediaType(Feature self, char const * nativeMediaType)
-        void
-        OGR_F_SetNativeMediaType(OGRFeatureH hFeat, const char
-        \*pszNativeMediaType)
+
 
         Sets the native media type for the feature.
 
         The native media type is the identifier for the format of the native
         data. It follows the IANA RFC 2045
-        (seehttps://en.wikipedia.org/wiki/Media_type), e.g.
+        (see https://en.wikipedia.org/wiki/Media_type), e.g.
         "application/vnd.geo+json" for JSon.
 
-        This function is the same as the C++ method
-        OGRFeature::SetNativeMediaType().
-
-        .. note:: See https://trac.osgeo.org/gdal/wiki/rfc60_improved_roundtripping_in_ogr
-
-        .. versionadded:: 2.1
-
+        See :cpp:func:`OGRFeature::SetNativeMediaType` and :ref:`rfc-60`.
 
         Parameters
         -----------
-        hFeat:
-            handle to the feature.
-        pszNativeMediaType:
-            a string with the native media type, or NULL if there is none.
+        nativeMediaType : str
+            a string with the native media type, or ``None``
 
         """
         return _ogr.Feature_SetNativeMediaType(self, *args)
 
     def SetFieldString(self, *args):
         r"""
         SetFieldString(Feature self, int id, char const * value)
-        void
-        OGR_F_SetFieldString(OGRFeatureH hFeat, int iField, const char
-        \*pszValue)
+
 
         Set field to string value.
 
-        OFTInteger fields will be set based on an atoi() conversion of the
-        string. OFTInteger64 fields will be set based on an CPLAtoGIntBig()
-        conversion of the string. OFTReal fields will be set based on an
-        CPLAtof() conversion of the string. Other field types may be
+        :py:const:`OFTInteger` fields will be set based on an atoi() conversion of the
+        string. :py:const:`OFTInteger64` fields will be set based on an :cpp:func:`CPLAtoGIntBig`
+        conversion of the string. :py:const:`OFTReal` fields will be set based on an
+        :cpp:func:`CPLAtof` conversion of the string. Other field types may be
         unaffected.
 
-        This function is the same as the C++ method OGRFeature::SetField().
+        See :cpp:func:`OGRFeature::SetField`.
 
         This method has only an effect on the in-memory feature object. If
         this object comes from a layer and the modifications must be
-        serialized back to the datasource, OGR_L_SetFeature() must be used
-        afterwards. Or if this is a new feature, OGR_L_CreateFeature() must be
+        serialized back to the datasource, :py:meth:`Layer.SetFeature` must be used
+        afterwards. Or if this is a new feature, :py:meth:`Layer.CreateFeature` must be
         used afterwards.
 
         Parameters
         -----------
-        hFeat:
-            handle to the feature that owned the field.
-        iField:
-            the field to fetch, from 0 to GetFieldCount()-1.
-        pszValue:
+        fld_index : int / str
+            Field name or 0-based numeric index. For repeated
+            access, use of the numeric index avoids a lookup
+            step.
+        value:
             the value to assign.
 
         """
         return _ogr.Feature_SetFieldString(self, *args)
 
     def Reference(self):
       pass
@@ -4395,14 +4429,44 @@
                 raise KeyError("Illegal field requested in SetField()")
             else:
                 return self.SetGeomField(fld_index, value)
         else:
             return self._SetField2(fld_index, value)
 
     def GetField(self, fld_index):
+        """
+        Get the value of a field in its native type.
+
+        Alternatively, the ``[]`` operator may be used.
+
+        Parameters
+        ----------
+        fld_index : int / str
+            Field name or 0-based numeric index. For repeated
+            access, use of the numeric index avoids a lookup
+            step.
+
+        Examples
+        --------
+        >>> with gdal.OpenEx("data/poly.shp") as ds:
+        ...     lyr = ds.GetLayer(0)
+        ...     feature = lyr.GetNextFeature()
+        ...     # name-based access
+        ...     feature.GetField("EAS_ID")
+        ...     feature["EAS_ID"]
+        ...     # index-based access
+        ...     index = feature.GetFieldIndex("EAS_ID")
+        ...     feature.GetField(index)
+        ...     feature[index]
+        ...
+        168
+        168
+        168
+        168
+        """
         if isinstance(fld_index, str):
             fld_index = self._getfieldindex(fld_index)
         if (fld_index < 0) or (fld_index > self.GetFieldCount()):
             raise KeyError("Illegal field requested in GetField()")
         if not (self.IsFieldSet(fld_index)) or self.IsFieldNull(fld_index):
             return None
         fld_type = self.GetFieldType(fld_index)
@@ -4435,16 +4499,16 @@
             return self.GetFieldAsBinary(fld_index)
 
     def SetFieldBinary(self, field_index_or_name, value):
         """
         SetFieldBinary(Feature self, field_index_or_name: int | str, value: bytes)
 
         Set field to binary data.
-        This function currently only has an effect on OFTBinary fields.
-        This function is the same as the C++ method OGRFeature::SetField().
+        This function currently only has an effect on :py:const:`OFTBinary` fields.
+        This function is the same as the C++ method :cpp:func:`OGRFeature::SetField`.
 
         Parameters
         -----------
         field_index_or_name:
             the field to set, from 0 to GetFieldCount()-1. Or the field name
         values:
             the data to apply.
@@ -4530,19 +4594,28 @@
         self._invalidate_geom_refs()
 
     def __repr__(self):
         return self.DumpReadableAsString()
 
 
     def ExportToJson(self, as_object=False, options=None):
-        """Exports a GeoJSON object which represents the Feature. The
-           as_object parameter determines whether the returned value
-           should be a Python object instead of a string. Defaults to False.
-           The options parameter is passed to Geometry.ExportToJson()"""
+        """
+        Export a GeoJSON object which represents the Feature.
 
+        Parameters
+        ----------
+        as_object : bool, default = False
+            determines whether the returned value should be a Python object instead of a string.
+        options : dict/str
+            Options to pass to :py:func:`Geometry.ExportToJson`
+
+        Returns
+        -------
+        str / dict
+        """
         try:
             import simplejson
         except ImportError:
             try:
                 import json as simplejson
             except ImportError:
                 raise ImportError("Unable to import simplejson or json, needed for ExportToJson.")
@@ -4596,882 +4669,748 @@
                 geom.this = None
 
 
 
 # Register Feature in _ogr:
 _ogr.Feature_swigregister(Feature)
 class FeatureDefn(object):
-    r"""Proxy of C++ OGRFeatureDefnShadow class."""
+    r"""
+
+
+    Python proxy of an :cpp:class:`OGRFeatureDefn`.
+
+
+    """
 
     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
     __repr__ = _swig_repr
     __swig_destroy__ = _ogr.delete_FeatureDefn
 
     def __init__(self, *args, **kwargs):
-        r"""__init__(FeatureDefn self, char const * name_null_ok=None) -> FeatureDefn"""
+        r"""
+        __init__(FeatureDefn self, char const * name_null_ok=None) -> FeatureDefn
+
+
+        Create a new feature definition object to hold the field definitions.
+
+        Parameters
+        ----------
+        name_null_ok : str, optional
+            Name for the :py:class:`FeatureDefn`.
+
+        """
         _ogr.FeatureDefn_swiginit(self, _ogr.new_FeatureDefn(*args, **kwargs))
 
     def GetName(self, *args):
         r"""
         GetName(FeatureDefn self) -> char const *
-        const char\*
-        OGR_FD_GetName(OGRFeatureDefnH hDefn)
 
-        Get name of the OGRFeatureDefn passed as an argument.
 
-        This function is the same as the C++ method OGRFeatureDefn::GetName().
+        Get name of the :py:class:`FeatureDefn`.
 
-        Parameters
-        -----------
-        hDefn:
-            handle to the feature definition to get the name from.
+        See :cpp:func:`OGRFeatureDefn::GetName`.
 
         Returns
         --------
         str:
-            the name. This name is internal and should not be modified, or freed.
+            the name
 
         """
         return _ogr.FeatureDefn_GetName(self, *args)
 
     def GetFieldCount(self, *args):
         r"""
         GetFieldCount(FeatureDefn self) -> int
-        int
-        OGR_FD_GetFieldCount(OGRFeatureDefnH hDefn)
+
 
         Fetch number of fields on the passed feature definition.
 
-        This function is the same as the C++ OGRFeatureDefn::GetFieldCount().
-
-        Parameters
-        -----------
-        hDefn:
-            handle to the feature definition to get the fields count from.
+        See :cpp:func:`OGRFeatureDefn::GetFieldCount`.
 
         Returns
         --------
         int:
             count of fields.
 
         """
         return _ogr.FeatureDefn_GetFieldCount(self, *args)
 
     def GetFieldDefn(self, *args):
         r"""
         GetFieldDefn(FeatureDefn self, int i) -> FieldDefn
-        OGRFieldDefnH
-        OGR_FD_GetFieldDefn(OGRFeatureDefnH hDefn, int iField)
+
 
         Fetch field definition of the passed feature definition.
 
-        This function is the same as the C++ method
-        OGRFeatureDefn::GetFieldDefn().
+        See :cpp:func:`OGRFeatureDefn::GetFieldDefn`.
 
         Parameters
         -----------
-        hDefn:
-            handle to the feature definition to get the field definition from.
-        iField:
-            the field to fetch, between 0 and GetFieldCount()-1.
+        i : int / str
+            Field name or 0-based numeric index. For repeated
+            access, use of the numeric index avoids a lookup
+            step.
 
         Returns
         --------
-        OGRFieldDefnH:
-            a handle to an internal field definition object or NULL if invalid
-            index. This object should not be modified or freed by the application.
+        FieldDefn:
+            internal field definition object or ``None`` if the field does not
+            exist. This object should not be modified by the application.
 
         """
+
+        if type(args[0]) is str:
+            args = (self.GetFieldIndex(args[0]), )
+
+
         return _ogr.FeatureDefn_GetFieldDefn(self, *args)
 
+
     def GetFieldIndex(self, *args):
         r"""
         GetFieldIndex(FeatureDefn self, char const * field_name) -> int
-        int
-        OGR_FD_GetFieldIndex(OGRFeatureDefnH hDefn, const char \*pszFieldName)
+
 
         Find field by name.
 
         The field index of the first field matching the passed field name
         (case insensitively) is returned.
 
-        This function is the same as the C++ method
-        OGRFeatureDefn::GetFieldIndex.
+        See :cpp:func:`OGRFeatureDefn::GetFieldIndex`.
 
         Parameters
         -----------
-        hDefn:
-            handle to the feature definition to get field index from.
-        pszFieldName:
+        field_name : str
             the field name to search for.
 
         Returns
         --------
         int:
             the field index, or -1 if no match found.
 
         """
         return _ogr.FeatureDefn_GetFieldIndex(self, *args)
 
     def AddFieldDefn(self, *args):
         r"""
         AddFieldDefn(FeatureDefn self, FieldDefn defn)
-        void
-        OGR_FD_AddFieldDefn(OGRFeatureDefnH hDefn, OGRFieldDefnH hNewField)
 
-        Add a new field definition to the passed feature definition.
+
+        Add a new field definition.
 
         To add a new field definition to a layer definition, do not use this
-        function directly, but use OGR_L_CreateField() instead.
+        function directly, but use :py:meth:`Layer.CreateField` instead.
 
-        This function should only be called while there are no OGRFeature
-        objects in existence based on this OGRFeatureDefn. The OGRFieldDefn
-        passed in is copied, and remains the responsibility of the caller.
+        This function should only be called while there are no :py:class:`Feature`
+        objects in existence based on this :py:class:`FeatureDefn`. The
+        :py:class:`FieldDefn` passed in is copied.
 
-        This function is the same as the C++ method
-        OGRFeatureDefn::AddFieldDefn().
+        See :cpp:func:`OGRFeatureDefn::AddFieldDefn`.
 
         Parameters
         -----------
-        hDefn:
-            handle to the feature definition to add the field definition to.
-        hNewField:
-            handle to the new field definition.
+        defn : FieldDefn
+            the new field definition.
 
         """
         return _ogr.FeatureDefn_AddFieldDefn(self, *args)
 
     def GetGeomFieldCount(self, *args):
         r"""
         GetGeomFieldCount(FeatureDefn self) -> int
-        int
-        OGR_FD_GetGeomFieldCount(OGRFeatureDefnH hDefn)
-
-        Fetch number of geometry fields on the passed feature definition.
 
-        This function is the same as the C++
-        OGRFeatureDefn::GetGeomFieldCount().
 
-        .. versionadded:: 1.11
+        Fetch number of geometry fields on the passed feature definition.
 
-        Parameters
-        -----------
-        hDefn:
-            handle to the feature definition to get the fields count from.
+        See :cpp:func:`OGRFeatureDefn::GetGeomFieldCount`.
 
         Returns
         --------
         int:
             count of geometry fields.
 
         """
         return _ogr.FeatureDefn_GetGeomFieldCount(self, *args)
 
     def GetGeomFieldDefn(self, *args):
         r"""
         GetGeomFieldDefn(FeatureDefn self, int i) -> GeomFieldDefn
-        OGRGeomFieldDefnH
-        OGR_FD_GetGeomFieldDefn(OGRFeatureDefnH hDefn, int iGeomField)
 
-        Fetch geometry field definition of the passed feature definition.
 
-        This function is the same as the C++ method
-        OGRFeatureDefn::GetGeomFieldDefn().
+        Fetch geometry field definition of the passed feature definition.
 
-        .. versionadded:: 1.11
+        See :cpp:func:`OGRFeatureDefn::GetGeomFieldDefn`.
 
         Parameters
         -----------
-        hDefn:
-            handle to the feature definition to get the field definition from.
-        iGeomField:
+        i : int
             the geometry field to fetch, between 0 and GetGeomFieldCount() - 1.
 
         Returns
         --------
-        OGRGeomFieldDefnH:
-            a handle to an internal field definition object or NULL if invalid
-            index. This object should not be modified or freed by the application.
+        GeomFieldDefn:
+            an internal field definition object or ``None`` if invalid
+            index. This object should not be modified by the application.
 
         """
         return _ogr.FeatureDefn_GetGeomFieldDefn(self, *args)
 
     def GetGeomFieldIndex(self, *args):
         r"""
         GetGeomFieldIndex(FeatureDefn self, char const * field_name) -> int
-        int
-        OGR_FD_GetGeomFieldIndex(OGRFeatureDefnH hDefn, const char
-        \*pszGeomFieldName)
+
 
         Find geometry field by name.
 
         The geometry field index of the first geometry field matching the
         passed field name (case insensitively) is returned.
 
-        This function is the same as the C++ method
-        OGRFeatureDefn::GetGeomFieldIndex.
+        See :cpp:func:`OGRFeatureDefn::GetGeomFieldIndex`.
 
         Parameters
         -----------
-        hDefn:
-            handle to the feature definition to get field index from.
-        pszGeomFieldName:
+        field_name : str
             the geometry field name to search for.
 
         Returns
         --------
         int:
             the geometry field index, or -1 if no match found.
 
         """
         return _ogr.FeatureDefn_GetGeomFieldIndex(self, *args)
 
     def AddGeomFieldDefn(self, *args):
         r"""
         AddGeomFieldDefn(FeatureDefn self, GeomFieldDefn defn)
-        void
-        OGR_FD_AddGeomFieldDefn(OGRFeatureDefnH hDefn, OGRGeomFieldDefnH
-        hNewGeomField)
 
-        Add a new field definition to the passed feature definition.
 
-        To add a new field definition to a layer definition, do not use this
-        function directly, but use OGR_L_CreateGeomField() instead.
+        Add a new geometry field definition.
 
-        This function should only be called while there are no OGRFeature
-        objects in existence based on this OGRFeatureDefn. The
-        OGRGeomFieldDefn passed in is copied, and remains the responsibility
-        of the caller.
+        To add a new field definition to a layer definition, do not use this
+        function directly, but use :py:meth:`Layer.CreateGeomField` instead.
 
-        This function is the same as the C++ method
-        OGRFeatureDefn::AddGeomFieldDefn().
+        This function should only be called while there are no :py:class:`Feature`
+        objects in existence based on this :py:class:`FeatureDefn`. The
+        :py:class:`GeomFieldDefn` passed in is copied.
 
-        .. versionadded:: 1.11
+        See :cpp:Func:`OGRFeatureDefn::AddGeomFieldDefn`.
 
         Parameters
         -----------
-        hDefn:
-            handle to the feature definition to add the geometry field
-            definition to.
-        hNewGeomField:
-            handle to the new field definition.
+        defn : GeomFieldDefn
+            new geometry field definition.
 
         """
         return _ogr.FeatureDefn_AddGeomFieldDefn(self, *args)
 
     def DeleteGeomFieldDefn(self, *args):
         r"""
         DeleteGeomFieldDefn(FeatureDefn self, int idx) -> OGRErr
-        OGRErr
-        OGR_FD_DeleteGeomFieldDefn(OGRFeatureDefnH hDefn, int iGeomField)
+
 
         Delete an existing geometry field definition.
 
         To delete an existing geometry field definition from a layer
         definition, do not use this function directly, but use
-        OGR_L_DeleteGeomField() instead ( not implemented yet).
-
-        This method should only be called while there are no OGRFeature
-        objects in existence based on this OGRFeatureDefn.
+        :py:meth:`Layer.DeleteGeomField` instead ( not implemented yet).
 
-        This method is the same as the C++ method
-        OGRFeatureDefn::DeleteGeomFieldDefn().
+        This function should only be called while there are no :py:class:`Feature`
+        objects in existence based on this :py:class:`FeatureDefn`.
 
-        .. versionadded:: 1.11
+        See :cpp:func:`OGRFeatureDefn::DeleteGeomFieldDefn`.
 
         Parameters
         -----------
-        hDefn:
-            handle to the feature definition.
-        iGeomField:
+        idx : int
             the index of the geometry field definition.
 
         Returns
         --------
-        OGRErr:
-            OGRERR_NONE in case of success.
+        int:
+            :py:const:`OGRERR_NONE` in case of success.
 
         """
         return _ogr.FeatureDefn_DeleteGeomFieldDefn(self, *args)
 
     def GetGeomType(self, *args):
         r"""
         GetGeomType(FeatureDefn self) -> OGRwkbGeometryType
-        OGRwkbGeometryType
-        OGR_FD_GetGeomType(OGRFeatureDefnH hDefn)
 
-        Fetch the geometry base type of the passed feature definition.
 
-        This function is the same as the C++ method
-        OGRFeatureDefn::GetGeomType().
+        Fetch the geometry base type of the passed feature definition.
 
-        Starting with GDAL 1.11, this method returns
-        GetGeomFieldDefn(0)->GetType().
+        This is equivalent to ``GetGeomFieldDefn(0).GetType()``.
 
-        Parameters
-        -----------
-        hDefn:
-            handle to the feature definition to get the geometry type from.
+        See :cpp:func:`OGRFeatureDefn::GetGeomType`.
 
         Returns
         --------
-        OGRwkbGeometryType:
+        int :
             the base type for all geometry related to this definition.
 
         """
         return _ogr.FeatureDefn_GetGeomType(self, *args)
 
     def SetGeomType(self, *args):
         r"""
         SetGeomType(FeatureDefn self, OGRwkbGeometryType geom_type)
-        void
-        OGR_FD_SetGeomType(OGRFeatureDefnH hDefn, OGRwkbGeometryType eType)
+
 
         Assign the base geometry type for the passed layer (the same as the
         feature definition).
 
+        This is equivalent to ``GetGeomFieldDefn(0).SetType()``.
+
         All geometry objects using this type must be of the defined type or a
-        derived type. The default upon creation is wkbUnknown which allows for
+        derived type. The default upon creation is :py:const:`wkbUnknown` which allows for
         any geometry type. The geometry type should generally not be changed
-        after any OGRFeatures have been created against this definition.
-
-        This function is the same as the C++ method
-        OGRFeatureDefn::SetGeomType().
+        after any :py:class:`Feature` objects have been created against this definition.
 
-        Starting with GDAL 1.11, this method calls
-        GetGeomFieldDefn(0)->SetType().
+        See :cpp:func:`OGRFeatureDefn::SetGeomType`.
 
         Parameters
         -----------
-        hDefn:
-            handle to the layer or feature definition to set the geometry type to.
-        eType:
+        geom_type : int
             the new type to assign.
 
         """
         return _ogr.FeatureDefn_SetGeomType(self, *args)
 
     def GetReferenceCount(self, *args):
         r"""
         GetReferenceCount(FeatureDefn self) -> int
-        int
-        OGR_FD_GetReferenceCount(OGRFeatureDefnH hDefn)
 
-        Fetch current reference count.
 
-        This function is the same as the C++ method
-        OGRFeatureDefn::GetReferenceCount().
+        Fetch current reference count.
 
-        Parameters
-        -----------
-        hDefn:
-            handle to the feature definition on witch OGRFeature are based on.
+        See :cpp:func:`OGRFeatureDefn::GetReferenceCount`.
 
         Returns
         --------
         int:
             the current reference count.
 
         """
         return _ogr.FeatureDefn_GetReferenceCount(self, *args)
 
     def IsGeometryIgnored(self, *args):
         r"""
         IsGeometryIgnored(FeatureDefn self) -> int
-        int
-        OGR_FD_IsGeometryIgnored(OGRFeatureDefnH hDefn)
 
-        Determine whether the geometry can be omitted when fetching features.
 
-        This function is the same as the C++ method
-        OGRFeatureDefn::IsGeometryIgnored().
+        Determine whether the geometry can be omitted when fetching features.
 
-        Starting with GDAL 1.11, this method returns
-        GetGeomFieldDefn(0)->IsIgnored().
+        Equivalent to ``GetGeomFieldDefn(0).IsIgnored()``.
 
-        Parameters
-        -----------
-        hDefn:
-            handle to the feature definition on witch OGRFeature are based on.
+        See :cpp:func:`OGRFeatureDefn::IsGeometryIgnored`.
 
         Returns
         --------
         int:
             ignore state
 
         """
         return _ogr.FeatureDefn_IsGeometryIgnored(self, *args)
 
     def SetGeometryIgnored(self, *args):
         r"""
         SetGeometryIgnored(FeatureDefn self, int bIgnored)
-        void
-        OGR_FD_SetGeometryIgnored(OGRFeatureDefnH hDefn, int bIgnore)
+
 
         Set whether the geometry can be omitted when fetching features.
 
-        This function is the same as the C++ method
-        OGRFeatureDefn::SetGeometryIgnored().
+        This is equivalent to ``GetGeomFieldDefn(0).SetIgnored()``.
 
-        Starting with GDAL 1.11, this method calls
-        GetGeomFieldDefn(0)->SetIgnored().
+        See :cpp:func:`OGRFeatureDefn::SetGeometryIgnored`.
 
         Parameters
         -----------
-        hDefn:
-            handle to the feature definition on witch OGRFeature are based on.
-        bIgnore:
+        bignored : bool
             ignore state
 
         """
         return _ogr.FeatureDefn_SetGeometryIgnored(self, *args)
 
     def IsStyleIgnored(self, *args):
         r"""
         IsStyleIgnored(FeatureDefn self) -> int
-        int
-        OGR_FD_IsStyleIgnored(OGRFeatureDefnH hDefn)
+
 
         Determine whether the style can be omitted when fetching features.
 
-        This function is the same as the C++ method
-        OGRFeatureDefn::IsStyleIgnored().
-
-        Parameters
-        -----------
-        hDefn:
-            handle to the feature definition on which OGRFeature are based on.
+        See :cpp:func:`OGRFeatureDefn::IsStyleIgnored`.
 
         Returns
         --------
         int:
             ignore state
 
         """
         return _ogr.FeatureDefn_IsStyleIgnored(self, *args)
 
     def SetStyleIgnored(self, *args):
         r"""
         SetStyleIgnored(FeatureDefn self, int bIgnored)
-        void
-        OGR_FD_SetStyleIgnored(OGRFeatureDefnH hDefn, int bIgnore)
+
 
         Set whether the style can be omitted when fetching features.
 
-        This function is the same as the C++ method
-        OGRFeatureDefn::SetStyleIgnored().
+        See :cpp:func:`OGRFeatureDefn::SetStyleIgnored`.
 
         Parameters
         -----------
-        hDefn:
-            handle to the feature definition on witch OGRFeature are based on.
-        bIgnore:
+        bignored : bool
             ignore state
 
         """
         return _ogr.FeatureDefn_SetStyleIgnored(self, *args)
 
     def IsSame(self, *args):
         r"""
         IsSame(FeatureDefn self, FeatureDefn other_defn) -> int
-        int OGR_FD_IsSame(OGRFeatureDefnH
-        hFDefn, OGRFeatureDefnH hOtherFDefn)
 
-        Test if the feature definition is identical to the other one.
 
-        .. versionadded:: 1.11
+        Test if the feature definition is identical to the other one.
 
         Parameters
         -----------
-        hFDefn:
-            handle to the feature definition on witch OGRFeature are based on.
-        hOtherFDefn:
-            handle to the other feature definition to compare to.
+        other_defn : FeatureDefn
+            other feature definition to compare to.
 
         Returns
         --------
         int:
-            TRUE if the feature definition is identical to the other one.
+            1 if the feature definition is identical to the other one.
 
         """
         return _ogr.FeatureDefn_IsSame(self, *args)
 
     def Destroy(self):
       "Once called, self has effectively been destroyed.  Do not access. For backwards compatibility only"
       _ogr.delete_FeatureDefn(self)
       self.thisown = 0
 
 
 
 # Register FeatureDefn in _ogr:
 _ogr.FeatureDefn_swigregister(FeatureDefn)
 class FieldDefn(object):
-    r"""Proxy of C++ OGRFieldDefnShadow class."""
+    r"""
+
+    Python proxy of an :cpp:class:`OGRFieldDefn`.
+
+    """
 
     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
     __repr__ = _swig_repr
     __swig_destroy__ = _ogr.delete_FieldDefn
 
     def __init__(self, *args, **kwargs):
-        r"""__init__(FieldDefn self, char const * name_null_ok="unnamed", OGRFieldType field_type=OFTString) -> FieldDefn"""
+        r"""
+        __init__(FieldDefn self, char const * name_null_ok="unnamed", OGRFieldType field_type=OFTString) -> FieldDefn
+
+        Python proxy of an :cpp:class:`OGRFieldDefn`.
+
+        """
         _ogr.FieldDefn_swiginit(self, _ogr.new_FieldDefn(*args, **kwargs))
 
     def GetName(self, *args):
         r"""GetName(FieldDefn self) -> char const *"""
         return _ogr.FieldDefn_GetName(self, *args)
 
     def GetNameRef(self, *args):
         r"""
         GetNameRef(FieldDefn self) -> char const *
-        const char\*
-        OGR_Fld_GetNameRef(OGRFieldDefnH hDefn)
 
-        Fetch name of this field.
 
-        This function is the same as the CPP method
-        OGRFieldDefn::GetNameRef().
+        Fetch name of this field.
 
-        Parameters
-        -----------
-        hDefn:
-            handle to the field definition.
+        See :cpp:func:`OGRFieldDefn::GetNameRef`.
 
         Returns
         --------
         str:
             the name of the field definition.
 
         """
         return _ogr.FieldDefn_GetNameRef(self, *args)
 
     def SetName(self, *args):
         r"""
         SetName(FieldDefn self, char const * name)
-        void OGR_Fld_SetName(OGRFieldDefnH
-        hDefn, const char \*pszName)
+
 
         Reset the name of this field.
 
-        This function is the same as the CPP method OGRFieldDefn::SetName().
+        See :cpp:func:`OGRFieldDefn::SetName`.
 
         Parameters
         -----------
-        hDefn:
-            handle to the field definition to apply the new name to.
-        pszName:
-            the new name to apply.
+        name : str
+            the new name to apply
 
         """
         return _ogr.FieldDefn_SetName(self, *args)
 
     def GetAlternativeName(self, *args):
         r"""GetAlternativeName(FieldDefn self) -> char const *"""
         return _ogr.FieldDefn_GetAlternativeName(self, *args)
 
     def GetAlternativeNameRef(self, *args):
         r"""
         GetAlternativeNameRef(FieldDefn self) -> char const *
-        const char\*
-        OGR_Fld_GetAlternativeNameRef(OGRFieldDefnH hDefn)
+
 
         Fetch the alternative name (or "alias") for this field.
 
         The alternative name is an optional attribute for a field which can
         provide a more user-friendly, descriptive name of a field which is not
         subject to the usual naming constraints defined by the data provider.
 
         This is a metadata style attribute only: the alternative name cannot
         be used in place of the actual field name during SQL queries or other
         field name dependent API calls.
 
-        This function is the same as the CPP method
-        OGRFieldDefn::GetAlternativeNameRef().
+        See :cpp:func:`OGRFieldDefn::GetAlternativeNameRef`.
 
         .. versionadded:: 3.2
 
-        Parameters
-        -----------
-        hDefn:
-            handle to the field definition.
-
         Returns
         --------
         str:
             the alternative name of the field definition.
 
         """
         return _ogr.FieldDefn_GetAlternativeNameRef(self, *args)
 
     def SetAlternativeName(self, *args):
         r"""
         SetAlternativeName(FieldDefn self, char const * alternativeName)
-        void
-        OGR_Fld_SetAlternativeName(OGRFieldDefnH hDefn, const char
-        \*pszAlternativeName)
+
 
         Reset the alternative name (or "alias") for this field.
 
         The alternative name is an optional attribute for a field which can
         provide a more user-friendly, descriptive name of a field which is not
         subject to the usual naming constraints defined by the data provider.
 
         This is a metadata style attribute only: the alternative name cannot
         be used in place of the actual field name during SQL queries or other
         field name dependent API calls.
 
-        This function is the same as the CPP method
-        OGRFieldDefn::SetAlternativeName().
+        See :cpp:func:`OGRFieldDefn::SetAlternativeName`.
 
         .. versionadded:: 3.2
 
         Parameters
         -----------
-        hDefn:
-            handle to the field definition to apply the new alternative name to.
-        pszAlternativeName:
+        alternativeName : str
             the new alternative name to apply.
 
         """
         return _ogr.FieldDefn_SetAlternativeName(self, *args)
 
     def GetType(self, *args):
         r"""
         GetType(FieldDefn self) -> OGRFieldType
-        OGRFieldType
-        OGR_Fld_GetType(OGRFieldDefnH hDefn)
 
-        Fetch type of this field.
 
-        This function is the same as the CPP method OGRFieldDefn::GetType().
+        Fetch type of this field.
 
-        Parameters
-        -----------
-        hDefn:
-            handle to the field definition to get type from.
+        See :cpp:func:`OGRFieldDefn::GetType`.
 
         Returns
         --------
-        OGRFieldType:
-            field type.
+        int
+            field type code, e.g. :py:const:`OFTInteger`
 
         """
         return _ogr.FieldDefn_GetType(self, *args)
 
     def SetType(self, *args):
         r"""
         SetType(FieldDefn self, OGRFieldType type)
-        void OGR_Fld_SetType(OGRFieldDefnH
-        hDefn, OGRFieldType eType)
+
 
         Set the type of this field.
 
-        This should never be done to an OGRFieldDefn that is already part of
-        an OGRFeatureDefn.
+        This should never be done to a :py:class:`FieldDefn` that is already part of
+        an :py:class:`FeatureDefn`.
 
-        This function is the same as the CPP method OGRFieldDefn::SetType().
+        See :cpp:func:`OGRFieldDefn::SetType`.
 
         Parameters
         -----------
-        hDefn:
-            handle to the field definition to set type to.
-        eType:
+        type : int
             the new field type.
 
+        Examples
+        --------
+        >>> f = ogr.FieldDefn()
+        >>> f.SetType(ogr.OFTReal)
+
         """
         return _ogr.FieldDefn_SetType(self, *args)
 
     def GetSubType(self, *args):
         r"""
         GetSubType(FieldDefn self) -> OGRFieldSubType
-        OGRFieldSubType
-        OGR_Fld_GetSubType(OGRFieldDefnH hDefn)
 
-        Fetch subtype of this field.
 
-        This function is the same as the CPP method
-        OGRFieldDefn::GetSubType().
+        Fetch subtype of this field.
 
-        .. versionadded:: 2.0
-
-        Parameters
-        -----------
-        hDefn:
-            handle to the field definition to get subtype from.
+        See :cpp:func:`OGRFieldDefn::GetSubType`.
 
         Returns
         --------
-        OGRFieldSubType:
-            field subtype.
+        int
+            field subtype code, default = :py:const:`OFSTNone`
 
         """
         return _ogr.FieldDefn_GetSubType(self, *args)
 
     def SetSubType(self, *args):
         r"""
         SetSubType(FieldDefn self, OGRFieldSubType type)
-        void
-        OGR_Fld_SetSubType(OGRFieldDefnH hDefn, OGRFieldSubType eSubType)
 
-        Set the subtype of this field.
 
-        This should never be done to an OGRFieldDefn that is already part of
-        an OGRFeatureDefn.
+        Set the subtype of this field.
 
-        This function is the same as the CPP method
-        OGRFieldDefn::SetSubType().
+        This should never be done to a :py:class:`FieldDefn` that is already part of
+        an :py:class:FeatureDefn`.
 
-        .. versionadded:: 2.0
+        See :cpp:func:`OGRFieldDefn::SetSubType`.
 
         Parameters
         -----------
-        hDefn:
-            handle to the field definition to set type to.
-        eSubType:
+        type :
             the new field subtype.
 
+        Examples
+        --------
+        >>> f = ogr.FieldDefn()
+        >>> f.SetType(ogr.OFTReal)
+        >>> f.SetSubType(ogr.OFSTJSON)
+        Warning 1: Type and subtype of field definition are not compatible. Resetting to OFSTNone
+        >>> f.SetSubType(ogr.OFSTFloat32)
+
         """
         return _ogr.FieldDefn_SetSubType(self, *args)
 
     def GetJustify(self, *args):
         r"""
         GetJustify(FieldDefn self) -> OGRJustification
-        OGRJustification
-        OGR_Fld_GetJustify(OGRFieldDefnH hDefn)
+
 
         Get the justification for this field.
 
-        This function is the same as the CPP method
-        OGRFieldDefn::GetJustify().
+        See :cpp:func:`OGRFieldDefn::GetJustify`.
 
         Note: no driver is know to use the concept of field justification.
 
-        Parameters
-        -----------
-        hDefn:
-            handle to the field definition to get justification from.
-
         Returns
         --------
         OGRJustification:
             the justification.
 
         """
         return _ogr.FieldDefn_GetJustify(self, *args)
 
     def SetJustify(self, *args):
         r"""
         SetJustify(FieldDefn self, OGRJustification justify)
-        void
-        OGR_Fld_SetJustify(OGRFieldDefnH hDefn, OGRJustification eJustify)
+
 
         Set the justification for this field.
 
         Note: no driver is know to use the concept of field justification.
 
-        This function is the same as the CPP method
-        OGRFieldDefn::SetJustify().
+        See :cpp:func:`OGRFieldDefn::SetJustify`.
 
         Parameters
         -----------
-        hDefn:
-            handle to the field definition to set justification to.
-        eJustify:
-            the new justification.
+        justify : int
+            the new justification
+
+        Examples
+        --------
+        >>> f = ogr.FieldDefn('desc', ogr.OFTString)
+        >>> f.SetJustify(ogr.OJRight)
 
         """
         return _ogr.FieldDefn_SetJustify(self, *args)
 
     def GetWidth(self, *args):
         r"""
         GetWidth(FieldDefn self) -> int
-        int OGR_Fld_GetWidth(OGRFieldDefnH
-        hDefn)
 
-        Get the formatting width for this field.
-
-        This function is the same as the CPP method OGRFieldDefn::GetWidth().
 
-        Parameters
-        -----------
-        hDefn:
-            handle to the field definition to get width from.
+        Get the formatting width for this field.
 
+        See :cpp:func:`OGRFieldDefn::GetWidth`.
 
         Returns
         --------
         int:
             the width, zero means no specified width.
 
         """
         return _ogr.FieldDefn_GetWidth(self, *args)
 
     def SetWidth(self, *args):
         r"""
         SetWidth(FieldDefn self, int width)
-        void OGR_Fld_SetWidth(OGRFieldDefnH
-        hDefn, int nNewWidth)
+
 
         Set the formatting width for this field in characters.
 
-        This function is the same as the CPP method OGRFieldDefn::SetWidth().
+        See :cpp:func:`OGRFieldDefn::SetWidth`.
 
         Parameters
         -----------
-        hDefn:
-            handle to the field definition to set width to.
-        nNewWidth:
-            the new width.
+        width : int
+            the new width
 
         """
         return _ogr.FieldDefn_SetWidth(self, *args)
 
     def GetPrecision(self, *args):
         r"""
         GetPrecision(FieldDefn self) -> int
-        int
-        OGR_Fld_GetPrecision(OGRFieldDefnH hDefn)
 
-        Get the formatting precision for this field.
 
-        This should normally be zero for fields of types other than OFTReal.
+        Get the formatting precision for this field.
 
-        This function is the same as the CPP method
-        OGRFieldDefn::GetPrecision().
+        This should normally be zero for fields of types other than :py:const:`OFTReal`.
 
-        Parameters
-        -----------
-        hDefn:
-            handle to the field definition to get precision from.
+        See :cpp:func:`OGRFieldDefn::GetPrecision`.
 
         Returns
         --------
         int:
             the precision.
 
         """
         return _ogr.FieldDefn_GetPrecision(self, *args)
 
     def SetPrecision(self, *args):
         r"""
         SetPrecision(FieldDefn self, int precision)
-        void
-        OGR_Fld_SetPrecision(OGRFieldDefnH hDefn, int nPrecision)
+
 
         Set the formatting precision for this field in characters.
 
-        This should normally be zero for fields of types other than OFTReal.
+        This should normally be zero for fields of types other than :py:const:`OFTReal`.
 
-        This function is the same as the CPP method
-        OGRFieldDefn::SetPrecision().
+        See :cpp:func:`OGRFieldDefn::SetPrecision`.
 
         Parameters
         -----------
-        hDefn:
-            handle to the field definition to set precision to.
-        nPrecision:
+        precision : int
             the new precision.
 
         """
         return _ogr.FieldDefn_SetPrecision(self, *args)
 
     def GetTZFlag(self, *args):
         r"""GetTZFlag(FieldDefn self) -> int"""
@@ -5488,203 +5427,165 @@
     def GetFieldTypeName(self, *args):
         r"""GetFieldTypeName(FieldDefn self, OGRFieldType type) -> char const *"""
         return _ogr.FieldDefn_GetFieldTypeName(self, *args)
 
     def IsIgnored(self, *args):
         r"""
         IsIgnored(FieldDefn self) -> int
-        int OGR_Fld_IsIgnored(OGRFieldDefnH
-        hDefn)
 
-        Return whether this field should be omitted when fetching features.
 
-        This method is the same as the C++ method OGRFieldDefn::IsIgnored().
+        Return whether this field should be omitted when fetching features.
 
-        Parameters
-        -----------
-        hDefn:
-            handle to the field definition
+        See :cpp:func:`OGRFieldDefn::IsIgnored`.
 
         Returns
         --------
         int:
             ignore state
 
         """
         return _ogr.FieldDefn_IsIgnored(self, *args)
 
     def SetIgnored(self, *args):
         r"""
         SetIgnored(FieldDefn self, int bIgnored)
-        void
-        OGR_Fld_SetIgnored(OGRFieldDefnH hDefn, int ignore)
+
 
         Set whether this field should be omitted when fetching features.
 
-        This method is the same as the C++ method OGRFieldDefn::SetIgnored().
+        See :cpp:func:`OGRFieldDefn::SetIgnored`.
 
         Parameters
         -----------
-        hDefn:
-            handle to the field definition
-        ignore:
+        bignored : bool
             ignore state
 
         """
         return _ogr.FieldDefn_SetIgnored(self, *args)
 
     def IsNullable(self, *args):
         r"""
         IsNullable(FieldDefn self) -> int
-        int
-        OGR_Fld_IsNullable(OGRFieldDefnH hDefn)
+
 
         Return whether this field can receive null values.
 
         By default, fields are nullable.
 
         Even if this method returns FALSE (i.e not-nullable field), it doesn't
-        mean that OGRFeature::IsFieldSet() will necessary return TRUE, as
+        mean that :py:meth:`Feature.IsFieldSet` will necessary return TRUE, as
         fields can be temporary unset and null/not-null validation is usually
-        done when OGRLayer::CreateFeature()/SetFeature() is called.
-
-        This method is the same as the C++ method OGRFieldDefn::IsNullable().
-
-        .. versionadded:: 2.0
-
-        Parameters
-        -----------
-        hDefn:
-            handle to the field definition
+        done when :py:meth:`Layer.CreateFeature`/:py:meth:`Layer.SetFeature` is called.
 
+        See :cpp:func:`OGRFieldDefn::IsNullable`.
 
         Returns
         --------
         int:
             TRUE if the field is authorized to be null.
 
         """
         return _ogr.FieldDefn_IsNullable(self, *args)
 
     def SetNullable(self, *args):
         r"""
         SetNullable(FieldDefn self, int bNullable)
-        void
-        OGR_Fld_SetNullable(OGRFieldDefnH hDefn, int bNullableIn)
+
 
         Set whether this field can receive null values.
 
         By default, fields are nullable, so this method is generally called
-        with FALSE to set a not-null constraint.
+        with ``False`` to set a not-null constraint.
 
         Drivers that support writing not-null constraint will advertise the
-        GDAL_DCAP_NOTNULL_FIELDS driver metadata item.
+        ``GDAL_DCAP_NOTNULL_FIELDS`` driver metadata item.
 
-        This method is the same as the C++ method OGRFieldDefn::SetNullable().
-
-        .. versionadded:: 2.0
+        See :cpp:func:`OGRFieldDefn::SetNullable`.
 
         Parameters
         -----------
-        hDefn:
-            handle to the field definition
-        bNullableIn:
-            FALSE if the field must have a not-null constraint.
+        bNullable : bool
+            ``False`` if the field must have a not-null constraint.
 
         """
         return _ogr.FieldDefn_SetNullable(self, *args)
 
     def IsUnique(self, *args):
         r"""
         IsUnique(FieldDefn self) -> int
-        int OGR_Fld_IsUnique(OGRFieldDefnH
-        hDefn)
+
 
         Return whether this field has a unique constraint.
 
         By default, fields have no unique constraint.
 
-        This method is the same as the C++ method OGRFieldDefn::IsUnique().
+        See :cpp:func:`OGRFieldDefn::IsUnique`.
 
         .. versionadded:: 3.2
 
-        Parameters
-        -----------
-        hDefn:
-            handle to the field definition
-
-
         Returns
         --------
         int:
             TRUE if the field has a unique constraint.
 
         """
         return _ogr.FieldDefn_IsUnique(self, *args)
 
     def SetUnique(self, *args):
         r"""
         SetUnique(FieldDefn self, int bUnique)
-        void
-        OGR_Fld_SetUnique(OGRFieldDefnH hDefn, int bUniqueIn)
+
 
         Set whether this field has a unique constraint.
 
         By default, fields have no unique constraint, so this method is
         generally called with TRUE to set a unique constraint.
 
         Drivers that support writing unique constraint will advertise the
-        GDAL_DCAP_UNIQUE_FIELDS driver metadata item. field can receive null
-        values.
+        ``GDAL_DCAP_UNIQUE_FIELDS`` driver metadata item.
+
+        Note that once a :py:class:`FieldDefn` has been added to a layer definition with
+        :py:meth:`Layer.AddFieldDefn`, its setter methods should not be called on the
+        object returned with ``GetLayerDefn().GetFieldDefn()``. Instead,
+        :py:meth:`Layer::AlterFieldDefn` should be called on a new instance of
+        :py:class:`FieldDefn`, for drivers that support :py:meth:`Layer.AlterFieldDefn`.
 
-        This method is the same as the C++ method OGRFieldDefn::SetUnique().
+        See :cpp:func:`OGRFieldDefn::SetUnique`.
 
         .. versionadded:: 3.2
 
         Parameters
         -----------
-        hDefn:
-            handle to the field definition
-        bUniqueIn:
-            TRUE if the field must have a unique constraint.
+        bUnique : bool
+            ``True`` if the field must have a unique constraint
 
         """
         return _ogr.FieldDefn_SetUnique(self, *args)
 
     def GetDefault(self, *args):
         r"""
         GetDefault(FieldDefn self) -> char const *
-        const char\*
-        OGR_Fld_GetDefault(OGRFieldDefnH hDefn)
+
 
         Get default field value.
 
-        This function is the same as the C++ method
-        OGRFieldDefn::GetDefault().
-
-        .. versionadded:: 2.0
-
-        Parameters
-        -----------
-        hDefn:
-            handle to the field definition.
+        See :cpp:func:`OGRFieldDefn::GetDefault`.
 
         Returns
         --------
         str:
-            default field value or NULL.
+            default field value or ``None``.
 
         """
         return _ogr.FieldDefn_GetDefault(self, *args)
 
     def SetDefault(self, *args):
         r"""
         SetDefault(FieldDefn self, char const * pszValue)
-        void
-        OGR_Fld_SetDefault(OGRFieldDefnH hDefn, const char \*pszDefault)
+
 
         Set default field value.
 
         The default field value is taken into account by drivers (generally
         those with a SQL interface) that support it at field creation time.
         OGR will generally not automatically set the default field value to
         null fields by itself when calling OGRFeature::CreateFeature() /
@@ -5698,112 +5599,85 @@
         expression (that might be ignored by other drivers). For a datetime
         literal value, format should be 'YYYY/MM/DD HH:MM:SS[.sss]'
         (considered as UTC time).
 
         Drivers that support writing DEFAULT clauses will advertise the
         GDAL_DCAP_DEFAULT_FIELDS driver metadata item.
 
-        This function is the same as the C++ method
-        OGRFieldDefn::SetDefault().
-
-        .. versionadded:: 2.0
+        See :cpp:func:`OGRFieldDefn::SetDefault`.
 
         Parameters
         -----------
-        hDefn:
-            handle to the field definition.
-        pszDefault:
+        pszValue : str
             new default field value or NULL pointer.
 
         """
         return _ogr.FieldDefn_SetDefault(self, *args)
 
     def IsDefaultDriverSpecific(self, *args):
         r"""
         IsDefaultDriverSpecific(FieldDefn self) -> int
-        int
-        OGR_Fld_IsDefaultDriverSpecific(OGRFieldDefnH hDefn)
+
 
         Returns whether the default value is driver specific.
 
         Driver specific default values are those that are not NULL, a numeric
         value, a literal value enclosed between single quote characters,
         CURRENT_TIMESTAMP, CURRENT_TIME, CURRENT_DATE or datetime literal
         value.
 
-        This function is the same as the C++ method
-        OGRFieldDefn::IsDefaultDriverSpecific().
-
-        .. versionadded:: 2.0
-
-        Parameters
-        -----------
-        hDefn:
-            handle to the field definition
-
+        See :cpp:func:`OGRFieldDefn::IsDefaultDriverSpecific`.
 
         Returns
         --------
         int:
             TRUE if the default value is driver specific.
 
         """
         return _ogr.FieldDefn_IsDefaultDriverSpecific(self, *args)
 
     def GetDomainName(self, *args):
         r"""
         GetDomainName(FieldDefn self) -> char const *
-        const char\*
-        OGR_Fld_GetDomainName(OGRFieldDefnH hDefn)
+
 
         Return the name of the field domain for this field.
 
-        By default, none (empty string) is returned.
+        By default an empty string is returned.
 
-        Field domains ( OGRFieldDomain class) are attached at the GDALDataset
-        level and should be retrieved with GDALDatasetGetFieldDomain().
+        Field domains ( :py:class:`FieldDomain` class) are attached at the :py:class:`Dataset` level and should be retrieved with :py:meth:`Dataset.GetFieldDomain`.
 
-        This method is the same as the C++ method
-        OGRFieldDefn::GetDomainName().
+        See :cpp:func:`OGRFieldDefn::GetDomainName`.
 
         .. versionadded:: 3.3
 
-        Parameters
-        -----------
-        hDefn:
-            handle to the field definition
-
         Returns
         --------
         str:
             the field domain name, or an empty string if there is none.
 
         """
         return _ogr.FieldDefn_GetDomainName(self, *args)
 
     def SetDomainName(self, *args):
         r"""
         SetDomainName(FieldDefn self, char const * name)
-        void
-        OGR_Fld_SetDomainName(OGRFieldDefnH hDefn, const char \*pszFieldName)
+
 
         Set the name of the field domain for this field.
 
-        Field domains ( OGRFieldDomain) are attached at the GDALDataset level.
+        Field domains ( :py:class:`FieldDomain`) are attached at the :py:class:`Dataset` level.
 
-        This method is the same as the C++ method
-        OGRFieldDefn::SetDomainName().
+        See :cpp:func:`OGRFieldDefn::SetDomainName`.
 
         .. versionadded:: 3.3
 
         Parameters
         -----------
-        hDefn:
-            handle to the field definition
-        pszFieldName:
+        name : str
             Field domain name.
 
         """
         return _ogr.FieldDefn_SetDomainName(self, *args)
 
     def GetComment(self, *args):
         r"""GetComment(FieldDefn self) -> char const *"""
@@ -5879,14 +5753,22 @@
         r"""IsNullable(GeomFieldDefn self) -> int"""
         return _ogr.GeomFieldDefn_IsNullable(self, *args)
 
     def SetNullable(self, *args):
         r"""SetNullable(GeomFieldDefn self, int bNullable)"""
         return _ogr.GeomFieldDefn_SetNullable(self, *args)
 
+    def GetCoordinatePrecision(self, *args):
+        r"""GetCoordinatePrecision(GeomFieldDefn self) -> GeomCoordinatePrecision"""
+        return _ogr.GeomFieldDefn_GetCoordinatePrecision(self, *args)
+
+    def SetCoordinatePrecision(self, *args):
+        r"""SetCoordinatePrecision(GeomFieldDefn self, GeomCoordinatePrecision coordPrec)"""
+        return _ogr.GeomFieldDefn_SetCoordinatePrecision(self, *args)
+
     type = property(GetType, SetType)
     name = property(GetName, SetName)
     srs = property(GetSpatialRef, SetSpatialRef)
 
 
 # Register GeomFieldDefn in _ogr:
 _ogr.GeomFieldDefn_swigregister(GeomFieldDefn)
@@ -6121,17 +6003,53 @@
         return _ogr.Geometry_GetGeometryName(self, *args)
 
     def Length(self, *args):
         r"""Length(Geometry self) -> double"""
         return _ogr.Geometry_Length(self, *args)
 
     def Area(self, *args):
-        r"""Area(Geometry self) -> double"""
+        r"""
+        Area(Geometry self) -> double
+
+        Compute geometry area.
+
+        The returned area is a 2D Cartesian (planar) area in square units of the
+        spatial reference system in use, so potentially 'square degrees' for a
+        geometry expressed in a geographic SRS.
+
+        For more details: :cpp:func:`OGR_G_Area`
+
+        Returns
+        --------
+        float:
+            the area of the geometry in square units of the spatial reference
+            system in use, or 0.0 for unsupported geometry types.
+
+
+        """
         return _ogr.Geometry_Area(self, *args)
 
+    def GeodesicArea(self, *args):
+        r"""
+        GeodesicArea(Geometry self) -> double
+
+        Compute geometry area, considered as a surface on the underlying
+        ellipsoid of the SRS attached to the geometry.
+
+        For more details: :cpp:func:`OGR_G_GeodesicArea`
+
+        Returns
+        --------
+        float:
+            the area in square meters, or a negative value for unsupported geometry types.
+
+
+        """
+        return _ogr.Geometry_GeodesicArea(self, *args)
+
     def IsClockwise(self, *args):
         r"""IsClockwise(Geometry self) -> bool"""
         return _ogr.Geometry_IsClockwise(self, *args)
 
     def GetArea(self, *args):
         r"""GetArea(Geometry self) -> double"""
         return _ogr.Geometry_GetArea(self, *args)
@@ -6368,14 +6286,18 @@
         Geometry:
             A newly allocated geometry now owned by the caller, or None on
             failure.
 
         """
         return _ogr.Geometry_MakeValid(self, *args)
 
+    def SetPrecision(self, *args):
+        r"""SetPrecision(Geometry self, double gridSize, int flags=0) -> Geometry"""
+        return _ogr.Geometry_SetPrecision(self, *args)
+
     def Normalize(self, *args):
         r"""
         Normalize(Geometry self) -> Geometry
 
         Attempts to bring geometry into normalized/canonical form.
 
         For more details: :cpp:func:`OGR_G_Normalize`
@@ -6475,14 +6397,18 @@
         --------
         Geometry:
             A new geometry representing the union or None if an error occurs.
 
         """
         return _ogr.Geometry_UnionCascaded(self, *args)
 
+    def UnaryUnion(self, *args):
+        r"""UnaryUnion(Geometry self) -> Geometry"""
+        return _ogr.Geometry_UnaryUnion(self, *args)
+
     def Difference(self, *args):
         r"""
         Difference(Geometry self, Geometry other) -> Geometry
 
         Compute difference.
 
         For more details: :cpp:func:`OGR_G_Difference`
@@ -7264,109 +7190,490 @@
     def Transform(self, *args):
         r"""Transform(GeomTransformer self, Geometry src_geom) -> Geometry"""
         return _ogr.GeomTransformer_Transform(self, *args)
 
 # Register GeomTransformer in _ogr:
 _ogr.GeomTransformer_swigregister(GeomTransformer)
 class FieldDomain(object):
-    r"""Proxy of C++ OGRFieldDomainShadow class."""
+    r"""
+
+
+    Python proxy of an :cpp:class:`OGRFieldDomain`.
+
+    Created using one of:
+
+    - :py:func:`CreateCodedFieldDomain`
+    - :py:func:`CreateGlobFieldDomain`
+    - :py:func:`CreateRangeFieldDomain`
+
+    """
 
     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
 
     def __init__(self, *args, **kwargs):
         raise AttributeError("No constructor defined")
     __repr__ = _swig_repr
     __swig_destroy__ = _ogr.delete_FieldDomain
 
     def GetName(self, *args):
-        r"""GetName(FieldDomain self) -> char const *"""
+        r"""
+        GetName(FieldDomain self) -> char const *
+
+
+        Get the name of the field domain.
+
+        See :cpp:func:`OGRFieldDomain::GetName`.
+
+        .. versionadded:: 3.3
+
+        Returns
+        --------
+        str
+            the field domain name.
+
+        """
         return _ogr.FieldDomain_GetName(self, *args)
 
     def GetDescription(self, *args):
-        r"""GetDescription(FieldDomain self) -> char const *"""
+        r"""
+        GetDescription(FieldDomain self) -> char const *
+
+
+        Get the description of the field domain.
+
+        See :cpp:func:`OGRFieldDomain::GetDescription`.
+
+        .. versionadded:: 3.3
+
+        Returns
+        --------
+        str
+            the field domain description (might be empty string).
+
+        """
         return _ogr.FieldDomain_GetDescription(self, *args)
 
     def GetFieldType(self, *args):
-        r"""GetFieldType(FieldDomain self) -> OGRFieldType"""
+        r"""
+        GetFieldType(FieldDomain self) -> OGRFieldType
+
+
+        Get the field type of the field domain.
+
+        See :cpp:func:`OGRFieldDomain::GetFieldType`.
+
+        .. versionadded:: 3.3
+
+        Returns
+        --------
+        int
+            the field type of the field domain.
+
+        """
         return _ogr.FieldDomain_GetFieldType(self, *args)
 
     def GetFieldSubType(self, *args):
-        r"""GetFieldSubType(FieldDomain self) -> OGRFieldSubType"""
+        r"""
+        GetFieldSubType(FieldDomain self) -> OGRFieldSubType
+
+
+        Get the field subtype of the field domain.
+
+        See :cpp:func:`OGRFieldDomain::GetFieldSubType`.
+
+        .. versionadded:: 3.3
+
+        Returns
+        --------
+        int
+            the field subtype of the field domain.
+
+        """
         return _ogr.FieldDomain_GetFieldSubType(self, *args)
 
     def GetDomainType(self, *args):
-        r"""GetDomainType(FieldDomain self) -> OGRFieldDomainType"""
+        r"""
+        GetDomainType(FieldDomain self) -> OGRFieldDomainType
+
+
+        Get the type of the field domain.
+
+        See :cpp:func:`OGRFieldDomain::GetDomainType`.
+
+        .. versionadded:: 3.3
+
+        Returns
+        --------
+        int
+            the type of the field domain.
+
+        Examples
+        --------
+        >>> d = ogr.CreateCodedFieldDomain('my_code', None, ogr.OFTInteger, ogr.OFSTNone, { 1 : 'owned', 2 : 'leased' })
+        >>> d.GetDomainType() == ogr.OFDT_CODED
+        True
+
+
+        """
         return _ogr.FieldDomain_GetDomainType(self, *args)
 
     def GetSplitPolicy(self, *args):
-        r"""GetSplitPolicy(FieldDomain self) -> OGRFieldDomainSplitPolicy"""
+        r"""
+        GetSplitPolicy(FieldDomain self) -> OGRFieldDomainSplitPolicy
+
+
+        Get the split policy of the field domain.
+
+        See :cpp:func:`OGRFieldDomain::GetSplitPolicy`.
+
+        .. versionadded:: 3.3
+
+        Returns
+        --------
+        int
+            the split policy of the field domain (default = :py:const:`OFDSP_DEFAULT_VALUE`)
+
+        """
         return _ogr.FieldDomain_GetSplitPolicy(self, *args)
 
     def SetSplitPolicy(self, *args):
-        r"""SetSplitPolicy(FieldDomain self, OGRFieldDomainSplitPolicy policy)"""
+        r"""
+        SetSplitPolicy(FieldDomain self, OGRFieldDomainSplitPolicy policy)
+
+
+        Set the split policy of the field domain.
+
+        See :cpp:func:`OGRFieldDomain::SetSplitPolicy`.
+
+        .. versionadded:: 3.3
+
+        policy : int
+            the split policy code of the field domain.
+
+        """
         return _ogr.FieldDomain_SetSplitPolicy(self, *args)
 
     def GetMergePolicy(self, *args):
-        r"""GetMergePolicy(FieldDomain self) -> OGRFieldDomainMergePolicy"""
+        r"""
+        GetMergePolicy(FieldDomain self) -> OGRFieldDomainMergePolicy
+
+
+        Get the merge policy of the field domain.
+
+        See :cpp:func:`OGRFieldDomain::GetMergePolicy`.
+
+        .. versionadded:: 3.3
+
+        Returns
+        --------
+        int
+            the merge policy of the field domain (default = :py:const:`OFDMP_DEFAULT_VALUE`)
+
+        """
         return _ogr.FieldDomain_GetMergePolicy(self, *args)
 
     def SetMergePolicy(self, *args):
-        r"""SetMergePolicy(FieldDomain self, OGRFieldDomainMergePolicy policy)"""
+        r"""
+        SetMergePolicy(FieldDomain self, OGRFieldDomainMergePolicy policy)
+
+
+        Set the merge policy of the field domain.
+
+        See :cpp:func:`OGRFieldDomain::SetMergePolicy`.
+
+        .. versionadded:: 3.3
+
+        Parameters
+        -----------
+        policy : int
+            the merge policy code of the field domain.
+
+        """
         return _ogr.FieldDomain_SetMergePolicy(self, *args)
 
     def GetEnumeration(self, *args):
-        r"""GetEnumeration(FieldDomain self) -> OGRCodedValue const *"""
+        r"""
+        GetEnumeration(FieldDomain self) -> OGRCodedValue const *
+
+
+        Get the enumeration as a mapping of codes to values.
+
+        See :cpp:func:`OGRCodedFieldDomain::GetEnumeration`.
+
+        .. versionadded:: 3.3
+
+        Returns
+        --------
+        dict
+
+        Examples
+        --------
+        >>> d = ogr.CreateCodedFieldDomain('my_domain', None, ogr.OFTInteger, ogr.OFSTNone, { 1 : 'owned', 2 : 'leased' })
+        >>> d.GetEnumeration()
+        {'1': 'owned', '2': 'leased'}
+
+
+        """
         return _ogr.FieldDomain_GetEnumeration(self, *args)
 
     def GetMinAsDouble(self, *args):
-        r"""GetMinAsDouble(FieldDomain self) -> double"""
+        r"""
+        GetMinAsDouble(FieldDomain self) -> double
+
+
+        Get the minimum value of a range domain.
+
+        See :cpp:func:`OGRRangeFieldDomain::GetMin()`
+
+        .. versionadded:: 3.3
+
+        Returns
+        --------
+        float
+            the minimum value of the range
+
+        """
         return _ogr.FieldDomain_GetMinAsDouble(self, *args)
 
     def GetMinAsString(self, *args):
-        r"""GetMinAsString(FieldDomain self) -> char const *"""
+        r"""
+        GetMinAsString(FieldDomain self) -> char const *
+
+
+        Get the minimum value of a range domain.
+
+        See :cpp:func:`OGRRangeFieldDomain::GetMin()`
+
+        .. versionadded:: 3.3
+
+        Returns
+        --------
+        str
+            the minimum value of the range
+
+        """
         return _ogr.FieldDomain_GetMinAsString(self, *args)
 
     def IsMinInclusive(self, *args):
         r"""IsMinInclusive(FieldDomain self) -> bool"""
         return _ogr.FieldDomain_IsMinInclusive(self, *args)
 
     def GetMaxAsDouble(self, *args):
-        r"""GetMaxAsDouble(FieldDomain self) -> double"""
+        r"""
+        GetMaxAsDouble(FieldDomain self) -> double
+
+
+        Get the maximum value of a range domain.
+
+        See :cpp:func:`OGRRangeFieldDomain::GetMax()`
+
+        .. versionadded:: 3.3
+
+        Returns
+        --------
+        float
+            the maximum value of the range
+
+        """
         return _ogr.FieldDomain_GetMaxAsDouble(self, *args)
 
     def GetMaxAsString(self, *args):
-        r"""GetMaxAsString(FieldDomain self) -> char const *"""
+        r"""
+        GetMaxAsString(FieldDomain self) -> char const *
+
+
+        Get the maximum value of a range domain.
+
+        See :cpp:func:`OGRRangeFieldDomain::GetMax()`
+
+        .. versionadded:: 3.3
+
+        Returns
+        --------
+        str
+            the maximum value of the range
+
+        """
         return _ogr.FieldDomain_GetMaxAsString(self, *args)
 
     def IsMaxInclusive(self, *args):
         r"""IsMaxInclusive(FieldDomain self) -> bool"""
         return _ogr.FieldDomain_IsMaxInclusive(self, *args)
 
     def GetGlob(self, *args):
-        r"""GetGlob(FieldDomain self) -> char const *"""
+        r"""
+        GetGlob(FieldDomain self) -> char const *
+
+
+        Get the glob expression.
+
+        See :cpp:func:`OGRGlobFieldDomain::GetGlob`.
+
+        .. versionadded:: 3.3
+
+        Returns
+        --------
+        str
+            the glob expression, or ``None`` in case of error
+
+        """
         return _ogr.FieldDomain_GetGlob(self, *args)
 
 # Register FieldDomain in _ogr:
 _ogr.FieldDomain_swigregister(FieldDomain)
 
 def CreateCodedFieldDomain(*args):
-    r"""CreateCodedFieldDomain(char const * name, char const * description, OGRFieldType type, OGRFieldSubType subtype, OGRCodedValue const * enumeration) -> FieldDomain"""
+    r"""
+    CreateCodedFieldDomain(char const * name, char const * description, OGRFieldType type, OGRFieldSubType subtype, OGRCodedValue const * enumeration) -> FieldDomain
+
+
+    Creates a new coded field domain.
+
+    See :cpp:func:`OGRCodedFieldDomain::OGRCodedFieldDomain`.
+
+    .. versionadded:: 3.3
+
+    Parameters
+    -----------
+    name : str
+        Domain name. Should not be ``None``.
+    description : str, optional
+        Domain description (can be ``None``)
+    type : int
+        Field type.
+    subtype : int
+        Field subtype.
+    enumeration : dict
+        Enumeration as a dictionary of (code : value) pairs. Should not be ``None``.
+
+    Returns
+    --------
+    FieldDomain
+
+    """
     return _ogr.CreateCodedFieldDomain(*args)
 
 def CreateRangeFieldDomain(*args):
-    r"""CreateRangeFieldDomain(char const * name, char const * description, OGRFieldType type, OGRFieldSubType subtype, double min, bool minIsInclusive, double max, double maxIsInclusive) -> FieldDomain"""
+    r"""
+    CreateRangeFieldDomain(char const * name, char const * description, OGRFieldType type, OGRFieldSubType subtype, double min, bool minIsInclusive, double max, double maxIsInclusive) -> FieldDomain
+
+    Creates a new range field domain.
+
+    See :cpp:func:`OGRRangeFieldDomain::OGRRangeFieldDomain`.
+
+    .. versionadded:: 3.3
+
+    Parameters
+    -----------
+    name : str
+        Domain name. Should not be ``None``.
+    description : str, optional
+        Domain description (can be ``None``)
+    type : int
+        Field type. Generally numeric. Potentially :py:const:`OFTDateTime`.
+    subtype : int
+        Field subtype.
+    min : float, optional
+        Minimum value (can be ``None``).
+    minIsInclusive : bool
+        Whether the minimum value is included in the range.
+    max : float, optional
+        Maximum value (can be ``None``).
+    maxIsInclusive : bool
+        Whether the maximum value is included in the range.
+
+    Returns
+    --------
+    FieldDomain
+
+    """
     return _ogr.CreateRangeFieldDomain(*args)
 
 def CreateRangeFieldDomainDateTime(*args):
     r"""CreateRangeFieldDomainDateTime(char const * name, char const * description, char const * min, bool minIsInclusive, char const * max, double maxIsInclusive) -> FieldDomain"""
     return _ogr.CreateRangeFieldDomainDateTime(*args)
 
 def CreateGlobFieldDomain(*args):
-    r"""CreateGlobFieldDomain(char const * name, char const * description, OGRFieldType type, OGRFieldSubType subtype, char const * glob) -> FieldDomain"""
+    r"""
+    CreateGlobFieldDomain(char const * name, char const * description, OGRFieldType type, OGRFieldSubType subtype, char const * glob) -> FieldDomain
+
+
+    Creates a new glob field domain.
+
+    See :cpp:func:`OGRGlobFieldDomain::OGRGlobFieldDomain`
+
+    .. versionadded:: 3.3
+
+    Parameters
+    -----------
+    name : str
+        Domain name. Should not be ``None``.
+    description : str, optional
+        Domain description (can be ``None``)
+    type : int
+        Field type.
+    subtype : int
+        Field subtype.
+    glob : str
+        Glob expression. Should not be ``None``.
+
+    Returns
+    --------
+    FieldDomain
+
+    """
     return _ogr.CreateGlobFieldDomain(*args)
+class GeomCoordinatePrecision(object):
+    r"""Proxy of C++ OGRGeomCoordinatePrecisionShadow class."""
+
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+
+    def __init__(self, *args, **kwargs):
+        raise AttributeError("No constructor defined")
+    __repr__ = _swig_repr
+    __swig_destroy__ = _ogr.delete_GeomCoordinatePrecision
+
+    def Set(self, *args):
+        r"""Set(GeomCoordinatePrecision self, double xyResolution, double zResolution, double mResolution)"""
+        return _ogr.GeomCoordinatePrecision_Set(self, *args)
+
+    def SetFromMeter(self, *args):
+        r"""SetFromMeter(GeomCoordinatePrecision self, SpatialReference srs, double xyMeterResolution, double zMeterResolution, double mResolution)"""
+        return _ogr.GeomCoordinatePrecision_SetFromMeter(self, *args)
+
+    def GetXYResolution(self, *args):
+        r"""GetXYResolution(GeomCoordinatePrecision self) -> double"""
+        return _ogr.GeomCoordinatePrecision_GetXYResolution(self, *args)
+
+    def GetZResolution(self, *args):
+        r"""GetZResolution(GeomCoordinatePrecision self) -> double"""
+        return _ogr.GeomCoordinatePrecision_GetZResolution(self, *args)
+
+    def GetMResolution(self, *args):
+        r"""GetMResolution(GeomCoordinatePrecision self) -> double"""
+        return _ogr.GeomCoordinatePrecision_GetMResolution(self, *args)
+
+    def GetFormats(self, *args):
+        r"""GetFormats(GeomCoordinatePrecision self) -> char **"""
+        return _ogr.GeomCoordinatePrecision_GetFormats(self, *args)
+
+    def GetFormatSpecificOptions(self, *args):
+        r"""GetFormatSpecificOptions(GeomCoordinatePrecision self, char const * formatName) -> char **"""
+        return _ogr.GeomCoordinatePrecision_GetFormatSpecificOptions(self, *args)
+
+    def SetFormatSpecificOptions(self, *args):
+        r"""SetFormatSpecificOptions(GeomCoordinatePrecision self, char const * formatName, char ** formatSpecificOptions)"""
+        return _ogr.GeomCoordinatePrecision_SetFormatSpecificOptions(self, *args)
+
+# Register GeomCoordinatePrecision in _ogr:
+_ogr.GeomCoordinatePrecision_swigregister(GeomCoordinatePrecision)
+
+def CreateGeomCoordinatePrecision(*args):
+    r"""CreateGeomCoordinatePrecision() -> GeomCoordinatePrecision"""
+    return _ogr.CreateGeomCoordinatePrecision(*args)
 
 def GetDriverCount(*args):
     r"""GetDriverCount() -> int"""
     return _ogr.GetDriverCount(*args)
 
 def GetOpenDSCount(*args):
     r"""GetOpenDSCount() -> int"""
@@ -7381,19 +7688,71 @@
     return _ogr.RegisterAll(*args)
 
 def GeometryTypeToName(*args):
     r"""GeometryTypeToName(OGRwkbGeometryType eType) -> char const *"""
     return _ogr.GeometryTypeToName(*args)
 
 def GetFieldTypeName(*args):
-    r"""GetFieldTypeName(OGRFieldType type) -> char const *"""
+    r"""
+    GetFieldTypeName(OGRFieldType type) -> char const *
+
+    Fetch human readable name for a field type.
+
+    See :cpp:func:`OGRFieldDefn::GetFieldTypeName`.
+
+    Parameters
+    -----------
+    type : int
+        the field type code to get name for
+
+    Returns
+    --------
+    str
+        the name
+
+    Examples
+    --------
+    >>> ogr.GetFieldTypeName(0)
+    'Integer'
+
+    >>> ogr.GetFieldTypeName(ogr.OFTReal)
+    'Real'
+
+    """
     return _ogr.GetFieldTypeName(*args)
 
 def GetFieldSubTypeName(*args):
-    r"""GetFieldSubTypeName(OGRFieldSubType type) -> char const *"""
+    r"""
+    GetFieldSubTypeName(OGRFieldSubType type) -> char const *
+
+
+    Fetch human readable name for a field subtype.
+
+    See :cpp:func:`OGRFieldDefn::GetFieldSubTypeName`.
+
+    Parameters
+    -----------
+    type : int
+        the field subtype to get name for.
+
+    Returns
+    --------
+    str
+        the name.
+
+    Examples
+    --------
+    >>> ogr.GetFieldSubTypeName(1)
+    'Boolean'
+
+    >>> ogr.GetFieldSubTypeName(ogr.OFSTInt16)
+    'Int16'
+
+
+    """
     return _ogr.GetFieldSubTypeName(*args)
 
 def GT_Flatten(*args):
     r"""GT_Flatten(OGRwkbGeometryType eType) -> OGRwkbGeometryType"""
     return _ogr.GT_Flatten(*args)
 
 def GT_SetZ(*args):
@@ -7474,14 +7833,21 @@
 
 def GetDriver(*args):
     r"""GetDriver(int driver_number) -> Driver"""
     return _ogr.GetDriver(*args)
 
 def GeneralCmdLineProcessor(*args):
     r"""GeneralCmdLineProcessor(char ** papszArgv, int nOptions=0) -> char **"""
+
+    import os
+    for i in range(len(args[0])):
+        if isinstance(args[0][i], (os.PathLike, int)):
+            args[0][i] = str(args[0][i])
+
+
     return _ogr.GeneralCmdLineProcessor(*args)
 
 def TermProgress_nocb(*args, **kwargs):
     r"""TermProgress_nocb(double dfProgress, char const * pszMessage=None, void * pData=None) -> int"""
     return _ogr.TermProgress_nocb(*args, **kwargs)
 TermProgress = _ogr.TermProgress
```

### Comparing `GDAL-3.8.5/osgeo/osr.py` & `GDAL-3.9.0/osgeo/osr.py`

 * *Files 24% similar despite different names*

```diff
@@ -454,82 +454,304 @@
     r"""OSRAreaOfUse_north_lat_degree_get(AreaOfUse area) -> double"""
     return _osr.OSRAreaOfUse_north_lat_degree_get(*args)
 
 def OSRAreaOfUse_name_get(*args):
     r"""OSRAreaOfUse_name_get(AreaOfUse area) -> char const *"""
     return _osr.OSRAreaOfUse_name_get(*args)
 class SpatialReference(object):
-    r"""Proxy of C++ OSRSpatialReferenceShadow class."""
+    r"""
+
+    Python proxy of an :cpp:class:`OGRSpatialReference`.
+
+    """
 
     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
     __repr__ = _swig_repr
 
     def __init__(self, *args, **kwargs):
-        r"""__init__(SpatialReference self, char const * wkt="") -> SpatialReference"""
+        r"""
+        __init__(SpatialReference self, char const * wkt="") -> SpatialReference
+
+        Python proxy of an :cpp:class:`OGRSpatialReference`.
+
+        """
         _osr.SpatialReference_swiginit(self, _osr.new_SpatialReference(*args, **kwargs))
     __swig_destroy__ = _osr.delete_SpatialReference
 
     def __str__(self, *args):
         r"""__str__(SpatialReference self) -> retStringAndCPLFree *"""
         return _osr.SpatialReference___str__(self, *args)
 
     def GetName(self, *args):
-        r"""GetName(SpatialReference self) -> char const *"""
+        r"""
+        GetName(SpatialReference self) -> char const *
+
+
+        Return the CRS name.
+
+        See :cpp:func:`OGRSpatialReference::GetName`.
+
+        Returns
+        -------
+        str
+
+        Examples
+        --------
+        >>> vt_sp = osr.SpatialReference()
+        >>> vt_sp.ImportFromEPSG(5646)
+        0
+        >>> vt_sp.GetName()
+        'NAD83 / Vermont (ftUS)'
+
+
+        """
         return _osr.SpatialReference_GetName(self, *args)
 
     def IsSame(self, *args, **kwargs):
-        r"""IsSame(SpatialReference self, SpatialReference rhs, char ** options=None) -> int"""
+        r"""
+        IsSame(SpatialReference self, SpatialReference rhs, char ** options=None) -> int
+
+
+        Determine if two spatial references describe the same system.
+
+        See :cpp:func:`OGRSpatialReference::IsSame`.
+
+        Parameters
+        ----------
+        rhs : SpatialReference
+        options : list/dict
+
+        Returns
+        -------
+        int
+            1 if the spatial references describe the same system, 0 otherwise
+
+
+        """
         return _osr.SpatialReference_IsSame(self, *args, **kwargs)
 
     def IsSameGeogCS(self, *args):
-        r"""IsSameGeogCS(SpatialReference self, SpatialReference rhs) -> int"""
+        r"""
+        IsSameGeogCS(SpatialReference self, SpatialReference rhs) -> int
+
+
+        Determine if two spatial references share the same geographic coordinate system.
+
+        See :cpp:func:`OGRSpatialReference::IsSameGeogCS`.
+
+        Parameters
+        ----------
+        rhs : SpatialReference
+        options : list/dict
+
+        Returns
+        -------
+        int
+            1 if the spatial references have the same GeogCS, 0 otherwise
+
+
+        """
         return _osr.SpatialReference_IsSameGeogCS(self, *args)
 
     def IsSameVertCS(self, *args):
-        r"""IsSameVertCS(SpatialReference self, SpatialReference rhs) -> int"""
+        r"""
+        IsSameVertCS(SpatialReference self, SpatialReference rhs) -> int
+
+
+        Determine if two spatial references share the same vertical coordinate system.
+
+        See :cpp:func:`OGRSpatialReference::IsSameVertCS`.
+
+        Parameters
+        ----------
+        rhs : SpatialReference
+        options : list/dict
+
+        Returns
+        -------
+        int
+            1 if the spatial references have the same VertCS, 0 otherwise
+
+
+        """
         return _osr.SpatialReference_IsSameVertCS(self, *args)
 
     def IsGeographic(self, *args):
-        r"""IsGeographic(SpatialReference self) -> int"""
+        r"""
+        IsGeographic(SpatialReference self) -> int
+
+
+        Check if this SRS is a geographic coordinate system.
+
+        See :cpp:func:`OGRSpatialReference::IsGeographic`.
+
+        Returns
+        -------
+        int
+            1 if the SRS is geographic, 0 otherwise
+
+        """
         return _osr.SpatialReference_IsGeographic(self, *args)
 
     def IsDerivedGeographic(self, *args):
-        r"""IsDerivedGeographic(SpatialReference self) -> int"""
+        r"""
+        IsDerivedGeographic(SpatialReference self) -> int
+
+
+        Check if this CRS is a derived geographic CRS, such as a rotated long/lat grid.
+
+        See :cpp:func:`OGRSpatialReference::IsDerivedGeographic`.
+
+        Returns
+        -------
+        int
+            1 if the CRS is derived geographic, 0 otherwise
+
+        """
         return _osr.SpatialReference_IsDerivedGeographic(self, *args)
 
     def IsProjected(self, *args):
-        r"""IsProjected(SpatialReference self) -> int"""
+        r"""
+        IsProjected(SpatialReference self) -> int
+
+
+        Check if this SRS is a projected coordinate system.
+
+        See :cpp:func:`OGRSpatialReference::IsProjected`.
+
+        Returns
+        -------
+        int
+            1 if the SRS is projected, 0 otherwise
+
+        """
         return _osr.SpatialReference_IsProjected(self, *args)
 
+    def IsDerivedProjected(self, *args):
+        r"""IsDerivedProjected(SpatialReference self) -> int"""
+        return _osr.SpatialReference_IsDerivedProjected(self, *args)
+
     def IsCompound(self, *args):
-        r"""IsCompound(SpatialReference self) -> int"""
+        r"""
+        IsCompound(SpatialReference self) -> int
+
+
+        Check if this CRS is a compound CRS.
+
+        See :cpp:func:`OGRSpatialReference::IsCompound`.
+
+        Returns
+        -------
+        int
+            1 if the CRS is compound, 0 otherwise
+
+        """
         return _osr.SpatialReference_IsCompound(self, *args)
 
     def IsGeocentric(self, *args):
-        r"""IsGeocentric(SpatialReference self) -> int"""
+        r"""
+        IsGeocentric(SpatialReference self) -> int
+
+
+        Check if this SRS is a geocentric coordinate system.
+
+        See :cpp:func:`OGRSpatialReference::IsGeocentric`.
+
+        Returns
+        -------
+        int
+            1 if the SRS is geocentric, 0 otherwise
+
+        """
         return _osr.SpatialReference_IsGeocentric(self, *args)
 
     def IsLocal(self, *args):
-        r"""IsLocal(SpatialReference self) -> int"""
+        r"""
+        IsLocal(SpatialReference self) -> int
+
+
+        Check if this CRS is a local CRS.
+
+        See :cpp:func:`OGRSpatialReference::IsLocal`.
+
+        Returns
+        -------
+        int
+            1 if the SRS is local, 0 otherwise
+
+        """
         return _osr.SpatialReference_IsLocal(self, *args)
 
     def IsVertical(self, *args):
-        r"""IsVertical(SpatialReference self) -> int"""
+        r"""
+        IsVertical(SpatialReference self) -> int
+
+
+        Check if this is a vertical coordinate system.
+
+        See :cpp:func:`OGRSpatialReference::IsVertical`.
+
+        Returns
+        -------
+        int
+            1 if the CRS is vertical, 0 otherwise
+
+
+        """
         return _osr.SpatialReference_IsVertical(self, *args)
 
     def IsDynamic(self, *args):
-        r"""IsDynamic(SpatialReference self) -> bool"""
+        r"""
+        IsDynamic(SpatialReference self) -> bool
+
+
+        Check if this CRS is a dynamic coordinate CRS.
+
+        See :cpp:func:`OGRSpatialReference::IsDynamic`.
+
+        Returns
+        -------
+        bool
+
+        """
         return _osr.SpatialReference_IsDynamic(self, *args)
 
     def HasPointMotionOperation(self, *args):
-        r"""HasPointMotionOperation(SpatialReference self) -> bool"""
+        r"""
+        HasPointMotionOperation(SpatialReference self) -> bool
+
+
+        Check if a CRS has an associated point motion operation.
+
+        See :cpp:func:`OGRSpatialReference::HasPointMotionOperation`.
+
+        Returns
+        -------
+        bool
+
+
+        """
         return _osr.SpatialReference_HasPointMotionOperation(self, *args)
 
     def GetCoordinateEpoch(self, *args):
-        r"""GetCoordinateEpoch(SpatialReference self) -> double"""
+        r"""
+        GetCoordinateEpoch(SpatialReference self) -> double
+
+
+        Return the coordinate epoch as a decimal year.
+
+        See :cpp:func:`OGRSpatialReference::GetCoordinateEpoch`.
+
+        Returns
+        -------
+        float
+            coordinate epoch as a decimal year, or 0 if not set/relevant
+
+
+        """
         return _osr.SpatialReference_GetCoordinateEpoch(self, *args)
 
     def SetCoordinateEpoch(self, *args):
         r"""SetCoordinateEpoch(SpatialReference self, double coordinateEpoch)"""
         return _osr.SpatialReference_SetCoordinateEpoch(self, *args)
 
     def EPSGTreatsAsLatLong(self, *args):
@@ -541,31 +763,102 @@
         return _osr.SpatialReference_EPSGTreatsAsNorthingEasting(self, *args)
 
     def SetAuthority(self, *args):
         r"""SetAuthority(SpatialReference self, char const * pszTargetKey, char const * pszAuthority, int nCode) -> OGRErr"""
         return _osr.SpatialReference_SetAuthority(self, *args)
 
     def GetAttrValue(self, *args):
-        r"""GetAttrValue(SpatialReference self, char const * name, int child=0) -> char const *"""
+        r"""
+        GetAttrValue(SpatialReference self, char const * name, int child=0) -> char const *
+
+
+        Fetch indicated attribute of named node.
+
+        See :cpp:func:`OGRSpatialReference::GetAttrValue`.
+
+        Parameters
+        ----------
+        name : str
+            tree node to look for (case insensitive)
+        child : int, default = 0
+            0-indexed child of the node
+
+        Returns
+        -------
+        str
+
+        Examples
+        --------
+        >>> vt_sp = osr.SpatialReference()
+        >>> vt_sp.ImportFromEPSG(5646)
+        0
+        >>> vt_sp.GetAttrValue('UNIT', 0)
+        'US survey foot'
+
+
+        """
         return _osr.SpatialReference_GetAttrValue(self, *args)
 
     def SetAttrValue(self, *args):
         r"""SetAttrValue(SpatialReference self, char const * name, char const * value) -> OGRErr"""
         return _osr.SpatialReference_SetAttrValue(self, *args)
 
     def SetAngularUnits(self, *args):
         r"""SetAngularUnits(SpatialReference self, char const * name, double to_radians) -> OGRErr"""
         return _osr.SpatialReference_SetAngularUnits(self, *args)
 
     def GetAngularUnits(self, *args):
-        r"""GetAngularUnits(SpatialReference self) -> double"""
+        r"""
+        GetAngularUnits(SpatialReference self) -> double
+
+
+        Fetch conversion between angular geographic coordinate system units and radians.
+
+        See :cpp:func:`OGRSpatialReference::GetAngularUnits`.
+
+        Returns
+        -------
+        float
+            Value to multiply angular distances by to transform them to radians.
+
+        Examples
+        --------
+        >>> srs = osr.SpatialReference()
+        >>> srs.ImportFromEPSG(4326)
+        0
+        >>> srs.GetAngularUnits()
+        0.017453292519943295
+
+
+        """
         return _osr.SpatialReference_GetAngularUnits(self, *args)
 
     def GetAngularUnitsName(self, *args):
-        r"""GetAngularUnitsName(SpatialReference self) -> char const *"""
+        r"""
+        GetAngularUnitsName(SpatialReference self) -> char const *
+
+
+        Fetch angular geographic coordinate system units.
+
+        See :cpp:func:`OGRSpatialReference::GetAngularUnits`.
+
+        Returns
+        -------
+        str
+
+        Examples
+        --------
+        >>> srs = osr.SpatialReference()
+        >>> srs.ImportFromEPSG(4326)
+        0
+        >>> srs.GetAngularUnitsName()
+        'degree'
+
+
+        """
         return _osr.SpatialReference_GetAngularUnitsName(self, *args)
 
     def SetTargetLinearUnits(self, *args):
         r"""SetTargetLinearUnits(SpatialReference self, char const * target, char const * name, double to_meters) -> OGRErr"""
         return _osr.SpatialReference_SetTargetLinearUnits(self, *args)
 
     def SetLinearUnits(self, *args):
@@ -573,79 +866,368 @@
         return _osr.SpatialReference_SetLinearUnits(self, *args)
 
     def SetLinearUnitsAndUpdateParameters(self, *args):
         r"""SetLinearUnitsAndUpdateParameters(SpatialReference self, char const * name, double to_meters) -> OGRErr"""
         return _osr.SpatialReference_SetLinearUnitsAndUpdateParameters(self, *args)
 
     def GetTargetLinearUnits(self, *args):
-        r"""GetTargetLinearUnits(SpatialReference self, char const * target_key) -> double"""
+        r"""
+        GetTargetLinearUnits(SpatialReference self, char const * target_key) -> double
+
+
+        Fetch linear units for a target.
+
+        See :cpp:func:`OGRSpatialReference::GetTargetLinearUnits`.
+
+        Parameters
+        ----------
+        target_key : str
+            key to look un, such as 'PROJCS' or 'VERT_CS'
+
+        Returns
+        -------
+        double
+
+
+        """
         return _osr.SpatialReference_GetTargetLinearUnits(self, *args)
 
     def GetLinearUnits(self, *args):
-        r"""GetLinearUnits(SpatialReference self) -> double"""
+        r"""
+        GetLinearUnits(SpatialReference self) -> double
+
+
+        Fetch the conversion between linear projection units and meters.
+
+        See :cpp:func:`OGRSpatialReference::GetLinearUnits`.
+
+        Returns
+        -------
+        float
+
+        Examples
+        --------
+        >>> vt_sp = osr.SpatialReference()
+        >>> vt_sp.ImportFromEPSG(5646)
+        0
+        >>> vt_sp.GetLinearUnits()
+        0.30480060960121924
+
+
+        """
         return _osr.SpatialReference_GetLinearUnits(self, *args)
 
     def GetLinearUnitsName(self, *args):
-        r"""GetLinearUnitsName(SpatialReference self) -> char const *"""
+        r"""
+        GetLinearUnitsName(SpatialReference self) -> char const *
+
+
+        Fetch the name of the linear projection units.
+
+        See :cpp:func:`OGRSpatialReference::GetLinearUnits`.
+
+        Returns
+        -------
+        str
+
+        Examples
+        --------
+        >>> vt_sp = osr.SpatialReference()
+        >>> vt_sp.ImportFromEPSG(5646)
+        0
+        >>> vt_sp.GetLinearUnitsName()
+        'US survey foot'
+
+
+        """
         return _osr.SpatialReference_GetLinearUnitsName(self, *args)
 
     def GetAuthorityCode(self, *args):
-        r"""GetAuthorityCode(SpatialReference self, char const * target_key) -> char const *"""
+        r"""
+        GetAuthorityCode(SpatialReference self, char const * target_key) -> char const *
+
+
+        Get the authority code for a node.
+
+        See :cpp:func:`OGRSpatialReference::GetAuthorityCode`.
+
+        Parameters
+        ----------
+        target_key : str
+            the partial or complete path to the node to get an authority from
+            (e.g., 'PROJCS', 'GEOGCS' or ``None`` to get an authority code
+            on the root element)
+
+        Returns
+        -------
+        str or ``None`` on failure
+
+        Examples
+        --------
+        >>> srs = osr.SpatialReference()
+        >>> srs.ImportFromEPSG(4326)
+        0
+        >>> srs.GetAuthorityName('DATUM')
+        'EPSG'
+        >>> srs.GetAuthorityCode('DATUM')
+        '6326'
+        >>> srs.GetAuthorityCode(None)
+        '4326'
+
+
+        """
         return _osr.SpatialReference_GetAuthorityCode(self, *args)
 
     def GetAuthorityName(self, *args):
-        r"""GetAuthorityName(SpatialReference self, char const * target_key) -> char const *"""
+        r"""
+        GetAuthorityName(SpatialReference self, char const * target_key) -> char const *
+
+
+        Get the authority name for a node.
+
+        See :cpp:func:`OGRSpatialReference::GetAuthorityName`.
+
+        Parameters
+        ----------
+        target_key : str
+            the partial or complete path to the node to get an authority from
+            (e.g., 'PROJCS', 'GEOGCS' or ``None`` to get an authority name
+            on the root element)
+
+        Returns
+        -------
+        str
+
+        """
         return _osr.SpatialReference_GetAuthorityName(self, *args)
 
     def GetAreaOfUse(self, *args):
-        r"""GetAreaOfUse(SpatialReference self) -> AreaOfUse"""
+        r"""
+        GetAreaOfUse(SpatialReference self) -> AreaOfUse
+
+
+        Return the area of use of the SRS.
+
+        See :cpp:func:`OGRSpatialReference::GetAreaOfUse`.
+
+        Returns
+        -------
+        AreaOfUse
+            object providing a description of the area of use as well as bounding parallels / meridians
+
+        Examples
+        --------
+
+        >>> vt_sp = osr.SpatialReference()
+        >>> vt_sp.ImportFromEPSG(5646)
+        0
+        >>> aou = vt_sp.GetAreaOfUse()
+        >>> aou.name
+        'United States (USA) - Vermont - counties of Addison; Bennington; Caledonia; Chittenden; Essex; Franklin; Grand Isle; Lamoille; Orange; Orleans; Rutland; Washington; Windham; Windsor.'
+        >>> aou.west_lon_degree, aou.south_lat_degree, aou.east_lon_degree, aou.north_lat_degree
+        (-73.44, 42.72, -71.5, 45.03)
+
+
+        """
         return _osr.SpatialReference_GetAreaOfUse(self, *args)
 
     def GetAxisName(self, *args):
-        r"""GetAxisName(SpatialReference self, char const * target_key, int iAxis) -> char const *"""
+        r"""
+        GetAxisName(SpatialReference self, char const * target_key, int iAxis) -> char const *
+
+
+        Fetch an axis description.
+
+        See :cpp:func:`OGRSpatialReference::GetAxis`.
+
+        Parameters
+        ----------
+        target_key : str
+            The portion of the coordinate system, either 'GEOGCS' or 'PROJCS'
+        iAxis : int
+            The 0-based index of the axis to fetch
+
+        Returns
+        -------
+        str
+
+        Examples
+        --------
+        >>> srs = osr.SpatialReference()
+        >>> srs.ImportFromEPSG(4979)
+        0
+        >>> for i in range(3):
+        ...     srs.GetAxisName('GEOGCS', i)
+        ...
+        'Geodetic latitude'
+        'Geodetic longitude'
+        'Ellipsoidal height'
+
+
+        """
         return _osr.SpatialReference_GetAxisName(self, *args)
 
     def GetAxesCount(self, *args):
-        r"""GetAxesCount(SpatialReference self) -> int"""
+        r"""
+        GetAxesCount(SpatialReference self) -> int
+
+
+        Return the number of axes of the coordinate system of the CRS.
+
+        See :cpp:func:`OGRSpatialReference::GetAxesCount`.
+
+        Returns
+        -------
+        int
+
+        Examples
+        --------
+        >>> srs = osr.SpatialReference()
+        >>> srs.ImportFromEPSG(4326)
+        0
+        >>> srs.GetAxesCount()
+        2
+        >>> srs.ImportFromEPSG(4979)
+        0
+        >>> srs.GetAxesCount()
+        3
+
+        """
         return _osr.SpatialReference_GetAxesCount(self, *args)
 
     def GetAxisOrientation(self, *args):
-        r"""GetAxisOrientation(SpatialReference self, char const * target_key, int iAxis) -> OGRAxisOrientation"""
+        r"""
+        GetAxisOrientation(SpatialReference self, char const * target_key, int iAxis) -> OGRAxisOrientation
+
+
+        Fetch an axis orientation.
+
+        See :cpp:func:`OGRSpatialReference::GetAxis`.
+
+        Parameters
+        ----------
+        target_key : str
+            The portion of the coordinate system, either 'GEOGCS' or 'PROJCS'
+        iAxis : int
+            The 0-based index of the axis to fetch
+
+        Returns
+        -------
+        int
+
+        Examples
+        --------
+        >>> srs = osr.SpatialReference()
+        >>> srs.ImportFromEPSG(4979)
+        0
+        >>> srs.GetAxisOrientation('GEOGCS', 0) == osr.OAO_North
+        True
+        >>> srs.GetAxisOrientation('GEOGCS', 1) == osr.OAO_East
+        True
+        >>> srs.GetAxisOrientation('GEOGCS', 2) == osr.OAO_Up
+        True
+
+        """
         return _osr.SpatialReference_GetAxisOrientation(self, *args)
 
     def GetAxisMappingStrategy(self, *args):
-        r"""GetAxisMappingStrategy(SpatialReference self) -> OSRAxisMappingStrategy"""
+        r"""
+        GetAxisMappingStrategy(SpatialReference self) -> OSRAxisMappingStrategy
+
+
+        Return the data axis to CRS axis mapping strategy:
+
+        - :py:const:`OAMS_TRADITIONAL_GIS_ORDER` means that for geographic CRS
+          with lag/long order, the data will still be long/lat ordered. Similarly
+          for a projected CRS with northing/easting order, the data will still be
+          easting/northing ordered.
+        - :py:const:`OAMS_AUTHORITY_COMPLIANT` means that the data axis will be
+          identical to the CRS axis.
+        - :py:const:`OAMS_CUSTOM` means that the ordering is defined with
+          :py:meth:`SetDataAxisToSRSAxisMapping`.
+
+        See :cpp:func:`OGRSpatialReference::GetAxisMappingStrategy`.
+
+        Returns
+        -------
+        int
+
+
+        """
         return _osr.SpatialReference_GetAxisMappingStrategy(self, *args)
 
     def SetAxisMappingStrategy(self, *args):
         r"""SetAxisMappingStrategy(SpatialReference self, OSRAxisMappingStrategy strategy)"""
         return _osr.SpatialReference_SetAxisMappingStrategy(self, *args)
 
     def GetDataAxisToSRSAxisMapping(self, *args):
-        r"""GetDataAxisToSRSAxisMapping(SpatialReference self)"""
+        r"""
+        GetDataAxisToSRSAxisMapping(SpatialReference self)
+
+
+        Return the data axis to SRS axis mapping.
+
+        See :cpp:func:`OGRSpatialReference::GetDataAxisToSRSAxisMapping`.
+
+        Returns
+        -------
+        tuple
+
+
+        """
         return _osr.SpatialReference_GetDataAxisToSRSAxisMapping(self, *args)
 
     def SetDataAxisToSRSAxisMapping(self, *args):
         r"""SetDataAxisToSRSAxisMapping(SpatialReference self, int nList) -> OGRErr"""
         return _osr.SpatialReference_SetDataAxisToSRSAxisMapping(self, *args)
 
     def SetUTM(self, *args):
         r"""SetUTM(SpatialReference self, int zone, int north=1) -> OGRErr"""
         return _osr.SpatialReference_SetUTM(self, *args)
 
     def GetUTMZone(self, *args):
-        r"""GetUTMZone(SpatialReference self) -> int"""
+        r"""
+        GetUTMZone(SpatialReference self) -> int
+
+
+        Get UTM zone.
+
+        See :cpp:func:`OGRSpatialReference::GetUTMZone`.
+
+        Returns
+        -------
+        int
+            UTM zone number. Negative in the southern hemisphere and positive in the northern hemisphere. If the SRS is not UTM, zero will be returned.
+
+
+        """
         return _osr.SpatialReference_GetUTMZone(self, *args)
 
     def SetStatePlane(self, *args):
         r"""SetStatePlane(SpatialReference self, int zone, int is_nad83=1, char const * unitsname="", double units=0.0) -> OGRErr"""
         return _osr.SpatialReference_SetStatePlane(self, *args)
 
     def AutoIdentifyEPSG(self, *args):
-        r"""AutoIdentifyEPSG(SpatialReference self) -> OGRErr"""
+        r"""
+        AutoIdentifyEPSG(SpatialReference self) -> OGRErr
+
+
+        Add an EPSG authority code to the CRS
+        where an aspect of the coordinate system can be easily and safely
+        corresponded with an EPSG identifier.
+
+        See :cpp:func:`OGRSpatialReference::AutoIdentifyEPSG`.
+
+        Returns
+        -------
+        int
+            :py:const:`OGRERR_NONE` or :py:const:`OGRERR_UNSUPPORTED_SRS`.
+
+
+        """
         return _osr.SpatialReference_AutoIdentifyEPSG(self, *args)
 
     def FindMatches(self, *args):
         r"""FindMatches(SpatialReference self, char ** options=None)"""
         return _osr.SpatialReference_FindMatches(self, *args)
 
     def SetProjection(self, *args):
@@ -653,35 +1235,149 @@
         return _osr.SpatialReference_SetProjection(self, *args)
 
     def SetProjParm(self, *args):
         r"""SetProjParm(SpatialReference self, char const * name, double val) -> OGRErr"""
         return _osr.SpatialReference_SetProjParm(self, *args)
 
     def GetProjParm(self, *args):
-        r"""GetProjParm(SpatialReference self, char const * name, double default_val=0.0) -> double"""
+        r"""
+        GetProjParm(SpatialReference self, char const * name, double default_val=0.0) -> double
+
+
+        Fetch a projection parameter value.
+
+        See :cpp:func:`OGRSpatialReference::GetProjParm`.
+
+        Parameters
+        ----------
+        name : str
+            parameter name, available as constants prefixed with `SRS_PP`.
+        default_val : float, default = 0.0
+            value to return if this parameter doesn't exist
+
+        Returns
+        -------
+        float
+
+        Examples
+        --------
+        >>> vt_sp = osr.SpatialReference()
+        >>> vt_sp.ImportFromEPSG(5646)
+        0
+        >>> vt_sp.GetProjParm(osr.SRS_PP_FALSE_EASTING)
+        1640416.6667
+        >>> vt_sp.GetProjParm(osr.SRS_PP_FALSE_NORTHING)
+        0.0
+
+
+        """
         return _osr.SpatialReference_GetProjParm(self, *args)
 
     def SetNormProjParm(self, *args):
         r"""SetNormProjParm(SpatialReference self, char const * name, double val) -> OGRErr"""
         return _osr.SpatialReference_SetNormProjParm(self, *args)
 
     def GetNormProjParm(self, *args):
-        r"""GetNormProjParm(SpatialReference self, char const * name, double default_val=0.0) -> double"""
+        r"""
+        GetNormProjParm(SpatialReference self, char const * name, double default_val=0.0) -> double
+
+
+        Fetch a normalized projection parameter value.
+
+        This method is the same as :py:meth:`GetProjParm` except that the value of the
+        parameter is normalized into degrees or meters depending on whether it is
+        linear or angular.
+
+        See :cpp:func:`OGRSpatialReference::GetNormProjParm`.
+
+        Parameters
+        ----------
+        name : str
+            parameter name, available as constants prefixed with `SRS_PP`.
+        default_val : float, default = 0.0
+            value to return if this parameter doesn't exist
+
+        Returns
+        -------
+        float
+
+        Examples
+        --------
+        >>> vt_sp = osr.SpatialReference()
+        >>> vt_sp.ImportFromEPSG(5646)
+        0
+        >>> vt_sp.GetProjParm(osr.SRS_PP_FALSE_EASTING)
+        1640416.6667
+        >>> vt_sp.GetNormProjParm(osr.SRS_PP_FALSE_EASTING)
+        500000.0000101601
+
+
+        """
         return _osr.SpatialReference_GetNormProjParm(self, *args)
 
     def GetSemiMajor(self, *args):
-        r"""GetSemiMajor(SpatialReference self) -> double"""
+        r"""
+        GetSemiMajor(SpatialReference self) -> double
+
+
+        Get spheroid semi major axis (in meters starting with GDAL 3.0)
+
+        See :cpp:func:`OGRSpatialReference::GetSemiMajor`.
+
+        Returns
+        -------
+        float
+            semi-major axis, or :py:const:`SRS_WGS84_SEMIMAJOR` if it cannot be found.
+
+        """
         return _osr.SpatialReference_GetSemiMajor(self, *args)
 
     def GetSemiMinor(self, *args):
-        r"""GetSemiMinor(SpatialReference self) -> double"""
+        r"""
+        GetSemiMinor(SpatialReference self) -> double
+
+
+        Get spheroid semi minor axis.
+
+        See :cpp:func:`OGRSpatialReference::GetSemiMinor`.
+
+        Returns
+        -------
+        float
+            semi-minor axis, or :py:const:`SRS_WGS84_SEMIMINOR` if it cannot be found.
+
+        """
         return _osr.SpatialReference_GetSemiMinor(self, *args)
 
     def GetInvFlattening(self, *args):
-        r"""GetInvFlattening(SpatialReference self) -> double"""
+        r"""
+        GetInvFlattening(SpatialReference self) -> double
+
+
+        Get the spheroid inverse flattening.
+
+        See :cpp:func:`OGRSpatialReference::GetInvFlattening`.
+
+        Returns
+        -------
+        float
+
+        Examples
+        --------
+        >>> srs = osr.SpatialReference()
+        >>> srs.ImportFromEPSG(4326) # WGS84
+        0
+        >>> srs.GetInvFlattening()
+        298.257223563
+        >>> srs.ImportFromEPSG(4269) # NAD83
+        0
+        >>> srs.GetInvFlattening()
+        298.257222101
+
+        """
         return _osr.SpatialReference_GetInvFlattening(self, *args)
 
     def SetACEA(self, *args, **kwargs):
         r"""SetACEA(SpatialReference self, double stdp1, double stdp2, double clat, double clong, double fe, double fn) -> OGRErr"""
         return _osr.SpatialReference_SetACEA(self, *args, **kwargs)
 
     def SetAE(self, *args, **kwargs):
@@ -848,32 +1544,58 @@
         r"""SetVerticalPerspective(SpatialReference self, double topoOriginLat, double topoOriginLon, double topoOriginHeight, double viewPointHeight, double fe, double fn) -> OGRErr"""
         return _osr.SpatialReference_SetVerticalPerspective(self, *args, **kwargs)
 
     def SetWellKnownGeogCS(self, *args):
         r"""SetWellKnownGeogCS(SpatialReference self, char const * name) -> OGRErr"""
         return _osr.SpatialReference_SetWellKnownGeogCS(self, *args)
 
-    def SetFromUserInput(self, *args):
-        r"""SetFromUserInput(SpatialReference self, char const * name) -> OGRErr"""
-        return _osr.SpatialReference_SetFromUserInput(self, *args)
+    def SetFromUserInput(self, *args, **kwargs):
+        r"""SetFromUserInput(SpatialReference self, char const * name, char ** options=None) -> OGRErr"""
+        return _osr.SpatialReference_SetFromUserInput(self, *args, **kwargs)
 
     def CopyGeogCSFrom(self, *args):
         r"""CopyGeogCSFrom(SpatialReference self, SpatialReference rhs) -> OGRErr"""
         return _osr.SpatialReference_CopyGeogCSFrom(self, *args)
 
     def SetTOWGS84(self, *args):
         r"""SetTOWGS84(SpatialReference self, double p1, double p2, double p3, double p4=0.0, double p5=0.0, double p6=0.0, double p7=0.0) -> OGRErr"""
         return _osr.SpatialReference_SetTOWGS84(self, *args)
 
     def HasTOWGS84(self, *args):
-        r"""HasTOWGS84(SpatialReference self) -> bool"""
+        r"""
+        HasTOWGS84(SpatialReference self) -> bool
+
+
+        Return whether the SRS has a TOWGS84 parameter.
+
+        See :cpp:func:`OGRSpatialReference::GetTOWGS84`.
+
+        Returns
+        -------
+        bool
+
+
+        """
         return _osr.SpatialReference_HasTOWGS84(self, *args)
 
     def GetTOWGS84(self, *args):
-        r"""GetTOWGS84(SpatialReference self) -> OGRErr"""
+        r"""
+        GetTOWGS84(SpatialReference self) -> OGRErr
+
+
+        Fetch TOWGS84 parameter, if available.
+
+        See :cpp:func:`OGRSpatialReference::GetTOWGS84`.
+
+        Returns
+        -------
+        tuple
+
+
+        """
         return _osr.SpatialReference_GetTOWGS84(self, *args)
 
     def AddGuessedTOWGS84(self, *args):
         r"""AddGuessedTOWGS84(SpatialReference self) -> OGRErr"""
         return _osr.SpatialReference_AddGuessedTOWGS84(self, *args)
 
     def SetLocalCS(self, *args):
@@ -897,35 +1619,147 @@
         return _osr.SpatialReference_SetVertCS(self, *args)
 
     def SetCompoundCS(self, *args):
         r"""SetCompoundCS(SpatialReference self, char const * name, SpatialReference horizcs, SpatialReference vertcs) -> OGRErr"""
         return _osr.SpatialReference_SetCompoundCS(self, *args)
 
     def ImportFromWkt(self, *args):
-        r"""ImportFromWkt(SpatialReference self, char ** ppszInput) -> OGRErr"""
+        r"""
+        ImportFromWkt(SpatialReference self, char ** ppszInput) -> OGRErr
+
+
+        Import from WKT string.
+
+        See :cpp:func:`OGRSpatialReference::importFromWkt`.
+
+        Parameters
+        ----------
+        ppszInput : str
+            WKT string
+
+        Returns
+        -------
+        int
+            :py:const:`OGRERR_NONE` if import succeeds, or :py:const:`OGRERR_CORRUPT_DATA` if it fails for any reason.
+
+
+        """
         return _osr.SpatialReference_ImportFromWkt(self, *args)
 
     def ImportFromProj4(self, *args):
-        r"""ImportFromProj4(SpatialReference self, char * ppszInput) -> OGRErr"""
+        r"""
+        ImportFromProj4(SpatialReference self, char * ppszInput) -> OGRErr
+
+
+        Initialize SRS based on PROJ coordinate string.
+
+        See :cpp:func:`OGRSpatialReference::importFromProj4`.
+
+        Parameters
+        ----------
+        ppszInput : str
+            PROJ coordinate string
+
+        Returns
+        -------
+        int
+            :py:const:`OGRERR_NONE` on success, or :py:const:`OGRERR_CORRUPT_DATA` on failure
+
+        Examples
+        --------
+        >>> srs = osr.SpatialReference()
+        >>> srs.ImportFromProj4('+proj=utm +zone=18 +datum=WGS84')
+        0
+
+        """
         return _osr.SpatialReference_ImportFromProj4(self, *args)
 
     def ImportFromUrl(self, *args):
-        r"""ImportFromUrl(SpatialReference self, char * url) -> OGRErr"""
+        r"""
+        ImportFromUrl(SpatialReference self, char * url) -> OGRErr
+
+
+        Initialize SRS based on a URL.
+
+        This method will download the spatial reference at a given URL and
+        feed it into :py:meth:`SetFromUserInput` for you.
+
+        See :cpp:func:`OGRSpatialReference::importFromUrl`.
+
+        Parameters
+        ----------
+        url : str
+
+        Returns
+        -------
+        int
+            :py:const:`OGRERR_NONE` on success, or an error code on failure
+
+
+        """
         return _osr.SpatialReference_ImportFromUrl(self, *args)
 
     def ImportFromESRI(self, *args):
         r"""ImportFromESRI(SpatialReference self, char ** ppszInput) -> OGRErr"""
         return _osr.SpatialReference_ImportFromESRI(self, *args)
 
     def ImportFromEPSG(self, *args):
-        r"""ImportFromEPSG(SpatialReference self, int arg) -> OGRErr"""
+        r"""
+        ImportFromEPSG(SpatialReference self, int arg) -> OGRErr
+
+
+        Initialize SRS based on EPSG geographic, projected or vertical CRS code.
+
+        Since GDAL 3.0, this method is identical to :py:meth:`ImportFromEPSGA`.
+
+        See :cpp:func:`OGRSpatialReference::importFromEPSG`.
+
+        Parameters
+        ----------
+        arg : int
+            EPSG code to search in PROJ database
+
+        Returns
+        -------
+        int
+            :py:const:`OGRERR_NONE` on success, or an error code on failure
+
+        Examples
+        --------
+        >>> srs = osr.SpatialReference()
+        >>> srs.ImportFromEPSG(4326)
+        0
+
+
+        """
         return _osr.SpatialReference_ImportFromEPSG(self, *args)
 
     def ImportFromEPSGA(self, *args):
-        r"""ImportFromEPSGA(SpatialReference self, int arg) -> OGRErr"""
+        r"""
+        ImportFromEPSGA(SpatialReference self, int arg) -> OGRErr
+
+
+        Initialize SRS based on EPSG geographic, projected or vertical CRS code.
+
+        Since GDAL 3.0, this method is identical to :py:meth:`ImportFromEPSG`.
+
+        See :cpp:func:`OGRSpatialReference::importFromEPSGA`.
+
+        Parameters
+        ----------
+        arg : int
+            EPSG code to search in PROJ database
+
+        Returns
+        -------
+        int
+            :py:const:`OGRERR_NONE` on success, or an error code on failure
+
+
+        """
         return _osr.SpatialReference_ImportFromEPSGA(self, *args)
 
     def ImportFromPCI(self, *args):
         r"""ImportFromPCI(SpatialReference self, char const * proj, char const * units="METRE", double [17] argin=0) -> OGRErr"""
         return _osr.SpatialReference_ImportFromPCI(self, *args)
 
     def ImportFromUSGS(self, *args):
@@ -944,28 +1778,112 @@
         r"""ImportFromMICoordSys(SpatialReference self, char const * pszCoordSys) -> OGRErr"""
         return _osr.SpatialReference_ImportFromMICoordSys(self, *args)
 
     def ImportFromOzi(self, *args):
         r"""ImportFromOzi(SpatialReference self, char const *const * papszLines) -> OGRErr"""
         return _osr.SpatialReference_ImportFromOzi(self, *args)
 
+    def ImportFromCF1(self, keyValues, units = ""):
+        """ Import a CRS from netCDF CF-1 definitions.
+
+        http://cfconventions.org/cf-conventions/cf-conventions.html#appendix-grid-mappings
+        """
+        import copy
+        keyValues = copy.deepcopy(keyValues)
+        for key in keyValues:
+            val = keyValues[key]
+            if isinstance(val, list):
+                val = ','.join(["%.18g" % x for x in val])
+                keyValues[key] = val
+        return _osr.SpatialReference_ImportFromCF1(self, keyValues, units)
+
+
+
     def ExportToWkt(self, *args):
-        r"""ExportToWkt(SpatialReference self, char ** options=None) -> OGRErr"""
+        r"""
+        ExportToWkt(SpatialReference self, char ** options=None) -> OGRErr
+
+
+        Export  this SRS into WKT 1 format.
+
+        See :cpp:func:`OGRSpatialReference::exportToWkt`.
+
+        Returns
+        -------
+        str
+
+        See Also
+        --------
+        :py:meth:`ExportToPrettyWkt`
+
+
+        """
         return _osr.SpatialReference_ExportToWkt(self, *args)
 
     def ExportToPrettyWkt(self, *args):
-        r"""ExportToPrettyWkt(SpatialReference self, int simplify=0) -> OGRErr"""
+        r"""
+        ExportToPrettyWkt(SpatialReference self, int simplify=0) -> OGRErr
+
+
+        Convert this SRS into a nicely formatted WKT 1 string for display to a
+        person.
+
+        See :cpp:func:`OGRSpatialReference::exportToPrettyWkt`.
+
+        Parameters
+        ----------
+        simplify : bool, default = False
+
+        Returns
+        -------
+        str
+
+
+        """
         return _osr.SpatialReference_ExportToPrettyWkt(self, *args)
 
     def ExportToPROJJSON(self, *args):
-        r"""ExportToPROJJSON(SpatialReference self, char ** options=None) -> OGRErr"""
+        r"""
+        ExportToPROJJSON(SpatialReference self, char ** options=None) -> OGRErr
+
+
+        Export this SRS in `PROJJSON <https://proj.org/en/latest/specifications/projjson.html>`_ format.
+
+        See :cpp:func:`OGRSpatialReference::exportToPROJJSON`.
+
+        Parameters
+        ----------
+        options : list/dict
+            Options to control the format of the output. See :cpp:func:`OGRSpatialReference::ExportToPROJJSON`.
+
+        Returns
+        -------
+        str
+
+
+        """
         return _osr.SpatialReference_ExportToPROJJSON(self, *args)
 
     def ExportToProj4(self, *args):
-        r"""ExportToProj4(SpatialReference self) -> OGRErr"""
+        r"""
+        ExportToProj4(SpatialReference self) -> OGRErr
+
+
+        Export this SRS to PROJ.4 legacy format.
+
+        .. warning::
+
+           Use of this function is discouraged. See :cpp:func:`OGRSpatialReference::exportToProj4`.
+
+        Returns
+        -------
+        str
+
+
+        """
         return _osr.SpatialReference_ExportToProj4(self, *args)
 
     def ExportToPCI(self, *args):
         r"""ExportToPCI(SpatialReference self) -> OGRErr"""
         return _osr.SpatialReference_ExportToPCI(self, *args)
 
     def ExportToUSGS(self, *args):
@@ -980,14 +1898,39 @@
         r"""ExportToXML(SpatialReference self, char const * dialect="") -> OGRErr"""
         return _osr.SpatialReference_ExportToXML(self, *args)
 
     def ExportToMICoordSys(self, *args):
         r"""ExportToMICoordSys(SpatialReference self) -> OGRErr"""
         return _osr.SpatialReference_ExportToMICoordSys(self, *args)
 
+    def ExportToCF1(self, options = {}):
+        """ Export a CRS to netCDF CF-1 definitions.
+
+        http://cfconventions.org/cf-conventions/cf-conventions.html#appendix-grid-mappings
+        """
+        keyValues = _osr.SpatialReference_ExportToCF1(self, options)
+        for key in keyValues:
+            val = keyValues[key]
+            try:
+                val = float(val)
+                keyValues[key] = val
+            except:
+                try:
+                    val = [float(x) for x in val.split(',')]
+                    keyValues[key] = val
+                except:
+                    pass
+        return keyValues
+
+
+
+    def ExportToCF1Units(self, *args):
+        r"""ExportToCF1Units(SpatialReference self, char ** options=None) -> retStringAndCPLFree *"""
+        return _osr.SpatialReference_ExportToCF1Units(self, *args)
+
     def CloneGeogCS(self, *args):
         r"""CloneGeogCS(SpatialReference self) -> SpatialReference"""
         return _osr.SpatialReference_CloneGeogCS(self, *args)
 
     def Clone(self, *args):
         r"""Clone(SpatialReference self) -> SpatialReference"""
         return _osr.SpatialReference_Clone(self, *args)
@@ -1075,23 +2018,30 @@
     def SetOnlyBest(self, *args):
         r"""SetOnlyBest(CoordinateTransformationOptions self, bool onlyBest) -> bool"""
         return _osr.CoordinateTransformationOptions_SetOnlyBest(self, *args)
 
 # Register CoordinateTransformationOptions in _osr:
 _osr.CoordinateTransformationOptions_swigregister(CoordinateTransformationOptions)
 class CoordinateTransformation(object):
-    r"""Proxy of C++ OSRCoordinateTransformationShadow class."""
+    r"""
+
+    Python proxy of an :cpp:class:`OGRCoordinateTransformation`.
+
+    """
 
     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
     __repr__ = _swig_repr
 
     def __init__(self, *args):
         r"""
         __init__(CoordinateTransformation self, SpatialReference src, SpatialReference dst) -> CoordinateTransformation
         __init__(CoordinateTransformation self, SpatialReference src, SpatialReference dst, CoordinateTransformationOptions options) -> CoordinateTransformation
+
+        Python proxy of an :cpp:class:`OGRCoordinateTransformation`.
+
         """
         _osr.CoordinateTransformation_swiginit(self, _osr.new_CoordinateTransformation(*args))
     __swig_destroy__ = _osr.delete_CoordinateTransformation
 
     def GetInverse(self, *args):
         r"""GetInverse(CoordinateTransformation self) -> CoordinateTransformation"""
         return _osr.CoordinateTransformation_GetInverse(self, *args)
@@ -1107,14 +2057,37 @@
 
     def TransformPoint(self, *args):
         """
         TransformPoint(CoordinateTransformation self, double [3] inout)
         TransformPoint(CoordinateTransformation self, double [4] inout)
         TransformPoint(CoordinateTransformation self, double x, double y, double z=0.0)
         TransformPoint(CoordinateTransformation self, double x, double y, double z, double t)
+
+        Transform a single point.
+
+        See :cpp:func:`OCTTransform`.
+
+        Returns
+        -------
+        tuple
+            A tuple of (x, y, z) or (x, y, z, t) values, depending on the input.
+
+        Examples
+        --------
+        >>> wgs84 = osr.SpatialReference()
+        >>> wgs84.ImportFromEPSG(4326)
+        0
+        >>> vt_sp = osr.SpatialReference()
+        >>> vt_sp.ImportFromEPSG(5646)
+        0
+        >>> ct = osr.CoordinateTransformation(wgs84, ps)
+        >>> ct.TransformPoint(-72.58, 44.26)
+        (7390620.052019633, -51202148.77747277, 0.0)
+        >>> ct.TransformPoint(-72.58, 44.26, 103)
+        (7390620.052019633, -51202148.77747277, 103.0)
         """
 
         import collections.abc
         if len(args) == 1 and isinstance(args[0], collections.abc.Sequence):
             len_args = len(args[0])
             if len_args == 3:
                 return self._TransformPoint3Double(args[0])
@@ -1122,30 +2095,135 @@
                 return self._TransformPoint4Double(args[0])
 
         return _osr.CoordinateTransformation_TransformPoint(self, *args)
 
 
 
     def TransformPointWithErrorCode(self, *args):
-        r"""TransformPointWithErrorCode(CoordinateTransformation self, double x, double y, double z, double t)"""
+        r"""
+        TransformPointWithErrorCode(CoordinateTransformation self, double x, double y, double z, double t)
+
+
+        Variant of :py:meth:`TransformPoint` that provides an error code.
+
+        See :cpp:func:`OCTTransformEx`.
+
+        Parameters
+        ----------
+        x : float
+        y : float
+        z : float
+        t : float
+
+        Returns
+        -------
+        tuple
+            tuple of (x, y, z, t, error) values
+
+
+        """
         return _osr.CoordinateTransformation_TransformPointWithErrorCode(self, *args)
 
     def TransformPoints(self, *args):
-        r"""TransformPoints(CoordinateTransformation self, int nCount)"""
+        r"""
+        TransformPoints(CoordinateTransformation self, int nCount)
+
+
+        Transform multiple points.
+
+        See :cpp:func:`OCTTransform`.
+
+        Parameters
+        ----------
+        arg
+            A list of tuples, or a 2xN, 3xN, or 4xN numpy array
+
+        Returns
+        -------
+        list
+            A list of tuples of (x, y, z) or (x, y, z, t) values, depending on the input.
+
+        Examples
+        --------
+        >>> ct.TransformPoints([(-72.58, 44.26), (-72.59, 44.26)])
+        [(7390620.052019633, -51202148.77747277, 0.0), (7387261.070131293, -51200373.68798984, 0.0)]
+
+        >>> import numpy as np
+        >>> ct.TransformPoints(np.array([[-72.58, 44.26], [-72.59, 44.26]]))
+        [(7390620.052019633, -51202148.77747277, 0.0), (7387261.070131293, -51200373.68798984, 0.0)]
+
+
+
+        """
         return _osr.CoordinateTransformation_TransformPoints(self, *args)
 
     def TransformBounds(self, *args):
-        r"""TransformBounds(CoordinateTransformation self, double minx, double miny, double maxx, double maxy, int densify_pts)"""
+        r"""
+        TransformBounds(CoordinateTransformation self, double minx, double miny, double maxx, double maxy, int densify_pts)
+
+
+        Transform a boundary, densifying the edges to account for nonlinear
+        transformations along these edges.
+
+        See :cpp:func:`OCTTransformBounds`.
+
+        Parameters
+        ----------
+        minx : float
+            Minimum bounding coordinate of the first axis in source CRS
+        miny : float
+            Minimum bounding coordinate of the second axis in source CRS
+        maxx : float
+            Maximum bounding coordinate of the first axis in source CRS
+        maxy : float
+            Maximum bounding coordinate of the second axis in source CRS
+        densify_pts : int
+            The number of points to use to densify the bounding polygon.
+            Recommended to use 21.
+
+        Returns
+        -------
+        tuple
+            Transformed values of xmin, ymin, xmax, ymax
+
+        Examples
+        --------
+        >>> ct.TransformBounds(-72.5, 44.2, -72.4, 44.3, 21)
+        (7415356.140468472, -51238192.683464445, 7454323.154814391, -51210287.42581475)
+
+
+        """
         return _osr.CoordinateTransformation_TransformBounds(self, *args)
 
 # Register CoordinateTransformation in _osr:
 _osr.CoordinateTransformation_swigregister(CoordinateTransformation)
 
 def CreateCoordinateTransformation(*args):
-    r"""CreateCoordinateTransformation(SpatialReference src, SpatialReference dst, CoordinateTransformationOptions options=None) -> CoordinateTransformation"""
+    r"""
+    CreateCoordinateTransformation(SpatialReference src, SpatialReference dst, CoordinateTransformationOptions options=None) -> CoordinateTransformation
+
+
+    Create a :py:class:`CoordinateTransformation` using a set of :py:class:`CoordinateTransformationOptions`.
+
+    See :cpp:func:`OCTNewCoordinateTransformationEx`.
+
+    Parameters
+    ----------
+    src : SpatialReference
+        source spatial reference system
+    dst : SpatialReference
+        target spatial reference ystem
+    options : CoordinateTransformationOptions
+
+    Returns
+    -------
+    CoordinateTransformation
+
+
+    """
     return _osr.CreateCoordinateTransformation(*args)
 OSR_CRS_TYPE_GEOGRAPHIC_2D = _osr.OSR_CRS_TYPE_GEOGRAPHIC_2D
 
 OSR_CRS_TYPE_GEOGRAPHIC_3D = _osr.OSR_CRS_TYPE_GEOGRAPHIC_3D
 
 OSR_CRS_TYPE_GEOCENTRIC = _osr.OSR_CRS_TYPE_GEOCENTRIC
```

### Comparing `GDAL-3.8.5/setup.py` & `GDAL-3.9.0/setup.py`

 * *Files 16% similar despite different names*

```diff
@@ -6,21 +6,22 @@
 # http://www.initd.org/tracker/psycopg/browser/psycopg2/trunk/setup.py
 # Howard Butler hobu.inc@gmail.com
 
 
 import os
 import sys
 from glob import glob
+from pathlib import Path
 
 from setuptools.command.build_ext import build_ext
 from setuptools import setup
 from setuptools import find_packages
 from setuptools import Extension
 
-version = '3.8.5'
+version = '3.9.0'
 
 # If CXX is defined in the environment, it will be used to link the .so
 # but setuptools will be confused if it is made of several words like 'ccache g++'
 # and it will try to use only the first word.
 # See https://lists.osgeo.org/pipermail/gdal-dev/2016-July/044686.html
 # Note: in general when doing "make", CXX will not be defined, unless it is defined as
 # an environment variable, but in that case it is the value of GDALmake.opt that
@@ -40,22 +41,22 @@
         print('WARNING: "CC=%s" was defined in the environment and contains more than one word. Unsetting it since that is incompatible of setuptools' % os.environ['CC'])
         del os.environ['CC']
 
 # ---------------------------------------------------------------------------
 # Switches
 # ---------------------------------------------------------------------------
 
-is_standalone_build = not os.path.exists('/home/even/gdal/3.8/build/swig/python')
+is_standalone_build = not os.path.exists('/home/even/gdal/3.9/build/swig/python')
 
 if is_standalone_build:
     include_dirs = []
     library_dirs = []
 else:
-    include_dirs = ['/home/even/gdal/3.8/build/port', '/home/even/gdal/3.8/port', '/home/even/gdal/3.8/build/gcore', '/home/even/gdal/3.8/gcore', '/home/even/gdal/3.8/alg', '/home/even/gdal/3.8/ogr/', '/home/even/gdal/3.8/ogr/ogrsf_frmts', '/home/even/gdal/3.8/gnm', '/home/even/gdal/3.8/apps']
-    library_dirs = ['/home/even/gdal/3.8/build']
+    include_dirs = ['/home/even/gdal/3.9/build/port', '/home/even/gdal/3.9/port', '/home/even/gdal/3.9/build/gcore', '/home/even/gdal/3.9/gcore', '/home/even/gdal/3.9/alg', '/home/even/gdal/3.9/ogr/', '/home/even/gdal/3.9/ogr/ogrsf_frmts', '/home/even/gdal/3.9/gnm', '/home/even/gdal/3.9/apps']
+    library_dirs = ['/home/even/gdal/3.9/build']
 libraries = ['gdal']
 
 
 # ---------------------------------------------------------------------------
 # Helper Functions
 # ---------------------------------------------------------------------------
 
@@ -68,14 +69,15 @@
             __builtins__[name] = value
         else:
             setattr(__builtins__, name, value)
 
     _set_builtin("__NUMPY_SETUP__", False)
 
     import numpy
+    print('Using numpy ' + numpy.__version__)
     return numpy.get_include()
 
 
 class gdal_config_error(Exception):
     pass
 
 
@@ -142,27 +144,66 @@
         try:
             compiler.compile([f.name], extra_postargs=[flagname])
         except Exception:
             return False
     return True
 
 # ---------------------------------------------------------------------------
+# BEGIN monkey patching of setuptools.command.easy_install.easy_install class
+# ---------------------------------------------------------------------------
+
+# "python setup.py install" uses setuptools.command.easy_install internally
+# When installing the .exe wrapper executable for our command line utilities,
+# that class removes the installed .py scripts themselves. Which we do not want,
+# since they may be directly used by users. So we do a monkey patching of
+# easy_install.install_wrapper_scripts to install a modified
+# easy_install.delete_blockers method that does NOT remove .py files
+if sys.platform == 'win32':
+    from setuptools.command.easy_install import easy_install
+
+    original_install_wrapper_scripts = easy_install.install_wrapper_scripts
+
+    def monkey_patched_install_wrapper_scripts(self, dist):
+        original_delete_blockers = easy_install.delete_blockers
+        def monkey_patched_delete_blockers(self, blockers):
+            blockers = filter(lambda x: not x.endswith('.py'), blockers)
+            return original_delete_blockers(self, blockers)
+
+        easy_install.delete_blockers = monkey_patched_delete_blockers
+        try:
+            return original_install_wrapper_scripts(self, dist)
+        finally:
+             easy_install.delete_blockers = original_delete_blockers
+
+    easy_install.install_wrapper_scripts = monkey_patched_install_wrapper_scripts
+
+# ---------------------------------------------------------------------------
+# END monkey patching of setuptools.command.easy_install.easy_install class
+# ---------------------------------------------------------------------------
+
+# ---------------------------------------------------------------------------
 # Imports
 # ---------------------------------------------------------------------------
 
 numpy_include_dir = '.'
+numpy_error_msg = ""
 try:
     numpy_include_dir = get_numpy_include()
     HAVE_NUMPY = numpy_include_dir != '.'
     if not HAVE_NUMPY:
-        print("WARNING: numpy found, but numpy headers were not found!  Array support will not be enabled")
+        numpy_error_msg = "numpy found, but numpy headers were not found!"
 except ImportError:
     HAVE_NUMPY = False
-    print('WARNING: numpy not available!  Array support will not be enabled')
+    numpy_error_msg = "numpy not available!"
 
+if not HAVE_NUMPY:
+   if "GDAL_PYTHON_BINDINGS_WITHOUT_NUMPY" in os.environ:
+      print("WARNING: " + numpy_error_msg + " Array support will not be enabled.")
+   else:
+      raise Exception(numpy_error_msg + " This error may happen if you build/install using setup.py directly, but should normally not happen if you install using pip install. If you still want to build the bindings without numpy support, define the GDAL_PYTHON_BINDINGS_WITHOUT_NUMPY environment variable")
 
 class gdal_ext(build_ext):
 
     GDAL_CONFIG = 'gdal-config'
     user_options = build_ext.user_options[:]
     user_options.extend([
         ('gdal-config=', None,
@@ -331,16 +372,16 @@
 package_dir = {'osgeo': 'osgeo', '': utils_package_root}
 
 readme = open('README.rst', encoding="utf-8").read()
 
 name = 'GDAL'
 author = "Frank Warmerdam"
 author_email = "warmerdam@pobox.com"
-maintainer = "Howard Butler"
-maintainer_email = "hobu.inc@gmail.com"
+maintainer = "GDAL contributors"
+maintainer_email = "gdal-dev@lists.osgeo.org"
 description = "GDAL: Geospatial Data Abstraction Library"
 license_type = "MIT"
 url = "http://www.gdal.org"
 
 classifiers = [
     'Development Status :: 5 - Production/Stable',
     'Intended Audience :: Developers',
@@ -353,14 +394,34 @@
     'Topic :: Scientific/Engineering :: GIS',
     'Topic :: Scientific/Engineering :: Information Analysis',
 
 ]
 
 exclude_package_data = {'': ['CMakeLists.txt']}
 
+scripts = sorted([x for x in filter(lambda x: not '__init__.py' in x,
+                 glob("gdal-utils/osgeo_utils/*.py"))], reverse=True)  # command line scripts
+
+def define_entry_points(scripts, entry_points=None):
+    """
+    Return a dict defining scripts that get installed to PYTHONHOME/Scripts.
+
+        console_scripts : [
+            # CLI_command = dirname.filename
+            'gdal_edit = osgeo_utils.gdal_edit',
+            'gdal_merge = osgeo_utils.gdal_merge',
+            ... ]
+    """
+    console_scripts = []
+    for f in scripts:
+        name = Path(f).stem  # 'gdal_edit' from 'gdal_edit.py'
+        console_scripts.append([f"{name} = osgeo_utils.{name}:main"])
+    entry_points = {"console_scripts": console_scripts}
+    return entry_points
+
 setup(
     name=name,
     version=version,
     author=author,
     author_email=author_email,
     maintainer=maintainer,
     maintainer_email=maintainer_email,
@@ -368,16 +429,17 @@
     long_description_content_type='text/x-rst',
     description=description,
     license=license_type,
     classifiers=classifiers,
     packages=packages,
     package_dir=package_dir,
     url=url,
-    python_requires='>=3.6.0',
+    python_requires='>=3.8.0',
     ext_modules=ext_modules,
     scripts=glob(utils_package_root + '/scripts/*.py'),
     # This must *not* be conditionalized by HAVE_NUMPY, since this is for a "pip install gdal[numpy]" type of installation
     extras_require={'numpy': ['numpy > 1.0.0']},
     zip_safe=False,
     cmdclass=dict(build_ext=gdal_ext),
     exclude_package_data = exclude_package_data,
+    entry_points=define_entry_points(scripts),
 )
```

